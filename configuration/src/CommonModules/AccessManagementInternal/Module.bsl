///////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2023, OOO 1C-Soft
// All rights reserved. This software and the related materials 
// are licensed under a Creative Commons Attribution 4.0 International license (CC BY 4.0).
// To view the license terms, follow the link:
// https://creativecommons.org/licenses/by/4.0/legalcode
///////////////////////////////////////////////////////////////////////////////////////////////////////
//

#Region Internal

////////////////////////////////////////////////////////////////////////////////
// Main procedures and functions.

// Adds a user to an access group of the built-in profile.
// The access group is determined by ID of the reference of a built-in profile.
// If an access group is not found, it will be created.
//
// Parameters:
//  User        - CatalogRef.Users
//                      - CatalogRef.ExternalUsers
//                      - CatalogRef.UserGroups
//                      - CatalogRef.ExternalUsersGroups - 
// 
//  SuppliedProfile - String - an ID string of a built-in profile.
//                      - CatalogRef.AccessGroupProfiles - 
//                        
//                        
//                        
//                        
// 
Procedure AddUserToAccessGroup(User, SuppliedProfile) Export
	
	ProcessUserLinkToAccessGroup(User, SuppliedProfile, True);
	
EndProcedure

// Updates the users of the assignee groups.
// 
// This procedure must be called when users are changed in assignee groups,
// for example, in task assignee groups.
//
// Assignee groups whose members are changed, are passed as parameter values.
//
// Parameters:
//  PerformersGroups - CatalogRef.TaskPerformersGroups - one group,
//                     - Array of CatalogRef.TaskPerformersGroups - 
//                     - Undefined - 
//
Procedure UpdatePerformersGroupsUsers(PerformersGroups = Undefined) Export
	
	If TypeOf(PerformersGroups) = Type("Array") And PerformersGroups.Count() = 0 Then
		Return;
	EndIf;
	
	Parameters = New Structure;
	Parameters.Insert("PerformersGroups", PerformersGroups);
	
	InformationRegisters.AccessValuesGroups.UpdateUsersGroups(Parameters);
	
EndProcedure

// Checks whether an access kind of the specified name exists.
// It is used for automation of conditional subsystem embedding.
// 
// Parameters:
//   AccessKindName - String - an access kind name.
// 
// Returns:
//  Structure:
//
Function AccessKindExists(AccessKindName) Export
	
	Return AccessKindProperties(AccessKindName) <> Undefined;
	
EndFunction

// Returns the user interface type for access setup.
//
// Returns:
//  Boolean
//
Function SimplifiedAccessRightsSetupInterface() Export
	
	SimplifiedInterface = False;
	AccessManagementOverridable.OnDefineAccessSettingInterface(SimplifiedInterface);
	
	Return SimplifiedInterface = True;
	
EndFunction

// Returns an array of allowed values of the specified types within all access groups.
// Used in the SetDynamicListFilters procedure to speed up the opening of dynamic lists.
// 
// Parameters:
//  Table      - String - a full name of the metadata object, for example, Document.PurchaseInvoice.
//  ValuesType  - Type    - a type of access values whose allowed values are to be returned.
//               - Array - 
//
//  Values     - Undefined - do not consider.
//               - Array - 
//
//  User - Undefined - return allowed values for the authorized user.
//               - CatalogRef.Users
//               - CatalogRef.ExternalUsers - 
//                   
//
//  ReturnAll   - Boolean - if set to True, all values will be returned, even
//                   if there are more than 100 values.
//
// Returns:
//  Undefined - 
//                 
//  
//
Function AllowedDynamicListValues(Table, ValuesType, Values = Undefined, User = Undefined, ReturnAll = False) Export
	
	If TypeOf(ValuesType) <> Type("Array") Then
		ValueTypes = New Array;
		ValueTypes.Add(ValuesType);
		
	ElsIf ValuesType.Count() = 0 Then
		Return Undefined;
	Else
		ValueTypes = ValuesType;
	EndIf;
	
	SetPrivilegedMode(True);
	
	ValuesQueryTextWithoutGroups =
	"SELECT TOP 101
	|	ValuesWithoutGroups.Ref AS Ref
	|FROM
	|	(SELECT
	|		&EmptyRefValue AS Ref
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		ValuesWithoutEmptyRef.Ref
	|	FROM
	|		&AccessValuesTable AS ValuesWithoutEmptyRef) AS ValuesWithoutGroups
	|WHERE
	|	TRUE IN
	|			(SELECT TOP 1
	|				TRUE
	|			FROM
	|				UserAccessGroups AS AccessGroups
	|			WHERE
	|				CASE
	|					WHEN TRUE IN
	|							(SELECT TOP 1
	|								TRUE
	|							FROM
	|								InformationRegister.AccessGroupsValues AS Values
	|							WHERE
	|								Values.AccessGroup = AccessGroups.Ref
	|								AND Values.AccessValue = ValuesWithoutGroups.Ref)
	|						THEN TRUE
	|					ELSE FALSE
	|				END = CASE
	|					WHEN TRUE IN
	|							(SELECT TOP 1
	|								TRUE
	|							FROM
	|								InformationRegister.DefaultAccessGroupsValues AS DefaultValues
	|							WHERE
	|								DefaultValues.AccessGroup = AccessGroups.Ref
	|								AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValuesWithoutGroups.Ref)
	|								AND DefaultValues.AllAllowed = FALSE)
	|						THEN TRUE
	|					ELSE FALSE
	|				END)
	|	AND ValuesWithoutGroups.Ref IN(&Values)";
	
	If TypeOf(Values) = Type("Array") Or ReturnAll Then
		ValuesQueryTextWithoutGroups = StrReplace(ValuesQueryTextWithoutGroups, "TOP 101", ""); // @query-part-1
	EndIf;
	If TypeOf(Values) <> Type("Array") Then
		ValuesQueryTextWithoutGroups = StrReplace(ValuesQueryTextWithoutGroups, "ValuesWithoutGroups.Ref IN(&Values)", "TRUE"); // @query-part-1
	EndIf;
	
	ValuesQueryTextWithGroups =
	"SELECT TOP 101
	|	ValuesWithGroups.Ref AS Ref
	|FROM
	|	(SELECT
	|		&EmptyRefValue AS Ref
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		ValuesWithoutEmptyRef.Ref
	|	FROM
	|		&AccessValuesTable AS ValuesWithoutEmptyRef) AS ValuesWithGroups
	|WHERE
	|	TRUE IN
	|			(SELECT TOP 1
	|				TRUE
	|			FROM
	|				UserAccessGroups AS AccessGroups
	|			WHERE
	|				CASE
	|					WHEN TRUE IN
	|							(SELECT TOP 1
	|								TRUE
	|							FROM
	|								InformationRegister.AccessGroupsValues AS Values
	|									INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
	|									ON
	|										Values.AccessGroup = AccessGroups.Ref
	|											AND Values.AccessValue = ValueGroups.AccessValuesGroup
	|											AND ValueGroups.AccessValue = ValuesWithGroups.Ref)
	|						THEN TRUE
	|					ELSE FALSE
	|				END = CASE
	|					WHEN TRUE IN
	|							(SELECT TOP 1
	|								TRUE
	|							FROM
	|								InformationRegister.DefaultAccessGroupsValues AS DefaultValues
	|							WHERE
	|								DefaultValues.AccessGroup = AccessGroups.Ref
	|								AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValuesWithGroups.Ref)
	|								AND DefaultValues.AllAllowed = FALSE)
	|						THEN TRUE
	|					ELSE FALSE
	|				END)
	|	AND ValuesWithGroups.Ref IN(&Values)";
	
	If TypeOf(Values) = Type("Array") Or ReturnAll Then
		ValuesQueryTextWithGroups = StrReplace(ValuesQueryTextWithGroups, "TOP 101", ""); // @query-part-1
	EndIf;
	If TypeOf(Values) <> Type("Array") Then
		ValuesQueryTextWithGroups = StrReplace(ValuesQueryTextWithGroups, "ValuesWithGroups.Ref IN(&Values)", "TRUE"); // @query-part-1
	EndIf;
	
	QueryTextAllValues =
	"SELECT TOP 101
	|	AllValues.Ref AS Ref
	|FROM
	|	(SELECT
	|		&EmptyRefValue AS Ref
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		ValuesWithoutEmptyRef.Ref
	|	FROM
	|		&AccessValuesTable AS ValuesWithoutEmptyRef) AS AllValues
	|WHERE
	|	AllValues.Ref IN(&Values)";
	
	If TypeOf(Values) = Type("Array") Or ReturnAll Then
		QueryTextAllValues = StrReplace(QueryTextAllValues, "TOP 101", ""); // @query-part-1
	EndIf;
	If TypeOf(Values) <> Type("Array") Then
		QueryTextAllValues = StrReplace(QueryTextAllValues, "AllValues.Ref IN(&Values)", "TRUE"); // @query-part-1
	EndIf;
	
	AccessKindsProperties = AccessKindsProperties();
	QueryText = "";
	If User <> Undefined Then
		AuthorizedUser = User;
	Else
		AuthorizedUser = Users.AuthorizedUser();
	EndIf;
	AddCurrentUser = False;
	HasUsedAccessKinds = False;
	UsedAccessKinds = UsedAccessKinds();
	
	For Each Current_Type In ValueTypes Do
		Properties = AccessKindsProperties.ByValuesTypes.Get(Current_Type); // See AccessKindProperties
		If Properties = Undefined Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'The ""%1"" type is not an Access Value type.';"), String(Current_Type));
			Raise ErrorText;
		EndIf;
		If UsedAccessKinds.Get(Properties.Ref) = Undefined Then
			CurrentQueryText = QueryTextAllValues;
		Else
			If AccessKindsProperties.AccessValuesTypesWithGroups.Get(Current_Type) = Undefined Then
				CurrentQueryText = ValuesQueryTextWithoutGroups;
			Else
				CurrentQueryText = ValuesQueryTextWithGroups;
			EndIf;
			HasUsedAccessKinds = True;
		EndIf;
		AccessValuesTable = Metadata.FindByType(Current_Type).FullName();
		CurrentQueryText = StrReplace(CurrentQueryText, "&AccessValuesTable", AccessValuesTable);
		CurrentQueryText = StrReplace(CurrentQueryText, "&EmptyRefValue",
			"VALUE(" + AccessValuesTable + ".EmptyRef)"); // @query-part-1
		If ValueIsFilled(QueryText) Then
			UnionQueryWithQuery(QueryText, CurrentQueryText);
		Else
			QueryText = CurrentQueryText;
		EndIf;
		If Current_Type = TypeOf(AuthorizedUser) Then
			AddCurrentUser = True;
		EndIf;
	EndDo;
	
	If Not HasUsedAccessKinds Then
		Return Undefined;
	EndIf;
	
	Query = New Query;
	Query.SetParameter("MainListTableName", Table);
	Query.SetParameter("AuthorizedUser", AuthorizedUser);
	Query.Text = AccessGroupsRequestText();
	If TypeOf(Values) = Type("Array") Then
		Query.SetParameter("Values", Values);
	EndIf;
	
	AddQueryToPackage(Query.Text, QueryText);
	
	Upload0 = Query.Execute().Unload();
	
	If TypeOf(Values) <> Type("Array")
	   And Not ReturnAll
	   And Upload0.Count() > 100 Then
		
		Return Undefined;
	EndIf;
	
	AllowedValues = Upload0.UnloadColumn("Ref");
	
	If AddCurrentUser Then
		AllowedValues.Add(AuthorizedUser);
	EndIf;
	
	Return AllowedValues;
	
EndFunction

// Adds system administrators to the access group
// connected with the predefined OpenExternalReportsAndDataProcessors profile.
//
Procedure SetExternalReportsAndDataProcessorsOpenRight(OpenAllowed) Export
	
	ProfileProperties = OpenExternalReportsAndDataProcessorsProfileDetails();
	ProfileProperties.Insert("Ref", Catalogs.AccessGroupProfiles.SuppliedProfileByID(
		ProfileProperties.Name, True));
	
	RoleID = Common.MetadataObjectID(
		Metadata.Roles.InteractiveOpenExtReportsAndDataProcessors);
	
	// It is not required to create an access group in the simplified interface (only profile).
	SimplifiedInterface = SimplifiedAccessRightsSetupInterface();
	If Not SimplifiedInterface Then
		ProfileGroup = OpenExternalReportsAndDataProcessorsAccessGroup(ProfileProperties);
	EndIf;
	
	If OpenAllowed Then
		// Adding administrators to access groups with this profile.
		AdministratorRole = Metadata.Roles.SystemAdministrator;
		IBUsers = InfoBaseUsers.GetUsers();
		UsersContent = New Array;
		For Each IBUser In IBUsers Do
			If IBUser.Roles.Contains(AdministratorRole) Then
				User = Catalogs.Users.FindByAttribute(
					"IBUserID",
					IBUser.UUID);
				If User = Undefined Then
					Continue;
				EndIf;
				If SimplifiedInterface Then
					// 
					AccessManagement.EnableProfileForUser(User, ProfileProperties.Ref);
				Else
					// 
					UsersContent.Add(User);
				EndIf;
			EndIf;
		EndDo;
		If Not SimplifiedInterface Then
			Block = New DataLock;
			LockItem = Block.Add("Catalog.AccessGroups");
			LockItem.SetValue("Ref", ProfileGroup);
			BeginTransaction();
			Try
				Block.Lock();
				AccessGroupObject = ProfileGroup.GetObject();
				For Each User In UsersContent Do
					If AccessGroupObject.Users.Find(User, "User") = Undefined Then
						AccessGroupObject.Users.Add().User = User;
					EndIf;
				EndDo;
				If AccessGroupObject.Modified() Then
					AccessGroupObject.Write();
				EndIf;
				CommitTransaction();
			Except
				RollbackTransaction();
				Raise;
			EndTry;
		EndIf;
	Else
		// Deleting a role from all profiles, except for the predefined one.
		Query = New Query;
		Query.Text =
		"SELECT DISTINCT
		|	AccessGroupProfilesRoles.Ref
		|FROM
		|	Catalog.AccessGroupProfiles.Roles AS AccessGroupProfilesRoles
		|WHERE
		|	AccessGroupProfilesRoles.Role = &Role
		|	AND AccessGroupProfilesRoles.Ref <> &ProfileToExclude";
		Query.SetParameter("Role", RoleID);
		Query.SetParameter("ProfileToExclude", ProfileProperties.Ref);
		ProfilesArray = Query.Execute().Unload().UnloadColumn("Ref");
		For Each Profile In ProfilesArray Do
			Block = New DataLock;
			LockItem = Block.Add("Catalog.AccessGroupProfiles");
			LockItem.SetValue("Ref", Profile);
			BeginTransaction();
			Try
				Block.Lock();
				ProfileObject = Profile.GetObject();
				FoundItems = ProfileObject.Roles.FindRows(New Structure("Role", RoleID));
				For Each TableRow In FoundItems Do
					ProfileObject.Roles.Delete(TableRow);
				EndDo;
				ProfileObject.Write();
				CommitTransaction();
			Except
				RollbackTransaction();
				Raise;
			EndTry;
		EndDo;
		
		// 
		Query = New Query;
		Query.Text =
		"SELECT DISTINCT
		|	AccessGroups.Ref
		|FROM
		|	Catalog.AccessGroups AS AccessGroups
		|WHERE
		|	AccessGroups.Profile = &Profile";
		Query.SetParameter("Profile", ProfileProperties.Ref);
		GroupsArray1 = Query.Execute().Unload().UnloadColumn("Ref");
		For Each AccessGroup In GroupsArray1 Do
			Block = New DataLock;
			LockItem = Block.Add("Catalog.AccessGroups");
			LockItem.SetValue("Ref", AccessGroup);
			BeginTransaction();
			Try
				Block.Lock();
				AccessGroupObject = AccessGroup.GetObject();
				AccessGroupObject.Users.Clear();
				AccessGroupObject.Write();
				CommitTransaction();
			Except
				RollbackTransaction();
				Raise;
			EndTry;
		EndDo;
	EndIf;
	
EndProcedure

// For internal use only.
Procedure OnRegisterExtensionsVersionUsageInSharedSession() Export
	
	If CurrentRunMode() = Undefined
	 Or Common.SeparatedDataUsageAvailable() Then
		Return;
	EndIf;
	
	ClearUseMainRolesForAllUsersCheckBoxForAllExtensions();
	
EndProcedure

// For internal use only.
//
// Returns:
//  Boolean
//
Function ScriptVariantRussian() Export
	
	Return Metadata.ScriptVariant = Metadata.ObjectProperties.ScriptVariant.Russian;
	
EndFunction

// Updates a role list of infobase users by their current
// access groups.
//  Users with the FullAccess role are skipped.
//
// Parameters:
//  UsersDetails - CatalogRef.Users
//                        - CatalogRef.ExternalUsers
//                        - Array - 
//                        - Undefined - 
//                        - Type - 
//                          
//                          
//                          
//
//  ServiceUserPassword - String - Password to sign in the Service Manager.
//
//  HasChanges - Boolean - a return value). True is returned
//                  to this parameter if changes are saved. Otherwise, not modified.
//
Procedure UpdateUserRoles(Val UsersDetails = Undefined,
                                    Val ServiceUserPassword = Undefined,
                                    HasChanges = False) Export
	
	If Not UsersInternal.CannotEditRoles() Then
		// 
		Return;
	EndIf;
	
	If UsersDetails = Undefined Then
		UsersArray = Undefined;
		Users.FindAmbiguousIBUsers(Undefined);
		
	ElsIf TypeOf(UsersDetails) = Type("Array") Then
		UsersArray = UsersDetails;
		If UsersArray.Count() = 0 Then
			Return;
		ElsIf UsersArray.Count() = 1 Then
			Users.FindAmbiguousIBUsers(UsersArray[0]);
		Else
			Users.FindAmbiguousIBUsers(Undefined);
		EndIf;
		
	ElsIf TypeOf(UsersDetails) = Type("Type") Then
		UsersArray = UsersDetails;
		Users.FindAmbiguousIBUsers(Undefined);
	Else
		UsersArray = New Array;
		UsersArray.Add(UsersDetails);
		Users.FindAmbiguousIBUsers(UsersDetails);
	EndIf;
	
	SetPrivilegedMode(True);
	
	CurrentUsersProperties = CurrentUsersProperties(UsersArray);
	
	// Checking parameters in the loop.
	AllRoles                             = UsersInternal.AllRoles().Map;
	IBUsersIDs       = CurrentUsersProperties.IBUsersIDs;
	NewUsersRoles              = CurrentUsersProperties.UsersRoles;
	Administrators                      = CurrentUsersProperties.Administrators;
	DataSeparationEnabled                  = Common.DataSeparationEnabled();
	InformationSecurityNeedsToBeUpdated              = InfobaseUpdate.InfobaseUpdateRequired();
	CurrentIBUserID = InfoBaseUsers.CurrentUser().UUID;
	
	RequiredAdministratorRoles = New Map;
	RequiredAdministratorRoles.Insert("FullAccess", True);
	If Not DataSeparationEnabled Then
		RequiredAdministratorRoles.Insert("SystemAdministrator", True);
	EndIf;
	StandardExtensionRoles = AccessManagementInternalCached.DescriptionStandardRolesSessionExtensions().SessionRoles;
	AdditionalAdministratorRoles = New Map(StandardExtensionRoles.AdditionalAdministratorRoles);
	OnPrepareAdminAdditionalRoles(AdditionalAdministratorRoles);
	AdditionalAdministratorRoles.Insert("InteractiveOpenExtReportsAndDataProcessors", True);
	
	// Expected result after the loop ends.
	NewIBAdministrators     = New Map;
	IBUsersToUpdate = New Map;
	InvalidRoles          = NewInvalidRoles(NewUsersRoles);
	
	For Each UserDetails In IBUsersIDs Do
		
		CurrentUser         = UserDetails.User;
		IBUserID = UserDetails.IBUserID;
		NewIBAdministrator        = False;
		
		// Search for an infobase user.
		If TypeOf(IBUserID) = Type("UUID") Then
			IBUser = InfoBaseUsers.FindByUUID(
				IBUserID);
		Else
			IBUser = Undefined;
		EndIf;
		
		If IBUser = Undefined
		 Or Not ValueIsFilled(IBUser.Name) Then
			Continue;
		EndIf;
		
		If InformationSecurityNeedsToBeUpdated
		   And IBUserID = CurrentIBUserID Then
			Continue;
		EndIf;
		
		Cancel = False;
		SSLSubsystemsIntegration.OnUpdateIBUserRoles(IBUserID, Cancel);
		If Cancel Then
			Continue;
		EndIf;
		
		Filter = New Structure("User", CurrentUser);
		NewRoles = NewUsersRoles.Copy(
			NewUsersRoles.FindRows(Filter), "Role, RoleRef");
		
		NewRoles.Indexes.Add("Role");
		
		If Administrators[CurrentUser] <> Undefined Then
			CurrentNewRoles = NewRoles;
			NewRoles = CurrentNewRoles.Copy(New Array);
			For Each KeyAndValue In RequiredAdministratorRoles Do
				NewRoles.Add().Role = KeyAndValue.Key;
			EndDo;
			For Each KeyAndValue In AdditionalAdministratorRoles Do
				If CurrentNewRoles.Find(KeyAndValue.Key, "Role") = Undefined Then
					Continue;
				EndIf;
				NewRoles.Add().Role = KeyAndValue.Key;
			EndDo;
		EndIf;
		
		// Check old roles.
		OldRoles        = New Map;
		RolesForAdding = New Map;
		RolesForDeletion   = New Map;
		
		For Each Role In IBUser.Roles Do
			NameOfRole = Role.Name;
			OldRoles.Insert(NameOfRole, True);
			If NewRoles.Find(NameOfRole, "Role") = Undefined Then
				RolesForDeletion.Insert(NameOfRole, Role);
			EndIf;
		EndDo;
		
		UnavailableRoles = UsersInternal.UnavailableRolesByUserType(
			TypeOf(CurrentUser) = Type("CatalogRef.ExternalUsers"));
		
		// 
		For Each String In NewRoles Do
			
			If OldRoles[String.Role] <> Undefined Then
				If DataSeparationEnabled
				   And UnavailableRoles.Get(String.Role) <> Undefined Then
					AddInvalidRole(InvalidRoles, String, CurrentUser, False);
					RolesForDeletion.Insert(String.Role, True);
				EndIf;
				Continue;
			EndIf;
			
			If AllRoles.Get(String.Role) = Undefined Then
				AddInvalidRole(InvalidRoles, String, CurrentUser, True);
				Continue;
			EndIf;
			
			If UnavailableRoles.Get(String.Role) <> Undefined Then
				AddInvalidRole(InvalidRoles, String, CurrentUser, False);
				Continue;
			EndIf;
			
			RolesForAdding.Insert(String.Role, True);
			
			If String.Role = "SystemAdministrator" Then
				NewIBAdministrator = True;
			EndIf;
		EndDo;
		
		// Completing the current user processing.
		If RolesForAdding.Count() = 0
		   And RolesForDeletion.Count()   = 0 Then
			Continue;
		EndIf;
		
		RolesChanges = New Structure;
		RolesChanges.Insert("UserRef", CurrentUser);
		RolesChanges.Insert("IBUser",     IBUser);
		RolesChanges.Insert("RolesForAdding",  RolesForAdding);
		RolesChanges.Insert("RolesForDeletion",    RolesForDeletion);
		
		If NewIBAdministrator Then
			NewIBAdministrators.Insert(CurrentUser, RolesChanges);
		Else
			IBUsersToUpdate.Insert(CurrentUser, RolesChanges);
		EndIf;
		
		HasChanges = True;
	EndDo;
	
	RegisterInvalidRoles(InvalidRoles);
	
	// Add administrators.
	If NewIBAdministrators.Count() > 0 Then
		UpdateIBUsersRoles(NewIBAdministrators, ServiceUserPassword);
	EndIf;
	
	// Deleting old administrators and updating other users.
	If IBUsersToUpdate.Count() > 0 Then
		UpdateIBUsersRoles(IBUsersToUpdate, ServiceUserPassword);
	EndIf;
	
	ClearUseMainRolesForAllUsersCheckBoxForAllExtensions();
	
EndProcedure

#Region UniversalRestriction

Function LimitAccessAtRecordLevelUniversally(WithConstantAccessRestrictionAtRecordLevel = True,
			WhenFirstAccessUpdateCompleted = False, UpdateSessionParametersWhenRequired = True) Export
	
	If WithConstantAccessRestrictionAtRecordLevel Then
		Value = ConstantLimitAccessAtRecordLevelUniversally();
		
		If UpdateSessionParametersWhenRequired
		   And (Value <> AccessManagementInternalCached.ConstantLimitAccessAtRecordLevelUniversally()
		      Or Value
		        And Not SessionParameters.RecordLevelAccessRestrictionIsUniversal
		        And ConstantFirstAccessUpdateCompleted()) Then
			
			UpdateSessionParameters();
			Value = AccessManagementInternalCached.ConstantLimitAccessAtRecordLevelUniversally();
		EndIf;
		
		Return Value
		      And (Not WhenFirstAccessUpdateCompleted
		         Or ConstantFirstAccessUpdateCompleted());
	EndIf;
	
	If UpdateSessionParametersWhenRequired
	   And Not SessionParameters.DIsableAccessKeysUpdate.Full
	   And Not SessionParameters.RecordLevelAccessRestrictionIsUniversal Then
		
		LastCheck = AccessManagementInternalCached.LastCheckOfAllowedSetsVersion();
		If LastCheck.Date + 3 <= CurrentSessionDate() Then
			
			Value = ConstantLimitAccessAtRecordLevelUniversally();
			If Value And ConstantFirstAccessUpdateCompleted()
			 Or Value <> AccessManagementInternalCached.ConstantLimitAccessAtRecordLevelUniversally() Then
				
				UpdateSessionParameters();
				Value = AccessManagementInternalCached.ConstantLimitAccessAtRecordLevelUniversally();
				LastCheck = AccessManagementInternalCached.LastCheckOfAllowedSetsVersion();
			EndIf;
			LastCheck.Date = CurrentSessionDate();
		EndIf;
	EndIf;
	
	If Not WhenFirstAccessUpdateCompleted Then
		Return AccessManagementInternalCached.ConstantLimitAccessAtRecordLevelUniversally();
	EndIf;
	
	Return SessionParameters.RecordLevelAccessRestrictionIsUniversal;
	
EndFunction

Function ConstantLimitAccessAtRecordLevelUniversally() Export
	
	Value = Constants.LimitAccessAtRecordLevelUniversally.Get();
	
	If Not Value And Not ScriptVariantRussian() Then
		Value = True;
		SetSafeModeDisabled(True);
		SetPrivilegedMode(True);
		ValueManager = ServiceValueManager(
			Constants.LimitAccessAtRecordLevelUniversally);
		ValueManager.Value = Value;
		ValueManager.Write();
		SetPrivilegedMode(False);
		SetSafeModeDisabled(False);
	EndIf;
	
	Return Value;
	
EndFunction

// Sets the use of the AccessUpdate scheduled job.
//
// Parameters:
//   Use - Boolean - If True, the job must be enabled. Otherwise, False.
//   WithoutCheckingIBUpdateExecution - Boolean
//
Procedure SetAccessUpdate(Use, WithoutCheckingIBUpdateExecution = False) Export
	
	If Use
	   And Not WithoutCheckingIBUpdateExecution
	   And InfobaseUpdate.InfobaseUpdateInProgress() Then
		
		Return; // After infobase update, the job is activated unconditionally.
	EndIf;
	
	If Use Then
		LastAccessUpdate = LastAccessUpdate();
		If LastAccessUpdate.AccessUpdateProhibited Then
			Return;
		EndIf;
	EndIf;
	
	EnableJob = ?(LimitAccessAtRecordLevelUniversally(), Use, False);
	
	Filter = New Structure("Metadata", Metadata.ScheduledJobs.AccessUpdateOnRecordsLevel);
	Jobs = ScheduledJobsServer.FindJobs(Filter);
	
	Required2Update = False;
	For Each Job In Jobs Do
		If EnableJob <> Job.Use Then
			Required2Update = True;
			Break;
		EndIf;
	EndDo;
	
	If Not Required2Update Then
		Return;
	EndIf;
	
	If EnableJob And ThisIsABackgroundAccessUpdateSession() Then
		Return;
	EndIf;
	
	If ExclusiveMode()
	 Or Not TransactionActive()
	 Or Common.FileInfobase() Then
		
		ChangeAccessUpdateScheduledJob(EnableJob);
		
	ElsIf EnableJob Then
		BackgroundJobs.Execute("AccessManagementInternal.EnableAccessUpdateScheduledJob",,,
			NStr("en = 'Access management: Enable ""access update"" scheduled job';",
				Common.DefaultLanguageCode()));
	Else
		BackgroundJobs.Execute("AccessManagementInternal.DisableAccessUpdateScheduledJob",,,
			NStr("en = 'Access management: Disable ""access update"" scheduled job';",
				Common.DefaultLanguageCode()));
	EndIf;
	
EndProcedure

// Returns text errors of object access restrictions without dependencies between objects.
// Texts are checked in the mode of maximum restrictions (as if all restriction kinds are enabled).
// The function must be called before the ImplementationSettings function to collect the entire error package.
//
// Returns:
//  Array of Structure:
//    * FullName   - String - Full name of a metadata object.
//    * ErrorText - String - an error text in access restriction.
//
Function AccessRestrictionErrors() Export
	
	Errors = New Array;
	CommonContext = CommonContextOfRestrictionParametersCalculation(, True, False);
	
	Try
		ListsWithRestriction = AccessManagementInternalCached.ListsWithRestriction();
	Except
		ErrorInfo = ErrorInfo();
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Access restriction lists are misspecified
			           |in procedure ""%1""
			           |of common module ""%2"". Reason:
			           |
			           |%3';"),
			"OnFillListsWithAccessRestriction",
			"AccessManagementOverridable",
			ErrorProcessing.DetailErrorDescription(ErrorInfo));
		ErrorObject = "CommonModule.AccessManagementOverridable";
		Errors.Add(New Structure("FullName, ErrorText", ErrorObject, ErrorText));
		Return Errors;
	EndTry;
	
	ErrorsTexts = New Map;
	CommonContext.Insert("ListsWithRestriction", ListsWithRestriction);
	CommonContext.Insert("RestrictionsDetails1", New Map);
	
	For Each ListDetails In CommonContext.ListsWithRestriction Do
		FullName = ListDetails.Key;
		Try
			ErrorText = AccessRestrictionError(CommonContext, FullName);
		Except
			ErrorInfo = ErrorInfo();
			ErrorText = ErrorProcessing.DetailErrorDescription(ErrorInfo);
		EndTry;
		If ValueIsFilled(ErrorText) And ErrorsTexts.Get(ErrorText) = Undefined Then
			ErrorsTexts.Insert(ErrorText, True);
			Errors.Add(New Structure("FullName, ErrorText", FullName, ErrorText));
		EndIf;
	EndDo;
	
	Return Errors;
	
EndFunction

// Returns implementation settings for developer tools.
//
// Parameters:
//  ActiveParameters - Undefined - a default value.
//                       - Structure - 
//
// Returns:
//  Structure:
//    * RestrictionsInRoles - Structure:
//       ** ForUsers        - Map of KeyAndValue:
//            *** Key     - String - a full name of the metadata object (list). Collection name in English.
//                                    Object form must have the OnReadAtServer inserted.
//            *** Value - Structure:
//                  **** TemplateForObject - Boolean - if True, the #ForObject template is used,
//                                                   if False, the #ForRegister template is used.
//                  **** Parameters - Array of String - array parameters (1 for the object, 6 for the register).
//                                   For example, the Owner field name, or a name of basic field of the Company register.
//       ** ForExternalUsers - Map of KeyAndValue - as for the users above:
//            *** Key     - String - a full name of the metadata object (list). Collection name in English.
//                                    Object form must have the OnReadAtServer inserted.
//            *** Value - Structure:
//                  **** TemplateForObject - Boolean - if True, the #ForObject template is used,
//                                                   if False, the #ForRegister template is used.
//                  **** Parameters - Array of String - array parameters (1 for the object, 6 for the register).
//                                   For example, the Owner field name, or a name of basic field of the Company register.
//
//    * PredefinedIDs - Map of KeyAndValue:
//        ** Key     - String - the name of the required predefined catalog item
//                               MetadataObjectIDs or ExtensionObjectIDs
//                               in the "<CatalogName>.<PredefinedItemName>" format.
//        ** Value - String - a full name of the relevant metadata object.
//
//    * AccessKeysValuesOwners - Structure - For the group of type collections:
//        ** References    - Array of String - full names of the reference types (collection name in English).
//        ** Documents - Array of String - full names of the object types (collection name in English).
//        ** Objects                      - Array of String - the same as in the previous paragraph.
//        ** RecordSets                - Array of String - the same as in the previous paragraph.
//        ** CalculationRegisterRecordSets - Array of String - the same as in the previous paragraph.
//
//    * AccessValues - Array of String - full names of the reference types (collection name in English).
//                                           To supplement the defined AccessValue type.
//
//    * KeysRegistersDimensionsTypes - Map of KeyAndValue:
//       For the dimensions with the Field name<?> of the AccessKeysForRegisters register and the AccessKeysToRegister<*> registers:
//           ** Key     - String - a register name.
//           ** Value - Structure:
//               *** TypesNames - Array of String - full type names (in English).
//               *** RegistersFields - Map of KeyAndValue:
//                     **** Key - String - a full name of the register being restricted.
//                     **** Value - Array of Structure:
//                            ***** Field - String - a register field name.
//                            ***** Type  - TypeDescription - register field types.
//                            Field order in the array matches
//                            internal fields Field1, Field2, …
//               *** RegistersFieldsByTypes - Map of KeyAndValue:
//                     **** Key - String - a full name of a type (in English).
//                     **** Value - Array of String - a full field name, for example,
//                                     "InformationRegister.AdditionalInfo.Property".
//
Function ImplementationSettings(ActiveParameters = Undefined) Export
	
	RestrictionsInRoles = New Structure;
	RestrictionsInRoles.Insert("ForUsers",        New Map);
	RestrictionsInRoles.Insert("ForExternalUsers", New Map);
	
	AccessKeysValuesOwners = New Structure;
	AccessKeysValuesOwners.Insert("References",        New Array);
	AccessKeysValuesOwners.Insert("Documents",     New Array);
	AccessKeysValuesOwners.Insert("Objects",       New Array);
	AccessKeysValuesOwners.Insert("RecordSets", New Array);
	AccessKeysValuesOwners.Insert("CalculationRegisterRecordSets", New Array);
	
	PredefinedIDs = New Map;
	AccessValues = New Array;
	KeysRegistersDimensionsTypes = New Map;
	KeysRegisterDimensionsTypes(KeysRegistersDimensionsTypes, "AccessKeysForRegisters");
	
	TablesTypesByNames = AccessManagementInternalCached.LanguageSyntax().TablesTypes.ByNames;
	AccessValues.Add(XMLRefTypeName(Metadata.Catalogs.AccessKeys.FullName(), TablesTypesByNames));
	
	AvailableRights = RightsForObjectsRightsSettingsAvailable();
	For Each AvailableRightsDetails In AvailableRights.ByFullNames Do
		AccessValues.Add(XMLRefTypeName(AvailableRightsDetails.Key, TablesTypesByNames));
	EndDo;
	
	If ActiveParameters = Undefined Then
		CommonContext = CommonContextOfRestrictionParametersCalculation(, True);
		NewStoredParameters = StoredAccessRestrictionParameters(CommonContext);
		ActiveParameters = New Structure(NewStoredParameters.ForWritingObjectsAndCheckingRights.Get()); // See NewStoredWriteParametersStructure
	EndIf;
	
	AddedLists = New Map;
	For Each VersionDetails In ActiveParameters.ListsRestrictionsVersions Do
		FullName = VersionDetails.Key;
		XMLFullName = XMLFullName(FullName, TablesTypesByNames);
		XMLRefTypeName  = XMLRefTypeName(FullName, TablesTypesByNames);
		XMLObjectTypeName = ObjectTypeOrXMLRecordSetName(FullName, TablesTypesByNames);
		
		If ValueIsFilled(XMLRefTypeName) Then
			AccessKeysValuesOwners.References.Add(XMLRefTypeName);
		EndIf;
		
		AddObjectToOwners(XMLObjectTypeName, AccessKeysValuesOwners);
		AddedLists.Insert(Upper(FullName), True);
		
		If VersionDetails.Value = Undefined Then
			Continue;
		EndIf;
		
		AddRestrictionsInRoles(XMLFullName,
			FullName,
			RestrictionsInRoles.ForUsers,
			ActiveParameters.AdditionalContext.ForUsers.ListRestrictionsProperties,
			KeysRegistersDimensionsTypes,
			TablesTypesByNames,
			PredefinedIDs);
		
		AddRestrictionsInRoles(XMLFullName,
			FullName,
			RestrictionsInRoles.ForExternalUsers,
			ActiveParameters.AdditionalContext.ForExternalUsers.ListRestrictionsProperties,
			KeysRegistersDimensionsTypes,
			TablesTypesByNames,
			PredefinedIDs);
	EndDo;
	
	For Each LeadingList In ActiveParameters.LeadingLists Do
		FullName = LeadingList.Key;
		If AddedLists.Get(Upper(FullName)) <> Undefined Then
			Continue;
		EndIf;
		XMLObjectTypeName = ObjectTypeOrXMLRecordSetName(FullName, TablesTypesByNames);
		AddObjectToOwners(XMLObjectTypeName, AccessKeysValuesOwners);
	EndDo;
	
	Settings = New Structure;
	Settings.Insert("RestrictionsInRoles",              RestrictionsInRoles);
	Settings.Insert("PredefinedIDs", PredefinedIDs);
	Settings.Insert("AccessKeysValuesOwners", AccessKeysValuesOwners);
	Settings.Insert("AccessValues",                AccessValues);
	Settings.Insert("KeysRegistersDimensionsTypes",   KeysRegistersDimensionsTypes);
	
	Return Settings;
	
EndFunction

// Returns access restriction check result for the developer tool.
//
// Parameters:
//  FullName - String - Full name of a metadata object.
//  AdditionalParameters - Undefined - check and return the current restriction.
//                          - Structure:
//        * Text - String - a new restriction text for users.
//        * TextForExternalUsers1 - String - a new restriction text for external users.
//        * ConsiderDependencies         - Boolean - consider dependencies between object restrictions.
//        * AllAccessKindsUsed   - Undefined - find by the current settings.
//                                       - Boolean - 
//                                                  
//
// Returns:
//  Structure:
//   * RestrictionDetailsError - String - if not blank, then the restriction description cannot be received.
//       If ConsiderDependencies = True, this is a text of the first error when all details are received.
//
//   * TextInManagerModule - Undefined - when RestrictionDetailsError is filled in.
//                           - Boolean - 
//                               
//
//   * ForUsers - Structure:
//      ** RestrictionToCheck - Undefined
//                                - String - 
//      ** ErrorsDescription         - See ErrorsDescription
//      ** RestrictionParametersGenerationError - Undefined
//                                                 - String - error text.
//      ** QueriesTextsGenerationError       - Undefined
//                                                 - String - error text.
//      ** RestrictionByOwnerPossible     - Undefined
//                                            - Boolean - 
//      ** TheOwnerRestrictionIsUsed - Undefined
//                                            - Boolean - 
//      ** RestrictionsInRoles - Undefined
//                           - Structure:
//          *** TemplateForObject - Boolean - if True, the #ForObject template is used,
//                                          if False, the #ForRegister template is used.
//          *** Parameters - Array -
//               **** Value - String - for example, the name of the "Owner" field or
//                                        the "Company" register reference field.
//      ** RestrictionInModule - Undefined
//                            - String - 
//      ** ByOwnerWithoutSavingAccessKeys - Undefined
//                                           - Boolean - 
//                                               
//
//   * ForExternalUsers - Structure - with properties like ForUsers.
//
//   * AccessKeysValuesOwner                            - String - Types for the same type collection.
//   * AccessKeysValuesOwnerObject                      - String - Types for the same type collection.
//   * AccessKeysValuesOwnerRecordSet                - String - Types for the same type collection.
//   * AccessKeysValuesOwnerCalculationRegisterRecordSet - String - Types for the same type collection.
//   * RegisterAccessKeysRegisterField                      - String - Types for the same type collection.
//   * AccessValue                                          - String - Types for the same type collection.
//
//   * DimensionTypesForSeparateKeyRegister - Undefined
//                                           - Structure:
//      ** InformationRegisterName - String - name of the access key register.
//      ** DimensionsTypes       - String - types for the corresponding register dimensions.
//
//   * PredefinedID - Undefined
//                                   - Structure:
//      ** CatalogName       - String - the name of the directory identifiers of the metadata objects (or extensions).
//      ** PredefinedItemName - String - name of the predefined one in the directory.
//
Function AccessRestrictionCheckResult(FullName, AdditionalParameters = Undefined) Export
	
	Return ObjectAccessRestrictionCheckResult(FullName, AdditionalParameters);
	
EndFunction

// Adds access update for the specified lists or all lists.
// 
// Parameters:
//  Lists - Undefined - schedule full access update.
//         - String - full name of the metadata object.
//         - CatalogRef.MetadataObjectIDs - ID.
//         - Array
//         - FixedArray - 
//
//  PlanningParameters - See AccessUpdatePlanningParameters
//
Procedure ScheduleAccessUpdate(Lists = Undefined, PlanningParameters = Undefined) Export
	
	If PlanningParameters = Undefined Then
		PlanningParameters = AccessUpdatePlanningParameters();
	EndIf;
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	If Not PlanningParameters.DataAccessKeys
	   And Not PlanningParameters.AllowedAccessKeys Then
		
		Return;
	EndIf;
	
	RegistersIDs     = New Array;
	KeysListsIDs = New Array;
	
	If Lists = Undefined Then
		If PlanningParameters.ListsRestrictionsVersions = Undefined Then
			ActiveParameters = ActiveAccessRestrictionParameters(Undefined, Undefined, False);
			ListsRestrictionsVersions = New Map(ActiveParameters.ListsRestrictionsVersions);
		Else
			ListsRestrictionsVersions = PlanningParameters.ListsRestrictionsVersions;
		EndIf;
		Query = New Query;
		Query.SetParameter("AllowedAccessKey",
			AccessManagementInternalCached.AllowedAccessKey());
		Query.Text =
		"SELECT DISTINCT
		|	VALUETYPE(DataAccessKeys.Object) AS RefType
		|FROM
		|	InformationRegister.AccessKeysForObjects AS DataAccessKeys
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|SELECT DISTINCT
		|	DataAccessKeys.Register AS Register
		|FROM
		|	InformationRegister.AccessKeysForRegisters AS DataAccessKeys
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|SELECT DISTINCT
		|	AccessKeys.List AS List
		|FROM
		|	Catalog.AccessKeys AS AccessKeys
		|WHERE
		|	AccessKeys.Ref <> &AllowedAccessKey";
		QueryResults = Query.ExecuteBatch();
		RegistersIDs     = QueryResults[1].Unload().UnloadColumn("Register");
		KeysListsIDs = QueryResults[2].Unload().UnloadColumn("List");
		
		Selection = QueryResults[0].Select();
		AllowedTypes = AccessManagementInternalCached.AllowedObjectsRefsTypesDetails();
		HasInvalidType = False;
		While Selection.Next() Do
			If TypeOf(Selection.RefType) <> Type("Type") Then
				Continue;
			ElsIf Selection.RefType = Type("Undefined")
			      Or Not AllowedTypes.ContainsType(Selection.RefType) Then
				HasInvalidType = True;
				Continue;
			EndIf;
			MetadataObject = Metadata.FindByType(Selection.RefType);
			If MetadataObject = Undefined Then
				Continue;
			EndIf;
			ListsRestrictionsVersions.Insert(MetadataObject.FullName(), True);
		EndDo;
		ListsRestrictionsVersions.Insert("Catalog.SetsOfAccessGroups", True);
		If HasInvalidType Then
			RegistersIDs.Add(Catalogs.MetadataObjectIDs.EmptyRef());
		EndIf;
		
		ListsToUpdate = New Array;
		For Each KeyAndValue In ListsRestrictionsVersions Do
			ListsToUpdate.Add(KeyAndValue.Key);
		EndDo;
		
		// 
		// 
		// 
		// 
		// 
		// 
		//    
		
	ElsIf TypeOf(Lists) <> Type("Array")
	        And TypeOf(Lists) <> Type("FixedArray") Then
		
		ListsToUpdate = CommonClientServer.ValueInArray(Lists);
	Else
		ListsToUpdate = Lists;
	EndIf;
	
	If ListsToUpdate.Count() = 0 Then
		Return;
	EndIf;
	
	If TypeOf(ListsToUpdate[0]) = Type("String") Then
		IDs = Common.MetadataObjectIDs(ListsToUpdate, Lists <> Undefined);
		ListsByIDs = New Map;
		For Each IDDetails In IDs Do
			ListsByIDs.Insert(IDDetails.Value, IDDetails.Key);
		EndDo;
	Else
		ListsByIDs = New Map;
		For Each Id In ListsToUpdate Do
			ListsByIDs.Insert(Id, "");
		EndDo;
	EndIf;
	
	If ValueIsFilled(RegistersIDs)
	 Or ValueIsFilled(KeysListsIDs) Then
		
		For Each RegisterID In RegistersIDs Do
			If RegisterID = Undefined Then
				ListsByIDs.Insert(
					Catalogs.MetadataObjectIDs.EmptyRef(), "");
			EndIf;
			ListsByIDs.Insert(RegisterID, "");
		EndDo;
		For Each AllowedItemsID In KeysListsIDs Do
			ListsByIDs.Insert(AllowedItemsID, "");
		EndDo;
	EndIf;
	
	AccessGroupsSetsCatalogID =
		InternalID("Catalog.SetsOfAccessGroups");
	
	CurrentSessionDate = CurrentSessionDate();
	RecordsUniqueKey = New UUID;
	
	IsSpotJob = False;
	JobParameters = New Structure;
	JobSize = 3;
	
	If PlanningParameters.IsObsoleteItemsDataProcessor Then
		PlanningParameters.IsUpdateContinuation = True;
		SetDataKeyKind(JobParameters, "ObsoleteItems");
		LatestUpdatedItemDate = '00010101';
		JobSize = 2;
	Else
		LeadingObject = PlanningParameters.LeadingObject; // See LeadingObjectDetails
		If LeadingObject <> Undefined
		   And Not (    LeadingObject.Property("AccordingToTheRightsCalculationCache")
		         Or LeadingObject.Property("ByAccessKeys")
		         Or LeadingObject.Property("ByValuesWithGroups")
		         Or LeadingObject.Property("ByFieldsValues")
		           And TypeOf(LeadingObject.ByFieldsValues.ChangesContent) = Type("ValueTable") ) Then
			LeadingObject = Undefined;
		EndIf;
		If LeadingObject <> Undefined Then
			IsSpotJob = True;
			PlanningParameters = New Structure(New FixedStructure(PlanningParameters));
			PlanningParameters.Insert("IsSpotJob");
			JobSize = 1;
			JobParameters.Insert("SpotJob", LeadingObject);
		EndIf;
		LatestUpdatedItemDate = ?(PlanningParameters.IsUpdateContinuation,
			MaxDateOnContinue(), MaxDate());
	EndIf;
	If JobParameters.Count() = 0 Then
		JobParameters = Undefined;
	EndIf;
	JobParametersStorage = New ValueStorage(JobParameters);
	
	DataAccessKeysUpdate       = ServiceRecordSet(InformationRegisters.DataAccessKeysUpdate);
	UsersAccessKeysUpdate = ServiceRecordSet(InformationRegisters.UsersAccessKeysUpdate);
	
	For Each ListDetails In ListsByIDs Do
		ListID = ListDetails.Key;
		
		If PlanningParameters.DataAccessKeys Then
			If PlanningParameters.ForUsers Then
				NewRecord = DataAccessKeysUpdate.Add();
				NewRecord.UniqueKey                   = RecordsUniqueKey;
				NewRecord.List                             = ListID;
				NewRecord.SpotJob                    = IsSpotJob;
				NewRecord.LatestUpdatedItemDate = LatestUpdatedItemDate;
				NewRecord.JobParameters                   = JobParametersStorage;
				NewRecord.JobSize                      = JobSize;
				NewRecord.RegisterRecordChangeDate        = CurrentSessionDate;
			EndIf;
			If PlanningParameters.ForExternalUsers Then
				NewRecord = DataAccessKeysUpdate.Add();
				NewRecord.UniqueKey                   = RecordsUniqueKey;
				NewRecord.List                             = ListID;
				NewRecord.ForExternalUsers            = True;
				NewRecord.SpotJob                    = IsSpotJob;
				NewRecord.LatestUpdatedItemDate = LatestUpdatedItemDate;
				NewRecord.JobParameters                   = JobParametersStorage;
				NewRecord.JobSize                      = JobSize;
				NewRecord.RegisterRecordChangeDate        = CurrentSessionDate;
			EndIf;
		EndIf;
		
		If ListID = AccessGroupsSetsCatalogID Then
			Continue;
		EndIf;
		
		If PlanningParameters.AllowedAccessKeys Then
			If PlanningParameters.ForUsers Then
				NewRecord = UsersAccessKeysUpdate.Add();
				NewRecord.UniqueKey            = RecordsUniqueKey;
				NewRecord.List                      = ListID;
				NewRecord.SpotJob             = IsSpotJob;
				NewRecord.JobParameters            = JobParametersStorage;
				NewRecord.JobSize               = JobSize;
				NewRecord.RegisterRecordChangeDate = CurrentSessionDate;
			EndIf;
			If PlanningParameters.ForExternalUsers Then
				NewRecord = UsersAccessKeysUpdate.Add();
				NewRecord.UniqueKey            = RecordsUniqueKey;
				NewRecord.List                      = ListID;
				NewRecord.ForExternalUsers     = True;
				NewRecord.SpotJob             = IsSpotJob;
				NewRecord.JobParameters            = JobParametersStorage;
				NewRecord.JobSize               = JobSize;
				NewRecord.RegisterRecordChangeDate = CurrentSessionDate;
			EndIf;
		EndIf;
	EndDo;
	
	If TransactionActive() And Common.FileInfobase() Then
		LockRegistersSchedulingUpdateAccessKeysInFileIB();
	EndIf;
	
	If DataAccessKeysUpdate.Count() > 0 Then
		DataAccessKeysUpdate.Write(False);
	EndIf;
	
	If UsersAccessKeysUpdate.Count() > 0 Then
		UsersAccessKeysUpdate.Write(False);
	EndIf;
	
	RegisterAccessUpdatePlanning(ListsByIDs,
		PlanningParameters, Lists = Undefined);
	
	If DataAccessKeysUpdate.Count() > 0
	 Or UsersAccessKeysUpdate.Count() > 0 Then
		
		SetAccessUpdate(True);
	EndIf;
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
EndProcedure

// The constructor of additional parameter structure for the ScheduleAccessUpdate procedure.
//
// Returns:
//  Structure:
//    * DataAccessKeys     - Boolean - True by default - schedule update of
//                                  data access keys.
//    * AllowedAccessKeys - Boolean - True by default - schedule update of access keys for
//                                  users and access groups.
//    * ForUsers        - Boolean - True by default - schedule an update for users.
//    * ForExternalUsers - Boolean - the default value of the UseExternalUsers
//                                         constant is schedule an update for external users.
//
Function AccessUpdatePlanningParameters(CalculateForExternalUsers = True) Export
	
	ForExternalUsers = ?(CalculateForExternalUsers,
		Constants.UseExternalUsers.Get(), True);
	
	Result = New Structure;
	Result.Insert("DataAccessKeys", True);
	Result.Insert("AllowedAccessKeys", True);
	Result.Insert("ForUsers", True);
	Result.Insert("ForExternalUsers", ForExternalUsers);
	Result.Insert("LeadingObject", Undefined);
	Result.Insert("ListsRestrictionsVersions", Undefined);
	Result.Insert("LongDesc", "");
	Result.Insert("IsUpdateContinuation", False);
	Result.Insert("IsObsoleteItemsDataProcessor", False);
	
	Return Result;
	
EndFunction

// Parameters:
//  LongDesc - String   - the name of the procedure which called the planning
//                        used for the extended registration in the log.
//  StartUpdate - Boolean - if True, planning
//                        will not be guaranteed as if there is a transaction,
//                        "as is" runs in the background for the update to start.
//
Procedure ScheduleAccessRestrictionParametersUpdate(LongDesc, StartUpdate = False) Export
	
	If Not LimitAccessAtRecordLevelUniversally() Then
		Return;
	EndIf;
	
	If Not TransactionActive() Or Not StartUpdate Then
		RecordPlanningForUpdatingAccessRestrictionSettings(LongDesc, StartUpdate);
		Return;
	EndIf;
	
	ProcedureParameters = New Array;
	ProcedureParameters.Add(LongDesc);
	ProcedureParameters.Add(StartUpdate);
	
	BackgroundJobs.Execute(
		"AccessManagementInternal.RecordPlanningForUpdatingAccessRestrictionSettings",
		ProcedureParameters,, NStr("en = 'Access management: Schedule access update';",
			Common.DefaultLanguageCode()));
	
EndProcedure

// Only for the ScheduleAccessRestrictionParametersUpdate procedure.
Procedure RecordPlanningForUpdatingAccessRestrictionSettings(LongDesc, StartUpdate) Export
	
	If Not LimitAccessAtRecordLevelUniversally() Then
		Return;
	EndIf;
	
	PlanningParameters = AccessUpdatePlanningParameters();
	PlanningParameters.AllowedAccessKeys = False;
	PlanningParameters.LongDesc = LongDesc;
	
	Id = InternalID("InformationRegister.AccessRestrictionParameters");
	If Id <> Null Then
		ScheduleAccessUpdate(Id, PlanningParameters);
		If StartUpdate Then
			StartAccessUpdate();
		EndIf;
	EndIf;
	
EndProcedure

// Starts access update if it is scheduled and not started yet.
Procedure StartAccessUpdate() Export
	
	If Not LimitAccessAtRecordLevelUniversally(False) Then
		Return;
	EndIf;
	
	If ExclusiveMode() Then
		Return;
	EndIf;
	
	StartAccessUpdateAtRecordLevel();
	
EndProcedure

// For internal use only.
Procedure UpdateAccessAfterInfobaseUpdate(ExecuteDeferredUpdateNow) Export
	
	If Common.DataSeparationEnabled()
	   And Not Common.SeparatedDataUsageAvailable() Then
		Return;
	EndIf;
	
	If ExecuteDeferredUpdateNow
	   And LimitAccessAtRecordLevelUniversally() Then
		
		ExecuteAccessUpdateAtRecordLevel(True, False, 0, True);
	EndIf;
	
EndProcedure

// For the ExtensionsRolesRights function and the FillAllExtensionParameters function
// of the ExtensionVersionParameters information register manager module.
//
Procedure SetARecordOfAccessRestrictionParametersInTheCurrentSession(Enable) Export
	
	SetPrivilegedMode(True);
	
	CurrentParameters = SessionParameters.AccessRestrictionParameters;
	PropertyName = "RecordingAccessRestrictionParametersInTheCurrentSession";
	
	If Not Enable And Not CurrentParameters.Property(PropertyName) Then
		Return;
	EndIf;
	
	NewParameters = New Structure(CurrentParameters);
	
	If Enable Then
		If Not NewParameters.Property(PropertyName) Then
			NewParameters.Insert(PropertyName, 0);
		EndIf;
		NewParameters[PropertyName] = NewParameters[PropertyName] + 1;
	Else
		NewParameters[PropertyName] = NewParameters[PropertyName] - 1;
		If NewParameters[PropertyName] < 1 Then
			NewParameters.Delete(PropertyName);
		EndIf;
	EndIf;
	
	SessionParameters.AccessRestrictionParameters = New FixedStructure(NewParameters);
	
	SetPrivilegedMode(False);
	
EndProcedure

#EndRegion

////////////////////////////////////////////////////////////////////////////////
// Configuration subsystems event handlers.

// See BatchEditObjectsOverridable.OnDefineObjectsWithEditableAttributes.
Procedure OnDefineObjectsWithEditableAttributes(Objects) Export
	Objects.Insert(Metadata.Catalogs.AccessGroups.FullName(), "AttributesToSkipInBatchProcessing");
	Objects.Insert(Metadata.Catalogs.AccessGroupProfiles.FullName(), "AttributesToSkipInBatchProcessing");
EndProcedure

// See CommonOverridable.OnAddSessionParameterSettingHandlers.
Procedure OnAddSessionParameterSettingHandlers(Handlers) Export
	
	Handlers.Insert("RecordLevelAccessRestrictionInUse",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("AccessKindsWithoutGroupsForAccessValues",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("AccessKindsWithSingleGroupForAccessValue",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("DisabledAccessKinds",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("AllAccessKindsExceptSpecialOnes",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("TablesWithIndividualRightsSettings",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("AccessValuesTypesWithGroups",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("RightsSettingsOwnersTypes",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("IDsOfTablesWithIndividualRightsSettings",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("TableOfExtensionsWithAccessRestriction",
		"AccessManagementInternal.SessionParametersSetting");
	
	#Region UniversalRestriction
	
	Handlers.Insert("RecordLevelAccessRestrictionIsUniversal",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("DIsableAccessKeysUpdate",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("AccessRestrictionTemplatesVersions",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("AllowedAccessGroupsSet",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("AllowedBlankAccessGroupsSet",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("AllowedUserGroupsSet",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("AllowedUser",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("CommonAccessRestrictionTemplateParameters",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("ListsWithRestrictionByFields",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("ListsWithAccessGroupsAccessKeysRestriction",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("ListsWithUsersAccessKeysRestriction",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("ListsWithReadRestrictionDisabled",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("AccessRestrictionParameters",
		"AccessManagementInternal.SessionParametersSetting");
	
	#EndRegion
	
EndProcedure

// See ScheduledJobsOverridable.OnDefineScheduledJobSettings
Procedure OnDefineScheduledJobSettings(Settings) Export
	
	Setting = Settings.Add();
	Setting.ScheduledJob = Metadata.ScheduledJobs.DataFillingForAccessRestriction;
	Setting.FunctionalOption = Metadata.FunctionalOptions.LimitAccessAtRecordLevel;
	
	Setting = Settings.Add();
	Setting.ScheduledJob = Metadata.ScheduledJobs.AccessUpdateOnRecordsLevel;
	Setting.FunctionalOption = Metadata.FunctionalOptions.LimitAccessAtRecordLevelUniversally;
	
EndProcedure

// Updates auxiliary data that depends only on configuration.
// Writes changes of this data (if any) by configuration versions
// to use these changes upon updating other auxiliary data,
// for example, in the UpdateAuxiliaryDataByConfigurationChanges handler.
//
Procedure UpdateAccessRestrictionParameters(HasChanges = Undefined) Export
	
	// 
	InformationRegisters.RolesRights.UpdateRegisterData(HasChanges);
	
	// ЗависимостиПравДоступа
	InformationRegisters.AccessRightsDependencies.UpdateRegisterData(HasChanges);
	
	// Parameter StandardSubsystems.AccessManagement.AccessKindsProperties.
	UpdateAccessKindsPropertiesDetails(HasChanges);
	
	// 
	InformationRegisters.ObjectsRightsSettings.UpdateAvailableRightsForObjectsRightsSettings(HasChanges);
	
	// 
	Catalogs.AccessGroupProfiles.UpdateSuppliedProfilesDescription(HasChanges);
	
	// 
	Catalogs.AccessGroupProfiles.UpdatePredefinedProfileComposition(HasChanges);
	
	// 
	InformationRegisters.AccessRestrictionParameters.UpdateAccessRestrictionTextsVersion(HasChanges);
	
EndProcedure

// Updates description of access kind properties in the application parameters.
// 
// Parameters:
//  HasChanges - Boolean - a return value. If recorded,
//                  True is set, otherwise, it does not change.
//
Procedure UpdateAccessKindsPropertiesDetails(HasChanges = False) Export
	
	SetPrivilegedMode(True);
	
	Cache = AccessManagementInternalCached.DescriptionPropertiesAccessTypesSession();
	NewValue = Cache.HashAmounts;
	
	BeginTransaction();
	Try
		HasCurrentChanges = False;
		PreviousValue2 = Undefined;
		
		StandardSubsystemsServer.UpdateApplicationParameter(
			"StandardSubsystems.AccessManagement.AccessKindsProperties",
			NewValue, HasCurrentChanges, PreviousValue2);
		
		PreviousValue2 = NewHashSumAccessTypeProperties(PreviousValue2);
		
		HasChangesOfGroupsTypesAndAccessValues =
			NewValue.HashSumGroupTypesFromAccessValues
			 <> PreviousValue2.HashSumGroupTypesFromAccessValues;
		
		StandardSubsystemsServer.AddApplicationParameterChanges(
			"StandardSubsystems.AccessManagement.GroupAndAccessValueTypes",
			?(HasChangesOfGroupsTypesAndAccessValues,
			  New FixedStructure("HasChanges", True),
			  New FixedStructure()) );
		
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
	If HasCurrentChanges Then
		HasChanges = True;
	EndIf;
	
EndProcedure

// See InfobaseUpdateSSL.OnAddUpdateHandlers.
Procedure OnAddUpdateHandlers(Handlers) Export
	
	// Shared data update handlers.
	Handler = Handlers.Add();
	Handler.SharedData = True;
	Handler.HandlerManagement = True;
	Handler.Priority = 1;
	Handler.Version = "*";
	Handler.ExecutionMode = "Seamless";
	Handler.Procedure = "AccessManagementInternal.FillSeparatedDataHandlers";
	
	// 
	Handler = Handlers.Add();
	Handler.Version = "*";
	Handler.ExecutionMode = "Seamless";
	Handler.Procedure = "AccessManagementInternal.UpdateAuxiliaryRegisterDataByConfigurationChanges";
	
	// 
	Handler = Handlers.Add();
	Handler.Version = "1.0.0.1";
	Handler.InitialFilling = True;
	Handler.Procedure = "Catalogs.AccessGroups.FillAdministratorsAccessGroupProfile";
	Handler.ExecutionMode = "Exclusively";
	Handler.ExecuteInMandatoryGroup = True;
	Handler.Priority = 1;
	
	Handler = Handlers.Add();
	Handler.Version = "2.4.1.1";
	Handler.Procedure = "AccessManagementInternal.UpdateProfileDataOpenExternalReportsAndDataProcessors";
	Handler.ExecutionMode = "Seamless";
	Handler.ExecuteInMandatoryGroup = True;
	Handler.Priority = 1;
	
	Handler = Handlers.Add();
	Handler.Version = "3.1.3.169";
	Handler.Procedure = "Catalogs.AccessGroups.ProcessDataForMigrationToNewVersion";
	Handler.ExecutionMode = "Deferred";
	Handler.RunAlsoInSubordinateDIBNodeWithFilters = True;
	Handler.Comment = NStr("en = 'Corrects data visibility in some lists with record-level access restrictions enabled.';");
	Handler.Id = New UUID("b73c2481-f789-4b2d-b705-8219aea0e75d");
	Handler.CheckProcedure = "InfobaseUpdate.DataUpdatedForNewApplicationVersion";
	Handler.UpdateDataFillingProcedure = "Catalogs.AccessGroups.RegisterDataToProcessForMigrationToNewVersion";
	Handler.ObjectsToRead = "Catalog.AccessGroups";
	Handler.ObjectsToChange = "InformationRegister.AccessGroupsTables,InformationRegister.AccessGroupsValues,InformationRegister.DefaultAccessGroupsValues";
	
	If Common.SubsystemExists("StandardSubsystems.NationalLanguageSupport") Then
		Handler.ExecutionPriorities = InfobaseUpdate.HandlerExecutionPriorities();
		NewRow = Handler.ExecutionPriorities.Add();
		NewRow.Procedure = "NationalLanguageSupportServer.ProcessDataForMigrationToNewVersion";
		NewRow.Order = "Before";
	EndIf;
	
	Handler = Handlers.Add();
	Handler.Version = "3.1.3.135";
	Handler.Procedure = "InformationRegisters.AccessValuesGroups.ProcessDataForMigrationToNewVersion";
	Handler.ExecutionMode = "Deferred";
	Handler.Comment = NStr("en = 'Updates data by application changes.';");
	Handler.Id = New UUID("b3cb643e-d5cf-40b7-9db3-6315a88c063d");
	Handler.UpdateDataFillingProcedure = "InformationRegisters.AccessValuesGroups.RegisterDataToProcessForMigrationToNewVersion";
	Handler.ObjectsToRead = "InformationRegister.AccessValuesGroups";
	Handler.ObjectsToChange = "InformationRegister.AccessValuesGroups";
	
	Handler = Handlers.Add();
	Handler.Version = "3.0.2.174";
	Handler.Procedure = "InformationRegisters.ObjectsRightsSettings.ProcessDataForMigrationToNewVersion";
	Handler.ExecutionMode = "Deferred";
	Handler.Comment = NStr("en = 'Updates service data of access rights settings.';");
	Handler.Id = New UUID("40d1c62f-c3f1-4608-8985-2dc618c3d758");
	Handler.UpdateDataFillingProcedure = "InformationRegisters.ObjectsRightsSettings.RegisterDataToProcessForMigrationToNewVersion";
	Handler.ObjectsToRead = "InformationRegister.ObjectsRightsSettings";
	Handler.ObjectsToChange = "InformationRegister.ObjectsRightsSettings";
	
EndProcedure

// See also InfobaseUpdateOverridable.OnDefineSettings
//
// Parameters:
//  Objects - Array of MetadataObject
//
Procedure OnDefineObjectsWithInitialFilling(Objects) Export
	
	Objects.Add(Metadata.Catalogs.AccessGroupProfiles);
	Objects.Add(Metadata.Catalogs.AccessGroups);
	
EndProcedure

// See InfobaseUpdateSSL.AfterUpdateInfobase.
Procedure AfterUpdateInfobase(Val PreviousVersion, Val CurrentVersion,
		Val CompletedHandlers, OutputUpdatesDetails, ExclusiveMode) Export
	
	UpdateAuxiliaryDataOfItemsChangedOnImport();
	
	If Common.SeparatedDataUsageAvailable() Then
		InformationRegisters.UsedAccessKinds.UpdateRegisterData();
		SetAccessUpdate(True, True);
	EndIf;
	
EndProcedure

// See InfobaseUpdateOverridable.OnPopulateObjectsPlannedForDeletion.
Procedure OnPopulateObjectsPlannedForDeletion(Objects) Export
	
	// 
	AccessRightsDependencies = InformationRegisters.AccessRightsDependencies.AccessRightsDependencies();
	LeadingTablesTypes = New Array;
	For Each String In AccessRightsDependencies Do
		LeadingTablesTypes.Add(TypeOf(String.LeadingTableType));
	EndDo;
	RequiredTypeOfLeadingTable = New TypeDescription(LeadingTablesTypes);
	
	AddObjectPlannedForDeletion(Objects, RequiredTypeOfLeadingTable,
		Metadata.InformationRegisters.AccessRightsDependencies.Dimensions.LeadingTableType);
	
	If Not Common.SeparatedDataUsageAvailable() Then
		Return;
	EndIf;
	
	ImplementationSettings = ImplementationSettings();
	AccessKindsProperties = AccessKindsProperties();
	
	// 
	TypesOfGroupsAndValues = New Array;
	For Each KeyAndValue In AccessKindsProperties.ByGroupsAndValuesTypes Do
		TypesOfGroupsAndValues.Add(KeyAndValue.Key);
	EndDo;
	RequiredAccessValueType = New TypeDescription(
		StrConcat(ImplementationSettings.AccessValues, ","));
	RequiredAccessValueType = New TypeDescription(RequiredAccessValueType, TypesOfGroupsAndValues);
	
	AddObjectPlannedForDeletion(Objects, RequiredAccessValueType,
		Metadata.InformationRegisters.AccessGroupsValues.Dimensions.AccessValue);
	
	AddObjectPlannedForDeletion(Objects, RequiredAccessValueType,
		Metadata.InformationRegisters.DefaultAccessGroupsValues.Dimensions.AccessValuesType);
	
	AddObjectPlannedForDeletion(Objects, RequiredAccessValueType,
		Metadata.InformationRegisters.AccessValuesGroups.Dimensions.AccessValue);
	
	AddObjectPlannedForDeletion(Objects, RequiredAccessValueType,
		Metadata.InformationRegisters.AccessValuesGroups.Dimensions.AccessValuesGroup);
	
	AddObjectPlannedForDeletion(Objects, RequiredAccessValueType,
		Metadata.InformationRegisters.UsedAccessKinds.Dimensions.AccessValuesType);
	
	AddObjectPlannedForDeletion(Objects, RequiredAccessValueType,
		Metadata.InformationRegisters.UsedAccessKindsByTables.Dimensions.AccessValuesType);
	
	// 
	AvailableRights = RightsForObjectsRightsSettingsAvailable();
	RightsSettingsOwnersTypes = New Array;
	For Each RightsOwner In AvailableRights.OwnersTypes Do
		RightsSettingsOwnersTypes.Add(TypeOf(RightsOwner));
	EndDo;
	RequiredTypeOfRightsSettingsOwner = New TypeDescription(RightsSettingsOwnersTypes);
	
	AddObjectPlannedForDeletion(Objects, RequiredTypeOfRightsSettingsOwner,
		Metadata.InformationRegisters.ObjectsRightsSettings.Dimensions.Object);
	
	AddObjectPlannedForDeletion(Objects, RequiredTypeOfRightsSettingsOwner,
		Metadata.InformationRegisters.ObjectRightsSettingsInheritance.Dimensions.Object);
	
	AddObjectPlannedForDeletion(Objects, RequiredTypeOfRightsSettingsOwner,
		Metadata.InformationRegisters.ObjectRightsSettingsInheritance.Dimensions.Parent);
	
	// 
	AddObjectPlannedForDeletion(Objects,
		New TypeDescription(StrConcat(ImplementationSettings.AccessKeysValuesOwners.References, ",")),
		Metadata.InformationRegisters.AccessKeysForObjects.Dimensions.Object);
	
	// 
	For Each KeysRegistersDetails In ImplementationSettings.KeysRegistersDimensionsTypes Do
		KeysRegisterName = KeysRegistersDetails.Key;
		KeysRegisterMetadata = Metadata.InformationRegisters[KeysRegisterName];
		FieldsCount = AccessManagementInternalCached.BasicRegisterFieldsCount(KeysRegisterName);
		RequiredFieldType = New TypeDescription(StrConcat(KeysRegistersDetails.Value.TypesNames, ","));
		For FieldNumber = 1 To FieldsCount Do
			FieldName = "Field" + FieldNumber;
			AddObjectPlannedForDeletion(Objects, RequiredFieldType,
				KeysRegisterMetadata.Dimensions[FieldName]);
		EndDo;
	EndDo;
	
	// 
	SubscriptionObjectsTypes = AccessManagementInternalCached.ObjectsTypesInSubscriptionsToEvents(
		"WriteAccessValuesSets");
	SubscriptionsObjectsRefsTypes = New Array;
	For Each KeyAndValue In SubscriptionObjectsTypes Do
		ObjectMetadata = Metadata.FindByType(KeyAndValue.Key);
		ObjectManager = Common.ObjectManagerByFullName(ObjectMetadata.FullName());
		EmptyRef = ObjectManager.EmptyRef();
		SubscriptionsObjectsRefsTypes.Add(TypeOf(EmptyRef));
	EndDo;
	RequiredTypeOfTablesWithWritingAccessValueSets = New TypeDescription(SubscriptionsObjectsRefsTypes);
	
	AddObjectPlannedForDeletion(Objects, RequiredTypeOfTablesWithWritingAccessValueSets,
		Metadata.InformationRegisters.AccessValuesSets.Dimensions.Object);
	
	// 
	AddObjectPlannedForDeletion(Objects, RequiredAccessValueType,
		Metadata.InformationRegisters.AccessValuesSets.Dimensions.AccessValue);
	
EndProcedure

// Parameters:
//  ChangingLanguages - See NationalLanguageSupportServer.DescriptionOfOldAndNewLanguageSettings
//
Procedure WhenChangingTheLanguageOfTheInformationBase(ChangingLanguages) Export
	
	Catalogs.AccessGroupProfiles.WhenChangingTheLanguageOfTheInformationBase(ChangingLanguages);
	
EndProcedure

// Fills parameter structures required by the
// application client code.
//
// Parameters:
//   Parameters   - Structure - a parameter structure.
//
Procedure OnAddClientParameters(Parameters) Export
	
	Parameters.Insert("SimplifiedAccessRightsSetupInterface",
		SimplifiedAccessRightsSetupInterface());
	
EndProcedure

// See CommonOverridable.OnAddReferenceSearchExceptions.
Procedure OnAddReferenceSearchExceptions(RefSearchExclusions) Export
	
	RefSearchExclusions.Add(Metadata.InformationRegisters.AccessValuesGroups);
	RefSearchExclusions.Add(Metadata.InformationRegisters.AccessRightsDependencies);
	RefSearchExclusions.Add(Metadata.InformationRegisters.AccessGroupsValues);
	RefSearchExclusions.Add(Metadata.InformationRegisters.DefaultAccessGroupsValues);
	RefSearchExclusions.Add(Metadata.InformationRegisters.AccessValuesSets);
	RefSearchExclusions.Add(Metadata.InformationRegisters.RolesRights);
	RefSearchExclusions.Add(Metadata.InformationRegisters.ObjectRightsSettingsInheritance);
	RefSearchExclusions.Add(Metadata.InformationRegisters.ObjectsRightsSettings);
	RefSearchExclusions.Add(Metadata.InformationRegisters.AccessGroupsTables);
	
	OnAddRefsSearchExceptionsThatAllowDeletion(RefSearchExclusions);
	
EndProcedure

// Objects with deferred deletion.
// See CommonOverridable.OnAddReferenceSearchExceptions
//
// Parameters:
//  RefSearchExclusions - See CommonOverridable.OnAddReferenceSearchExceptions.RefSearchExclusions
//
Procedure OnAddRefsSearchExceptionsThatAllowDeletion(RefSearchExclusions) Export
	
	RefSearchExclusions.Add(Metadata.Catalogs.AccessKeys);
	RefSearchExclusions.Add(Metadata.Catalogs.SetsOfAccessGroups);
	RefSearchExclusions.Add(Metadata.InformationRegisters.ExternalUsersAccessKeys);
	RefSearchExclusions.Add(Metadata.InformationRegisters.AccessGroupsAccessKeys);
	RefSearchExclusions.Add(Metadata.InformationRegisters.AccessGroupSetsAccessKeys);
	RefSearchExclusions.Add(Metadata.InformationRegisters.AccessKeysForObjects);
	RefSearchExclusions.Add(Metadata.InformationRegisters.AccessKeysForRegisters);
	RefSearchExclusions.Add(Metadata.InformationRegisters.UsersAccessKeys);
	RefSearchExclusions.Add(Metadata.InformationRegisters.DataAccessKeysUpdate);
	RefSearchExclusions.Add(Metadata.InformationRegisters.UsersAccessKeysUpdate);
	RefSearchExclusions.Add(Metadata.InformationRegisters.AccessRestrictionParameters);
	
	For Each InformationRegister In Metadata.InformationRegisters Do 
		If StrStartsWith(Upper(InformationRegister.Name), Upper("AccessKeysToRegister")) Then 
			RefSearchExclusions.Add(InformationRegister);
		EndIf;
	EndDo;
	
EndProcedure

// This procedure is called when importing predefined item references while importing important data.
// Allows correcting or registering information on non-unique
// predefined items. Also allows you to cancel further actions if the uniqueness issue cannot be solved.
//
// Parameters:
//   Object          - CatalogObject
//                   - ChartOfCharacteristicTypesObject
//                   - ChartOfAccountsObject
//                   - ChartOfCalculationTypesObject -
//                     
//   WriteToLog - Boolean - a return value. Set to False not to
//                     add the uniqueness conflict details to the event log in a common message.
//                     Set to False if the uniqueness conflict was resolved automatically.
//   Cancel           - Boolean - a return value. Set to True to raise an exception
//                     with cancellation details.
//   CancelDetails  - String -  a return value. If Cancel is set to True, the description is added
//                     to the list of the reasons preventing from further actions.
//
Procedure OnFindNotUniquePredefinedItem(Object, WriteToLog, Cancel, CancelDetails) Export
	
	If TypeOf(Object) = Type("CatalogObject.AccessGroupProfiles")
	   And Object.PredefinedDataName = "Administrator" Then
		
		WriteToLog = False;
		
		Query = New Query;
		Query.SetParameter("Ref", Object.Ref);
		Query.SetParameter("PredefinedDataName", "Administrator");
		Query.Text =
		"SELECT
		|	AccessGroupProfiles.Ref AS Ref
		|FROM
		|	Catalog.AccessGroupProfiles AS AccessGroupProfiles
		|WHERE
		|	AccessGroupProfiles.Ref <> &Ref
		|	AND AccessGroupProfiles.PredefinedDataName = &PredefinedDataName";
		
		Selection = Query.Execute().Select();
		
		Block = New DataLock;
		LockItem = Block.Add("Catalog.AccessGroupProfiles");
		
		While Selection.Next() Do
			LockItem.SetValue("Ref", Selection.Ref);
			BeginTransaction();
			Try
				Block.Lock();
				CurrentObject = Selection.Ref.GetObject();
				CurrentObject.PredefinedDataName = "";
				CurrentObject.SuppliedDataID = "";
				InfobaseUpdate.WriteData(CurrentObject);
				CommitTransaction();
			Except
				RollbackTransaction();
				Raise;
			EndTry;
		EndDo;
		
	ElsIf TypeOf(Object) = Type("CatalogObject.AccessGroups")
	        And Object.PredefinedDataName = "Administrators" Then
		
		WriteToLog = False;
		
		Query = New Query;
		Query.SetParameter("PredefinedDataName", "Administrators");
		Query.Text =
		"SELECT DISTINCT
		|	AccessGroupsUsers_SSLy.User
		|FROM
		|	Catalog.AccessGroups.Users AS AccessGroupsUsers_SSLy
		|WHERE
		|	AccessGroupsUsers_SSLy.Ref.PredefinedDataName = &PredefinedDataName";
		AllUsers = Query.Execute().Unload().UnloadColumn("User");
		
		Write = False;
		For Each User In AllUsers Do
			If Object.Users.Find(User, "User") = Undefined Then
				Object.Users.Add().User = User;
				Write = True;
			EndIf;
		EndDo;
		
		If Write Then
			InfobaseUpdate.WriteData(Object);
		EndIf;
		
		Query.SetParameter("Ref", Object.Ref);
		Query.Text =
		"SELECT
		|	AccessGroups.Ref AS Ref
		|FROM
		|	Catalog.AccessGroups AS AccessGroups
		|WHERE
		|	AccessGroups.Ref <> &Ref
		|	AND AccessGroups.PredefinedDataName = &PredefinedDataName";
		
		Selection = Query.Execute().Select();
		
		Block = New DataLock;
		LockItem = Block.Add("Catalog.AccessGroups");
		
		While Selection.Next() Do
			LockItem.SetValue("Ref", Selection.Ref);
			BeginTransaction();
			Try
				Block.Lock();
				CurrentObject = Selection.Ref.GetObject();
				CurrentObject.PredefinedDataName = "";
				InfobaseUpdate.WriteData(CurrentObject);
				CommitTransaction();
			Except
				RollbackTransaction();
				Raise;
			EndTry;
		EndDo;
	EndIf;
	
EndProcedure

// See DataExchangeOverridable.OnSetUpSubordinateDIBNode.
Procedure OnSetUpSubordinateDIBNode() Export
	
	// Роли расширений назначаются независимо во всех РИБ-
	Catalogs.AccessGroupProfiles.DeleteExtensionsRolesInAllAccessGroupsProfiles();
	
	// Администраторы назначаются независимо во всех РИБ-
	Catalogs.AccessGroups.DeleteMembersOfAdministratorsAccessGroupWithoutIBUser();
	
	If Common.IsStandaloneWorkplace() Then
		Catalogs.AccessGroupProfiles.UpdateSuppliedProfilesByConfigurationChanges();
	EndIf;
	Catalogs.AccessGroupProfiles.UpdateNonSuppliedProfilesOnConfigurationChanges();
	
	If LimitAccessAtRecordLevelUniversally()
	   And (Common.IsSubordinateDIBNodeWithFilter()
	      Or Common.IsStandaloneWorkplace()) Then
		
		PlanningParameters = AccessUpdatePlanningParameters();
		PlanningParameters.LongDesc = "OnSetUpSubordinateDIBNode";
		ScheduleAccessUpdate(, PlanningParameters);
	EndIf;
	
EndProcedure

// See StandardSubsystems.OnSendDataToMaster.
Procedure OnSendDataToMaster(DataElement, ItemSend, Recipient) Export
	
	If AccessManagementSubsystemObjectOnlyToCreateInitialImage(DataElement) Then
		ItemSend = DataItemSend.Ignore;
		Return;
	EndIf;
	
	// 
	// 
	If Common.IsStandaloneWorkplace()
	   And (    TypeOf(DataElement) = Type("CatalogObject.AccessGroupProfiles")
	        And IsProfileOpenExternalReportsAndDataProcessors(DataElement)
	      Or TypeOf(DataElement) = Type("CatalogObject.AccessGroups")
	        And Not DataElement.IsFolder
	        And IsProfileOpenExternalReportsAndDataProcessors(DataElement.Profile) ) Then
		
		ItemSend = DataItemSend.Ignore;
	EndIf;
	
	// Extension roles are assigned independently in all DIB nodes.
	If TypeOf(DataElement) = Type("CatalogObject.AccessGroupProfiles") Then
		Catalogs.AccessGroupProfiles.DeleteExtensionsRoles(DataElement);
	EndIf;
	
EndProcedure

// See StandardSubsystemsServer.OnSendDataToSlave.
Procedure OnSendDataToSlave(DataElement, ItemSend, InitialImageCreating, Recipient) Export
	
	// 
	// 
	// 
	
	// 
	// 
	// 
	
	If InitialImageCreating Then
		Return;
	EndIf;
	
	If AccessManagementSubsystemObjectOnlyToCreateInitialImage(DataElement) Then
		ItemSend = DataItemSend.Ignore;
		Return;
	EndIf;
	
EndProcedure

// See StandardSubsystemsServer.OnReceiveDataFromMaster.
Procedure OnReceiveDataFromMaster(DataElement, ItemReceive, SendBack, Sender) Export
	
	// Standard data processor cannot be overridden.
	If ItemReceive = DataItemReceive.Ignore Then
		Return;
	EndIf;
	
	If AccessManagementSubsystemObjectOnlyToCreateInitialImage(DataElement) Then
		ItemReceive = DataItemReceive.Ignore;
		Return;
	EndIf;
	
	OnReceiveDataFromMasterOrSlave(DataElement);
	
EndProcedure

// See StandardSubsystemsServer.OnReceiveDataFromSlave.
Procedure OnReceiveDataFromSlave(DataElement, ItemReceive, SendBack, Sender) Export
	
	// Standard data processor cannot be overridden.
	If ItemReceive = DataItemReceive.Ignore Then
		Return;
	EndIf;
	
	If AccessManagementSubsystemObjectOnlyToCreateInitialImage(DataElement) Then
		ItemReceive = DataItemReceive.Ignore;
		Return;
	EndIf;
	
	If Not Common.DataSeparationEnabled() Then
		OnReceiveDataFromMasterOrSlave(DataElement);
		
	ElsIf TypeOf(DataElement) = Type("ConstantValueManager.LimitAccessAtRecordLevel")
	      Or TypeOf(DataElement) = Type("ConstantValueManager.LimitAccessAtRecordLevelUniversally")
	      Or TypeOf(DataElement) = Type("CatalogObject.AccessGroups")
	      Or TypeOf(DataElement) = Type("CatalogObject.AccessGroupProfiles")
	      Or TypeOf(DataElement) = Type("InformationRegisterRecordSet.AccessValuesGroups")
	      Or TypeOf(DataElement) = Type("InformationRegisterRecordSet.AccessValuesSets")
	      Or TypeOf(DataElement) = Type("InformationRegisterRecordSet.ObjectRightsSettingsInheritance")
	      Or TypeOf(DataElement) = Type("InformationRegisterRecordSet.ObjectsRightsSettings")
	      Or TypeOf(DataElement) = Type("InformationRegisterRecordSet.UsedAccessKinds") Then
		
		// 
		// 
		ItemReceive = DataItemReceive.Ignore;
		SendBack = True;
	EndIf;
	
EndProcedure

// See StandardSubsystemsServer.AfterGetData.
Procedure AfterGetData(Sender, Cancel, GetFromMasterNode) Export
	
	If InfobaseUpdate.InfobaseUpdateInProgress() Then
		Return;
	EndIf;
	
	UpdateAuxiliaryDataOfItemsChangedOnImport();
	
EndProcedure

// See description in the FillAllExtensionsParameters procedure
// of the ExtensionVersionParameters information register manager module.
//
Procedure OnFillAllExtensionParameters() Export
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	// Parameter StandardSubsystems.AccessManagement.RolesRights.
	UpdateAccessGroupsTablesForEnabledExtensions();
	
	If InformationRegisters.ApplicationRuntimeParameters.UpdateRequired1() Then
		// 
		// 
		// 
		Return;
	EndIf;
	
	// Parameter StandardSubsystems.AccessManagement.AccessKindsProperties.
	UpdateGroupsAndSetsOfAccessValuesWhenGroupTypesAndValuesChange();
	
	// 
	InformationRegisters.ObjectsRightsSettings.UpdateAuxiliaryRegisterDataByConfigurationChanges1();
	
	// 
	Catalogs.AccessGroupProfiles.UpdateSuppliedProfilesByConfigurationChanges();
	Catalogs.AccessGroupProfiles.UpdateNonSuppliedProfilesOnConfigurationChanges();
	
	// 
	Catalogs.AccessGroups.MarkForDeletionSelectedProfilesAccessGroups();
	
	// 
	// 
	// 
	UpdateUserRoles();
	
	// Parameter StandardSubsystems.AccessManagement.AccessRestrictionTextsVersion.
	ScheduleAccessRestrictionParametersUpdate(
		"OnFillAllExtensionParameters");
	
EndProcedure

// Event handlers of the Users subsystem.

// See UsersOverridable.OnDefineSettings.
Procedure OnDefineSettings(Settings) Export
	
	// 
	// 
	Settings.EditRoles = False;
	
EndProcedure

// See UsersOverridable.ChangeActionsOnForm.
Procedure OnDefineActionsInForm(Val UserOrGroup, Val ActionsOnForm) Export
	
	ActionsOnForm.Roles = "";
	
EndProcedure

// See SSLSubsystemsIntegration.AfterWriteAdministratorOnAuthorization.
Procedure AfterWriteAdministratorOnAuthorization(Comment) Export
	
	Comment =
		NStr("en = 'The application was started on behalf of a user with the ""Full access"" role
		           |that is not registered in the user list.
		           |The user is automatically registered in the list
		           |and added to the ""Administrators"" access group.
		           |
		           |Please use the ""Users"" list to manage users and their rights
		           |instead of the default user list in Designer mode.';");
	
EndProcedure

// See SSLSubsystemsIntegration.AfterSetIBUser.
Procedure AfterSetIBUser(Ref, ServiceUserPassword) Export
	
	UpdateUserRoles(Ref, ServiceUserPassword);
	
	If LimitAccessAtRecordLevelUniversally() Then
		ScheduleAccessUpdateOnIndirectChangeOfAccessGroupMembers(
			CommonClientServer.ValueInArray(Ref),, True);
	EndIf;
	
EndProcedure

// See SSLSubsystemsIntegration.OnDefineQuestionTextBeforeWriteFirstAdministrator.
Procedure OnDefineQuestionTextBeforeWriteFirstAdministrator(QueryText) Export
	
	QueryText =
		NStr("en = 'You are about to add the first user to the list of users.
		           |The user will be automatically added to the Administrators access group.
		           |Do you want to continue?';")
	
EndProcedure

// See SSLSubsystemsIntegration.OnCreateAdministrator.
Procedure OnCreateAdministrator(Administrator, Refinement) Export
	
	If TypeOf(Administrator) <> Type("CatalogRef.Users") Then
		Return;
	EndIf;
	
	Query = New Query;
	Query.SetParameter("User", Administrator);
	Query.SetParameter("AdministratorsAccessGroup",
		AccessManagement.AdministratorsAccessGroup());
	Query.Text =
	"SELECT
	|	TRUE AS TrueValue
	|FROM
	|	Catalog.AccessGroups.Users AS AccessGroupsUsers_SSLy
	|WHERE
	|	AccessGroupsUsers_SSLy.Ref = &AdministratorsAccessGroup
	|	AND AccessGroupsUsers_SSLy.User = &User";
	
	If Not Query.Execute().IsEmpty() Then
		Return;
	EndIf;
	
	CommentForLog = StringFunctionsClientServer.SubstituteParametersToString(
		NStr("en = 'User ""%1"" was added to the Administrators access group. Reason:
		           |%2';"),
		Administrator,
		Refinement);
	
	AdministratorsAccessGroup = AccessManagement.AdministratorsAccessGroup();
	
	Block = New DataLock;
	LockItem = Block.Add("Catalog.AccessGroups");
	LockItem.SetValue("Ref", AdministratorsAccessGroup);
	
	BeginTransaction();
	Try
		Block.Lock();
		Object = AdministratorsAccessGroup.GetObject();
		LockDataForEdit(Object.Ref, Object.DataVersion);
		If Object.Users.Find(Administrator, "User") = Undefined Then
			Object.Users.Add().User = Administrator;
			InfobaseUpdate.WriteData(Object);
			WriteLogEvent(
				NStr("en = 'Access management.Automatic change of ""Administrators"" access group';",
				     Common.DefaultLanguageCode()),
				EventLogLevel.Information,
				Metadata.Catalogs.Users,
				Administrator,
				CommentForLog,
				EventLogEntryTransactionMode.Transactional);
		EndIf;
		UnlockDataForEdit(Object.Ref);
		
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

// See SSLSubsystemsIntegration.AfterAddChangeUserOrGroup.
Procedure AfterAddChangeUserOrGroup(Ref, IsNew) Export
	
	If IsNew Then
		If TypeOf(Ref) = Type("CatalogRef.UserGroups")
		 Or TypeOf(Ref) = Type("CatalogRef.ExternalUsersGroups") Then
		
			Parameters = New Structure;
			Parameters.Insert("UserGroups", Ref);
			InformationRegisters.AccessValuesGroups.UpdateUsersGroups(Parameters);
		EndIf;
	EndIf;
	
EndProcedure

// See SSLSubsystemsIntegration.AfterUserGroupsUpdate.
Procedure AfterUserGroupsUpdate(ItemsToChange, ModifiedGroups) Export
	
	Parameters = New Structure;
	Parameters.Insert("Users",        ItemsToChange);
	Parameters.Insert("UserGroups", ModifiedGroups);
	
	InformationRegisters.AccessValuesGroups.UpdateUsersGroups(Parameters);
	
	UpdateUserRoles(ItemsToChange);
	
	If LimitAccessAtRecordLevelUniversally() Then
		ScheduleAccessUpdateOnIndirectChangeOfAccessGroupMembers(ItemsToChange);
		ScheduleAccessUpdateOnIndirectChangeOfAccessGroupMembers(ModifiedGroups);
	EndIf;
	
EndProcedure

// See SSLSubsystemsIntegration.AfterChangeExternalUserAuthorizationObject.
Procedure AfterChangeExternalUserAuthorizationObject(ExternalUser,
                                                               PreviousAuthorizationObject,
                                                               NewAuthorizationObject) Export
	
	AuthorizationObjects = New Array;
	If PreviousAuthorizationObject <> NULL Then
		AuthorizationObjects.Add(PreviousAuthorizationObject);
	EndIf;
	AuthorizationObjects.Add(NewAuthorizationObject);
	
	Parameters = New Structure;
	Parameters.Insert("AuthorizationObjects", AuthorizationObjects);
	
	InformationRegisters.AccessValuesGroups.UpdateUsersGroups(Parameters);
	
EndProcedure

// Copies rights of one user to another.
Procedure OnCopyRightsToNewUser(Source, Receiver) Export
	
	If TransactionActive()
	   And Common.FileInfobase() Then
		
		Block = New DataLock;
		Block.Add("Catalog.AccessGroups");
		// ACC:1320-
		// 
		// 
		// 
		Block.Lock();
		// ACC:1320-on.
	EndIf;
	
	SimplifiedInterface = SimplifiedAccessRightsSetupInterface();
	Query = New Query;
	Query.SetParameter("User", Source);
	
	If SimplifiedInterface Then
		Query.Text =
		"SELECT DISTINCT
		|	AccessGroups.Profile AS Profile
		|FROM
		|	Catalog.AccessGroups AS AccessGroups
		|	INNER JOIN Catalog.AccessGroups.Users AS AccessGroupsUsers_SSLy
		|	ON
		|		AccessGroups.User = &User
		|		AND AccessGroupsUsers_SSLy.Ref = AccessGroups.Ref
		|		AND AccessGroupsUsers_SSLy.User = &User";
	Else
		Query.Text =
		"SELECT DISTINCT
		|	AccessGroupsUsers_SSLy.Ref AS AccessGroup
		|FROM
		|	Catalog.AccessGroups.Users AS AccessGroupsUsers_SSLy
		|WHERE
		|	AccessGroupsUsers_SSLy.User = &User";
	EndIf;
	
	QueryResult = Query.Execute();
	If QueryResult.IsEmpty() Then
		Return;
	EndIf;
	
	Selection = QueryResult.Select();
	
	If Not SimplifiedInterface Then
		Block = New DataLock();
		LockItem = Block.Add("Catalog.AccessGroups");
		LockItem.DataSource = QueryResult;
	EndIf;
	
	BeginTransaction();
	Try
		If SimplifiedInterface Then
			While Selection.Next() Do
				AccessManagement.EnableDisableUserProfile(Receiver, Selection.Profile, True, Source);
			EndDo;
		Else
			Block.Lock();
			While Selection.Next() Do
				AccessGroupObject = Selection.AccessGroup.GetObject(); // CatalogObject.AccessGroups
				If AccessGroupObject.Users.Find(Receiver, "User") = Undefined Then
					String = AccessGroupObject.Users.Add();
					String.User = Receiver;
					AccessGroupObject.Write();
				EndIf;
			EndDo;
		EndIf;
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

// Event handlers of the ReportsOptions subsystem.

// See ReportsOptionsOverridable.CustomizeReportsOptions.
Procedure OnSetUpReportsOptions(Settings) Export
	
	ModuleReportsOptions = Common.CommonModule("ReportsOptions");
	ModuleReportsOptions.CustomizeReportInManagerModule(Settings, Metadata.Reports.AccessRights);
	ModuleReportsOptions.CustomizeReportInManagerModule(Settings, Metadata.Reports.AccessRightsAnalysis);
	ModuleReportsOptions.CustomizeReportInManagerModule(Settings, Metadata.Reports.RolesRights);
	
EndProcedure

// See ReportsOptionsOverridable.BeforeAddReportCommands.
Procedure BeforeAddReportCommands(ReportsCommands, Parameters, StandardProcessing) Export
	
	Reports.AccessRightsAnalysis.BeforeAddReportCommands(ReportsCommands, Parameters, StandardProcessing);
	Reports.RolesRights.BeforeAddReportCommands(ReportsCommands, Parameters, StandardProcessing);
	
EndProcedure

// 

// See ReportMailingOverridable.DetermineReportsToExclude
Procedure WhenDefiningExcludedReports(ReportsToExclude) Export
	
	ReportsToExclude.Add(Metadata.Reports.AccessRights);
	
EndProcedure

// AccountingAudit subsystem event handlers.

// See SSLSubsystemsIntegration.OnDefineObjectsToExcludeFromCheck
Procedure OnDefineObjectsToExcludeFromCheck(Objects) Export
	OnAddRefsSearchExceptionsThatAllowDeletion(Objects);
EndProcedure

// AccessManagement subsystem event handlers.

// See AccessManagementOverridable.OnFillListsWithAccessRestriction.
Procedure OnFillListsWithAccessRestriction(Lists) Export
	
	Lists.Insert(Metadata.Catalogs.AccessGroupProfiles, True);
	Lists.Insert(Metadata.Catalogs.AccessGroups, True);
	
EndProcedure

// Events handlers of the SaaSTechnology library.

// See ExportImportDataOverridable.OnRegisterDataExportHandlers
Procedure OnRegisterDataExportHandlers(HandlersTable) Export
	
	Handler = HandlersTable.Add();
	Handler.MetadataObject = Metadata.Catalogs.AccessGroupProfiles;
	Handler.Handler = Catalogs.AccessGroupProfiles;
	Handler.BeforeExportObject = True;
	Handler.Version = "1.0.0.1";
	
	Handler = HandlersTable.Add();
	Handler.MetadataObject = Metadata.Catalogs.AccessGroups;
	Handler.Handler = Catalogs.AccessGroups;
	Handler.BeforeExportObject = True;
	Handler.Version = "1.0.0.1";
	
	Handler = HandlersTable.Add();
	Handler.MetadataObject = Metadata.InformationRegisters.AccessGroupsValues;
	Handler.Handler = InformationRegisters.AccessGroupsValues;
	Handler.BeforeExportObject = True;
	Handler.Version = "1.0.0.1";
	
	Handler = HandlersTable.Add();
	Handler.MetadataObject = Metadata.InformationRegisters.DefaultAccessGroupsValues;
	Handler.Handler = InformationRegisters.DefaultAccessGroupsValues;
	Handler.BeforeExportObject = True;
	Handler.Version = "1.0.0.1";
	
EndProcedure

// MonitoringCenter procedures and functions.

// Returns the query text to collect the statistic data on the use of access group and role profiles.
//
// Returns:
//  String
//
Function RolesUsageQueryText() Export
	
	Return
	"SELECT
	|	UserGroupCompositions.UsersGroup AS UsersGroup,
	|	UsersInfo.User AS User,
	|	CASE
	|		WHEN DATEDIFF(UsersInfo.LastActivityDate, &CurrentDate, DAY) <= 7
	|			THEN 1
	|		ELSE 0
	|	END AS ActiveWeekly,
	|	CASE
	|		WHEN DATEDIFF(UsersInfo.LastActivityDate, &CurrentDate, DAY) <= 30
	|			THEN 1
	|		ELSE 0
	|	END AS ActiveMonthly
	|INTO TTGroupListsAndActivity
	|FROM
	|	InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|		LEFT JOIN InformationRegister.UsersInfo AS UsersInfo
	|		ON UserGroupCompositions.User = UsersInfo.User
	|WHERE
	|	UserGroupCompositions.Used
	|	AND NOT UserGroupCompositions.User.IBUserID = &EmptyUID
	|
	|INDEX BY
	|	UsersGroup,
	|	User
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	AccessGroupProfiles.Ref AS Profile,
	|	AccessGroupProfiles.SuppliedDataID AS SuppliedDataID,
	|	AccessGroupProfiles.SuppliedProfileChanged AS SuppliedProfileChanged,
	|	AccessGroupProfiles.Description AS Description,
	|	AccessGroupsUsers_SSLy.Ref AS AccessGroup,
	|	AccessGroupsUsers_SSLy.Ref.User = VALUE(Catalog.Users.EmptyRef)
	|		OR AccessGroupsUsers_SSLy.Ref.User = VALUE(Catalog.ExternalUsers.EmptyRef)
	|		OR AccessGroupsUsers_SSLy.Ref.User = UNDEFINED AS CommonAccessGroup,
	|	AccessGroupsUsers_SSLy.User AS TabularSectionUser,
	|	UserGroupCompositions.User AS InformationRegisterUser,
	|	UserGroupCompositions.ActiveWeekly AS ActiveWeekly,
	|	UserGroupCompositions.ActiveMonthly AS ActiveMonthly
	|INTO TTProfileData
	|FROM
	|	Catalog.AccessGroups.Users AS AccessGroupsUsers_SSLy
	|		INNER JOIN TTGroupListsAndActivity AS UserGroupCompositions
	|		ON AccessGroupsUsers_SSLy.User = UserGroupCompositions.UsersGroup
	|		INNER JOIN Catalog.AccessGroupProfiles AS AccessGroupProfiles
	|		ON (AccessGroupProfiles.Ref = AccessGroupsUsers_SSLy.Ref.Profile)
	|			AND (NOT AccessGroupsUsers_SSLy.Ref.Profile.DeletionMark)
	|WHERE
	|	NOT AccessGroupsUsers_SSLy.Ref.Profile.DeletionMark
	|
	|GROUP BY
	|	AccessGroupProfiles.Ref,
	|	AccessGroupProfiles.Description,
	|	AccessGroupsUsers_SSLy.User,
	|	UserGroupCompositions.User,
	|	UserGroupCompositions.ActiveWeekly,
	|	UserGroupCompositions.ActiveMonthly,
	|	AccessGroupsUsers_SSLy.Ref,
	|	AccessGroupsUsers_SSLy.Ref.User = VALUE(Catalog.Users.EmptyRef)
	|		OR AccessGroupsUsers_SSLy.Ref.User = VALUE(Catalog.ExternalUsers.EmptyRef)
	|		OR AccessGroupsUsers_SSLy.Ref.User = UNDEFINED,
	|	AccessGroupProfiles.SuppliedDataID,
	|	AccessGroupProfiles.SuppliedProfileChanged
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT DISTINCT
	|	TTProfileData.Profile AS Profile,
	|	TTProfileData.Description AS Description,
	|	TTProfileData.SuppliedDataID AS SuppliedDataID,
	|	TTProfileData.SuppliedProfileChanged AS SuppliedProfileChanged
	|INTO Profiles
	|FROM
	|	TTProfileData AS TTProfileData
	|
	|INDEX BY
	|	Profile
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	Profiles.Profile AS Profile,
	|	SUM(CASE
	|			WHEN NOT AccessGroupProfilesAccessTypes.AccessKind IS NULL
	|				THEN 1
	|			ELSE 0
	|		END) AS TotalAccessKinds,
	|	SUM(CASE
	|			WHEN ISNULL(AccessGroupProfilesAccessTypes.Predefined, FALSE)
	|				THEN 1
	|			ELSE 0
	|		END) AS PresetAccessKinds
	|INTO AccessKinds
	|FROM
	|	Profiles AS Profiles
	|		LEFT JOIN Catalog.AccessGroupProfiles.AccessKinds AS AccessGroupProfilesAccessTypes
	|		ON Profiles.Profile = AccessGroupProfilesAccessTypes.Ref
	|
	|GROUP BY
	|	Profiles.Profile
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	Nested.Profile AS Profile,
	|	COUNT(DISTINCT Nested.AccessGroup) AS AccessGroup,
	|	SUM(CASE
	|			WHEN NOT Nested.CommonAccessGroup
	|				THEN 1
	|			ELSE 0
	|		END) AS PersonalGroup
	|INTO AccessGroups
	|FROM
	|	(SELECT
	|		TTProfileData.Profile AS Profile,
	|		TTProfileData.AccessGroup AS AccessGroup,
	|		TTProfileData.CommonAccessGroup AS CommonAccessGroup
	|	FROM
	|		TTProfileData AS TTProfileData
	|	
	|	GROUP BY
	|		TTProfileData.Profile,
	|		TTProfileData.AccessGroup,
	|		TTProfileData.CommonAccessGroup) AS Nested
	|
	|GROUP BY
	|	Nested.Profile
	|
	|INDEX BY
	|	Profile
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	Nested.Profile AS Profile,
	|	SUM(CASE
	|			WHEN Nested.TabularSectionUser REFS Catalog.UserGroups
	|				THEN 1
	|			ELSE 0
	|		END) AS UserGroups_SSLy,
	|	SUM(CASE
	|			WHEN Nested.TabularSectionUser REFS Catalog.ExternalUsersGroups
	|				THEN 1
	|			ELSE 0
	|		END) AS GroupsOfExternalUsers
	|INTO UserGroups
	|FROM
	|	(SELECT
	|		TTProfileData.Profile AS Profile,
	|		TTProfileData.TabularSectionUser AS TabularSectionUser
	|	FROM
	|		TTProfileData AS TTProfileData
	|	
	|	GROUP BY
	|		TTProfileData.Profile,
	|		TTProfileData.TabularSectionUser) AS Nested
	|
	|GROUP BY
	|	Nested.Profile
	|
	|INDEX BY
	|	Profile
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	Nested.Profile AS Profile,
	|	SUM(CASE
	|			WHEN Nested.InformationRegisterUser REFS Catalog.Users
	|				THEN 1
	|			ELSE 0
	|		END) AS Users,
	|	SUM(CASE
	|			WHEN Nested.InformationRegisterUser REFS Catalog.ExternalUsers
	|				THEN 1
	|			ELSE 0
	|		END) AS ExternalUsers,
	|	SUM(Nested.ActiveWeekly) AS ActiveWeekly,
	|	SUM(Nested.ActiveMonthly) AS ActiveMonthly
	|INTO ProfileUsers
	|FROM
	|	(SELECT
	|		TTProfileData.Profile AS Profile,
	|		TTProfileData.InformationRegisterUser AS InformationRegisterUser,
	|		SUM(TTProfileData.ActiveWeekly) AS ActiveWeekly,
	|		SUM(TTProfileData.ActiveMonthly) AS ActiveMonthly
	|	FROM
	|		TTProfileData AS TTProfileData
	|	
	|	GROUP BY
	|		TTProfileData.Profile,
	|		TTProfileData.InformationRegisterUser) AS Nested
	|
	|GROUP BY
	|	Nested.Profile
	|
	|INDEX BY
	|	Profile
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	Profiles.Profile AS Profile,
	|	Profiles.Description AS Description,
	|	Profiles.SuppliedDataID AS SuppliedDataID,
	|	Profiles.SuppliedProfileChanged AS SuppliedProfileChanged,
	|	ISNULL(AccessGroups.AccessGroup, 0) AS AccessGroup,
	|	ISNULL(AccessGroups.PersonalGroup, 0) AS PersonalGroup,
	|	ISNULL(UserGroups.UserGroups_SSLy, 0) AS UserGroups_SSLy,
	|	ISNULL(UserGroups.GroupsOfExternalUsers, 0) AS GroupsOfExternalUsers,
	|	ISNULL(ProfileUsers.Users, 0) AS Users,
	|	ISNULL(ProfileUsers.ExternalUsers, 0) AS ExternalUsers,
	|	ISNULL(ProfileUsers.ActiveWeekly, 0) AS ActiveWeekly,
	|	ISNULL(ProfileUsers.ActiveMonthly, 0) AS ActiveMonthly,
	|	ISNULL(AccessKinds.TotalAccessKinds, 0) AS TotalAccessKinds,
	|	ISNULL(AccessKinds.PresetAccessKinds, 0) AS PresetAccessKinds
	|FROM
	|	Profiles AS Profiles
	|		LEFT JOIN ProfileUsers AS ProfileUsers
	|		ON Profiles.Profile = ProfileUsers.Profile
	|		LEFT JOIN UserGroups AS UserGroups
	|		ON Profiles.Profile = UserGroups.Profile
	|		LEFT JOIN AccessGroups AS AccessGroups
	|		ON Profiles.Profile = AccessGroups.Profile
	|		LEFT JOIN AccessKinds AS AccessKinds
	|		ON Profiles.Profile = AccessKinds.Profile
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT DISTINCT
	|	Profiles.Profile AS Profile,
	|	ISNULL(AccessGroupProfilesRoles.Role.Name, """") AS RoleName
	|FROM
	|	Profiles AS Profiles
	|		LEFT JOIN Catalog.AccessGroupProfiles.Roles AS AccessGroupProfilesRoles
	|		ON Profiles.Profile = AccessGroupProfilesRoles.Ref
	|			AND (Profiles.SuppliedDataID = &EmptyUID
	|				OR Profiles.SuppliedProfileChanged)
	|
	|ORDER BY
	|	Profile";
	
EndFunction

#EndRegion

#Region Private

// See ExportImportDataOverridable.OnRegisterDataExportHandlers.
Procedure BeforeExportObject(Container, ObjectExportManager, Serializer, Object, Artifacts, Cancel) Export
	
	// Extension roles are assigned independently both in the box and in the service.
	If TypeOf(Object) = Type("CatalogObject.AccessGroupProfiles") Then
		Catalogs.AccessGroupProfiles.DeleteExtensionsRoles(Object);
	EndIf;
	
	// 
	// 
	If Common.DataSeparationEnabled() Then
		Return;
	EndIf;
	
	If TypeOf(Object) = Type("CatalogObject.AccessGroupProfiles") Then
		Profile = Object;
		
	ElsIf TypeOf(Object) = Type("CatalogObject.AccessGroups") And Not Object.IsFolder Then
		Profile = Object.Profile;
	Else
		Return;
	EndIf;
	
	If IsProfileOpenExternalReportsAndDataProcessors(Profile) Then
		Cancel = True;
	EndIf;
	
EndProcedure

// See ExportImportDataOverridable.OnRegisterDataExportHandlers.
Procedure BeforeExportRecordSet(Container, ObjectExportManager, Serializer, Object, Artifacts, Cancel) Export
	
	// 
	// 
	If Common.DataSeparationEnabled() Then
		Return;
	EndIf;
	
	AccessGroups = ProfileAccessGroupsOpenExternalReportsAndDataProcessors();
	
	IndexOf = Object.Count() - 1;
	While IndexOf >= 0 Do
		If AccessGroups.Find(Object[IndexOf].AccessGroup) <> Undefined Then
			Object.Delete(IndexOf);
		EndIf;
		IndexOf = IndexOf - 1;
	EndDo;
	
EndProcedure

// Parameters:
//  ParameterName - String
//  SpecifiedParameters - Array of String
//
Procedure SessionParametersSetting(ParameterName, SpecifiedParameters) Export
	
	#Region UniversalRestriction
	If ParameterName = "AccessRestrictionParameters" Then
		SessionParameters.AccessRestrictionParameters = New FixedStructure(New Structure);
		SpecifiedParameters.Add("AccessRestrictionParameters");
		Return;
	EndIf;
	
	If ParameterName = "DIsableAccessKeysUpdate" Then
		SessionParameters.DIsableAccessKeysUpdate = NewDisableOfAccessKeysUpdate();
		SpecifiedParameters.Add("DIsableAccessKeysUpdate");
		Return;
	EndIf;
	
	UniversalRestriction = LimitAccessAtRecordLevelUniversally(True, True, False);
	
	If ParameterName = "RecordLevelAccessRestrictionIsUniversal"
	 Or SessionParameters.RecordLevelAccessRestrictionIsUniversal <> UniversalRestriction Then
		
		BeforeChangeSessionParametersForTemplates(
			New Structure("RecordLevelAccessRestrictionIsUniversal", UniversalRestriction),
			ParameterName = "RecordLevelAccessRestrictionIsUniversal");
		
		SessionParameters.RecordLevelAccessRestrictionIsUniversal = UniversalRestriction;
	EndIf;
	
	SpecifiedParameters.Add("RecordLevelAccessRestrictionIsUniversal");
	If ParameterName = "RecordLevelAccessRestrictionIsUniversal" Then
		Return;
	EndIf;
	#EndRegion
	
	// 
	// 
	LimitAccessAtRecordLevel = Constants.LimitAccessAtRecordLevel.Get();
	InfobaseLockedForUpdate = ValueIsFilled(
		InfobaseUpdateInternal.InfobaseLockedForUpdate(False));
	
	#Region UniversalRestriction
	If Not LimitAccessAtRecordLevel
	 Or Not UniversalRestriction
	 Or InfobaseLockedForUpdate Then
		
		SessionParameters.ListsWithReadRestrictionDisabled =
			?(InfobaseLockedForUpdate
				Or Not UniversalRestriction, "Undefined", "All");
		
		BlankAccessGroupsSet = Catalogs.SetsOfAccessGroups.EmptyRef();
		
		SessionParameters.AccessRestrictionTemplatesVersions   = AccessRestrictionTemplatesVersions();
		SessionParameters.AllowedAccessGroupsSet       = BlankAccessGroupsSet;
		SessionParameters.AllowedBlankAccessGroupsSet = BlankAccessGroupsSet;
		SessionParameters.AllowedUserGroupsSet = BlankAccessGroupsSet;
		SessionParameters.AllowedUser            = BlankAccessGroupsSet;
		SessionParameters.CommonAccessRestrictionTemplateParameters = "";
		SessionParameters.ListsWithAccessGroupsAccessKeysRestriction  = "";
		SessionParameters.ListsWithUsersAccessKeysRestriction = "";
		SessionParameters.ListsWithRestrictionByFields = "";
		
		SpecifiedParameters.Add("ListsWithReadRestrictionDisabled");
		SpecifiedParameters.Add("AccessRestrictionTemplatesVersions");
		SpecifiedParameters.Add("AllowedAccessGroupsSet");
		SpecifiedParameters.Add("AllowedBlankAccessGroupsSet");
		SpecifiedParameters.Add("AllowedUserGroupsSet");
		SpecifiedParameters.Add("AllowedUser");
		SpecifiedParameters.Add("CommonAccessRestrictionTemplateParameters");
		SpecifiedParameters.Add("ListsWithAccessGroupsAccessKeysRestriction");
		SpecifiedParameters.Add("ListsWithUsersAccessKeysRestriction");
		SpecifiedParameters.Add("ListsWithRestrictionByFields");
	EndIf;
	#EndRegion
	
	If Not LimitAccessAtRecordLevel
	 Or UniversalRestriction
	 Or InfobaseLockedForUpdate Then
		
		SessionParameters.RecordLevelAccessRestrictionInUse =
			?(InfobaseLockedForUpdate
				Or UniversalRestriction, "", False);
		
		SessionParameters.AllAccessKindsExceptSpecialOnes             = "";
		SessionParameters.DisabledAccessKinds      = "";
		SessionParameters.AccessKindsWithoutGroupsForAccessValues      = "";
		SessionParameters.AccessKindsWithSingleGroupForAccessValue = "";
		
		SessionParameters.AccessValuesTypesWithGroups
			= New FixedArray(New Array);
		
		SessionParameters.TablesWithIndividualRightsSettings = "";
		
		SessionParameters.IDsOfTablesWithIndividualRightsSettings
			= New FixedArray(New Array);
		
		SessionParameters.RightsSettingsOwnersTypes
			= New FixedArray(New Array);
		
		SessionParameters.TableOfExtensionsWithAccessRestriction = "";
		
		SpecifiedParameters.Add("RecordLevelAccessRestrictionInUse");
		SpecifiedParameters.Add("AllAccessKindsExceptSpecialOnes");
		SpecifiedParameters.Add("DisabledAccessKinds");
		SpecifiedParameters.Add("AccessKindsWithoutGroupsForAccessValues");
		SpecifiedParameters.Add("AccessKindsWithSingleGroupForAccessValue");
		SpecifiedParameters.Add("AccessValuesTypesWithGroups");
		SpecifiedParameters.Add("TablesWithIndividualRightsSettings");
		SpecifiedParameters.Add("IDsOfTablesWithIndividualRightsSettings");
		SpecifiedParameters.Add("RightsSettingsOwnersTypes");
		SpecifiedParameters.Add("TableOfExtensionsWithAccessRestriction");
	EndIf;
	
	If InfobaseLockedForUpdate Then
		Return;
	EndIf;
	
	#Region UniversalRestriction
	If UniversalRestriction Then
		ActiveAccessRestrictionParameters(Undefined, Undefined, False, True);
		Return;
	EndIf;
	#EndRegion
	
	If Not LimitAccessAtRecordLevel Then
		Return;
	EndIf;
	
	SessionParameters.RecordLevelAccessRestrictionInUse = True;
	
	Query = New Query;
	Query.SetParameter("CurrentUser", Users.AuthorizedUser());
	Query.Text =
	"SELECT
	|	DefaultValues.AccessValuesType AS ValuesType
	|FROM
	|	InformationRegister.DefaultAccessGroupsValues AS DefaultValues
	|		INNER JOIN Catalog.AccessGroups.Users AS AccessGroupsUsers_SSLy
	|		ON (AccessGroupsUsers_SSLy.Ref = DefaultValues.AccessGroup)
	|		INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|		ON (AccessGroupsUsers_SSLy.User = UserGroupCompositions.UsersGroup)
	|			AND (UserGroupCompositions.User = &CurrentUser)
	|
	|GROUP BY
	|	DefaultValues.AccessValuesType
	|
	|HAVING
	|	MIN(DefaultValues.AllAllowedWithoutExceptions) = TRUE";
	
	ValuesTypesAllAllowedWithoutExceptions = Query.Execute().Unload().UnloadColumn("ValuesType");
	
	// Setting parameters AllAccessKindsExceptSpecialOnes and DisabledAccessKinds.
	AllAccessKindsExceptSpecialOnes        = New Array;
	DisabledAccessKinds = New Array;
	
	AccessKindsProperties = AccessKindsProperties();
	UsedAccessKinds = UsedAccessKinds();
	
	For Each AccessKindProperties In AccessKindsProperties.Array Do
		AllAccessKindsExceptSpecialOnes.Add(AccessKindProperties.Name);
		
		If UsedAccessKinds.Get(AccessKindProperties.Ref) = Undefined
		 Or ValuesTypesAllAllowedWithoutExceptions.Find(AccessKindProperties.Ref) <> Undefined Then
			
			DisabledAccessKinds.Add(AccessKindProperties.Name);
		EndIf;
	EndDo;
	
	SessionParameters.AllAccessKindsExceptSpecialOnes = AllAccessKindsCombinations(AllAccessKindsExceptSpecialOnes);
	
	SpecifiedParameters.Add("AllAccessKindsExceptSpecialOnes");
	
	AllAccessKindsExceptSpecialOnesDisabled = (AllAccessKindsExceptSpecialOnes.Count()
		= DisabledAccessKinds.Count());
	
	If AllAccessKindsExceptSpecialOnesDisabled Then
		SessionParameters.DisabledAccessKinds = "All";
	Else
		SessionParameters.DisabledAccessKinds
			= AllAccessKindsCombinations(DisabledAccessKinds);
	EndIf;
	
	SpecifiedParameters.Add("DisabledAccessKinds");
	
	// 
	// 
	SessionParameters.AccessKindsWithoutGroupsForAccessValues =
		AllAccessKindsCombinations(AccessKindsProperties.NoGroupsForAccessValue);
	SessionParameters.AccessKindsWithSingleGroupForAccessValue =
		AllAccessKindsCombinations(AccessKindsProperties.WithOneGroupForAccessValue);
	
	AccessValuesTypesWithGroups = New Array;
	For Each KeyAndValue In AccessKindsProperties.AccessValuesTypesWithGroups Do
		AccessValuesTypesWithGroups.Add(KeyAndValue.Value);
	EndDo;
	SessionParameters.AccessValuesTypesWithGroups = New FixedArray(AccessValuesTypesWithGroups);
	
	SpecifiedParameters.Add("AccessKindsWithoutGroupsForAccessValues");
	SpecifiedParameters.Add("AccessKindsWithSingleGroupForAccessValue");
	SpecifiedParameters.Add("AccessValuesTypesWithGroups");
	
	// 
	// 
	AvailableRights = RightsForObjectsRightsSettingsAvailable();
	SeparateTables = AvailableRights.SeparateTables;
	TablesWithIndividualRightsSettings = "";
	IDsOfTablesWithIndividualRightsSettings = New Array;
	For Each KeyAndValue In SeparateTables Do
		TablesWithIndividualRightsSettings = TablesWithIndividualRightsSettings
			+ "|" + KeyAndValue.Value + ";" + Chars.LF;
		IDsOfTablesWithIndividualRightsSettings.Add(KeyAndValue.Key);
	EndDo;
	
	SessionParameters.TablesWithIndividualRightsSettings = TablesWithIndividualRightsSettings;
	
	SessionParameters.IDsOfTablesWithIndividualRightsSettings =
		New FixedArray(IDsOfTablesWithIndividualRightsSettings);
	
	SessionParameters.RightsSettingsOwnersTypes = AvailableRights.OwnersTypes;
	
	FullNames = Catalogs.ExtensionObjectIDs.DataTablesFullNames();
	ExtensionsTables = StrConcat(FullNames, ";" + Chars.LF + "|");
	ExtensionsTables = ?(ExtensionsTables = "", "", "|" + ExtensionsTables + ";" + Chars.LF);
	
	SessionParameters.TableOfExtensionsWithAccessRestriction = ExtensionsTables;
	
	SpecifiedParameters.Add("TablesWithIndividualRightsSettings");
	SpecifiedParameters.Add("IDsOfTablesWithIndividualRightsSettings");
	SpecifiedParameters.Add("RightsSettingsOwnersTypes");
	SpecifiedParameters.Add("TableOfExtensionsWithAccessRestriction");
	
EndProcedure

// Returns:
//  FixedStructure:
//   * Regularly - Boolean
//   * Full      - Boolean
//   * NestedDisconnections - FixedArray
//   * EditedLists - ValueStorage
//
Function NewDisableOfAccessKeysUpdate() Export
	
	Properties = New Structure;
	Properties.Insert("Regularly",         False);
	Properties.Insert("Full",              False);
	Properties.Insert("NestedDisconnections", New FixedArray(New Array));
	Properties.Insert("EditedLists",    New ValueStorage(New Map));
	
	Return New FixedStructure(Properties);
	
EndFunction

// For internal use only.
Procedure UpdateSessionParameters() Export
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	SpecifiedParameters = New Array;
	SessionParametersSetting("", SpecifiedParameters);
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
	RefreshReusableValues();
	
EndProcedure

// Checking the Administrators access group before writing.
Procedure CheckAdministratorsAccessGroupForIBUser(GroupUsers, ErrorDescription) Export
	
	Users.FindAmbiguousIBUsers(Undefined);
	
	// Checking a blank list of infobase users in the Administrators access group.
	SetPrivilegedMode(True);
	ValidAdministratorFound = False;
	
	For Each UserDetails In GroupUsers Do
		
		If Not ValueIsFilled(UserDetails.User)
		 Or TypeOf(UserDetails.User) <> Type("CatalogRef.Users")
		   And TypeOf(UserDetails.User) <> Type("CatalogRef.Users") Then
			Continue;
		EndIf;
		
		IBUser = InfoBaseUsers.FindByUUID(
			UserDetails.User.IBUserID);
		
		If IBUser <> Undefined
		   And Users.CanSignIn(IBUser) Then
			
			ValidAdministratorFound = True;
			Break;
		EndIf;
	EndDo;
	
	If Not ValidAdministratorFound Then
		ErrorDescription =
			NStr("en = 'At least one user authorized to sign in
			           |must be included in
			           |the ""Administrators"" access group.';");
	EndIf;
	
EndProcedure

// See AccessManagement.HasTableRestrictionByAccessKind
Function HasTableRestrictionByAccessKind(Table, AccessKind, AllAccessKinds) Export
	
	SetPrivilegedMode(True);
	
	DisabledAccessKinds = SessionParameters.DisabledAccessKinds;
	If DisabledAccessKinds = "All"
	 Or StrFind(DisabledAccessKinds, "," + AccessKind + ",") > 0 Then
		Return False;
	EndIf;
	
	AccessKindsArray1 = StrSplit(AllAccessKinds, ",", False);
	AccessKindsProperties = AccessKindsProperties();
	
	ErrorTitle = StringFunctionsClientServer.SubstituteParametersToString(
		NStr("en = 'Error in function ""%1"" of common module ""%2"".';"),
		"HasTableRestrictionByAccessKind", "AccessManagement")
		+ Chars.LF;
	
	AccessKindProperties = AccessKindsProperties.ByNames.Get(AccessKind);
	If AccessKindProperties = Undefined Then
		ErrorText = ErrorTitle + StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Access kind ""%1"" specified in parameter ""%2"" does not exist.';"),
			AccessKind, "AccessKind");
		Raise ErrorText;
	EndIf;
	AccessKindRef = AccessKindProperties.Ref;
	
	AllDisabledTableAccessKinds = True;
	AccessKindsUse = New Map;
	AccessKindSpecifiedInAllAccessKinds = False;
	
	For Each CurrentAccessKind In AccessKindsArray1 Do
		CurrentAccessKind = TrimAll(CurrentAccessKind);
		AccessKindProperties = AccessKindsProperties.ByNames.Get(CurrentAccessKind);
		If AccessKindProperties = Undefined Then
			ErrorText = ErrorTitle + StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'Access kind ""%1"" specified in parameter ""%2"" does not exist. Details:
				           |""%3"".';"),
				CurrentAccessKind, "AllAccessKinds", AllAccessKinds);
			Raise ErrorText;
		EndIf;
		If AccessKindProperties.Name = AccessKind Then
			AccessKindSpecifiedInAllAccessKinds = True;
		EndIf;
		Used = StrFind(DisabledAccessKinds, "," + AccessKindProperties.Name + ",") = 0;
		AccessKindsUse.Insert(AccessKindProperties.Ref, Used);
		If Used Then
			AllDisabledTableAccessKinds = False;
		EndIf;
	EndDo;
	
	If Not AccessKindSpecifiedInAllAccessKinds Then
		ErrorText = ErrorTitle + StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Access kind ""%1"" specified in parameter ""%2"" does not exist in parameter ""%3""
			           |Details: ""%4"".';"),
			AccessKind, "AccessKind", "AllAccessKinds", AllAccessKinds);
		Raise ErrorText;
	EndIf;
	
	If AllDisabledTableAccessKinds Then
		Return False;
	EndIf;
	
	Query = New Query;
	Query.SetParameter("MainListTableName", Table);
	Query.SetParameter("AuthorizedUser", Users.AuthorizedUser());
	
	Query.Text = AccessGroupsRequestText();
	
	QueryText =
	"SELECT
	|	DefaultValues.AccessGroup AS AccessGroup,
	|	DefaultValues.AccessValuesType AS AccessKind
	|FROM
	|	InformationRegister.DefaultAccessGroupsValues AS DefaultValues
	|		INNER JOIN UserAccessGroups AS UserAccessGroups
	|		ON DefaultValues.AccessGroup = UserAccessGroups.Ref
	|WHERE
	|	NOT DefaultValues.AllAllowedWithoutExceptions
	|	AND TRUE IN
	|			(SELECT TOP 1
	|				TRUE
	|			FROM
	|				Catalog.AccessGroups.Users AS AccessGroupsUsers_SSLy
	|					INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|					ON
	|						AccessGroupsUsers_SSLy.Ref = DefaultValues.AccessGroup
	|							AND AccessGroupsUsers_SSLy.User = UserGroupCompositions.UsersGroup
	|							AND UserGroupCompositions.User = &AuthorizedUser)";
	
	AddQueryToPackage(Query.Text, QueryText);
	Selection = Query.Execute().Select();
	
	SetAccessGroupsOfAccessKinds = New Map;
	HasAccessGroupWithRestrictionByAccessKind = False;
	
	While Selection.Next() Do
		SetAccessKinds = SetAccessGroupsOfAccessKinds.Get(Selection.AccessGroup);
		If SetAccessKinds = Undefined Then
			SetAccessKinds = New Map;
			SetAccessGroupsOfAccessKinds.Insert(Selection.AccessGroup, SetAccessKinds);
		EndIf;
		If AccessKindsUse.Get(Selection.AccessKind) = Undefined Then
			Continue;
		EndIf;
		SetAccessKinds.Insert(Selection.AccessKind, True);
		If Selection.AccessKind = AccessKindRef Then
			HasAccessGroupWithRestrictionByAccessKind = True;
		EndIf;
	EndDo;
	
	HasAccessGroupWithoutRestrictionsByAllAccessKinds = False;
	
	For Each AccessGroupDetails In SetAccessGroupsOfAccessKinds Do
		SetAccessKinds = AccessGroupDetails.Value;
		AllTableAccessKindsWithoutRestrictionsInAccessGroup = True;
		For Each AccessKindUsageDetails In AccessKindsUse Do
			If Not AccessKindUsageDetails.Value Then
				Continue; // Obsolete.
			EndIf;
			If SetAccessKinds.Get(AccessKindUsageDetails.Key) = Undefined Then
				Continue; // AllAllowedWithoutExceptions or there are no restrictions by access kind.
			EndIf;
			AllTableAccessKindsWithoutRestrictionsInAccessGroup = False;
			Break;
		EndDo;
		If AllTableAccessKindsWithoutRestrictionsInAccessGroup Then
			HasAccessGroupWithoutRestrictionsByAllAccessKinds = True;
			Break;
		EndIf;
	EndDo;
	
	If HasAccessGroupWithoutRestrictionsByAllAccessKinds Then
		Return False;
	EndIf;
	
	Return HasAccessGroupWithRestrictionByAccessKind;
	
EndFunction

// Parameters:
//  Objects            - See InfobaseUpdate.AddObjectPlannedForDeletion.Objects
//  See InfobaseUpdate.AddObjectPlannedForDeletion.Object
//  RequiredTypes      - TypeDescription
//  
//
Procedure AddObjectPlannedForDeletion(Objects, RequiredTypes, MetadataDimensions)
	
	If RequiredTypes.Types().Count() = 0 Then
		ExcessiveTypes = MetadataDimensions.Type;
	Else
		ExcessiveTypes = New TypeDescription(MetadataDimensions.Type,, RequiredTypes.Types());
	EndIf;
	
	If ExcessiveTypes.Types().Count() = 0 Then
		Return;
	EndIf;
	
	NameParts = StrSplit(MetadataDimensions.FullName(), ".");
	NameParts.Delete(2);
	
	InfobaseUpdate.AddObjectPlannedForDeletion(Objects,
		StrConcat(NameParts, "."), ExcessiveTypes);
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Event subscription handlers.

// UpdateAccessValuesGroups subscription handler responds to the BeforeWrite event by calling:
// - a method for recording access value groups to
//   the AccessValuesGroups information register for required metadata objects.
//
Procedure UpdateAccessValuesGroups(Val Object, Cancel) Export
	
	If Object.DataExchange.Load Then
		Return;
	EndIf;
	
	If StandardSubsystemsServer.IsMetadataObjectID(Object) Then
		Return;
	EndIf;
	
	If Object.IsNew()
	   And Common.FileInfobase()
	   And Not SkipAccessCheck(Cancel, Object) Then
		
		Block = New DataLock;
		Block.Add("InformationRegister.ExtensionVersionParameters");
		Block.Lock();
	EndIf;
	
	AccessKindsProperties = AccessKindsProperties();
	AccessValuesWithGroups = AccessKindsProperties.AccessValuesWithGroups;
	
	If AccessValuesWithGroups.ByTypesForUpdate.Get(TypeOf(Object)) <> Undefined Then
		InformationRegisters.AccessValuesGroups.UpdateAccessValuesGroups(Object);
	EndIf;
	
	If AccessKindsProperties.ByValuesTypesWithHierarchy.Get(TypeOf(Object)) <> Undefined Then
		Parent = Common.ObjectAttributeValue(Object.Ref, "Parent");
		If Object.Parent <> Parent Then
			Object.AdditionalProperties.Insert("UpdateAccessGroupsValues");
		EndIf;
	EndIf;
	
EndProcedure

// Handler of the UpdateAccessGroupsValues subscription to the OnWrite event:
// - updates values of the access groups selected considering the hierarchy.
//
Procedure UpdateAccessGroupsValues(Source) Export
	
	If Source.DataExchange.Load Then
		Return;
	EndIf;
	
	If Source.AdditionalProperties.Property("UpdateAccessGroupsValues") Then
		AccessGroups = AccessGroupsUsingAccessValuesHierarchy(TypeOf(Source.Ref));
		InformationRegisters.AccessGroupsValues.UpdateRegisterData(AccessGroups);
	EndIf;
	
EndProcedure

// The UpdateRightsSettingsOwnersGroups subscription handler responds to the BeforeWrite event by calling:
// - a method for recording a hierarchy of the object right settings owner to
//   the ObjectRightsSettingsInheritance information register for required metadata objects.
//
Procedure UpdateRightsSettingsOwnersGroups(Val Object, Cancel) Export
	
	If Object.DataExchange.Load Then
		Return;
	EndIf;
	
	If StandardSubsystemsServer.IsMetadataObjectID(Object) Then
		Return;
	EndIf;
	
	AvailableRights = RightsForObjectsRightsSettingsAvailable();
	AvailableRightsByTypes = AvailableRights.ByTypes;
	
	If AvailableRightsByTypes.Get(TypeOf(Object)) <> Undefined Then
		InformationRegisters.ObjectRightsSettingsInheritance.UpdateRegisterData(Object);
	EndIf;
	
EndProcedure

// The WriteAccessValuesSets subscription handler responds to the OnWrite event by
// calling the method used for recording object access values to InformationRegister.AccessValuesSets.
//  The AccessManagement subsystem can be used when
// the specified subscription does not exist if access value sets are not applied.
//
Procedure RecordSetsOfWriteAccessValues(Val Object, Cancel) Export
	
	// 
	// 
	// 
	// 
	If Object.DataExchange.Load
	   And Not Object.AdditionalProperties.Property("WriteAccessValuesSets") Then
		
		Return;
	EndIf;
	
	If StandardSubsystemsServer.IsMetadataObjectID(Object) Then
		Return;
	EndIf;
	
	WriteAccessValuesSets(Object, , Object.AdditionalProperties.Property(
		"WriteAccessValueSetsOnUpdateIB"));
	
EndProcedure

// WriteDependentAccessValuesSets subscription handler
// responds to the OnWrite event by overwriting dependent access value sets in the AccessValuesSets information register.
//
//  The AccessManagement subsystem can be used when
// the specified subscription does not exist if dependent access value sets are not applied.
//
Procedure WriteDependentSetsOfWriteAccessValues(Val Object, Cancel) Export
	
	// 
	// 
	// 
	// 
	If Object.DataExchange.Load
	   And Not Object.AdditionalProperties.Property("WriteDependentAccessValuesSets") Then
		
		Return;
	EndIf;
	
	If StandardSubsystemsServer.IsMetadataObjectID(Object) Then
		Return;
	EndIf;
	
	WriteDependentAccessValuesSets(Object, Object.AdditionalProperties.Property(
		"WriteAccessValueSetsOnUpdateIB"));
	
EndProcedure

// FillAccessValuesSetsForTabularSections* subscription handler for the BeforeWrite event
// fills access values of the AccessValuesSets object tabular section
// when the #ByValuesSets template is used to restrict access to the object.
//  The AccessManagement subsystem can be used when
// the specified subscription does not exist if the sets are not applied for the specified purpose.
//
// Parameters:
//  Source        - CatalogObject
//                  - DocumentObject
//                  - ChartOfCharacteristicTypesObject
//                  - ChartOfAccountsObject
//                  - ChartOfCalculationTypesObject
//                  - BusinessProcessObject
//                  - TaskObject
//                  - ExchangePlanObject - a data object that is passed to the pre-Recording event subscription.
//
//  Cancel           - Boolean - a parameter passed to the BeforeWrite event subscription.
//
//  WriteMode     - Boolean - a parameter passed to the BeforeWrite event subscription
//                    when the type of the Source parameter is DocumentObject.
//
//  PostingMode - Boolean - a parameter passed to the BeforeWrite event subscription
//                    when the type of the Source parameter is DocumentObject.
//
Procedure FillAccessValuesSetsForTabularSections(Source, Cancel = Undefined, WriteMode = Undefined, PostingMode = Undefined) Export
	
	// 
	// 
	// 
	// 
	If Source.DataExchange.Load
	   And Not Source.AdditionalProperties.Property("WriteAccessValuesSets") Then
		Return;
	EndIf;
	
	If StandardSubsystemsServer.IsMetadataObjectID(Source) Then
		Return;
	EndIf;
	
	If Not (  PrivilegedMode()
	         And Source.AdditionalProperties.Property(
	             "AccessValuesSetsOfTabularSectionAreFilled")) Then
		
		If Source.IsNew()
		   And Common.FileInfobase()
		   And Not SkipAccessCheck(Cancel, Source) Then
			
			PreliminaryLockBeforeNewRecordToFileInfobase();
		EndIf;
		
		Table = GetAccessValuesSetsOfTabularSection(Source);
		PrepareAccessValuesSetsForWrite(Undefined, Table, False);
		Source.AccessValuesSets.Load(Table);
	EndIf;
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Scheduled job handlers.

// DataFillingForAccessRestriction scheduled job handler.
Procedure DataFillingForAccessRestrictionJobHandler() Export
	
	Common.OnStartExecuteScheduledJob(
		Metadata.ScheduledJobs.DataFillingForAccessRestriction);
	
	DataFillingForAccessRestriction();
	
EndProcedure

// Sequentially fills and updates the data required for the AccessManagement
// subsystem in the access restriction mode at the record level.
// 
//  Fills sets of access values when the access restriction mode is enabled.
// The sets are filled in by portions during each run, until all
// access value sets are filled in.
//  When the restriction access mode at the record level is disabled,
// the access value sets filled in earlier are removed upon rewriting the objects, not immediately.
//  The procedure updates cache attributes at the record level regardless of the access restriction mode.
//  Disables the scheduled job after all updates are completed and data is filled.
//
//  The progress information is written to the event log.
//
//  The procedure can be called from the application, for example, when updating the infobase.
// For data update purposes, the Catalog.AccessGroups.UpdateDataRestrictionAccess form is available.
// This form can be used for interactive update of access restriction data
// when updating the infobase.
//
Procedure DataFillingForAccessRestriction(DataVolume = 0, OnlyCacheAttributes = False, HasChanges = Undefined) Export
	
	SetPrivilegedMode(True);
	
	AccessKindsProperties = AccessKindsProperties();
	AccessValuesWithGroups = AccessKindsProperties.AccessValuesWithGroups;
	
	If Constants.LimitAccessAtRecordLevel.Get() And Not OnlyCacheAttributes Then
		
		// Filling access value groups in the AccessValuesGroups information register.
		For Each TableName In AccessValuesWithGroups.NamesOfTablesToUpdate Do
			
			If DataVolume < 10000 Then
				
				Query = New Query;
				Query.Text =
				"SELECT
				|	VALUE(Catalog.Users.EmptyRef) AS Ref
				|WHERE
				|	NOT TRUE IN
				|				(SELECT TOP 1
				|					TRUE AS TrueValue
				|				FROM
				|					InformationRegister.AccessValuesGroups AS AccessValuesGroups
				|				WHERE
				|					AccessValuesGroups.AccessValue = VALUE(Catalog.Users.EmptyRef)
				|					AND AccessValuesGroups.DataGroup = 0)
				|
				|UNION ALL
				|
				|SELECT TOP 10000
				|	CurrentTable.Ref
				|FROM
				|	&CurrentTable AS CurrentTable
				|		LEFT JOIN InformationRegister.AccessValuesGroups AS AccessValuesGroups
				|		ON CurrentTable.Ref = AccessValuesGroups.AccessValue
				|			AND (AccessValuesGroups.DataGroup = 0)
				|WHERE
				|	AccessValuesGroups.AccessValue IS NULL";
				
				Query.Text = StrReplace(Query.Text, "Catalog.Users", TableName);
				Query.Text = StrReplace(Query.Text, "&CurrentTable", TableName);
				// 
				Values = Query.Execute().Unload().UnloadColumn("Ref");
				
				InformationRegisters.AccessValuesGroups.UpdateAccessValuesGroups(Values, HasChanges);
				
				DataVolume = DataVolume + Values.Count();
			EndIf;
			
		EndDo;
		
		If DataVolume < 10000 And Not AccessManagement.ProductiveOption() Then
			
			// Filling the AccessValuesSets information register.
			ObjectsTypes = AccessManagementInternalCached.ObjectsTypesInSubscriptionsToEvents(
				"WriteAccessValuesSets");
			
			For Each TypeDetails In ObjectsTypes Do
				Type = TypeDetails.Key;
				
				If DataVolume < 10000 And Type <> Type("String") Then
				
					Query = New Query;
					Query.Text =
					"SELECT TOP 10000
					|	CurrentTable.Ref AS Ref
					|FROM
					|	&CurrentTable AS CurrentTable
					|		LEFT JOIN InformationRegister.AccessValuesSets AS InformationRegisterAccessValuesSets
					|		ON CurrentTable.Ref = InformationRegisterAccessValuesSets.Object
					|WHERE
					|	InformationRegisterAccessValuesSets.Object IS NULL ";
					Query.Text = StrReplace(Query.Text, "&CurrentTable", Metadata.FindByType(Type).FullName());
					// 
					Selection = Query.Execute().Select();
					DataVolume = DataVolume + Selection.Count();
					
					While Selection.Next() Do
						// 
						UpdateAccessValuesSets(Selection.Ref, HasChanges);
					EndDo;
				EndIf;
			EndDo;
		EndIf;
	EndIf;
	
	// Updating cache attributes in access value sets.
	If DataVolume < 10000 And Not AccessManagement.ProductiveOption() Then
		
		AccessValuesTypes          = AccessKindsProperties.ByValuesTypes;
		AccessValuesTypesWithGroups = AccessKindsProperties.AccessValuesTypesWithGroups;
		
		ValuesTypesTable = New ValueTable;
		ValuesTypesTable.Columns.Add("ValuesType", Metadata.DefinedTypes.AccessValue.Type);
		For Each KeyAndValue In AccessValuesTypes Do
			ValuesTypesTable.Add().ValuesType = MetadataObjectEmptyRef(KeyAndValue.Key);
		EndDo;
		
		TableOfValuesTypesWithGroups = New ValueTable;
		TableOfValuesTypesWithGroups.Columns.Add("ValuesType", Metadata.DefinedTypes.AccessValue.Type);
		For Each KeyAndValue In AccessValuesTypesWithGroups Do
			TableOfValuesTypesWithGroups.Add().ValuesType = MetadataObjectEmptyRef(KeyAndValue.Key);
		EndDo;
		
		Query = New Query;
		Query.SetParameter("ValuesTypesTable", ValuesTypesTable);
		Query.SetParameter("TableOfValuesTypesWithGroups", TableOfValuesTypesWithGroups);
		Query.Text =
		"SELECT
		|	TypesTable.ValuesType
		|INTO ValuesTypesTable
		|FROM
		|	&ValuesTypesTable AS TypesTable
		|
		|INDEX BY
		|	TypesTable.ValuesType
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|SELECT
		|	TypesTable.ValuesType
		|INTO TableOfValuesTypesWithGroups
		|FROM
		|	&TableOfValuesTypesWithGroups AS TypesTable
		|
		|INDEX BY
		|	TypesTable.ValuesType
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|SELECT TOP 10000
		|	AccessValuesSets.Object,
		|	AccessValuesSets.SetNumber,
		|	AccessValuesSets.AccessValue,
		|	AccessValuesSets.Refinement,
		|	AccessValuesSets.Read,
		|	AccessValuesSets.Update
		|FROM
		|	InformationRegister.AccessValuesSets AS AccessValuesSets
		|WHERE
		|	CASE
		|			WHEN AccessValuesSets.StandardValue <> TRUE IN
		|					(SELECT TOP 1
		|						TRUE
		|					FROM
		|						ValuesTypesTable AS ValuesTypesTable
		|					WHERE
		|						VALUETYPE(ValuesTypesTable.ValuesType) = VALUETYPE(AccessValuesSets.AccessValue))
		|				THEN TRUE
		|			WHEN AccessValuesSets.StandardValue = TRUE
		|				THEN AccessValuesSets.ValueWithoutGroups = TRUE IN
		|						(SELECT TOP 1
		|							TRUE
		|						FROM
		|							TableOfValuesTypesWithGroups AS TableOfValuesTypesWithGroups
		|						WHERE
		|							VALUETYPE(TableOfValuesTypesWithGroups.ValuesType) = VALUETYPE(AccessValuesSets.AccessValue))
		|			ELSE AccessValuesSets.ValueWithoutGroups = TRUE
		|		END";
		Selection = Query.Execute().Select();
		DataVolume = DataVolume + Selection.Count();
		
		While Selection.Next() Do
			RecordManager = InformationRegisters.AccessValuesSets.CreateRecordManager();
			FillPropertyValues(RecordManager, Selection);
			
			AccessValueType = TypeOf(Selection.AccessValue);
			
			If AccessValuesTypes.Get(AccessValueType) <> Undefined Then
				RecordManager.StandardValue = True;
				If AccessValuesTypesWithGroups.Get(AccessValueType) = Undefined Then
					RecordManager.ValueWithoutGroups = True;
				EndIf;
			EndIf;
			
			RecordManager.Write();
			HasChanges = True;
		EndDo;
	EndIf;
	
	If DataVolume < 10000 Then
		WriteLogEvent(
			NStr("en = 'Access management.Populate data for access restriction';",
				 Common.DefaultLanguageCode()),
			EventLogLevel.Information,
			,
			,
			NStr("en = 'Population of access restriction data completed.';"),
			EventLogEntryTransactionMode.Transactional);
			
		SetDataFillingForAccessRestriction(False);
	Else
		WriteLogEvent(
			NStr("en = 'Access management.Populate data for access restriction';",
				 Common.DefaultLanguageCode()),
			EventLogLevel.Information,
			,
			,
			NStr("en = 'A batch of access restriction data is recorded.';"),
			EventLogEntryTransactionMode.Transactional);
	EndIf;
	
EndProcedure

// Determines usage of a scheduled job for filling access management data.
//
// Parameters:
//   Use - Boolean - If True, the job must be enabled. Otherwise, False.
//
Procedure SetDataFillingForAccessRestriction(Val Use) Export
	
	ScheduledJobsServer.SetPredefinedScheduledJobUsage(
		Metadata.ScheduledJobs.DataFillingForAccessRestriction, Use);
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Procedures and functions for access kind management.

// Returns True if the access kind is enabled by functional options for all sessions.
//
// Parameters:
//  AccessKind - DefinedType.AccessValue - a blank reference of the main access kind value type.
//             - String - name of the access type.
//
// Returns:
//  Boolean
//
Function AccessKindUsed(Val AccessKind) Export
	
	If Not AccessManagement.LimitAccessAtRecordLevel() Then
		Return False;
	EndIf;
	
	AccessKindProperties = AccessKindProperties(AccessKind);
	If AccessKindProperties = Undefined Then
		Return False;
	EndIf;
	
	Query = New Query;
	Query.SetParameter("AccessValuesType", AccessKindProperties.Ref);
	Query.Text =
	"SELECT TOP 1
	|	TRUE AS TrueValue
	|FROM
	|	InformationRegister.UsedAccessKinds AS UsedAccessKinds
	|WHERE
	|	UsedAccessKinds.AccessValuesType = &AccessValuesType";
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	Used = Not Query.Execute().IsEmpty();
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
	Return Used;
	
EndFunction

// Returns:
//  Map of KeyAndValue:
//   * Key - DefinedType.AccessValue - empty link of the main type of access type.
//   * Value - Boolean - the value is True.
//
Function UsedAccessKinds() Export
	
	Result = New Map;
	
	If Not AccessManagement.LimitAccessAtRecordLevel() Then
		Return Result;
	EndIf;
	
	Query = New Query;
	Query.Text =
	"SELECT
	|	UsedAccessKinds.AccessValuesType AS AccessValuesType
	|FROM
	|	InformationRegister.UsedAccessKinds AS UsedAccessKinds";
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	Selection = Query.Execute().Select();
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
	AccessKindsProperties = AccessKindsProperties();
	
	While Selection.Next() Do
		If AccessKindsProperties.ByRefs.Get(Selection.AccessValuesType) = Undefined Then
			Continue;
		EndIf;
		Result.Insert(Selection.AccessValuesType, True);
	EndDo;
	
	Return Result;
	
EndFunction

// Returns the properties of an access kind or all access kinds.
//
// Parameters:
//  AccessKind - DefinedType.AccessValue - a blank reference of the main access kind value type.
//             - String - name of the access type.
//
// Returns:
//   Structure:
//     * Name - String
//     * Ref - DefinedType.AccessValue
//     * ValuesType - Type
//     * ValuesGroupsType - Type
//     * MultipleValuesGroups - Boolean
//     * AdditionalTypes - Array of See AdditionalAccessKindType
//     * TypesOfValuesToSelect - Array of Type
//   Undefined
//
Function AccessKindProperties(AccessKind) Export
	
	Properties = AccessKindsProperties();
	
	If TypeOf(AccessKind) = Type("String") Then
		AccessKindProperties = Properties.ByNames.Get(AccessKind);
	Else
		AccessKindProperties = Properties.ByRefs.Get(AccessKind);
	EndIf;
	
	Return AccessKindProperties;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Procedures and functions for access value set management.

// Returns new sets to be used to fill a tabular section.
//
// Parameters:
//  Object - DefinedType.OwnerLimitedByAccessValuesSetsObject
//         - DefinedType.OwnerWithRestrictedAccessValueSetsDocument
//
// Returns:
//   See AccessManagement.AccessValuesSetsTable
//
Function GetAccessValuesSetsOfTabularSection(Object)
	
	ValueTypeObject = TypeOf(Object);
	
	If Object.Metadata().TabularSections.Find("AccessValuesSets") = Undefined Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Invalid parameters.
			           |Tabular section ""%2""
			           |in an object of type ""%1"" does not exist.';"),
			ValueTypeObject, "AccessValuesSets");
		Raise ErrorText;
	EndIf;
	
	Table = AccessManagement.AccessValuesSetsTable();
	
	If Not AccessManagement.LimitAccessAtRecordLevel() Then
		Return Table;
	EndIf;
	
	AccessManagement.FillAccessValuesSets(Object, Table);
	
	AccessManagement.AddAccessValuesSets(
		Table, AccessManagement.AccessValuesSetsTable(), False, True);
	
	Return Table;
	
EndFunction

// Updates object access value sets if they are changed.
// The sets are updated both in the tabular section (if used) and
// in the AccessValuesSets information register.
//
// Parameters:
//  ReferenceOrObject - AnyRef
//                  - DefinedType.AccessValuesSetsOwnerObject - 
//                    
//
//  HasChanges - Boolean
//                - Undefined
//  
//  IBUpdate    - Boolean - if True, write data
//                            without performing unnecessary and redundant actions with the data.
//                            See InfobaseUpdate.WriteData.
//
Procedure UpdateAccessValuesSets(ReferenceOrObject, HasChanges = Undefined, IBUpdate = False) Export
	
	SetPrivilegedMode(True);
	
	Object = ?(ReferenceOrObject = ReferenceOrObject.Ref, ReferenceOrObject.GetObject(), ReferenceOrObject);
	ObjectReference = Object.Ref;
	ValueTypeObject = TypeOf(Object);
	
	SetsRecorded = AccessManagementInternalCached.ObjectsTypesInSubscriptionsToEvents(
		"WriteAccessValuesSets").Get(ValueTypeObject) <> Undefined;
	
	If Not SetsRecorded Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Invalid parameters.
			           |Cannot find object type ""%1""
			           |in event subscription %2.';"),
			ValueTypeObject,
			"WriteAccessValuesSets");
		Raise ErrorText;
	EndIf;
	
	If Metadata.InformationRegisters.AccessValuesSets.Dimensions.Object.Type.Types().Find(TypeOf(ObjectReference)) = Undefined Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'An error occurred when writing access value sets:
			           |The ""%3"" type is not specified in dimension ""%2""
			           |of information register ""%1""';"),
			"AccessValuesSets",
			"Object",
			TypeOf(ObjectReference));
		Raise ErrorText;
	EndIf;
	
	If ObjectReference.Metadata().TabularSections.Find("AccessValuesSets") <> Undefined Then
		// Object update is required.
		Table = GetAccessValuesSetsOfTabularSection(Object);
		
		If AccessValuesSetsOfTabularSectionChanged(ObjectReference, Table) Then
			PrepareAccessValuesSetsForWrite(Undefined, Table, False);
			
			Object.AdditionalProperties.Insert("WriteAccessValuesSets");
			Object.AdditionalProperties.Insert("WriteDependentAccessValuesSets");
			Object.AdditionalProperties.Insert("AccessValuesSetsOfTabularSectionAreFilled");
			Object.AccessValuesSets.Load(Table);
			If IBUpdate Then
				Object.AdditionalProperties.Insert("WriteAccessValueSetsOnUpdateIB");
				InfobaseUpdate.WriteData(Object);
			Else
				Object.DataExchange.Load = True;
				// ACC:1327-
				// 
				// 
				Object.Write();
				// ACC:1327-on
			EndIf;
			HasChanges = True;
		EndIf;
	EndIf;
	
	// Object update is not required, or it has already been updated.
	WriteAccessValuesSets(Object, HasChanges, IBUpdate);
	
EndProcedure

// Fills auxiliary data that speeds up access restriction template operations.
//  It is executed before writing to the AccessValuesSets register.
//
// Parameters:
//  ObjectReference - AnyRef - a reference to the object for which access value sets are filled in.
//  Table        - ValueTable
//  AddCacheAttributes - Boolean
//
Procedure PrepareAccessValuesSetsForWrite(ObjectReference, Table, AddCacheAttributes = False) Export
	
	If AddCacheAttributes Then
		
		Table.Columns.Add("Object", Metadata.InformationRegisters.AccessValuesSets.Dimensions.Object.Type);
		Table.Columns.Add("StandardValue", New TypeDescription("Boolean"));
		Table.Columns.Add("ValueWithoutGroups", New TypeDescription("Boolean"));
		
		AccessKindsProperties = AccessKindsProperties();
		
		AccessValuesTypesWithGroups = AccessKindsProperties.AccessValuesTypesWithGroups;
		AccessValuesTypes          = AccessKindsProperties.ByValuesTypes;
	EndIf;
	
	// Normalizing Read, Update resources
	SetNumber = -1;
	For Each String In Table Do
		
		If AddCacheAttributes Then
			// 
			String.Object = ObjectReference;
			
			AccessValueType = TypeOf(String.AccessValue);
			
			If AccessValuesTypes.Get(AccessValueType) <> Undefined Then
				String.StandardValue = True;
				If AccessValuesTypesWithGroups.Get(AccessValueType) = Undefined Then
					String.ValueWithoutGroups = True;
				EndIf;
			EndIf;
			
		EndIf;
		
		// 
		// 
		If SetNumber = String.SetNumber Then
			String.Read    = False;
			String.Update = False;
		Else
			SetNumber = String.SetNumber;
		EndIf;
	EndDo;
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Procedures and functions for actions performed upon changing subsystem settings.

// Enables data population for access restriction and
// updates some data immediately if necessary.
//
// The procedure is called from the OnWrite handler of the LimitAccessAtRecordLevel constant.
//
Procedure OnChangeAccessRestrictionAtRecordLevel(AccessRestrictionAtRecordLevelEnabled) Export
	
	SetPrivilegedMode(True);
	
	InformationRegisters.UsedAccessKinds.UpdateRegisterData(, True);
	InformationRegisters.UsedAccessKinds.WhenChangingTheUseOfAccessTypes();
	
	If AccessRestrictionAtRecordLevelEnabled Then
		WriteLogEvent(
			NStr("en = 'Access management.Populate data for access restriction';",
			     Common.DefaultLanguageCode()),
			EventLogLevel.Information,
			,
			,
			NStr("en = 'Population of access restriction data started.';"),
			EventLogEntryTransactionMode.Transactional);
		
		SetDataFillingForAccessRestriction(True);
	EndIf;
	
	If LimitAccessAtRecordLevelUniversally(True) Then
		
		ScheduleAccessRestrictionParametersUpdate(
			"OnChangeAccessRestrictionAtRecordLevel");
		
		PlanningParameters = AccessUpdatePlanningParameters();
		PlanningParameters.IsUpdateContinuation = True;
		PlanningParameters.LongDesc = "RestrictAccessAtRecordsLevelOnWrite";
		ScheduleAccessUpdate(, PlanningParameters);
		
		SetAccessUpdate(True);
	EndIf;
	
	UpdateSessionParameters();
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Management of AccessKinds and AccessValues tables in edit forms.

// Fills the auxiliary data required for the form.
// The data does not depend on the object content or filled for a new object.
//
// The form has to contain the attributes listed below.
// Attributes marked with (&) are filled automatically, but they must be created in the form.
// Attributes marked with a number sign (#) must be created in the form if
// the CurrentAccessGroup attribute is to be created in the form (see below). 
// Attributes marked with the at sign (@) are created automatically.
//
//  CurrentAccessGroup - an optional attribute,
//                         it is not used unless created in the form.
//
//  AccessKinds - a table with the following fields:
//    #AccessGroup - CatalogRef.AccessGroups,
//    AccessKind - DefinedType.AccessValue,
//    PresetAccessKind - Boolean (for the profile only),
//    AllAllowed - Boolean,
//    &AccessKindPresentation - String - a setting presentation,
//    &AllAllowedPresentation - String - a setting presentation,
//    @IsInUse - Boolean.
//
//  AccessValues - a table with the following fields:
//    #AccessGroup - CatalogRef.AccessGroups,
//    &AccessKind - DefinedType.AccessValue,
//    AccessValue - DefinedType.AccessValue,
//    &RowNumberByKind - Number.
//
//  &UseExternalUsers - Boolean - an attribute will be created if it is not in the form.
//  &AccessKindLabel - String - a presentation of the current access kind in the form.
//  @IsAccessGroupsProfile - Boolean.
//  @CurrentAccessKind - DefinedType.AccessValue.
//  @CurrentTypesOfValuesToSelect - ValueList.
//  @CurrentTypeOfValuesToSelect - DefinedType.AccessValue.
//  @TablesStorageAttributeName - String.
//  @AccessKindUsers - DefinedType.AccessValue.
//  @AccessKindExternalUsers - DefinedType.AccessValue.
//  
//  @AllAccessKinds - a table with the following fields:
//    @Ref - DefinedType.AccessValue,
//    @Presentation - String,
//    @IsInUse - Boolean.
//
//  @PresentationsAllAllowed - a table with the following fields:
//    @Name - String,
//    @Presentation - String.
//
//  @AllTypesOfValuesToSelect - a table with the following fields:
//    @AccessKind - DefinedType.AccessValue,
//    @ValuesType - DefinedType.AccessValue,
//    @TypePresentation - String,
//    @TableName - String,
//    @ItemsHierarchy - Boolean.
//
// Parameters:
//  Form      - See AccessManagementInternalClientServer.AllowedValuesEditFormParameters
//
//  ThisProfile - Boolean - indicates that access kinds can be set up,
//               also settings presentation contains 4 values, not 2.
//
//  TablesStorageAttributeName - String - containing, for example, the Object row that
//               contains the AccessKinds and AccessValues tables (see below). 
//               If a blank row is specified,
//               the tables are considered to be stored in the form attributes.
//
Procedure OnCreateAtServerAllowedValuesEditForm(Form, ThisProfile = False, TablesStorageAttributeName = "Object") Export
	
	AddAuxiliaryDataAttributesToForm(Form, TablesStorageAttributeName);
	
	Form.TablesStorageAttributeName = TablesStorageAttributeName;
	Form.IsAccessGroupProfile = ThisProfile;
	
	AccessKindsProperties = AccessKindsProperties();
	
	// Filling access value types of all access kinds.
	For Each AccessKindProperties In AccessKindsProperties.Array Do
		For Each Type In AccessKindProperties.TypesOfValuesToSelect Do
			TypesArray = New Array;
			TypesArray.Add(Type);
			TypeDetails = New TypeDescription(TypesArray);
			
			TypeMetadata = Metadata.FindByType(Type);
			If Metadata.Enums.Find(TypeMetadata.Name) = TypeMetadata Then
				TypePresentation = TypeMetadata.Presentation();
			Else
				TypePresentation = ?(ValueIsFilled(TypeMetadata.ObjectPresentation),
					TypeMetadata.ObjectPresentation,
					TypeMetadata.Presentation());
			EndIf;
			
			NewRow = Form.AllTypesOfValuesToSelect.Add();
			NewRow.AccessKind        = AccessKindProperties.Ref;
			NewRow.ValuesType       = TypeDetails.AdjustValue(Undefined);
			NewRow.TypePresentation = TypePresentation;
			NewRow.TableName        = TypeMetadata.FullName();
			NewRow.HierarchyOfItems = AccessKindsProperties.ByValuesTypesWithHierarchy.Get(Type) <> Undefined;
		EndDo;
	EndDo;
	
	Form.AccessKindUsers           = Catalogs.Users.EmptyRef();
	Form.AccessKindExternalUsers    = Catalogs.ExternalUsers.EmptyRef();
	Form.UseExternalUsers = ExternalUsers.UseExternalUsers();
	
	FillTableAllAccessKindsInForm(Form);
	
	FillPresentationTableAllAllowedInForm(Form, ThisProfile);
	
	ApplyTableAccessKindsInForm(Form);
	
	CheckoutTableAccessValuesForm(Form);
	
	DeleteNonExistentAccessKindsAndValues(Form);
	AccessManagementInternalClientServer.FillAccessKindsPropertiesInForm(Form);
	
	RefreshUnusedAccessKindsRepresentation(Form, True);
	
	// Parameter settings of access value selection.
	ChoiceParameters = New Array;
	ChoiceParameters.Add(New ChoiceParameter("IsAccessValueSelection", True));
	Form.Items.AccessValuesAccessValue.ChoiceParameters = New FixedArray(ChoiceParameters);
	
EndProcedure

// When rereading data, it fills or updates
// required auxiliary data that depends on the object content.
//
Procedure OnRereadAtServerAllowedValuesEditForm(Form, CurrentObject) Export
	
	DeleteNonExistentAccessKindsAndValues(Form, CurrentObject);
	DeleteNonExistentAccessKindsAndValues(Form);
	
	AccessManagementInternalClientServer.FillAccessKindsPropertiesInForm(Form);
	
	AccessManagementInternalClientServer.OnChangeCurrentAccessKind(Form, False);
	
EndProcedure

// Deletes unused access values before writing.
// Unused access values are sometimes created when you replace or delete an access kind
// with filled access values.
//
Procedure BeforeWriteAtServerAllowedValuesEditForm(Form, CurrentObject) Export
	
	DeleteExcessAccessValues(Form, CurrentObject);
	DeleteExcessAccessValues(Form);
	
EndProcedure

// Updates access kind properties.
Procedure AfterWriteAtServerAllowedValuesEditForm(Form, CurrentObject, WriteParameters) Export
	
	DeleteNonExistentAccessKindsAndValues(Form, CurrentObject);
	DeleteNonExistentAccessKindsAndValues(Form);
	
	AccessManagementInternalClientServer.FillAccessKindsPropertiesInForm(Form);
	
EndProcedure

// Hides or shows unused access kinds.
Procedure RefreshUnusedAccessKindsRepresentation(Form, OnCreateAtServer = False) Export
	
	Items = Form.Items;
	
	If Not OnCreateAtServer Then
		Items.SnowUnusedAccessKinds.Check =
			Not Items.SnowUnusedAccessKinds.Check;
	EndIf;
	
	Filter = AccessManagementInternalClientServer.FilterInAllowedValuesEditFormTables(
		Form);
	
	If Not Items.SnowUnusedAccessKinds.Check Then
		Filter.Insert("Used", True);
	EndIf;
	
	Items.AccessKinds.RowFilter = New FixedStructure(Filter);
	
	Items.AccessKindsAccessTypePresentation.ChoiceList.Clear();
	
	For Each String In Form.AllAccessKinds Do
		
		If Not Items.SnowUnusedAccessKinds.Check
		   And Not String.Used Then
			
			Continue;
		EndIf;
		
		Items.AccessKindsAccessTypePresentation.ChoiceList.Add(String.Presentation);
	EndDo;
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Universal procedures and functions.

// For internal use only.
Procedure SetFilterCriterionInQuery(Val Query, Val Values, Val ValuesParameterName, Val ParameterNameFilterConditionsFieldName) Export
	
	If Values = Undefined Then
		
	ElsIf TypeOf(Values) <> Type("Array")
	        And TypeOf(Values) <> Type("FixedArray") Then
		
		Query.SetParameter(ValuesParameterName, Values);
		
	ElsIf Values.Count() = 1 Then
		Query.SetParameter(ValuesParameterName, Values[0]);
	Else
		Query.SetParameter(ValuesParameterName, Values);
	EndIf;
	
	For LineNumber = 1 To StrLineCount(ParameterNameFilterConditionsFieldName) Do
		CurrentRow = StrGetLine(ParameterNameFilterConditionsFieldName, LineNumber);
		If Not ValueIsFilled(CurrentRow) Then
			Continue;
		EndIf;
		SeparatorIndex = StrFind(CurrentRow, ":");
		If SeparatorIndex = 0 Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'Error executing procedure ""%1"".
				           |
				           |Parameter ""%2"" is missing a delimiter (colon)
				           |in the following string of %3 format:
				           |""%4"".';"),
				"AccessManagement.SetFilterCriterionInQuery",
				"ParameterNameFilterConditionsFieldName",
				"<ParameterNameConditions>:<FieldName>",
				CurrentRow);
			Raise ErrorText;
		EndIf;
		FilterCriterionParameterName = Left(CurrentRow, SeparatorIndex-1);
		FieldName = Mid(CurrentRow, SeparatorIndex+1);
		If Values = Undefined Then
			FilterCriterion = "True";
			
		ElsIf TypeOf(Values) <> Type("Array")
		        And TypeOf(Values) <> Type("FixedArray") Then
			
			FilterCriterion = FieldName + " = &" + ValuesParameterName;
			
		ElsIf Values.Count() = 1 Then
			FilterCriterion = FieldName + " = &" + ValuesParameterName;
		Else
			FilterCriterion = FieldName + " IN (&" + ValuesParameterName + ")";
		EndIf;
		Query.Text = StrReplace(Query.Text, FilterCriterionParameterName, FilterCriterion);
	EndDo;
	
EndProcedure

// Updates a record set in the database
// if the set records do not match the database records.
//
// Parameters:
//  Data - Structure:
//    * RecordSet           - InformationRegisterRecordSet - a blank or read RecordSet with or without set filter.
//                             - InformationRegisterManager - the Manager of the register to generate a set of records.
//
//    * NewRecords            - ValueTable - in a register format.
//
//    * ComparisonFields          - String - contains a list of fields whose values are required to calculate
//                               record set differences, for example, Dimension1, Dimension2, Source1.
//                               The ChangeDate attribute is not included in the list.
//
//    * FilterField             - Undefined - an entire registry is written or
//                                              the filter is already set in a record set.
//                               String - a field name, for which the filter is to be set.
//
//    * FilterValue         - Filter - a value that will be set as a filter
//                               by a filter field if the filter field is set.
//
//    * RecordSetRead   - Boolean - if True, then not specified record set already contains
//                               the read records. Data lock of these records is set and
//                               transaction is open.
//
//    * IsCheckOnly         - Boolean - if True, do not write,
//                               only find out if writing is required and set
//                               the HasChanges property.
//
//    * AdditionalProperties - Structure
//                             - Undefined - 
//                               
//                               
//
//    * IBUpdate           - Boolean - if True, write data
//                               without performing unnecessary and redundant actions with the data.
//                               See InfobaseUpdate.WriteData.
//                               If the property is not inserted, the value is calculated by Or using the following functions:
//                               InfobaseUpdateInProgress and IsCallFromUpdateHandler
//                               of the InfobaseUpdate common module.
//
//  HasChanges         - Boolean - a return value. If recorded,
//                          True is set, otherwise, it does not change.
//
//  ModifiedRecords      - Undefined - no actions, otherwise,
//                          it returns a value table in the register format with the RowChangeKind field
//                          of the Number type (-1 the record is deleted, 1 the record is added).
//
Procedure UpdateRecordSet(Val Data, HasChanges = Undefined, ModifiedRecords = Undefined) Export
	
	AllParameters = New Structure;
	AllParameters.Insert("RecordSet");
	AllParameters.Insert("NewRecords");
	AllParameters.Insert("ComparisonFields");
	AllParameters.Insert("FilterField");
	AllParameters.Insert("FilterValue");
	AllParameters.Insert("RecordSetRead", False);
	AllParameters.Insert("NoOverwriting", False);
	AllParameters.Insert("IsCheckOnly", False);
	AllParameters.Insert("AdditionalProperties");
	AllParameters.Insert("IBUpdate",
		    InfobaseUpdate.InfobaseUpdateInProgress()
		Or InfobaseUpdate.IsCallFromUpdateHandler());
	
	FillParameters_(Data, AllParameters, "RecordSet, NewRecords");
	
	FullRegisterName = Metadata.FindByType(TypeOf(Data.RecordSet)).FullName();
	RegisterManager = Common.ObjectManagerByFullName(FullRegisterName);
	If Data.RecordSet = RegisterManager Then
		RecordSet = RegisterManager.CreateRecordSet(); // InformationRegisterRecordSet
	Else
		RecordSet = Data.RecordSet; // InformationRegisterRecordSet
	EndIf;
	NewRecords    = Data.NewRecords;
	FilterField     = Data.FilterField;
	FilterValue = Data.FilterValue;
	
	If ValueIsFilled(FilterField) Then
		SetFilter(RecordSet.Filter[FilterField], FilterValue);
	EndIf;
	
	If Not Data.RecordSetRead Then
		LockRecordSetArea(RecordSet, FullRegisterName);
		RecordSet.Read();
	EndIf;
	
	Data.ComparisonFields = ?(Data.ComparisonFields = Undefined,
		RecordSetFields(RecordSet), Data.ComparisonFields);
	
	If Data.NoOverwriting Then
		SingleRecordSet = RegisterManager.CreateRecordSet();
		RecordKeyDetails = AccessManagementInternalCached.RecordKeyDetails(FullRegisterName);
		FilterRecords = New Structure(RecordKeyDetails.FieldsString);
		OtherDimensionsFields = New Array;
		For Each Field In RecordKeyDetails.FieldArray Do
			If Field <> FilterField Then
				OtherDimensionsFields.Add(Field);
			EndIf;
		EndDo;
		RecordsToDelete = New ValueTable;
		For Each Field In OtherDimensionsFields Do
			RecordsToDelete.Columns.Add(Field);
		EndDo;
		Data.NewRecords = NewRecords.Copy();
		NewRecords = Data.NewRecords;
	EndIf;
	
	HasCurrentChanges = False;
	If ModifiedRecords = Undefined Then
		If RecordSet.Count() = NewRecords.Count() Or Data.NoOverwriting Then
			Filter = New Structure(Data.ComparisonFields);
			NewRecords.Indexes.Add(Data.ComparisonFields);
			For Each Record In RecordSet Do
				FillPropertyValues(Filter, Record);
				FoundRows = NewRecords.FindRows(Filter);
				If FoundRows.Count() = 0 Then
					HasCurrentChanges = True;
					HasChanges = True;
					If Data.NoOverwriting Then
						FillPropertyValues(FilterRecords, Record);
						If NewRecords.FindRows(FilterRecords).Count() = 0 Then
							FillPropertyValues(RecordsToDelete.Add(), FilterRecords);
						EndIf;
					Else
						Break;
					EndIf;
				ElsIf Data.NoOverwriting Then
					NewRecords.Delete(FoundRows[0]);
				EndIf;
			EndDo;
			If Data.NoOverwriting And NewRecords.Count() > 0 Then
				HasCurrentChanges = True;
				HasChanges = True;
			EndIf;
		Else
			HasCurrentChanges = True;
			HasChanges = True;
		EndIf;
	Else
		If RecordSet.Count() <> NewRecords.Count() Then
			HasCurrentChanges = True;
			HasChanges = True;
		EndIf;
		If RecordSet.Count() > NewRecords.Count() Then
			ModifiedRecords = RecordSet.Unload();
			SearchedRecords   = NewRecords;
			LineChangeType = -1;
		Else
			ModifiedRecords = NewRecords.Copy();
			SearchedRecords   = RecordSet.Unload();
			LineChangeType = 1;
		EndIf;
		ModifiedRecords.Columns.Add("LineChangeType", New TypeDescription("Number"));
		ModifiedRecords.FillValues(LineChangeType, "LineChangeType");
		LineChangeType = ?(LineChangeType = 1, -1, 1);
		Filter = New Structure(Data.ComparisonFields);
		
		For Each String In SearchedRecords Do
			FillPropertyValues(Filter, String);
			Rows = ModifiedRecords.FindRows(Filter);
			If Rows.Count() = 0 Then
				NewRow = ModifiedRecords.Add();
				FillPropertyValues(NewRow, Filter);
				NewRow.LineChangeType = LineChangeType;
				HasCurrentChanges = True;
				HasChanges = True;
			Else
				ModifiedRecords.Delete(Rows[0]);
			EndIf;
		EndDo;
	EndIf;
	
	If HasCurrentChanges Then
		If Data.IsCheckOnly Then
			Return;
		EndIf;
		If Data.NoOverwriting Then
			SetAdditionalProperties(SingleRecordSet, Data.AdditionalProperties);
			For Each String In RecordsToDelete Do
				If ValueIsFilled(FilterField) Then
					SetFilter(SingleRecordSet.Filter[FilterField], FilterValue);
				EndIf;
				For Each Field In OtherDimensionsFields Do
					SetFilter(SingleRecordSet.Filter[Field], String[Field]);
				EndDo;
				WriteObjectOrRecordSet(Data, SingleRecordSet);
			EndDo;
			SingleRecordSet.Add();
			For Each String In NewRecords Do
				If ValueIsFilled(FilterField) Then
					SetFilter(SingleRecordSet.Filter[FilterField], FilterValue);
				EndIf;
				For Each Field In OtherDimensionsFields Do
					SetFilter(SingleRecordSet.Filter[Field], String[Field]);
				EndDo;
				FillPropertyValues(SingleRecordSet[0], String);
				WriteObjectOrRecordSet(Data, SingleRecordSet);
			EndDo;
		Else
			SetAdditionalProperties(RecordSet, Data.AdditionalProperties);
			RecordSet.Load(NewRecords);
			WriteObjectOrRecordSet(Data, RecordSet);
		EndIf;
	EndIf;
	
EndProcedure

// Updates register rows with a multiple-value filter for one or
// two register dimensions. Checks for changes;
// if no changes are found, no data is overwritten.
//
// Parameters:
//  Data - Structure:
//    * RegisterManager          - InformationRegisterManager - register manager to create a record set.
//
//    * NewRecords               - ValueTable - in a register format.
//
//    * ComparisonFields             - String - contains a list of fields whose values are required to calculate
//                                  record set differences, for example, Dimension1, Dimension2,
//                                  Source1. The ChangeDate attribute is not included in the list.
//
//    * FirstDimensionName       - Undefined - there is no filter by dimension.
//                                - String       - 
//                                                 
//                                
//    * FirstDimensionValues  - Undefined - there is no filter by dimension, similar to
//                                                 FirstDimensionName = Undefined.
//                                - AnyRef  - 
//                                                 
//                                - Array       - 
//                                                 
//                                                 
//
//    * SecondDimensionName       - Undefined
//                                - String - 
//    * SecondDimensionValues  - Undefined
//                                - AnyRef
//                                - Array - 
//    * ThirdDimensionName      - Undefined
//                                - String - 
//    * ThirdDimensionValues - Undefined
//                                - AnyRef
//                                - Array - 
//
//    * IsCheckOnly            - Boolean - if True, do not write,
//                                  only find out if writing is required and set
//                                  the HasChanges property.
//
//    * AdditionalProperties    - Undefined
//                                - Structure - 
//                                  
//                                  
//
//    * IBUpdate              - Boolean - if True, write data
//                                  without performing unnecessary and redundant actions with the data.
//                                  See InfobaseUpdate.WriteData.
//                                  If the property is not inserted, the value is calculated by Or using the following functions:
//                                  InfobaseUpdateInProgress and IsCallFromUpdateHandler
//                                  of the InfobaseUpdate common module.
//
//  HasChanges             - Boolean - a return value. If recorded,
//                              True is set, otherwise, it does not change.
//
Procedure UpdateRecordSets(Val Data, HasChanges) Export
	
	AllParameters = New Structure;
	AllParameters.Insert("RegisterManager");
	AllParameters.Insert("NewRecords");
	AllParameters.Insert("ComparisonFields");
	AllParameters.Insert("FirstDimensionName");
	AllParameters.Insert("FirstDimensionValues");
	AllParameters.Insert("SecondDimensionName");
	AllParameters.Insert("SecondDimensionValues");
	AllParameters.Insert("ThirdDimensionName");
	AllParameters.Insert("ThirdDimensionValues");
	AllParameters.Insert("NewRecordsContainOnlyDifferences", False);
	AllParameters.Insert("FixedFilter");
	AllParameters.Insert("IsCheckOnly", False);
	AllParameters.Insert("AdditionalProperties");
	AllParameters.Insert("IBUpdate",
		    InfobaseUpdate.InfobaseUpdateInProgress()
		Or InfobaseUpdate.IsCallFromUpdateHandler());
	
	FillParameters_(Data, AllParameters, "RegisterManager, NewRecords");
	
	// Preprocessing parameters.
	
	If Not DimensionParametersGroupProcessed(Data.FirstDimensionName, Data.FirstDimensionValues) Then
		HasChanges = True;
		Return;
	EndIf;
	If Not DimensionParametersGroupProcessed(Data.SecondDimensionName, Data.SecondDimensionValues) Then
		HasChanges = True;
		Return;
	EndIf;
	If Not DimensionParametersGroupProcessed(Data.ThirdDimensionName, Data.ThirdDimensionValues) Then
		HasChanges = True;
		Return;
	EndIf;
	
	OrderDimensionsParametersGroups(Data);
	
	// 
	Data.Insert("RecordSet",       Data.RegisterManager.CreateRecordSet());
	Data.Insert("RegisterMetadata", Metadata.FindByType(TypeOf(Data.RecordSet)));
	Data.Insert("FullRegisterName",  Data.RegisterMetadata.FullName());
	
	If Data.NewRecordsContainOnlyDifferences Then
		Data.Insert("SetForSingleRecord", Data.RegisterManager.CreateRecordSet());
	EndIf;
	
	If Data.FixedFilter <> Undefined Then
		For Each KeyAndValue In Data.FixedFilter Do
			SetFilter(Data.RecordSet.Filter[KeyAndValue.Key], KeyAndValue.Value);
		EndDo;
	EndIf;
	
	If Data.NewRecordsContainOnlyDifferences Then
		
		If Data.FirstDimensionName = Undefined Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'Invalid parameters in procedure ""%1"".';"),
				"UpdateRecordSets");
			Raise ErrorText;
		Else
			If Data.SecondDimensionName = Undefined Then
				RecordByMultipleSets = False;
			Else
				RecordByMultipleSets = RecordByMultipleSets(Data,
					New Structure, Data.FirstDimensionName, Data.FirstDimensionValues);
			EndIf;
			
			If RecordByMultipleSets Then
				FieldList = Data.FirstDimensionName + ", " + Data.SecondDimensionName;
				Data.NewRecords.Indexes.Add(FieldList);
				
				CountByFirstDimensionValues = Data.CountByValues;
				
				For Each FirstValue In Data.FirstDimensionValues Do
					Filter = New Structure(Data.FirstDimensionName, FirstValue);
					SetFilter(Data.RecordSet.Filter[Data.FirstDimensionName], FirstValue);
					
					If Data.ThirdDimensionName = Undefined Then
						RecordByMultipleSets = False;
					Else
						// @skip-
						RecordByMultipleSets = RecordByMultipleSets(Data,
							Filter, Data.SecondDimensionName, Data.SecondDimensionValues);
					EndIf;
					
					If RecordByMultipleSets Then
						For Each SecondValue In Data.SecondDimensionValues Do
							Filter.Insert(Data.SecondDimensionName, SecondValue);
							SetFilter(Data.RecordSet.Filter[Data.SecondDimensionName], SecondValue);
							
							// Updating by three dimensions.
							RefreshNewSetRecordsByVariousNewRecords(Data, Filter, HasChanges);
						EndDo;
						Data.RecordSet.Filter[Data.SecondDimensionName].Use = False;
					Else
						// 
						Data.Insert("CountByValues", CountByFirstDimensionValues);
						RefreshNewSetRecordsByVariousNewRecords(Data, Filter, HasChanges);
					EndIf;
				EndDo;
			Else
				// Updating by one dimension.
				ReadCountForReading(Data);
				RefreshNewSetRecordsByVariousNewRecords(Data, New Structure, HasChanges);
			EndIf;
		EndIf;
	Else
		If Data.FirstDimensionName = Undefined Then
			// Update all records.
			
			CurrentData = New Structure("RecordSet, NewRecords, ComparisonFields,
				|IsCheckOnly, AdditionalProperties, IBUpdate");
			FillPropertyValues(CurrentData, Data);
			UpdateRecordSet(CurrentData, HasChanges);
			
		ElsIf Data.SecondDimensionName = Undefined Then
			// 
			Filter = New Structure(Data.FirstDimensionName);
			For Each Value In Data.FirstDimensionValues Do
				
				SetFilter(Data.RecordSet.Filter[Data.FirstDimensionName], Value);
				Filter[Data.FirstDimensionName] = Value;
				
				If Data.FirstDimensionValues.Count() <> 1 Then
					NewSetRecords = Data.NewRecords;
				Else
					NewSetRecords = Data.NewRecords.Copy(Filter);
				EndIf;
				
				CurrentData = New Structure("RecordSet, ComparisonFields,
					|IsCheckOnly, AdditionalProperties, IBUpdate");
				FillPropertyValues(CurrentData, Data);
				CurrentData.Insert("NewRecords", NewSetRecords);
				
				UpdateRecordSet(CurrentData, HasChanges);
			EndDo;
			
		ElsIf Data.ThirdDimensionName = Undefined Then
			// 
			FieldList = Data.FirstDimensionName + ", " + Data.SecondDimensionName;
			Data.NewRecords.Indexes.Add(FieldList);
			Filter = New Structure(FieldList);
			
			For Each FirstValue In Data.FirstDimensionValues Do
				SetFilter(Data.RecordSet.Filter[Data.FirstDimensionName], FirstValue);
				Filter[Data.FirstDimensionName] = FirstValue;
				
				UpdateNewSetRecordsByAllNewRecords(
					Data,
					Filter,
					FieldList,
					Data.SecondDimensionName,
					Data.SecondDimensionValues,
					HasChanges);
			EndDo;
		Else
			// 
			FieldList = Data.FirstDimensionName + ", " + Data.SecondDimensionName + ", " + Data.ThirdDimensionName;
			Data.NewRecords.Indexes.Add(FieldList);
			Filter = New Structure(FieldList);
			
			For Each FirstValue In Data.FirstDimensionValues Do
				SetFilter(Data.RecordSet.Filter[Data.FirstDimensionName], FirstValue);
				Filter[Data.FirstDimensionName] = FirstValue;
				
				For Each SecondValue In Data.SecondDimensionValues Do
					SetFilter(Data.RecordSet.Filter[Data.SecondDimensionName], SecondValue);
					Filter[Data.SecondDimensionName] = SecondValue;
					
					UpdateNewSetRecordsByAllNewRecords(
						Data,
						Filter,
						FieldList,
						Data.SecondDimensionName,
						Data.SecondDimensionValues,
						HasChanges);
				EndDo;
			EndDo;
		EndIf;
	EndIf;
	
EndProcedure

// Updates an information register by data in the RowsChanges value table.
//
// Parameters:
//  Data - Structure:
//
//  * RegisterManager       - InformationRegisterManager - register manager to create a record set.
//
//  * EditStringContent  - ValueTable - containing the register fields and
//                             the RowChangeKind field (Number):
//                               1 means that a row must be added.
//                               1 means that a row must be deleted.
//
//  * FixedFilter     - Structure - containing a dimension name in the key and a filter
//                             value in the value. It can be used when there are
//                             more than 3 dimensions and it is known in advance that the dimensions above 3
//                             will have a single value. Dimensions specified
//                             in a fixed filter are not used when generating record
//                             sets for updating.
//
//  * FilterDimensions        - String - a string of comma-separated dimensions
//                             that must be used when generating record sets
//                             for updating (no more than 3). Any unspecified
//                             dimensions will be converted to a fixed filter
//                             if all their values match.
//
//  * IsCheckOnly         - Boolean - if True, do not write,
//                             only find out if writing is required and set
//                             the HasChanges property.
//
//  * AdditionalProperties - Undefined
//                           - Structure - 
//                             
//                             
//
//  * IBUpdate           - Boolean - if True, write data
//                             without performing unnecessary and redundant actions with the data.
//                             See InfobaseUpdate.WriteData.
//                             If the property is not inserted, the value is calculated by Or using the following functions:
//                             InfobaseUpdateInProgress and IsCallFromUpdateHandler
//                             of the InfobaseUpdate common module.
//
//  HasChanges         - Boolean - a return value. If recorded,
//                          True is set, otherwise, it does not change.
//
Procedure UpdateInformationRegister(Val Data, HasChanges = Undefined) Export
	
	If Data.EditStringContent.Count() = 0 Then
		Return;
	EndIf;
	
	AllParameters = New Structure;
	AllParameters.Insert("RegisterManager");
	AllParameters.Insert("EditStringContent");
	AllParameters.Insert("FixedFilter", New Structure);
	AllParameters.Insert("FilterDimensions");
	AllParameters.Insert("IsCheckOnly", False);
	AllParameters.Insert("AdditionalProperties");
	AllParameters.Insert("IBUpdate",
		    InfobaseUpdate.InfobaseUpdateInProgress()
		Or InfobaseUpdate.IsCallFromUpdateHandler());
	
	FillParameters_(Data, AllParameters, "RegisterManager, EditStringContent");
	
	RegisterMetadata = Metadata.FindByType(TypeOf(Data.RegisterManager.EmptyKey()));
	RecordKeyDetails = AccessManagementInternalCached.RecordKeyDetails(RegisterMetadata.FullName());
	
	If Data.FilterDimensions <> Undefined Then
		Data.FilterDimensions = New Structure(Data.FilterDimensions);
	EndIf;
	
	FilterDimensionsArray   = New Array;
	FilterDimensionsValues = New Structure;
	ChangeWithoutFixedFilter = New Structure;
	
	For Each Field In RecordKeyDetails.FieldArray Do
		If Not Data.FixedFilter.Property(Field) Then
			Values = TableColumnValues(Data.EditStringContent, Field);
			
			If Values.Count() = 1 Then
				Data.FixedFilter.Insert(Field, Values[0]);
				Continue;
			EndIf;
			
			If Data.FilterDimensions = Undefined
			 Or Data.FilterDimensions.Property(Field) Then
				
				FilterDimensionsArray.Add(Field);
				FilterDimensionsValues.Insert(Field, Values);
				
			ElsIf Not ValueIsFilled(ChangeWithoutFixedFilter) Then
				ChangeWithoutFixedFilter.Insert("Field",     Field);
				ChangeWithoutFixedFilter.Insert("Values", Values);
			EndIf;
		EndIf;
	EndDo;
	
	If FilterDimensionsArray.Count() = 0 Then
		If ValueIsFilled(ChangeWithoutFixedFilter) Then
			Field     = ChangeWithoutFixedFilter.Field;
			Values = ChangeWithoutFixedFilter.Values;
		EndIf;
		FilterDimensionsArray.Add(Field);
		FilterDimensionsValues.Insert(Field, Values);
	EndIf;
	
	Data.Insert("FirstDimensionName", FilterDimensionsArray[0]);
	Data.Insert("FirstDimensionValues", FilterDimensionsValues[Data.FirstDimensionName]);
	
	If FilterDimensionsArray.Count() > 1 Then
		Data.Insert("SecondDimensionName", FilterDimensionsArray[1]);
		Data.Insert("SecondDimensionValues", FilterDimensionsValues[Data.SecondDimensionName]);
	Else
		Data.Insert("SecondDimensionName", Undefined);
		Data.Insert("SecondDimensionValues", Undefined);
	EndIf;
	
	If FilterDimensionsArray.Count() > 2 Then
		Data.Insert("ThirdDimensionName", FilterDimensionsArray[2]);
		Data.Insert("ThirdDimensionValues", FilterDimensionsValues[Data.ThirdDimensionName]);
	Else
		Data.Insert("ThirdDimensionName", Undefined);
		Data.Insert("ThirdDimensionValues", Undefined);
	EndIf;
	
	Data.Insert("ComparisonFields", RecordKeyDetails.FieldsString);
	Data.Insert("NewRecordsContainOnlyDifferences", True);
	Data.Insert("NewRecords", Data.EditStringContent);
	Data.Delete("EditStringContent");
	Data.Delete("FilterDimensions");
	
	UpdateRecordSets(Data, HasChanges);
	
EndProcedure

// Returns a blank reference of a metadata object of a reference type.
//
// Parameters:
//  MetadataObjectDetails - MetadataObject,
//                            - Type - 
//                            - String - full name of the metadata object.
// Returns:
//  AnyRef
//
Function MetadataObjectEmptyRef(MetadataObjectDetails) Export
	
	If TypeOf(MetadataObjectDetails) = Type("MetadataObject") Then
		MetadataObject = MetadataObjectDetails;
		
	ElsIf TypeOf(MetadataObjectDetails) = Type("Type") Then
		MetadataObject = Metadata.FindByType(MetadataObjectDetails);
	Else
		MetadataObject = Common.MetadataObjectByFullName(MetadataObjectDetails);
	EndIf;
	
	If MetadataObject = Undefined Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Error in function ""%1""
			           |of common module ""%2"".
			           |
			           |Parameter ""%3"" is invalid.';"),
			"MetadataObjectEmptyRef",
			"AccessManagementInternal",
			"MetadataObjectDetails");
		Raise ErrorText;
	EndIf;
	
	EmptyRef = Undefined;
	Try
		ObjectManager = Common.ObjectManagerByFullName(MetadataObject.FullName());
		EmptyRef = ObjectManager.EmptyRef();
	Except
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Error in function ""%1""
			           |of common module ""%2"".
			           |
			           |Cannot get an empty reference for metadata object
			           |""%3"".';"),
			"MetadataObjectEmptyRef",
			"AccessManagementInternal",
			MetadataObject.FullName());
		Raise ErrorText;
	EndTry;
	
	Return EmptyRef;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Other procedures and functions

// Creates a query to find differences between the register rows in the specified data area
// (based on filters in the FieldsAndFilter parameter).
//
// Parameters:
//  NewDataSelectionQueryText - String
//
//  FieldsAndFilter - Array of Structure - with the "FieldName", FilterCriterionParameterName properties.
//
//  FullRegisterName - String       - a query for old data is generated automatically.
//                    - Undefined - 
//
//  TemporaryTablesQueriesText - String - a temporary table query if required.
//
//  OldDataSelectionQueryText - String       - a query for old data, with nonstandard filters.
//                           - Undefined - 
//
// Returns:
//  String - 
//
Function ChangesSelectionQueryText(NewDataSelectionQueryText,
                                    FieldsAndFilter,
                                    FullRegisterName            = Undefined,
                                    TemporaryTablesQueriesText = Undefined,
                                    OldDataSelectionQueryText     = Undefined) Export
	
	// Preparing the old data query text.
	If FullRegisterName <> Undefined Then
		OldDataSelectionQueryText =
		"SELECT
		|	&SelectedFields,
		|	&RowChangeKindFieldSubstitution
		|FROM
		|	FullRegisterName AS OldData
		|WHERE
		|	&FilterConditions";
	EndIf;
	
	SelectedFields = "";
	FilterConditions = "TRUE";
	For Each FieldDetails In FieldsAndFilter Do
		// 
		SelectedFields = SelectedFields + StrReplace(
			"
			|	OldData.Field,",
			"Field",
			KeyAndValue(FieldDetails).Key);
			
		// Aggregate the filter conditions.
		If ValueIsFilled(KeyAndValue(FieldDetails).Value) Then
			FilterConditions = FilterConditions + StrReplace(
				"
				|	AND &FilterCriterionParameterName", "&FilterCriterionParameterName",  // @query-part-1
				KeyAndValue(FieldDetails).Value);
		EndIf;
	EndDo;
	
	OldDataSelectionQueryText =
		StrReplace(OldDataSelectionQueryText, "&SelectedFields,",  SelectedFields);
	
	OldDataSelectionQueryText =
		StrReplace(OldDataSelectionQueryText, "&FilterConditions",    FilterConditions);
	
	OldDataSelectionQueryText =
		StrReplace(OldDataSelectionQueryText, "FullRegisterName", FullRegisterName);
	
	If StrFind(OldDataSelectionQueryText, "&RowChangeKindFieldSubstitution") = 0 Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Invalid value in parameter ""%1""
			           |of procedure ""%2"" of module ""%3"".
			           |
			           |The query is missing a string ""%4"".';"),
			"OldDataSelectionQueryText",
			"ChangesSelectionQueryText",
			"AccessManagementInternal",
			"&RowChangeKindFieldSubstitution");
		Raise ErrorText;
	EndIf;
	
	OldDataSelectionQueryText = StrReplace(
		OldDataSelectionQueryText, "&RowChangeKindFieldSubstitution", "-1 AS LineChangeType");
	
	If StrFind(NewDataSelectionQueryText, "&RowChangeKindFieldSubstitution") = 0 Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Invalid value in parameter ""%1""
			           |of procedure ""%2"" of module ""%3"".
			           |
			           |The query is missing a string ""%1"".';"),
			"NewDataSelectionQueryText",
			"ChangesSelectionQueryText",
			"AccessManagementInternal",
			"&RowChangeKindFieldSubstitution");
		Raise ErrorText;
	EndIf;
	
	NewDataSelectionQueryText = StrReplace(
		NewDataSelectionQueryText,  "&RowChangeKindFieldSubstitution", "1 AS LineChangeType");
	
	// Preparing a text of change selection query.
	QueryText =
	"SELECT
	|	&SelectedFields,
	|	SUM(AllRows.LineChangeType) AS LineChangeType
	|FROM
	|	NewAndOldRowsSelectionQueryText AS AllRows
	|	
	|GROUP BY
	|	&GroupFields
	|	
	|HAVING
	|	SUM(AllRows.LineChangeType) <> 0";
	
	NewAndOldRowsSelectionQueryText =
	"	(" + NewDataSelectionQueryText + "
	|	
	|	UNION ALL
	|	
	|	" + OldDataSelectionQueryText + ")"; // @query-part-1
	
	SelectedFields = "";
	GroupFields = "";
	For Each FieldDetails In FieldsAndFilter Do
		// 
		SelectedFields = SelectedFields + StrReplace(
			"
			|	AllRows.Field,",
			"Field",
			KeyAndValue(FieldDetails).Key);
		
		// 
		GroupFields = GroupFields + StrReplace(
			"
			|	AllRows.Field,",
			"Field",
			KeyAndValue(FieldDetails).Key);
	EndDo;
	GroupFields = Left(GroupFields, StrLen(GroupFields)-1);
	QueryText = StrReplace(QueryText, "&SelectedFields,",  SelectedFields);
	QueryText = StrReplace(QueryText, "&GroupFields", GroupFields);
	
	QueryText = StrReplace(QueryText,
		"NewAndOldRowsSelectionQueryText", NewAndOldRowsSelectionQueryText);
	
	If ValueIsFilled(TemporaryTablesQueriesText) Then
		QueryText = TemporaryTablesQueriesText +
		"
		|;
		|" + QueryText;
	EndIf;
	
	Return QueryText;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Infobase update.

// Fills in separated data handler that depends on shared data change.
//
// Parameters:
//   Parameters - Structure - parameters of the update handler:
//     * SeparatedHandlers - See InfobaseUpdate.NewUpdateHandlerTable
// 
Procedure FillSeparatedDataHandlers(Parameters = Undefined) Export
	
	If Parameters <> Undefined And HasChangesOfAccessRestrictionParameters() Then
		Handlers = Parameters.SeparatedHandlers;
		Handler = Handlers.Add();
		Handler.Version = "*";
		Handler.ExecutionMode = "Seamless";
		Handler.Procedure = "AccessManagementInternal.UpdateAuxiliaryRegisterDataByConfigurationChanges";
	EndIf;
	
EndProcedure

// Updates auxiliary data that partially depends on the configuration.
//
// Updated when there are configuration changes recorded in access restriction
// parameters when updating the infobase to the current configuration version.
//
Procedure UpdateAuxiliaryRegisterDataByConfigurationChanges(Parameters = Undefined) Export
	
	// 
	InformationRegisters.AccessGroupsTables.UpdateRegisterDataByConfigurationChanges();
	
	// Parameter StandardSubsystems.AccessManagement.AccessKindsProperties.
	UpdateGroupsAndSetsOfAccessValuesWhenGroupTypesAndValuesChange();
	
	// 
	InformationRegisters.ObjectsRightsSettings.UpdateAuxiliaryRegisterDataByConfigurationChanges1();
	
	// 
	Catalogs.AccessGroupProfiles.UpdateSuppliedProfilesByConfigurationChanges();
	Catalogs.AccessGroupProfiles.UpdateNonSuppliedProfilesOnConfigurationChanges();
	
	// 
	Catalogs.AccessGroups.MarkForDeletionSelectedProfilesAccessGroups();
	
	// 
	InformationRegisters.AccessRestrictionParameters.ScheduleAccessUpdateByConfigurationChanges();
	
EndProcedure

// Updates settings and enables a scheduled job.
Procedure EnableDataFillingForAccessRestriction() Export
	
	Use = Constants.LimitAccessAtRecordLevel.Get();
	
	If Common.DataSeparationEnabled() Then
		SetDataFillingForAccessRestriction(Use);
	Else
		Schedule = New JobSchedule;
		Schedule.WeeksPeriod = 1;
		Schedule.DaysRepeatPeriod = 1;
		Schedule.RepeatPeriodInDay = 300;
		Schedule.RepeatPause = 90;
		
		MetadataJob = Metadata.ScheduledJobs.DataFillingForAccessRestriction;
		Job = ScheduledJobsServer.GetScheduledJob(MetadataJob);
		
		Job.Use = Use;
		Job.Schedule = Schedule;
		
		Job.RestartIntervalOnFailure
			= MetadataJob.RestartIntervalOnFailure;
		
		Job.RestartCountOnFailure
			= MetadataJob.RestartCountOnFailure;
		
		Job.Write();
	EndIf;
	
EndProcedure

// Updates data of the InteractiveOpenExtReportsAndDataProcessors profile.
Procedure UpdateProfileDataOpenExternalReportsAndDataProcessors() Export
	
	ProfileUUID = New UUID(
		OpenExternalReportsAndDataProcessorsProfileID());
	
	Ref = Catalogs.AccessGroupProfiles.GetRef(ProfileUUID);
	If Common.ObjectAttributeValue(Ref, "Ref") = Undefined Then
		Return;
	EndIf;
	MarkForDeletionRef = False;
	
	Block = New DataLock;
	LockItem = Block.Add("Catalog.AccessGroupProfiles");
	LockItem.SetValue("Ref", Ref);
	
	If Common.DataSeparationEnabled() Then
		MarkForDeletionRef = True;
	Else
		ProfileDetails = OpenExternalReportsAndDataProcessorsProfileDetails();
		SuppliedProfileReference = Catalogs.AccessGroupProfiles.SuppliedProfileByID(
			ProfileDetails.Name);
		
		If Ref <> SuppliedProfileReference Then
			If SuppliedProfileReference <> Undefined Then
				MarkForDeletionRef = True;
			Else
				// Assign a default master data record ID.
				BeginTransaction();
				Try
					Block.Lock();
					ProfileObject = Ref.GetObject();
					ProfileObject.SuppliedDataID = ProfileUUID;
					ProfileObject.Comment = "";
					InfobaseUpdate.WriteObject(ProfileObject, False);
					CommitTransaction();
				Except
					RollbackTransaction();
					Raise;
				EndTry;
			EndIf;
		EndIf;
	EndIf;
	
	If MarkForDeletionRef Then
		BeginTransaction();
		Try
			Block.Lock();
			ProfileObject = Ref.GetObject();
			ProfileObject.DeletionMark = True;
			InfobaseUpdate.WriteObject(ProfileObject, False);
			CommitTransaction();
		Except
			RollbackTransaction();
			Raise;
		EndTry;
		
		ProfileGroups = ProfileGroups(Ref, False);
		For Each GroupReference In ProfileGroups Do
			Block = New DataLock;
			LockItem = Block.Add("Catalog.AccessGroups");
			LockItem.SetValue("Ref", GroupReference);
			BeginTransaction();
			Try
				Block.Lock();
				GroupObject = GroupReference.GetObject();
				GroupObject.DeletionMark = True;
				InfobaseUpdate.WriteObject(GroupObject, False);
				CommitTransaction();
			Except
				RollbackTransaction();
				Raise;
			EndTry;
		EndDo;
	EndIf;
	
EndProcedure

// For internal use only.
Procedure UpdateAuxiliaryAccessGroupsData(Parameters) Export
	
	Catalogs.AccessGroups.UpdateAuxiliaryAccessGroupsData(Parameters);
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Auxiliary procedures and functions.

// Returns:
//   See InformationRegisters.RolesRights.RolesRightsTable
//
Function ExtensionsRolesRights() Export
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	ExtensionsRolesRights = Undefined;
	
	SetARecordOfAccessRestrictionParametersInTheCurrentSession(True);
	Try
		UpdateAccessGroupsTablesForEnabledExtensions(ExtensionsRolesRights);
	Except
		SetARecordOfAccessRestrictionParametersInTheCurrentSession(False);
		Raise;
	EndTry;
	SetARecordOfAccessRestrictionParametersInTheCurrentSession(False);
	
	Return ExtensionsRolesRights;
	
EndFunction

// Parameters:
//  ExtensionsRolesRights - See InformationRegisters.RolesRights.RolesRightsTable
//
Procedure UpdateAccessGroupsTablesForEnabledExtensions(ExtensionsRolesRights = Undefined)
	
	BlankExtensionsRolesRights = InformationRegisters.RolesRights.RolesRightsTable(True, True, True);
	
	If Common.SubsystemExists("StandardSubsystems.DataExchange") Then
		ModuleDataExchangeServer = Common.CommonModule("DataExchangeServer");
		If ModuleDataExchangeServer.SubordinateDIBNodeSetup() Then
			ExtensionsRolesRights = BlankExtensionsRolesRights;
			Return;
		EndIf;
	EndIf;
	
	// 
	// 
	SetNewExtenstionsRolesRights = False;
	If ValueIsFilled(SessionParameters.AttachedExtensions) Then
		ExtensionsRolesRightsStorage = StandardSubsystemsServer.ExtensionParameter(
			"StandardSubsystems.AccessManagement.RolesRights"); // ValueStorage
		
		If ExtensionsRolesRightsStorage = Undefined Then
			ExtensionsRolesRights = Undefined;
		Else
			ExtensionsRolesRights = ValueFromStorage(ExtensionsRolesRightsStorage);
			If Not IsExtensionsRolesRights(ExtensionsRolesRights, BlankExtensionsRolesRights) Then
				ExtensionsRolesRights = Undefined;
			EndIf;
		EndIf;
		If ExtensionsRolesRights = Undefined Then
			Query = InformationRegisters.RolesRights.ChangesQuery(True);
			ExtensionsRolesRights = Query.Execute().Unload();
			SetNewExtenstionsRolesRights = True;
		EndIf;
	Else
		ExtensionsRolesRights = BlankExtensionsRolesRights;
	EndIf;
	
	// Checking whether it is required to update the AccessGroupsTables register.
	ParameterName = "StandardSubsystems.AccessManagement.AccessGroupTablesUpdateParameters";
	ParametersOfUpdate = StandardSubsystemsServer.ExtensionParameter(ParameterName, True);
	
	If TypeOf(ParametersOfUpdate) <> Type("Structure")
	 Or Not ParametersOfUpdate.Property("LastExtensionsRolesRights")
	 Or Not IsExtensionsRolesRights(ParametersOfUpdate.LastExtensionsRolesRights, BlankExtensionsRolesRights) Then
		
		UpdateRequired = True;
		LastExtensionsRolesRights = Undefined;
	Else
		LastExtensionsRolesRights = ParametersOfUpdate.LastExtensionsRolesRights;
		UpdateRequired = ExtensionsRolesRightsChanged(ExtensionsRolesRights, LastExtensionsRolesRights);
	EndIf;
	
	If Not UpdateRequired Then
		If SetNewExtenstionsRolesRights Then;
			StandardSubsystemsServer.SetExtensionParameter(
				"StandardSubsystems.AccessManagement.RolesRights",
				New ValueStorage(ExtensionsRolesRights));
		EndIf;
		Return;
	EndIf;
	
	If LastExtensionsRolesRights = Undefined Then
		// Since the latest extension role rights are unavailable, update the entire register.
		ObjectsWithUpdateRightsChanges = Undefined;
	Else
		CurrentObjectsWithRightsChanges = InformationRegisters.RolesRights.ChangedMetadataObjects(
			ExtensionsRolesRights.Copy());
		
		LastObjectsWithRightsChanges = InformationRegisters.RolesRights.ChangedMetadataObjects(
			LastExtensionsRolesRights.Copy());
		
		ObjectsWithUpdateRightsChanges = New Array(CurrentObjectsWithRightsChanges);
		For Each Id In LastObjectsWithRightsChanges Do
			ObjectsWithUpdateRightsChanges.Add(Id);
		EndDo;
	EndIf;
	
	NewUpdateParameters = New Structure;
	NewUpdateParameters.Insert("LastExtensionsRolesRights", ExtensionsRolesRights);
	
	Block = New DataLock;
	Block.Add("InformationRegister.AccessGroupsTables");
	LockItem = Block.Add("InformationRegister.ExtensionVersionParameters");
	LockItem.SetValue("ExtensionsVersion", Catalogs.ExtensionsVersions.EmptyRef());
	LockItem.SetValue("ParameterName", ParameterName);
	
	BeginTransaction();
	Try
		Block.Lock();
		IsAlreadyModified = False;
		StandardSubsystemsServer.ExtensionParameter(ParameterName, True, IsAlreadyModified);
		If IsAlreadyModified Then
			CheckWhetherTheMetadataIsUpToDate();
		EndIf;
		If SetNewExtenstionsRolesRights Then;
			StandardSubsystemsServer.SetExtensionParameter(
				"StandardSubsystems.AccessManagement.RolesRights",
				New ValueStorage(ExtensionsRolesRights));
		EndIf;
		StandardSubsystemsServer.SetExtensionParameter(ParameterName,
			NewUpdateParameters, True);
		InformationRegisters.AccessGroupsTables.UpdateRegisterData(, ObjectsWithUpdateRightsChanges);
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

// For the UpdateAccessGroupsTablesForEnabledExtensions procedure.
// 
// Parameters:
//  ExtensionsRolesRights       - See InformationRegisters.RolesRights.RolesRightsTable
//  BlankExtensionsRolesRights - See InformationRegisters.RolesRights.RolesRightsTable
//
Function IsExtensionsRolesRights(ExtensionsRolesRights, BlankExtensionsRolesRights)
	
	If TypeOf(ExtensionsRolesRights) <> Type("ValueTable") Then
		Return False;
	EndIf;
	
	If ExtensionsRolesRights.Columns.Count() <> BlankExtensionsRolesRights.Columns.Count() Then
		Return False;
	EndIf;
	
	For Each Column In BlankExtensionsRolesRights.Columns Do
		FoundColumn = ExtensionsRolesRights.Columns.Find(Column.Name);
		If FoundColumn = Undefined Then
			Return False;
		EndIf;
		If Column.ValueType <> FoundColumn.ValueType Then
			Return False;
		EndIf;
	EndDo;
	
	Return True;
	
EndFunction

// For the UpdateAccessGroupsTablesForEnabledExtensions procedure.
// 
// Parameters:
//  NewExtensionsRolesRights  - See InformationRegisters.RolesRights.RolesRightsTable
//  OldExtensionsRolesRights - See InformationRegisters.RolesRights.RolesRightsTable
//
Function ExtensionsRolesRightsChanged(NewExtensionsRolesRights, OldExtensionsRolesRights)
	
	If NewExtensionsRolesRights.Count() <> OldExtensionsRolesRights.Count() Then
		Return True;
	EndIf;
	
	Filter = New Structure;
	Fields = New Array;
	For Each Column In NewExtensionsRolesRights.Columns Do
		Fields.Add(Column.Name);
		Filter.Insert(Column.Name);
	EndDo;
	OldExtensionsRolesRights.Indexes.Add(StrConcat(Fields, ","));
	
	For Each String In NewExtensionsRolesRights Do
		FillPropertyValues(Filter, String);
		If OldExtensionsRolesRights.FindRows(Filter).Count() <> 1 Then
			Return True;
		EndIf;
	EndDo;
	
	Return False;
	
EndFunction

Procedure OnChangeAccessValuesSets(Val ObjectReference, IBUpdate = False)
	
	RefsToDependentObjects = New Array;
	
	AccessManagementOverridable.OnChangeAccessValuesSets(
		ObjectReference, RefsToDependentObjects);
	
	For Each DependentObjectRef In RefsToDependentObjects Do
		
		If DependentObjectRef.Metadata().TabularSections.Find("AccessValuesSets") = Undefined Then
			// 
			// 
			WriteAccessValuesSets(DependentObjectRef, , IBUpdate);
		Else
			// Object change is required.
			Object = DependentObjectRef.GetObject();
			Table = GetAccessValuesSetsOfTabularSection(Object);
			If Not AccessValuesSetsOfTabularSectionChanged(DependentObjectRef, Table) Then
				Continue;
			EndIf;
			PrepareAccessValuesSetsForWrite(Undefined, Table, False);
			Try
				LockDataForEdit(DependentObjectRef, Object.DataVersion);
				Object.AdditionalProperties.Insert("WriteAccessValuesSets");
				Object.AdditionalProperties.Insert("WriteDependentAccessValuesSets");
				Object.AdditionalProperties.Insert("AccessValuesSetsOfTabularSectionAreFilled");
				Object.AccessValuesSets.Load(Table);
				If IBUpdate Then
					Object.AdditionalProperties.Insert("WriteAccessValueSetsOnUpdateIB");
					InfobaseUpdate.WriteData(Object);
				Else
					Object.DataExchange.Load = True;
					// ACC:1327-
					// 
					// 
					Object.Write();
					// ACC:1327-off.
				EndIf;
				UnlockDataForEdit(DependentObjectRef);
			Except
				ErrorInfo = ErrorInfo();
				ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("en = 'Cannot update the dependent access value set of the ""%1"" object
					           |due to:
					           |
					           |%2';"),
					String(DependentObjectRef),
					ErrorProcessing.BriefErrorDescription(ErrorInfo));
				Raise ErrorText;
			EndTry;
		EndIf;
	EndDo;
	
EndProcedure

Function OpenExternalReportsAndDataProcessorsProfileID()
	
	Return "1b3472f6-4d87-11e6-8264-5404a6a6895d";
	
EndFunction

Function IsProfileOpenExternalReportsAndDataProcessors(Profile) Export
	
	If TypeOf(Profile) = Type("CatalogRef.AccessGroupProfiles") Then
		ProfileID = Common.ObjectAttributeValue(Profile, "SuppliedDataID");
		
	ElsIf Not Profile.IsFolder Then
		ProfileID = Profile.SuppliedDataID;
	Else
		Return False;
	EndIf;
	
	Return Upper(String(ProfileID)) = Upper(OpenExternalReportsAndDataProcessorsProfileID());
	
EndFunction

Function ProfileAccessGroupsOpenExternalReportsAndDataProcessors()
	
	Query = New Query;
	Query.SetParameter("SuppliedDataID",
		New UUID(OpenExternalReportsAndDataProcessorsProfileID()));
	
	Query.Text =
	"SELECT
	|	AccessGroups.Ref AS Ref
	|FROM
	|	Catalog.AccessGroups AS AccessGroups
	|WHERE
	|	AccessGroups.Profile.SuppliedDataID = &SuppliedDataID";
	
	Return Query.Execute().Unload().UnloadColumn("Ref");
	
EndFunction

Function OpenExternalReportsAndDataProcessorsProfileDetails() Export
	
	ProfileDetails = AccessManagement.NewAccessGroupProfileDescription();
	ProfileDetails.Name           = "OpenExternalReportsAndDataProcessors";
	ProfileDetails.Parent      = "AdditionalProfiles";
	ProfileDetails.Id = OpenExternalReportsAndDataProcessorsProfileID();
	
	ProfileDetails.Description =
		NStr("en = 'Open external reports and data processors';", Common.DefaultLanguageCode());
	
	ProfileDetails.LongDesc =
		NStr("en = 'Grants the right to open external reports and data processors from the ""File—Open"" menu.
		           |It is recommended that you do not change the list of profile''s roles.';");
	
	ProfileDetails.Roles.Add("InteractiveOpenExtReportsAndDataProcessors");
	
	Return ProfileDetails;
	
EndFunction

Function OpenExternalReportsAndDataProcessorsAccessGroup(ProfileProperties)
	
	// Search by ID.
	UUID = New UUID("f6929bcb-532f-11e6-a20f-5404a6a6895d");
	Ref = Catalogs.AccessGroups.GetRef(UUID);
	RefExists = (Common.ObjectAttributeValue(Ref, "Ref") <> Undefined);
	If RefExists Then
		Return Ref;
	EndIf;
	
	// Search by profile.
	ProfileGroups = ProfileGroups(ProfileProperties.Ref, Undefined);
	If ProfileGroups.Count() > 0 Then
		Return ProfileGroups[0];
	EndIf;
	
	// Create a group.
	AccessGroupObject = Catalogs.AccessGroups.CreateItem();
	AccessGroupObject.SetNewObjectRef(Ref);
	AccessGroupObject.Description = ProfileProperties.Description;
	AccessGroupObject.Profile      = ProfileProperties.Ref;
	AccessGroupObject.Comment  =
		NStr("en = 'Grants the right to open external reports and data processors from the ""File—Open"" menu.';",
			Common.DefaultLanguageCode());
	
	AccessGroupObject.Write(); // 
	
	Return AccessGroupObject.Ref;
	
EndFunction

Function ProfileGroups(ProfileRef, DeletionMark)
	
	Query = New Query;
	Query.Text =
	"SELECT
	|	AccessGroups.Ref
	|FROM
	|	Catalog.AccessGroups AS AccessGroups
	|WHERE
	|	AccessGroups.Profile = &Profile
	|	AND AccessGroups.DeletionMark = &DeletionMark
	|
	|ORDER BY
	|	AccessGroups.DeletionMark";
	
	Query.SetParameter("Profile", ProfileRef);
	
	If DeletionMark = Undefined Then
		Query.Text = StrReplace(Query.Text, "AND AccessGroups.DeletionMark = &DeletionMark", ""); // @query-part-1
	Else
		Query.SetParameter("DeletionMark", DeletionMark);
	EndIf;
	
	Return Query.Execute().Unload().UnloadColumn("Ref");
	
EndFunction

// For AllowedDynamicListValues and HasRestrictionByAccessKind functions.
Function AccessGroupsRequestText()
	
	Return
	"SELECT
	|	AccessGroups.Ref AS Ref
	|INTO UserAccessGroups
	|FROM
	|	Catalog.MetadataObjectIDs AS CurrentTableProperties
	|		INNER JOIN Catalog.AccessGroups AS AccessGroups
	|		ON (CurrentTableProperties.FullName = &MainListTableName)
	|			AND (TRUE IN
	|				(SELECT TOP 1
	|					TRUE
	|				FROM
	|					InformationRegister.AccessGroupsTables AS AccessGroupsTables
	|				WHERE
	|					AccessGroupsTables.Table = CurrentTableProperties.Ref
	|					AND AccessGroupsTables.AccessGroup = AccessGroups.Ref))
	|			AND (AccessGroups.Ref IN
	|				(SELECT
	|					AccessGroupsUsers_SSLy.Ref AS AccessGroup
	|				FROM
	|					Catalog.AccessGroups.Users AS AccessGroupsUsers_SSLy
	|						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|						ON
	|							UserGroupCompositions.User = &AuthorizedUser
	|								AND UserGroupCompositions.UsersGroup = AccessGroupsUsers_SSLy.User))";
	
EndFunction

// For the UpdateRecordSet, UpdateRecordSets, and UpdateInformationRegister procedures.
Procedure FillParameters_(InputParameters, Val AllParameters, Val RequiredParameters2 = "")
	
	If TypeOf(InputParameters) = Type("Structure") Then
		Parameters = InputParameters;
	ElsIf InputParameters = Undefined Then
		Parameters = New Structure;
	Else
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Invalid type of property set ""%1.""
			           |Allowed types: %2 and %3.';"),
			TypeOf(InputParameters), "Structure", "Undefined");
		Raise ErrorText;
	EndIf;
	
	For Each KeyAndValue In Parameters Do
		If Not AllParameters.Property(KeyAndValue.Key) Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'The %1 parameter does not exist.';"),
				KeyAndValue.Key);
			Raise ErrorText;
		EndIf;
		AllParameters[KeyAndValue.Key] = Parameters[KeyAndValue.Key];
	EndDo;
	
	If ValueIsFilled(RequiredParameters2) Then
		RequiredParameters2 = New Structure(RequiredParameters2);
		
		For Each KeyAndValue In RequiredParameters2 Do
			If Not Parameters.Property(KeyAndValue.Key) Then
				ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("en = 'The required parameter %1 is not specified.';"),
					KeyAndValue.Key);
				Raise ErrorText;
			EndIf;
		EndDo;
	EndIf;
	
	InputParameters = AllParameters;
	
EndProcedure

// For the OnSendDataToMaster, OnSendDataToSubordinate,
// OnReceiveDataFromMaster, OnReceiveDataFromSlave procedures.
//
Function AccessManagementSubsystemObjectOnlyToCreateInitialImage(DataElement)
	
	Return TypeOf(DataElement) = Type("InformationRegisterRecordSet.RolesRights")
	    Or TypeOf(DataElement) = Type("InformationRegisterRecordSet.AccessRightsDependencies")
	    Or TypeOf(DataElement) = Type("InformationRegisterRecordSet.AccessGroupsTables")
	    Or TypeOf(DataElement) = Type("InformationRegisterRecordSet.AccessGroupsValues")
	    Or TypeOf(DataElement) = Type("InformationRegisterRecordSet.DefaultAccessGroupsValues")
	    Or TypeOf(DataElement) = Type("CatalogObject.AccessKeys")
	    Or TypeOf(DataElement) = Type("CatalogObject.SetsOfAccessGroups")
	    Or TypeOf(DataElement) = Type("InformationRegisterRecordSet.ExternalUsersAccessKeys")
	    Or TypeOf(DataElement) = Type("InformationRegisterRecordSet.AccessGroupsAccessKeys")
	    Or TypeOf(DataElement) = Type("InformationRegisterRecordSet.AccessGroupSetsAccessKeys")
	    Or TypeOf(DataElement) = Type("InformationRegisterRecordSet.AccessKeysForObjects")
	    Or TypeOf(DataElement) = Type("InformationRegisterRecordSet.AccessKeysForRegisters")
	    Or TypeOf(DataElement) = Type("InformationRegisterRecordSet.UsersAccessKeys")
	    Or TypeOf(DataElement) = Type("InformationRegisterRecordSet.DataAccessKeysUpdate")
	    Or TypeOf(DataElement) = Type("InformationRegisterRecordSet.UsersAccessKeysUpdate")
	    Or TypeOf(DataElement) = Type("InformationRegisterRecordSet.AccessRestrictionParameters")
	    Or TypeOf(DataElement) = Type("InformationRegisterRecordSet.UsedAccessKindsByTables")
	    Or TypeOf(DataElement) = Type("ConstantValueManager.FirstAccessUpdateCompleted");
	
EndFunction

// For procedures OnReceiveDataFromMaster, OnReceiveDataFromSlave
Procedure OnReceiveDataFromMasterOrSlave(DataElement)
	
	If TypeOf(DataElement) = Type("ConstantValueManager.LimitAccessAtRecordLevel") Then
		Constants.LimitAccessAtRecordLevel.CreateValueManager().RegisterAChangeWhenUploading(DataElement);
	EndIf;
	
	If TypeOf(DataElement) = Type("InformationRegisterRecordSet.UsedAccessKinds") Then
		InformationRegisters.UsedAccessKinds.RegisterAChangeWhenUploading(DataElement);
	EndIf;
	
	If TypeOf(DataElement) = Type("CatalogObject.AccessGroupProfiles") Then
		// Роли расширений назначаются независимо во всех РИБ-
		Catalogs.AccessGroupProfiles.RestoreExtensionsRolesComponents(DataElement);
		// 
		Catalogs.AccessGroupProfiles.RegisterProfileChangedOnImport(DataElement);
	EndIf;
	
	If TypeOf(DataElement) = Type("CatalogObject.AccessGroups") Then
		// Администраторы назначаются независимо во всех РИБ-
		Catalogs.AccessGroups.RestoreAdministratorsAccessGroupMembers(DataElement);
		// 
		Catalogs.AccessGroups.RegisterAccessGroupChangedOnImport(DataElement);
	EndIf;
	
	// Registering users changed in a user group to update roles after receiving data.
	If TypeOf(DataElement) = Type("CatalogObject.UserGroups")
	 Or TypeOf(DataElement) = Type("CatalogObject.ExternalUsersGroups") Then
		Catalogs.AccessGroups.RegisterUsersOfUserGroupChangedOnImport(DataElement);
	EndIf;
	
	// Registering a user changed upon import to update roles after importing.
	If TypeOf(DataElement) = Type("CatalogObject.Users")
	 Or TypeOf(DataElement) = Type("CatalogObject.ExternalUsers") Then
		Catalogs.AccessGroups.RegisterUserChangedOnImport(DataElement);
	EndIf;
	
	If TypeOf(DataElement) <> Type("ObjectDeletion") Then
		Return;
	EndIf;
	
	DataElement = DataElement; // ObjectDeletion
	
	// Registering a changed profile to update auxiliary data after importing.
	If TypeOf(DataElement.Ref) = Type("CatalogRef.AccessGroupProfiles") Then
		Catalogs.AccessGroupProfiles.RegisterProfileChangedOnImport(DataElement);
	EndIf;
	
	// Registering a changed access group to update auxiliary data after importing.
	If TypeOf(DataElement.Ref) = Type("CatalogRef.AccessGroups") Then
		Catalogs.AccessGroups.RegisterAccessGroupChangedOnImport(DataElement);
	EndIf;
	
	// Registering users changed in a user group to update roles after importing.
	If TypeOf(DataElement.Ref) = Type("CatalogRef.UserGroups")
	 Or TypeOf(DataElement.Ref) = Type("CatalogRef.ExternalUsersGroups") Then
		Catalogs.AccessGroups.RegisterUsersOfUserGroupChangedOnImport(DataElement);
	EndIf;
	
	// Registering a user changed upon import to update roles after importing.
	If TypeOf(DataElement.Ref) = Type("CatalogRef.Users")
	 Or TypeOf(DataElement.Ref) = Type("CatalogRef.ExternalUsers") Then
		Catalogs.AccessGroups.RegisterUserChangedOnImport(DataElement);
	EndIf;
	
EndProcedure

// For AfterReceiveData and AfterUpdateInfobase procedures.
Procedure UpdateAuxiliaryDataOfItemsChangedOnImport()
	
	InformationRegisters.ExtensionVersionParameters.LockForChangeInFileIB();
	
	Constants.LimitAccessAtRecordLevel.CreateValueManager().ProcessTheChangeRegisteredDuringTheUpload();
	InformationRegisters.UsedAccessKinds.ProcessTheChangeRegisteredDuringTheUpload();
	Catalogs.AccessGroupProfiles.UpdateAuxiliaryProfilesDataChangedOnImport();
	Catalogs.AccessGroups.UpdateAccessGroupsAuxiliaryDataChangedOnImport();
	Catalogs.AccessGroups.UpdateUsersRolesChangedOnImport();
	
EndProcedure

// 
// 

Function ProcessUserLinkToAccessGroup(User, SuppliedProfile, Enable = Undefined)
	
	If TypeOf(User) <> Type("CatalogRef.Users")
	   And TypeOf(User) <> Type("CatalogRef.UserGroups")
	   And TypeOf(User) <> Type("CatalogRef.ExternalUsers")
	   And TypeOf(User) <> Type("CatalogRef.ExternalUsersGroups") Then
		
		Return False;
	EndIf;
	
	SuppliedProfileID = Undefined;
	
	If TypeOf(SuppliedProfile) = Type("String") Then
		If StringFunctionsClientServer.IsUUID(SuppliedProfile) Then
			
			SuppliedProfileID = SuppliedProfile;
			
			SuppliedProfile = Catalogs.AccessGroupProfiles.SuppliedProfileByID(
				SuppliedProfileID,, True);
		Else
			Return False;
		EndIf;
	EndIf;
	
	If TypeOf(SuppliedProfile) <> Type("CatalogRef.AccessGroupProfiles") Then
		Return False;
	EndIf;
	
	If SuppliedProfileID = Undefined Then
		SuppliedProfileID =
			Catalogs.AccessGroupProfiles.SuppliedProfileID(SuppliedProfile);
	EndIf;
	
	If SuppliedProfileID = Catalogs.AccessGroupProfiles.AdministratorProfileID() Then
		Return False;
	EndIf;
	
	ProfileProperties = Catalogs.AccessGroupProfiles.SuppliedProfileProperties(SuppliedProfileID); 
	
	If ProfileProperties = Undefined
	 Or ProfileProperties.AccessKinds.Count() <> 0 Then
		
		Return False;
	EndIf;
	
	AccessGroup = Undefined;
	
	If SimplifiedAccessRightsSetupInterface() Then
		
		If TypeOf(User) <> Type("CatalogRef.Users")
		   And TypeOf(User) <> Type("CatalogRef.ExternalUsers") Then
			
			Return False;
		EndIf;
		
		Query = New Query;
		Query.SetParameter("Profile", SuppliedProfile);
		Query.SetParameter("User", User);
		Query.Text =
		"SELECT
		|	AccessGroups.Ref AS Ref
		|FROM
		|	Catalog.AccessGroups AS AccessGroups
		|WHERE
		|	AccessGroups.Profile = &Profile
		|	AND AccessGroups.User = &User";
		Selection = Query.Execute().Select();
		If Selection.Next() Then
			AccessGroup = Selection.Ref;
		EndIf;
		
		If AccessGroup = Undefined Then
			If Enable <> True Then
				Return False;
			Else
				AccessGroup = Catalogs.AccessGroups.CreateItem();
				AccessGroup.Description = ProfileProperties.Description;
				AccessGroup.Profile      = SuppliedProfile;
				AccessGroup.User = User;
				AccessGroup.Users.Add().User = User;
				AccessGroup.Write();
				Return True;
			EndIf;
		EndIf;
	Else
		Query = New Query;
		Query.SetParameter("SuppliedProfile", SuppliedProfile);
		Query.Text =
		"SELECT
		|	AccessGroups.Ref AS Ref,
		|	AccessGroups.MainSuppliedProfileAccessGroup
		|FROM
		|	Catalog.AccessGroups AS AccessGroups
		|WHERE
		|	AccessGroups.Profile = &SuppliedProfile
		|
		|ORDER BY
		|	AccessGroups.MainSuppliedProfileAccessGroup DESC";
		Selection = Query.Execute().Select();
		If Selection.Next() Then
			AccessGroup = Selection.Ref; // CatalogRef.AccessGroups - 
		EndIf;
		
		If AccessGroup = Undefined Then
			If Enable <> True Then
				Return False;
			Else
				AccessGroup = Catalogs.AccessGroups.CreateItem();
				AccessGroup.MainSuppliedProfileAccessGroup = True;
				AccessGroup.Description = ProfileProperties.Description;
				AccessGroup.Profile = SuppliedProfile;
				AccessGroup.Users.Add().User = User;
				AccessGroup.Write();
				Return True;
			EndIf;
		EndIf;
	EndIf;
	
	Query = New Query;
	Query.SetParameter("Ref", AccessGroup);
	Query.SetParameter("User", User);
	Query.Text =
	"SELECT TOP 1
	|	TRUE AS TrueValue
	|FROM
	|	Catalog.AccessGroups.Users AS GroupMembers
	|WHERE
	|	GroupMembers.Ref = &Ref
	|	AND GroupMembers.User = &User";
	UserFound = Not Query.Execute().IsEmpty();
	
	If Enable = Undefined Then
		Return UserFound;
	EndIf;
	
	If Enable And UserFound Then
		Return True;
	EndIf;
	
	If Not Enable And Not UserFound Then
		Return True;
	EndIf;
	
	Block = New DataLock;
	LockItem = Block.Add("Catalog.AccessGroups");
	LockItem.SetValue("Ref", AccessGroup);
	
	BeginTransaction();
	Try
		Block.Lock();
		
		AccessGroup = AccessGroup.GetObject();
		
		If Not SimplifiedAccessRightsSetupInterface()
		   And Not AccessGroup.MainSuppliedProfileAccessGroup Then
			
			AccessGroup.MainSuppliedProfileAccessGroup = True;
		EndIf;
		
		If Enable Then
			AccessGroup.Users.Add().User = User;
		Else
			Filter = New Structure("User", User);
			Rows = AccessGroup.Users.FindRows(Filter);
			For Each String In Rows Do
				AccessGroup.Users.Delete(String);
			EndDo;
		EndIf;
		
		AccessGroup.Write();
		
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
	Return True;
	
EndFunction

// For procedure WriteAccessValuesSetsOnWrite.

// Overwrites access value sets of the object being checked
// in InformationRegister.AccessValuesSets using the
// AccessManagement.FillAccessValuesSets() procedure.
//
// Procedure is called from AccessManagementInternal.WriteAccessValuesSets()
// but it can be called from anywhere, for example,
// when you enable access restrictions at the record level.
//
// Calls the applied developer procedure
// AccessManagementOverridable.OnChangeAccessValuesSets()
// used to rewrite dependent access value sets.
//
// Parameters:
//  Object       - AnyRef
//               - DefinedType.AccessValuesSetsOwnerObject -
//                 
//                 
//  IBUpdate - Boolean - if True, write data 
//                 without performing unnecessary and redundant actions with the data.
//                 See InfobaseUpdate.WriteData.
//
Procedure WriteAccessValuesSets(Val Object, HasChanges = Undefined, IBUpdate = False)
	
	SetPrivilegedMode(True);
	
	// 
	// 
	Object = ?(Object = Object.Ref, Object.GetObject(), Object);
	ObjectReference = Object.Ref;
	ValueTypeObject = TypeOf(Object);
	
	SetsRecorded = AccessManagementInternalCached.ObjectsTypesInSubscriptionsToEvents(
		"WriteAccessValuesSets").Get(ValueTypeObject) <> Undefined;
	
	If Not SetsRecorded Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Invalid parameters.
			           |Cannot find object type ""%1""
			           |in event subscriptions %2.';"),
			ValueTypeObject,
			"WriteAccessValuesSets");
		Raise ErrorText;
	EndIf;
	
	PossibleObjectsTypes = AccessManagementInternalCached.TableFieldTypes(
		"InformationRegister.AccessValuesSets.Dimension.Object");
	
	If PossibleObjectsTypes.Get(TypeOf(ObjectReference)) = Undefined Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'An error occurred when writing access value sets:
			           |The ""%3"" type is not specified in dimension ""%2""
			           |of information register ""%1"".';"),
			"AccessValuesSets",
			"Object",
			TypeOf(ObjectReference));
		Raise ErrorText;
	EndIf;
	
	If AccessManagement.LimitAccessAtRecordLevel()
	   And Not AccessManagement.ProductiveOption() Then
		
		If Metadata.FindByType(ValueTypeObject).TabularSections.Find("AccessValuesSets") = Undefined Then
			
			Table = AccessManagement.AccessValuesSetsTable();
			AccessManagement.FillAccessValuesSets(Object, Table);
			
			AccessManagement.AddAccessValuesSets(
				Table, AccessManagement.AccessValuesSetsTable(), False, True);
		Else
			TabularSectionBeingFilled = AccessManagementInternalCached.ObjectsTypesInSubscriptionsToEvents(
				"FillAccessValuesSetsForTabularSections
				|FillAccessValuesSetsForTabularSectionsDocuments_SSLy").Get(ValueTypeObject) <> Undefined;
			
			If Not TabularSectionBeingFilled Then
				ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("en = 'Invalid parameters.
					           |Cannot find object type ""%1""
					           |in event subscriptions %2.';"),
					ValueTypeObject,
					"FillAccessValuesSetsForTabularSections");
				Raise ErrorText;
			EndIf;
			// 
			Table = Object.AccessValuesSets.Unload();
		EndIf;
		
		PrepareAccessValuesSetsForWrite(ObjectReference, Table, True);
		
		Data = New Structure;
		Data.Insert("RegisterManager",   InformationRegisters.AccessValuesSets);
		Data.Insert("FixedFilter", New Structure("Object", ObjectReference));
		Data.Insert("NewRecords",        Table);
		Data.Insert("IBUpdate",       IBUpdate);
		
		BeginTransaction();
		Try
			UpdateRecordSets(Data, HasChanges);
			CommitTransaction();
		Except
			RollbackTransaction();
			Raise;
		EndTry;
		
		If HasChanges = True Then
			OnChangeAccessValuesSets(ObjectReference, IBUpdate);
		EndIf;
	Else
		Query = New Query(
		"SELECT TOP 1
		|	TRUE AS TrueValue
		|FROM
		|	InformationRegister.AccessValuesSets AS AccessValuesSets
		|WHERE
		|	AccessValuesSets.Object = &ObjectReference");
		
		Query.SetParameter("ObjectReference", ObjectReference);
		
		// 
		// 
		// 
		If Not Query.Execute().IsEmpty() Then
		// ACC:1328-on.
			
			// 
			// 
			// 
			RecordSet = InformationRegisters.AccessValuesSets.CreateRecordSet();
			RecordSet.Filter.Object.Set(ObjectReference);
			RecordSet.Write();
			HasChanges = True;
			
			// Clearing obsolete dependent sets.
			OnChangeAccessValuesSets(ObjectReference, IBUpdate);
		EndIf;
	EndIf;
	
EndProcedure

// For procedure WriteDependentAccessValuesSetsOnWrite.

// Overwrites access value sets of dependent objects.
//
//  Procedure is called from AccessManagementInternal.WriteDependentAccessValuesSets()
// The subscription type content complements (without overlapping) the WriteAccessValuesSets subscription type content
// with types that
// do not require recording sets to the AccessValuesSets information register but the sets themselves belong to other sets. Example: a set of files
// from the Files catalog might belong to several Job business processes created
// based on files. Recording the file sets to the register is not required.
//
// Calls the applied developer procedure
// AccessManagementOverridable.OnChangeAccessValuesSets()
// used for overwriting dependent value sets,
// thus creating a recursion.
//
// Parameters:
//  Object       - AnyRef
//               - DefinedType.AccessValuesSetsOwnerObject -
//                 
//                 
//
//  IBUpdate - Boolean - if True, write data 
//                 without performing unnecessary and redundant actions with the data.
//                 See InfobaseUpdate.WriteData.
//
Procedure WriteDependentAccessValuesSets(Val Object, IBUpdate = False)
	
	SetPrivilegedMode(True);
	
	// 
	// 
	Object = ?(Object = Object.Ref, Object.GetObject(), Object);
	ObjectReference = Object.Ref;
	ValueTypeObject = TypeOf(Object);
	
	IsLeadingObject = AccessManagementInternalCached.ObjectsTypesInSubscriptionsToEvents(
		"WriteDependentAccessValuesSets").Get(ValueTypeObject) <> Undefined;
	
	If Not IsLeadingObject Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Invalid parameters.
			           |Cannot find object type ""%1""
			           |in event subscription %2.';"),
			ValueTypeObject,
			"WriteDependentAccessValuesSets");
		Raise ErrorText;
	EndIf;
	
	OnChangeAccessValuesSets(ObjectReference, IBUpdate);
	
EndProcedure

// 
// 

// Checks whether shared data was changed for any data area.
Function HasChangesOfAccessRestrictionParameters()
	
	SetPrivilegedMode(True);
	
	Parameters = New Array;
	Parameters.Add("StandardSubsystems.AccessManagement.RoleRightMetadataObjects");
	Parameters.Add("StandardSubsystems.AccessManagement.RightsForObjectsRightsSettingsAvailable");
	Parameters.Add("StandardSubsystems.AccessManagement.SuppliedProfilesDescription");
	Parameters.Add("StandardSubsystems.AccessManagement.AccessGroupPredefinedProfiles");
	Parameters.Add("StandardSubsystems.AccessManagement.GroupAndAccessValueTypes");
	Parameters.Add("StandardSubsystems.AccessManagement.AccessRestrictionTextsVersion");
	
	For Each Parameter In Parameters Do
		
		LastChanges = StandardSubsystemsServer.ApplicationParameterChanges(Parameter);
		
		If LastChanges = Undefined
		 Or LastChanges.Count() > 0 Then
			
			Return True;
		EndIf;
		
	EndDo;
	
	Return False;
	
EndFunction

// For procedure UpdateUsersRoles.

// 
//
// Parameters:
//  AdditionalRoles - Map of KeyAndValue:
//    * Key     - String -
//    * Value - Boolean - Truth.
//
Procedure OnPrepareAdminAdditionalRoles(AdditionalRoles)
	Return;
EndProcedure

Function CurrentUsersProperties(UsersArray)
	
	Query = New Query;
	
	Query.SetParameter("AdministratorsAccessGroup",
		AccessManagement.AdministratorsAccessGroup());
	
	Query.SetParameter("BlankID",
		CommonClientServer.BlankUUID());
	
	If UsersArray = Undefined Then
		Query.Text =
		"SELECT
		|	Users.Ref AS User,
		|	Users.IBUserID
		|INTO UsersToCheck
		|FROM
		|	Catalog.Users AS Users
		|WHERE
		|	Users.IsInternal = FALSE
		|	AND Users.IBUserID <> &BlankID
		|
		|UNION ALL
		|
		|SELECT
		|	ExternalUsers.Ref,
		|	ExternalUsers.IBUserID
		|FROM
		|	Catalog.ExternalUsers AS ExternalUsers
		|WHERE
		|	ExternalUsers.IBUserID <> &BlankID";
		
	ElsIf TypeOf(UsersArray) = Type("Type") Then
		If Metadata.FindByType(UsersArray) = Metadata.Catalogs.ExternalUsers Then
			Query.Text =
			"SELECT
			|	ExternalUsers.Ref AS User,
			|	ExternalUsers.IBUserID
			|INTO UsersToCheck
			|FROM
			|	Catalog.ExternalUsers AS ExternalUsers
			|WHERE
			|	ExternalUsers.IBUserID <> &BlankID";
		Else
			Query.Text =
			"SELECT
			|	Users.Ref AS User,
			|	Users.IBUserID
			|INTO UsersToCheck
			|FROM
			|	Catalog.Users AS Users
			|WHERE
			|	Users.IsInternal = FALSE
			|	AND Users.IBUserID <> &BlankID";
		EndIf;
	Else
		InitialUsers = New ValueTable;
		InitialUsers.Columns.Add("User", New TypeDescription(
			"CatalogRef.Users, CatalogRef.ExternalUsers"));
		
		For Each User In UsersArray Do
			InitialUsers.Add().User = User;
		EndDo;
		
		Query.SetParameter("InitialUsers", InitialUsers);
		Query.Text =
		"SELECT DISTINCT
		|	InitialUsers.User
		|INTO InitialUsers
		|FROM
		|	&InitialUsers AS InitialUsers
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|SELECT
		|	Users.Ref AS User,
		|	Users.IBUserID
		|INTO UsersToCheck
		|FROM
		|	Catalog.Users AS Users
		|		INNER JOIN InitialUsers AS InitialUsers
		|		ON Users.Ref = InitialUsers.User
		|			AND (Users.IsInternal = FALSE)
		|			AND (Users.IBUserID <> &BlankID)
		|
		|UNION ALL
		|
		|SELECT
		|	ExternalUsers.Ref,
		|	ExternalUsers.IBUserID
		|FROM
		|	Catalog.ExternalUsers AS ExternalUsers
		|		INNER JOIN InitialUsers AS InitialUsers
		|		ON ExternalUsers.Ref = InitialUsers.User
		|			AND (ExternalUsers.IBUserID <> &BlankID)";
	EndIf;
	
	QueryText =
	"SELECT
	|	Users.Ref AS User,
	|	Users.IBUserID
	|FROM
	|	Catalog.AccessGroups.Users AS AccessGroupsUsers_SSLy
	|		INNER JOIN Catalog.Users AS Users
	|		ON (AccessGroupsUsers_SSLy.Ref = &AdministratorsAccessGroup)
	|			AND AccessGroupsUsers_SSLy.User = Users.Ref
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	UsersToCheck.User,
	|	UsersToCheck.IBUserID
	|FROM
	|	UsersToCheck AS UsersToCheck
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT DISTINCT
	|	UsersToCheck.User AS User,
	|	AccessGroupsUsers_SSLy.Ref.Profile AS Profile
	|INTO UsersProfiles
	|FROM
	|	UsersToCheck AS UsersToCheck
	|		INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|		ON UsersToCheck.User = UserGroupCompositions.User
	|			AND (UserGroupCompositions.Used)
	|			AND (&ExcludeExternalUsers)
	|		INNER JOIN Catalog.AccessGroups.Users AS AccessGroupsUsers_SSLy
	|		ON (UserGroupCompositions.UsersGroup = AccessGroupsUsers_SSLy.User)
	|			AND (NOT AccessGroupsUsers_SSLy.Ref.DeletionMark)
	|			AND (NOT AccessGroupsUsers_SSLy.Ref.Profile.DeletionMark)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT DISTINCT
	|	UsersProfiles.User,
	|	Roles.Role AS RoleRef,
	|	Roles.Role.Name AS Role
	|FROM
	|	UsersProfiles AS UsersProfiles
	|		INNER JOIN Catalog.AccessGroupProfiles.Roles AS Roles
	|		ON (Roles.Ref = UsersProfiles.Profile)
	|WHERE
	|	Roles.Role <> UNDEFINED";
	
	Query.Text = Query.Text + "
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|" + QueryText;
	
	If Constants.UseExternalUsers.Get() Then
		Query.Text = StrReplace(Query.Text, "&ExcludeExternalUsers", "TRUE");
	Else
		// @query-part-2
		Query.Text = StrReplace(Query.Text, "&ExcludeExternalUsers",
			"VALUETYPE(UsersToCheck.User) = TYPE(Catalog.Users)");
	EndIf;
	
	QueriesResults = Query.ExecuteBatch();
	LastResult = QueriesResults.Count()-1;
	Total = New Structure;
	
	Total.Insert("Administrators", New Map);
	
	For Each String In QueriesResults[LastResult-3].Unload() Do
		Total.Administrators.Insert(String.User, True);
	EndDo;
	
	Total.Insert("IBUsersIDs", QueriesResults[LastResult-2].Unload());
	Total.IBUsersIDs.Indexes.Add("User");
	
	Total.Insert("UsersRoles", QueriesResults[LastResult].Unload());
	Total.UsersRoles.Indexes.Add("User");
	
	AllUsersRoles = Total.UsersRoles.Copy(, "RoleRef");
	AllUsersRoles.GroupBy("RoleRef");
	RoleIDs = AllUsersRoles.UnloadColumn("RoleRef");
	CheckActualityofNewUserRolesInSession(RoleIDs);
	RolesMetadata = Common.MetadataObjectsByIDs(RoleIDs, False);
	
	For Each String In Total.UsersRoles Do
		RoleMetadata = RolesMetadata.Get(String.RoleRef);
		If TypeOf(RoleMetadata) = Type("MetadataObject") Then
			String.Role = RoleMetadata.Name;
		EndIf;
	EndDo;
	
	Return Total;
	
EndFunction

// For function CurrentUsersProperties.
Procedure CheckActualityofNewUserRolesInSession(RoleIDs)
	
	ParameterName = "StandardSubsystems.AccessManagement.RoleIDs";
	SessionValue = AccessManagementInternalCached.SessionRoleIds();
	
	CurrentValue = LatestRoleIds(ParameterName);
	
	If CurrentValue.HashSum = SessionValue.HashSum Then
		Return;
	EndIf;
	
	Block = New DataLock;
	LockItem = Block.Add("InformationRegister.ExtensionVersionParameters");
	LockItem.SetValue("ExtensionsVersion", Catalogs.ExtensionsVersions.EmptyRef());
	LockItem.SetValue("ParameterName", ParameterName);
	
	BeginTransaction();
	Try
		Block.Lock();
		IsAlreadyModified = False;
		CurrentValue = LatestRoleIds(ParameterName, IsAlreadyModified);
		If CurrentValue.HashSum <> SessionValue.HashSum Then
			SkipNowUpdate = False;
			If IsAlreadyModified Then
				Try
					CheckWhetherTheMetadataIsUpToDate();
				Except
					SessionIds  = SessionValue.RoleIDs;
					CurrentIDs = CurrentValue.RoleIDs;
					For Each RoleID In RoleIDs Do
						IsIncurrent = CurrentIDs.Get(RoleID) <> Undefined;
						IsInSession  = SessionIds.Get(RoleID) <> Undefined;
						If IsIncurrent <> IsInSession Then
							Raise;
						EndIf;
					EndDo;
					SkipNowUpdate = True;
				EndTry;
			EndIf;
			If Not SkipNowUpdate Then
				StandardSubsystemsServer.SetExtensionParameter(ParameterName, SessionValue, True);
			EndIf;
		EndIf;
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

// See AccessManagementInternalCached.SessionRoleIds
Function LatestRoleIds(ParameterName, IsAlreadyModified = False)
	
	Value = StandardSubsystemsServer.ExtensionParameter(ParameterName, True, IsAlreadyModified);
	If TypeOf(Value) <> Type("FixedStructure")
	 Or Not Value.Property("HashSum")
	 Or Not Value.Property("RoleIDs")
	 Or TypeOf(Value.RoleIDs) <> Type("FixedMap") Then
		
		Value = New Structure("HashSum, RoleIDs", "", New Map);
	EndIf;
	
	Return Value;
	
EndFunction

// Parameters:
//  NewUsersRoles - ValueTable
// 
// Returns:
//  ValueTable:
//   * User - CatalogRef.Users
//                  - CatalogRef.ExternalUsers
//   * RoleRef   - CatalogRef.MetadataObjectIDs
//                  - CatalogRef.ExtensionObjectIDs
//   * Role         - String - role name.
//
Function NewInvalidRoles(NewUsersRoles)
	
	Result = NewUsersRoles.Copy(
		New Array, "User, Role, RoleRef");
	
	Result.Columns.Add("IsUnfoundRole", New TypeDescription("Boolean"));
	
	Return Result;
	
EndFunction

// Parameters:
//  InvalidRoles - See NewInvalidRoles
//  RoleDetails - ValueTableRow
//  User - CatalogRef.Users
//               - CatalogRef.ExternalUsers
//
Procedure AddInvalidRole(InvalidRoles, RoleDetails, User, IsUnfoundRole)
	
	NewRow = InvalidRoles.Add();
	FillPropertyValues(NewRow, RoleDetails);
	NewRow.User = User;
	NewRow.IsUnfoundRole = IsUnfoundRole;
	
EndProcedure

// Parameters:
//  InvalidRoles - See NewInvalidRoles
//
Procedure RegisterInvalidRoles(InvalidRoles)
	
	If Not ValueIsFilled(InvalidRoles) Then
		Return;
	EndIf;
	
	InvalidRolesProfiles = ProfilesOfUsersWithRoles(InvalidRoles);
	InvalidRolesProfiles.Indexes.Add("User, RoleRef");
	Filter = New Structure("User, RoleRef");
	
	For Each InvalidRole In InvalidRoles Do
		FillPropertyValues(Filter, InvalidRole);
		Rows = InvalidRolesProfiles.FindRows(Filter);
		For Each String In Rows Do
			If InvalidRole.IsUnfoundRole Then
				RegisterNotFoundRole(InvalidRole, String.Profile);
			Else
				RegisterUnavailableRole(InvalidRole, String.Profile);
			EndIf;
		EndDo;
	EndDo;
	
EndProcedure

Procedure RegisterUnavailableRole(RoleDetails, Profile)
	
	WriteLogEvent(
		NStr("en = 'Access management.Role is unavailable to user';",
		     Common.DefaultLanguageCode()),
		EventLogLevel.Error,
		Metadata.Catalogs.AccessGroupProfiles,
		Profile,
		StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'When updating user roles ""%1"",
			           |role ""%2""
			           |%3
			           |of access group profile ""%4""
			           |%5
			           |is unavailable to the user.';"),
			String(RoleDetails.User),
			RoleDetails.Role,
			GetURL(RoleDetails.RoleRef),
			String(Profile),
			GetURL(Profile)),
		EventLogEntryTransactionMode.Transactional);
	
EndProcedure

Procedure RegisterNotFoundRole(RoleDetails, Profile)
	
	WriteLogEvent(
		NStr("en = 'Access management.Role not found in metadata';",
		     Common.DefaultLanguageCode()),
		EventLogLevel.Error,
		Metadata.Catalogs.AccessGroupProfiles,
		Profile,
		StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'When updating user roles ""%1"",
			           |role ""%2""
			           |%3
			           |of access group profile ""%4""
			           |%5
			           |does not exist in metadata.';"),
			String(RoleDetails.User),
			RoleDetails.Role,
			GetURL(RoleDetails.RoleRef),
			String(Profile),
			GetURL(Profile)),
		EventLogEntryTransactionMode.Transactional);
	
EndProcedure

Procedure UpdateIBUsersRoles(IBUsersToUpdate, ServiceUserPassword)
	
	ShouldNotifyServiceManager = Common.DataSeparationEnabled()
		And Common.SubsystemExists("StandardSubsystems.SaaSOperations.UsersSaaS");
	
	For Each KeyAndValue In IBUsersToUpdate Do
		RolesForAdding  = KeyAndValue.Value.RolesForAdding;
		RolesForDeletion    = KeyAndValue.Value.RolesForDeletion;
		IBUser     = KeyAndValue.Value.IBUser;
		UserRef = KeyAndValue.Value.UserRef;
		
		If ShouldNotifyServiceManager Then
			HadFullRights = IBUser.Roles.Contains(Metadata.Roles.FullAccess);
			HadLogonRights = Users.HasRightsToLogIn(IBUser);
		EndIf;
		
		For Each KeyAndValue In RolesForAdding Do
			IBUser.Roles.Add(Metadata.Roles[KeyAndValue.Key]);
		EndDo;
		
		For Each KeyAndValue In RolesForDeletion Do
			If TypeOf(KeyAndValue.Value) = Type("MetadataObject") Then
				Role = KeyAndValue.Value;
			Else
				Role = Metadata.Roles[KeyAndValue.Key];
			EndIf;
			IBUser.Roles.Delete(Role);
		EndDo;
		
		BeginTransaction();
		Try
			WriteUserOnRolesUpdate(UserRef,
				IBUser, HadFullRights, HadLogonRights, ServiceUserPassword);
			
			CommitTransaction();
		Except
			RollbackTransaction();
			Raise;
		EndTry;
	EndDo;
	
EndProcedure

Procedure ClearUseMainRolesForAllUsersCheckBoxForAllExtensions()
	
	Filter = New Structure("UseDefaultRolesForAllUsers", True);
	Extensions = ConfigurationExtensions.Get(Filter);
	DataSeparationEnabled = Common.DataSeparationEnabled();
	CurrentActionArea = ?(Common.SeparatedDataUsageAvailable(),
		ConfigurationExtensionScope.DataSeparation,
		ConfigurationExtensionScope.InfoBase);
	
	For Each Extension In Extensions Do
		If Not Extension.UseDefaultRolesForAllUsers
		 Or DataSeparationEnabled
		   And Extension.Scope <> CurrentActionArea Then
			Continue;
		EndIf;
		Catalogs.ExtensionsVersions.DisableSecurityWarnings(Extension);
		Catalogs.ExtensionsVersions.DisableMainRolesUsageForAllUsers(Extension);
		// 
		// 
		// 
		Try
			Extension.Write();
		Except
			// Processing is not required.
		EndTry;
		// ACC:280-
	EndDo;
	
EndProcedure

// Parameters:
//  InvalidRoles - See NewInvalidRoles
//
// Returns:
//  ValueTable:
//   * User - CatalogRef.Users
//                  - CatalogRef.ExternalUsers
//   * RoleRef   - CatalogRef.MetadataObjectIDs
//                  - CatalogRef.ExtensionObjectIDs
//   * Profile      - CatalogRef.AccessGroupProfiles
// 
Function ProfilesOfUsersWithRoles(InvalidRoles)
	
	Query = New Query;
	Query.SetParameter("InvalidRoles", InvalidRoles);
	Query.SetParameter("BlankID",
		CommonClientServer.BlankUUID());
	
	Query.Text =
	"SELECT DISTINCT
	|	InvalidRoles.User AS User,
	|	InvalidRoles.RoleRef AS RoleRef
	|INTO InvalidRoles
	|FROM
	|	&InvalidRoles AS InvalidRoles
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT DISTINCT
	|	InvalidRoles.User AS User,
	|	InvalidRoles.RoleRef AS RoleRef,
	|	Roles.Ref AS Profile
	|FROM
	|	InvalidRoles AS InvalidRoles
	|		INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|		ON (UserGroupCompositions.User = InvalidRoles.User)
	|			AND (UserGroupCompositions.Used)
	|		INNER JOIN Catalog.AccessGroups.Users AS AccessGroupsUsers_SSLy
	|		ON (AccessGroupsUsers_SSLy.User = UserGroupCompositions.UsersGroup)
	|			AND (NOT AccessGroupsUsers_SSLy.Ref.DeletionMark)
	|		INNER JOIN Catalog.AccessGroupProfiles.Roles AS Roles
	|		ON (Roles.Ref = AccessGroupsUsers_SSLy.Ref.Profile)
	|			AND (NOT Roles.Ref.DeletionMark)
	|			AND (Roles.Role = InvalidRoles.RoleRef)";
	
	Return Query.Execute().Unload();
	
EndFunction

// This method is required by UpdateIBUsersRoles procedure.
Procedure WriteUserOnRolesUpdate(UserRef, IBUser,
			HadFullRights, HadLogonRights, ServiceUserPassword)
	
	UsersInternal.WriteInfobaseUser(IBUser,
		TypeOf(UserRef) = Type("CatalogRef.ExternalUsers"),
		UserRef);
	
	If HadFullRights = Undefined Then
		Return;
	EndIf;
	
	HasFullRights = IBUser.Roles.Contains(Metadata.Roles.FullAccess);
	HasLogonRights = Users.HasRightsToLogIn(IBUser);
	
	If HasFullRights = HadFullRights
	   And HasLogonRights = HadLogonRights Then
		Return;
	EndIf;
	
	ModuleUsersInternalSaaS = Common.CommonModule("UsersInternalSaaS");
	
	If HasFullRights <> HadFullRights Then
		If ServiceUserPassword = Undefined Then
			If Common.SubsystemExists("CloudTechnology.Core") Then
				ModuleSaaSOperations = Common.CommonModule("SaaSOperations");
				SessionWithoutSeparators = ModuleSaaSOperations.SessionWithoutSeparators();
			Else
				SessionWithoutSeparators = True;
			EndIf;
			If SessionWithoutSeparators Then
				Return;
			EndIf;
			
			SimplifiedInterface = SimplifiedAccessRightsSetupInterface();
			
			If HadFullRights Then
				Template = NStr("en = 'To disable administrator access for user %1, enter the password of current service user %2.';");
			Else
				Template = NStr("en = 'To grant user %1 administrator access, enter the password of current service user %2.';");
			EndIf;
			
			If HadFullRights And SimplifiedInterface Then
				Refinement = NStr("en = 'This action can be performed only in a user card if the Administrator profile is disabled for them.';");
			ElsIf Not HadFullRights And SimplifiedInterface Then
				Refinement = NStr("en = 'This action can be performed only in a user card if the Administrator profile is enabled for them.';");
			ElsIf HadFullRights Then
				Refinement = NStr("en = 'This action can be performed only in a card of the Administrators access group or in a user card when the user is removed from the Administrators access group.';");
			Else
				Refinement = NStr("en = 'This action can be performed only in a card of the Administrators access group or in a user card when the user is added to the Administrators access group.';");
			EndIf;
			
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(Template,
				IBUser.Name, InfoBaseUsers.CurrentUser().Name);
			ErrorText = ErrorText + Chars.LF + Chars.LF + Refinement;
			
			Raise ErrorText;
		Else
			ModuleUsersInternalSaaS.WriteSaaSUser(UserRef,
				False, ServiceUserPassword);
		EndIf;
	EndIf;
	
	If HasLogonRights <> HadLogonRights Then
		ModuleUsersInternalSaaS.NotifyHasRightsToLogIn(UserRef,
			HasLogonRights);
	EndIf;
	
EndProcedure

// For procedure ChangesSelectionQueryText.

Function KeyAndValue(Structure)
	
	For Each KeyAndValue In Structure Do
		Return KeyAndValue;
	EndDo;
	
	Return "";
	
EndFunction

// For the UpdateRecordSet and UpdateNewSetRecordsByVariousNewRecords procedures.

Procedure WriteObjectOrRecordSet(Data, ObjectOrRecordSet)
	
	If Data.IBUpdate Then
		InfobaseUpdate.WriteData(ObjectOrRecordSet);
	Else
		ObjectOrRecordSet.Write();
	EndIf;
	
EndProcedure

// For the UpdateRecordSet and UpdateRecordSets procedures.

Function DimensionParametersGroupProcessed(DimensionName, RegisterDimensionValues)
	
	If DimensionName = Undefined Then
		RegisterDimensionValues = Undefined;
		
	ElsIf RegisterDimensionValues = Undefined Then
		DimensionName = Undefined;
		
	ElsIf TypeOf(RegisterDimensionValues) <> Type("Array")
	        And TypeOf(RegisterDimensionValues) <> Type("FixedArray") Then
		
		DimensionValue = RegisterDimensionValues;
		RegisterDimensionValues = New Array;
		RegisterDimensionValues.Add(DimensionValue);
		
	ElsIf RegisterDimensionValues.Count() = 0 Then
		Return False;
	EndIf;
	
	Return True;
	
EndFunction

Procedure OrderDimensionsParametersGroups(Data)
	
	If Data.SecondDimensionName = Undefined Then
		Data.SecondDimensionName       = Data.ThirdDimensionName;
		Data.SecondDimensionValues  = Data.ThirdDimensionValues;
		Data.ThirdDimensionName      = Undefined;
		Data.ThirdDimensionValues = Undefined;
	EndIf;
	
	If Data.FirstDimensionName = Undefined Then
		Data.FirstDimensionName       = Data.SecondDimensionName;
		Data.FirstDimensionValues  = Data.SecondDimensionValues;
		Data.SecondDimensionName       = Data.ThirdDimensionName;
		Data.SecondDimensionValues  = Data.ThirdDimensionValues;
		Data.ThirdDimensionName      = Undefined;
		Data.ThirdDimensionValues = Undefined;
	EndIf;
	
	If Data.SecondDimensionValues  <> Undefined
	   And Data.ThirdDimensionValues <> Undefined
	   And Data.SecondDimensionValues.Count()
	   > Data.ThirdDimensionValues.Count() Then
		
		DimensionName      = Data.SecondDimensionName;
		RegisterDimensionValues = Data.SecondDimensionValues;
		
		Data.SecondDimensionName       = Data.ThirdDimensionName;
		Data.SecondDimensionValues  = Data.ThirdDimensionValues;
		Data.ThirdDimensionName      = DimensionName;
		Data.ThirdDimensionValues = RegisterDimensionValues;
	EndIf;
	
	If Data.FirstDimensionValues <> Undefined
	   And Data.SecondDimensionValues <> Undefined
	   And Data.FirstDimensionValues.Count()
	   > Data.SecondDimensionValues.Count() Then
		
		DimensionName      = Data.FirstDimensionName;
		RegisterDimensionValues = Data.FirstDimensionValues;
		
		Data.FirstDimensionName      = Data.SecondDimensionName;
		Data.FirstDimensionValues = Data.SecondDimensionValues;
		Data.SecondDimensionName      = DimensionName;
		Data.SecondDimensionValues = RegisterDimensionValues;
	EndIf;
	
EndProcedure

Function RecordSetFields(RecordSet)
	
	ComparisonFields = "";
	Table = RecordSet.Unload(New Array);
	For Each Column In Table.Columns Do
		ComparisonFields = ComparisonFields + "," + Column.Name;
	EndDo;
	ComparisonFields = Mid(ComparisonFields, 2);
	
	Return ComparisonFields;
	
EndFunction

Procedure UpdateNewSetRecordsByAllNewRecords(Val Data, Val Filter, Val FieldList,
				Val DimensionName, Val RegisterDimensionValues, HasChanges)
	
	LockRecordSetArea(Data.RecordSet, Data.FullRegisterName);
	
	Data.RecordSet.Read();
	NewSetRecords = Data.RecordSet.Unload();
	NewSetRecords.Indexes.Add(FieldList);
	
	For Each Value In RegisterDimensionValues Do
		Filter[DimensionName] = Value;
		For Each RecordWasFound In NewSetRecords.FindRows(Filter) Do
			NewSetRecords.Delete(RecordWasFound);
		EndDo;
		For Each RecordWasFound In Data.NewRecords.FindRows(Filter) Do
			FillPropertyValues(NewSetRecords.Add(), RecordWasFound);
		EndDo;
	EndDo;
	
	CurrentData = New Structure("RecordSet, ComparisonFields,
		|IsCheckOnly, AdditionalProperties, IBUpdate");
	FillPropertyValues(CurrentData, Data);
	CurrentData.Insert("NewRecords", NewSetRecords);
	CurrentData.Insert("RecordSetRead", True);
	
	UpdateRecordSet(CurrentData, HasChanges);
	
EndProcedure

Procedure RefreshNewSetRecordsByVariousNewRecords(Val Data, Val Filter, HasChanges)
	
	// Getting a number of records to be read.
	
	If Filter.Count() = 0 Then
		CurrentNewRecords = Data.NewRecords.Copy(); // ValueTable
		CountForReading = Data.CountForReading;
	Else
		CurrentNewRecords = Data.NewRecords.Copy(Filter); // ValueTable
		
		CountByValues = Data.CountByValues; // ValueTable
		FieldName = CountByValues.Columns[0].Name;
		CountRow = Data.CountByValues.Find(Filter[FieldName], FieldName);
		CountForReading = ?(CountRow = Undefined, 0, CountRow.Count);
	EndIf;
	
	NewRecordFilter = New Structure("LineChangeType, " + Data.ComparisonFields, 1);
	CurrentNewRecords.Indexes.Add("LineChangeType, " + Data.ComparisonFields);

	RecordsKeys = CurrentNewRecords.Copy(, "LineChangeType, " + Data.ComparisonFields);
	RecordsKeys.GroupBy("LineChangeType, " + Data.ComparisonFields);
	RecordsKeys.GroupBy(Data.ComparisonFields, "LineChangeType");
	
	FilterByRecordKey = New Structure(Data.ComparisonFields);
	
	If UpdateEntireRecordSet(CountForReading, RecordsKeys) Then
		
		LockRecordSetArea(Data.RecordSet, Data.FullRegisterName);
		Data.RecordSet.Read();
		NewSetRecords = Data.RecordSet.Unload(); // ValueTable
		NewSetRecords.Indexes.Add(Data.ComparisonFields);
		
		For Each String In RecordsKeys Do
			FillPropertyValues(FilterByRecordKey, String);
			FoundRows = NewSetRecords.FindRows(FilterByRecordKey);
			If String.LineChangeType = -1 Then
				If FoundRows.Count() > 0 Then
					// 
					NewSetRecords.Delete(FoundRows[0]);
				EndIf;
			Else
				// Adding a new or updating an old row.
				If FoundRows.Count() = 0 Then
					RowToFill = NewSetRecords.Add();
				Else
					RowToFill = FoundRows[0];
				EndIf;
				FillPropertyValues(NewRecordFilter, FilterByRecordKey);
				FoundRecords = CurrentNewRecords.FindRows(NewRecordFilter);
				If FoundRecords.Count() = 1 Then
					NewRecord = FoundRecords[0];
				Else // Error in the NewRecords parameter.
					ExceptionOnRecordSearchError(Data);
				EndIf;
				FillPropertyValues(RowToFill, NewRecord);
			EndIf;
		EndDo;
		// Changing a record set to make it different from the new set records.
		If Data.RecordSet.Count() = NewSetRecords.Count() Then
			Data.RecordSet.Add();
		EndIf;
		
		CurrentData = New Structure("RecordSet, ComparisonFields,
			|IsCheckOnly, AdditionalProperties, IBUpdate");
		FillPropertyValues(CurrentData, Data);
		CurrentData.Insert("NewRecords", NewSetRecords);
		CurrentData.Insert("RecordSetRead", True);
		
		UpdateRecordSet(CurrentData, HasChanges);
	Else
		// Row-by-row update.
		SetAdditionalProperties(Data.SetForSingleRecord, Data.AdditionalProperties);
		For Each String In RecordsKeys Do
			Data.SetForSingleRecord.Clear();
			FillPropertyValues(FilterByRecordKey, String);
			For Each KeyAndValue In FilterByRecordKey Do
				SetFilter(
					Data.SetForSingleRecord.Filter[KeyAndValue.Key], KeyAndValue.Value);
			EndDo;
			LockRecordSetArea(Data.SetForSingleRecord, Data.FullRegisterName);
			If String.LineChangeType > -1 Then
				// Adding a new row or updating the existing row.
				FillPropertyValues(NewRecordFilter, FilterByRecordKey);
				FoundRecords = CurrentNewRecords.FindRows(NewRecordFilter);
				If FoundRecords.Count() = 1 Then
					NewRecord = FoundRecords[0];
				Else // Error in the NewRecords parameter.
					ExceptionOnRecordSearchError(Data);
				EndIf;
				FillPropertyValues(Data.SetForSingleRecord.Add(), NewRecord);
			EndIf;
			HasChanges = True;
			If Data.IsCheckOnly Then
				Return;
			EndIf;
			WriteObjectOrRecordSet(Data, Data.SetForSingleRecord);
		EndDo;
	EndIf;
	
EndProcedure

// For the UpdateNewSetRecordsByVariousNewRecords procedure.
Function UpdateEntireRecordSet(CountForReading, RecordsKeys)
	
	If CountForReading > 10000 Then
		Return False; // Record set is too big.
	EndIf;
	
	CountOfItemsToDelete = RecordsKeys.FindRows(
		New Structure("LineChangeType", -1)).Count();
	
	CountOfItemsToAdd = RecordsKeys.FindRows(
		New Structure("LineChangeType", 1)).Count();
	
	ForWriteCount = CountForReading - CountOfItemsToDelete
		+ CountOfItemsToAdd;
	
	If ForWriteCount > 10000 Then
		Return False; // Record set is too big.
	EndIf;
	
	ItemsToChangeCount = RecordsKeys.Count()
		- (CountOfItemsToDelete + CountOfItemsToAdd);
	
	NotChangedCount = CountForReading
		- (CountOfItemsToDelete + ItemsToChangeCount);
	
	FullyRewriteCosts =
	//                
	      CountOfItemsToDelete   * ( 0.05  +  0.1          )
	    + ItemsToChangeCount  * ( 0.05  +  0.1   +  1   )
	    + CountOfItemsToAdd * (                   1   )
	    + NotChangedCount  * ( 0.05  +  0.1   +  1   );
	
	CostsToRewriteOneRecord =
	//                
	      CountOfItemsToDelete   * (   0.5          )
	    + ItemsToChangeCount  * (   0.5  +  1.2  )
	    + CountOfItemsToAdd * (   0.5  +  1.2  );
	
	Return FullyRewriteCosts < CostsToRewriteOneRecord;
	
EndFunction

Procedure ExceptionOnRecordSearchError(Parameters)
	
	For Each ChangesRow In Parameters.NewRecords Do
		If ChangesRow.LineChangeType <>  1
		   And ChangesRow.LineChangeType <> -1 Then
			
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'Error in procedure %1
				           |of common module %2.
				           |
				           |Invalid value of parameter ""%3"":
				           |Column ""%4"" contains invalid value ""%5"".
				           |
				           |Valid values are ""1"" and ""-1"".';"),
				"UpdateRecordSets",
				"AccessManagementInternal",
				"NewRecords",
				"LineChangeType",
				String(ChangesRow.LineChangeType));
			Raise ErrorText;
		EndIf;
	EndDo;
	
	ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
		NStr("en = 'Error in procedure %1
		           |of common module %2.
		           |
		           |Cannot find a mandatory string
		           |in parameter ""%3"".';"),
		"UpdateRecordSets",
		"AccessManagementInternal",
		"NewRecords");
	
	Raise ErrorText;
	
EndProcedure

Procedure LockRecordSetArea(RecordSet, FullRegisterName = Undefined)
	
	If Not TransactionActive() Then
		Return;
	EndIf;
	
	If FullRegisterName = Undefined Then
		FullRegisterName = Metadata.FindByType(TypeOf(RecordSet)).FullName();
	EndIf;
	
	Block = New DataLock;
	LockItem = Block.Add(FullRegisterName);
	For Each FilterElement In RecordSet.Filter Do
		If FilterElement.Use Then
			LockItem.SetValue(FilterElement.DataPath, FilterElement.Value);
		EndIf;
	EndDo;
	Block.Lock();
	
EndProcedure

Procedure SetFilter(FilterElement, FilterValue)
	
	FilterElement.Value = FilterValue;
	FilterElement.Use = True;
	
EndProcedure

Function RecordByMultipleSets(Data, Filter, FieldName, ValueOfField)
	
	Query = New Query;
	Query.SetParameter("ValueOfField", ValueOfField);
	Query.Text =
	"SELECT
	|	COUNT(*) AS Count
	|FROM
	|	&CurrentTable AS CurrentTable
	|WHERE
	|	&FilterCriterion
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	COUNT(*) AS Count
	|FROM
	|	&CurrentTable AS CurrentTable
	|WHERE
	|	CurrentTable.FieldName IN(&ValueOfField)
	|	AND &FilterCriterion
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	CurrentTable.FieldName AS FieldName,
	|	COUNT(*) AS Count
	|FROM
	|	&CurrentTable AS CurrentTable
	|WHERE
	|	CurrentTable.FieldName IN(&ValueOfField)
	|	AND &FilterCriterion
	|
	|GROUP BY
	|	CurrentTable.FieldName";
	
	FilterCriterion = "TRUE";
	If Data.FixedFilter <> Undefined Then
		For Each KeyAndValue In Data.FixedFilter Do
			FilterCriterion = FilterCriterion + "
			|	AND CurrentTable." + KeyAndValue.Key + " = &" + KeyAndValue.Key; // @query-part-1
			Query.SetParameter(KeyAndValue.Key, KeyAndValue.Value);
		EndDo;
	EndIf;
	
	FilterOfItemsToAdd = New Structure;
	FilterOfItemsToAdd.Insert("LineChangeType", 1);
	FilterOfItemsToRemove = New Structure;
	FilterOfItemsToRemove.Insert("LineChangeType", -1);
	
	For Each KeyAndValue In Filter Do
		FilterCriterion = FilterCriterion + "
		|	AND CurrentTable." + KeyAndValue.Key + " = &" + KeyAndValue.Key; // @query-part-1
		Query.SetParameter(KeyAndValue.Key, KeyAndValue.Value);
		FilterOfItemsToAdd.Insert(KeyAndValue.Key, KeyAndValue.Value);
		FilterOfItemsToRemove.Insert(KeyAndValue.Key, KeyAndValue.Value);
	EndDo;
	
	Query.Text = StrReplace(Query.Text, "FieldName", FieldName);
	Query.Text = StrReplace(Query.Text, "&CurrentTable", Data.FullRegisterName);
	Query.Text = StrReplace(Query.Text, "&FilterCriterion", FilterCriterion);
	
	QueriesResults = Query.ExecuteBatch();
	
	// Total number of items without filter.
	CountOfAllItems = QueriesResults[0].Unload()[0].Count;
	Data.Insert("CountForReading", CountOfAllItems);
	
	// Number of filtered items to be updated.
	CountOfItemsToUpdate = QueriesResults[1].Unload()[0].Count;
	
	CountOfItemsToAdd = Data.NewRecords.FindRows(FilterOfItemsToAdd).Count();
	If CountOfItemsToAdd > CountOfItemsToUpdate Then
		CountOfItemsToUpdate = CountOfItemsToAdd;
	EndIf;
	
	CountOfItemsToDelete = Data.NewRecords.FindRows(FilterOfItemsToRemove).Count();
	If CountOfItemsToDelete > CountOfItemsToUpdate Then
		CountOfItemsToUpdate = CountOfItemsToDelete;
	EndIf;
	
	// Number of items to be read by filter values.
	CountByValues = QueriesResults[2].Unload();
	CountByValues.Indexes.Add(FieldName);
	Data.Insert("CountByValues", CountByValues);
	
	Return CountOfAllItems * 0.7 > CountOfItemsToUpdate;
	
EndFunction

Procedure ReadCountForReading(Data)
	
	Query = New Query;
	Query.Text =
	"SELECT
	|	COUNT(*) AS Count
	|FROM
	|	&CurrentTable AS CurrentTable
	|WHERE
	|	&FilterCriterion";
	
	FilterCriterion = "TRUE";
	If Data.FixedFilter <> Undefined Then
		For Each KeyAndValue In Data.FixedFilter Do
			FilterCriterion = FilterCriterion + "
			|	AND CurrentTable." + KeyAndValue.Key + " = &" + KeyAndValue.Key; // @query-part-1
			Query.SetParameter(KeyAndValue.Key, KeyAndValue.Value);
		EndDo;
	EndIf;
	
	Query.Text = StrReplace(Query.Text, "&CurrentTable", Data.FullRegisterName);
	Query.Text = StrReplace(Query.Text, "&FilterCriterion", FilterCriterion);
	
	Data.Insert("CountForReading", Query.Execute().Unload()[0].Count);
	
EndProcedure

Procedure SetAdditionalProperties(RecordSet, AdditionalProperties)
	
	If TypeOf(AdditionalProperties) = Type("Structure") Then
		For Each KeyAndValue In AdditionalProperties Do
			RecordSet.AdditionalProperties.Insert(KeyAndValue.Key, KeyAndValue.Value);
		EndDo;
	EndIf;
	
EndProcedure

// For procedure UpdateInformationRegister.

Function TableColumnValues(Table, ColumnName)
	
	NewTable = Table.Copy(, ColumnName);
	
	NewTable.GroupBy(ColumnName);
	
	Return NewTable.UnloadColumn(ColumnName);
	
EndFunction

// Management of AccessKinds and AccessValues tables in edit forms.

Procedure AddAuxiliaryDataAttributesToForm(Form, TablesStorageAttributeName)
	
	AttributesToBeAdded = New Array;
	AccessValuesTypesDetails = Metadata.DefinedTypes.AccessValue.Type;
	
	PathToObject = ?(ValueIsFilled(TablesStorageAttributeName), TablesStorageAttributeName + ".", "");
	
	// 
	AttributesToBeAdded.Add(New FormAttribute(
		"Used", New TypeDescription("Boolean"), PathToObject + "AccessKinds"));
	
	// 
	AttributesToBeAdded.Add(New FormAttribute(
		"CurrentAccessKind", AccessValuesTypesDetails));
	
	AttributesToBeAdded.Add(New FormAttribute(
		"CurrentTypesOfValuesToSelect", New TypeDescription("ValueList")));
	
	AttributesToBeAdded.Add(New FormAttribute(
		"CurrentTypeOfValuesToSelect", AccessValuesTypesDetails));
	
	If Not FormAttributeExists(Form, "UseExternalUsers") Then
		AttributesToBeAdded.Add(New FormAttribute(
			"UseExternalUsers", New TypeDescription("Boolean")));
	EndIf;
	
	AttributesToBeAdded.Add(New FormAttribute(
		"TablesStorageAttributeName", New TypeDescription("String")));
	
	AttributesToBeAdded.Add(New FormAttribute(
		"IsAccessGroupProfile", New TypeDescription("Boolean")));
	
	AttributesToBeAdded.Add(New FormAttribute(
		"AccessKindUsers", AccessValuesTypesDetails));
	
	AttributesToBeAdded.Add(New FormAttribute(
		"AccessKindExternalUsers", AccessValuesTypesDetails));
	
	// 
	AttributesToBeAdded.Add(New FormAttribute(
		"AllAccessKinds", New TypeDescription("ValueTable")));
	
	AttributesToBeAdded.Add(New FormAttribute(
		"Ref", AccessValuesTypesDetails, "AllAccessKinds"));
	
	AttributesToBeAdded.Add(New FormAttribute(
		"Presentation", New TypeDescription("String"), "AllAccessKinds"));
	
	AttributesToBeAdded.Add(New FormAttribute(
		"Used", New TypeDescription("Boolean"), "AllAccessKinds"));
	
	// 
	AttributesToBeAdded.Add(New FormAttribute(
		"PresentationsAllAllowed", New TypeDescription("ValueTable")));
	
	AttributesToBeAdded.Add(New FormAttribute(
		"Name", New TypeDescription("String"), "PresentationsAllAllowed"));
	
	AttributesToBeAdded.Add(New FormAttribute(
		"Presentation", New TypeDescription("String"), "PresentationsAllAllowed"));
	
	// 
	AttributesToBeAdded.Add(New FormAttribute(
		"AllTypesOfValuesToSelect", New TypeDescription("ValueTable")));
	
	AttributesToBeAdded.Add(New FormAttribute(
		"AccessKind", AccessValuesTypesDetails, "AllTypesOfValuesToSelect"));
	
	AttributesToBeAdded.Add(New FormAttribute(
		"ValuesType", AccessValuesTypesDetails, "AllTypesOfValuesToSelect"));
	
	AttributesToBeAdded.Add(New FormAttribute(
		"TypePresentation", New TypeDescription("String"), "AllTypesOfValuesToSelect"));
	
	AttributesToBeAdded.Add(New FormAttribute(
		"TableName", New TypeDescription("String"), "AllTypesOfValuesToSelect"));
	
	AttributesToBeAdded.Add(New FormAttribute(
		"HierarchyOfItems", New TypeDescription("Boolean"), "AllTypesOfValuesToSelect"));
	
	Form.ChangeAttributes(AttributesToBeAdded);
	
EndProcedure

Procedure FillTableAllAccessKindsInForm(Form)
	
	AccessKindsProperties = AccessKindsProperties();
	AllAccessKinds = Form.AllAccessKinds;
	UsedAccessKinds = UsedAccessKinds();
	
	For Each AccessKindProperties In AccessKindsProperties.Array Do
		String = AllAccessKinds.Add();
		String.Ref        = AccessKindProperties.Ref;
		String.Used  = UsedAccessKinds.Get(String.Ref) <> Undefined;
		// Make sure the presentations are unique.
		Presentation = AccessKindPresentation(AccessKindProperties);
		Filter = New Structure("Presentation", Presentation);
		While AllAccessKinds.FindRows(Filter).Count() > 0 Do
			Filter.Presentation = Filter.Presentation + " ";
		EndDo;
		String.Presentation = Filter.Presentation;
	EndDo;
	
EndProcedure

Procedure FillPresentationTableAllAllowedInForm(Form, ThisProfile)
	
	PresentationsAllAllowed = Form.PresentationsAllAllowed;
	
	If ThisProfile Then
		String = PresentationsAllAllowed.Add();
		String.Name = "AllDeniedByDefault";
		String.Presentation = NStr("en = 'All denied, configure exceptions in access groups';");
		
		String = PresentationsAllAllowed.Add();
		String.Name = "AllAllowedByDefault";
		String.Presentation = NStr("en = 'All allowed, configure exceptions in access groups';");
		
		String = PresentationsAllAllowed.Add();
		String.Name = "AllDenied";
		String.Presentation = NStr("en = 'All denied, configure exceptions in profile';");
		
		String = PresentationsAllAllowed.Add();
		String.Name = "AllAllowed";
		String.Presentation = NStr("en = 'All allowed, configure exceptions in profile';");
	Else
		String = PresentationsAllAllowed.Add();
		String.Name = "AllDenied";
		String.Presentation = NStr("en = 'All denied';");
		
		String = PresentationsAllAllowed.Add();
		String.Name = "AllAllowed";
		String.Presentation = NStr("en = 'All allowed';");
	EndIf;
	
	ChoiceList = Form.Items.AccessKindsAllAllowedPresentation.ChoiceList; // ValueList
	
	For Each String In PresentationsAllAllowed Do
		ChoiceList.Add(String.Presentation);
	EndDo;
	
EndProcedure

Procedure ApplyTableAccessKindsInForm(Form)
	
	Parameters = AllowedValuesEditFormParameters(Form);
	
	// Appearance of representation of unused access kinds.
	ConditionalAppearanceItem = Form.ConditionalAppearance.Items.Add();
	
	AppearanceColorItem = ConditionalAppearanceItem.Appearance.Items.Find("TextColor");
	AppearanceColorItem.Value = WebColors.Gray;
	AppearanceColorItem.Use = True;
	
	DataFilterItemsGroup = ConditionalAppearanceItem.Filter.Items.Add(Type("DataCompositionFilterItemGroup"));
	DataFilterItemsGroup.GroupType = DataCompositionFilterItemsGroupType.AndGroup;
	DataFilterItemsGroup.Use = True;
	
	DataFilterItem = DataFilterItemsGroup.Items.Add(Type("DataCompositionFilterItem"));
	DataFilterItem.LeftValue  = New DataCompositionField(Parameters.PathToTables + "AccessKinds.AccessKind");
	DataFilterItem.ComparisonType   = DataCompositionComparisonType.NotEqual;
	DataFilterItem.RightValue = Undefined;
	DataFilterItem.Use  = True;
	
	DataFilterItem = DataFilterItemsGroup.Items.Add(Type("DataCompositionFilterItem"));
	DataFilterItem.LeftValue  = New DataCompositionField(Parameters.PathToTables + "AccessKinds.Used");
	DataFilterItem.ComparisonType   = DataCompositionComparisonType.Equal;
	DataFilterItem.RightValue = False;
	DataFilterItem.Use  = True;
	
	AppearanceFieldItem = ConditionalAppearanceItem.Fields.Items.Add();
	AppearanceFieldItem.Field = New DataCompositionField("AccessKinds");
	AppearanceFieldItem.Use = True;
	
EndProcedure

Procedure CheckoutTableAccessValuesForm(Form)
	
	Parameters = AllowedValuesEditFormParameters(Form);
	EmptyAccessValueReferences = EmptyAccessValueReferences();
	
	// Appearance of empty access value references.
	For Each String In EmptyAccessValueReferences Do
		ConditionalAppearanceItem = Form.ConditionalAppearance.Items.Add();
		
		ElementDesignText = ConditionalAppearanceItem.Appearance.Items.Find("Text");
		ElementDesignText.Value = String.Presentation;
		ElementDesignText.Use = True;
		
		DataFilterItem = ConditionalAppearanceItem.Filter.Items.Add(Type("DataCompositionFilterItem"));
		DataFilterItem.LeftValue  = New DataCompositionField(Parameters.PathToTables + "AccessValues.AccessValue");
		DataFilterItem.ComparisonType   = DataCompositionComparisonType.Equal;
		DataFilterItem.RightValue = String.EmptyRef;
		DataFilterItem.Use  = True;
		
		AppearanceFieldItem = ConditionalAppearanceItem.Fields.Items.Add();
		AppearanceFieldItem.Field = New DataCompositionField("AccessValuesAccessValue");
		AppearanceFieldItem.Use = True;
	EndDo;
	
EndProcedure

Procedure DeleteExcessAccessValues(Form, CurrentObject = Undefined)
	
	Parameters = AllowedValuesEditFormParameters(Form, CurrentObject);
	
	AccessKindsProperties = AccessKindsProperties();
	ByGroupsAndValuesTypes = AccessKindsProperties.ByGroupsAndValuesTypes;
	
	Filter = AccessManagementInternalClientServer.FilterInAllowedValuesEditFormTables(
		Form, "");
	
	IndexOf = Parameters.AccessValues.Count()-1;
	While IndexOf >= 0 Do
		AccessValue = Parameters.AccessValues[IndexOf].AccessValue;
		
		AccessKindProperties = ByGroupsAndValuesTypes.Get(TypeOf(AccessValue)); // See AccessKindProperties
		If AccessKindProperties <> Undefined Then
			FillPropertyValues(Filter, Parameters.AccessValues[IndexOf]);
			Filter.Insert("AccessKind", AccessKindProperties.Ref);
		EndIf;
		
		If AccessKindProperties = Undefined
		 Or Parameters.AccessValues[IndexOf].AccessKind <> Filter.AccessKind
		 Or Parameters.AccessKinds.FindRows(Filter).Count() = 0 Then
			
			Parameters.AccessValues.Delete(IndexOf);
		EndIf;
		IndexOf = IndexOf - 1;
	EndDo;
	
EndProcedure

Procedure DeleteNonExistentAccessKindsAndValues(Form, CurrentObject = Undefined)
	
	Parameters = AllowedValuesEditFormParameters(Form, CurrentObject);
	
	IndexOf = Parameters.AccessKinds.Count()-1;
	While IndexOf >= 0 Do
		AccessKind = Parameters.AccessKinds[IndexOf].AccessKind;
		If AccessKindProperties(AccessKind) = Undefined Then
			Parameters.AccessKinds.Delete(IndexOf);
		EndIf;
		IndexOf = IndexOf - 1;
	EndDo;
	
	DeleteExcessAccessValues(Form, CurrentObject);
	
EndProcedure

Function AllowedValuesEditFormParameters(Form, CurrentObject = Undefined)
	
	Return AccessManagementInternalClientServer.AllowedValuesEditFormParameters(
		Form, CurrentObject);
	
EndFunction

Function FormAttributeExists(Form, AttributeName)
	
	Structure = New Structure(AttributeName, Null);
	
	FillPropertyValues(Structure, Form);
	
	Return Structure[AttributeName] <> Null;
	
EndFunction

Function EmptyAccessValueReferences() Export
	
	Table = New ValueTable;
	Table.Columns.Add("EmptyRef", Metadata.DefinedTypes.AccessValue.Type);
	Table.Columns.Add("Presentation", New TypeDescription("String",
		,,, New StringQualifiers(150, AllowedLength.Variable)));
	
	For Each Type In Metadata.DefinedTypes.AccessValue.Type.Types() Do
		Types = New Array;
		Types.Add(Type);
		TypeDetails = New TypeDescription(Types);
		NewRow = Table.Add();
		NewRow.EmptyRef = TypeDetails.AdjustValue(Undefined);
		NewRow.Presentation = "<" + StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Empty reference: ""%1""';"), String(Type)) + ">";
	EndDo;
	
	Return Table;
	
EndFunction

// For the SessionParametersSetting procedure.

Function AllAccessKindsCombinations(UnorderedNamesArray)
	
	// 
	// 
	MaxCombinationLength = 4;
	
	List = New ValueList;
	If TypeOf(UnorderedNamesArray) = Type("FixedArray") Then
		List.LoadValues(New Array(UnorderedNamesArray));
	Else
		List.LoadValues(UnorderedNamesArray);
	EndIf;
	List.SortByValue();
	NamesArray = List.UnloadValues();
	
	RowTotal = New Array;
	TotalRow = New Array;
	
	// Full list is always supported.
	For Each Name In NamesArray Do
		TotalRow.Add(Name);
	EndDo;
	
	RowTotal.Add(TotalRow);
	
	If NamesArray.Count() < 3 Then
		Return RowsGroupsInLine(RowTotal);
	EndIf;
	
	FirstName = NamesArray[0];
	NamesArray.Delete(0);
	
	LatestName = NamesArray[NamesArray.Count()-1];
	NamesArray.Delete(NamesArray.Count()-1);
	
	CountOfNamesInCombination = NamesArray.Count();
	
	If CountOfNamesInCombination > 1 Then
		
		If (CountOfNamesInCombination-1) <= MaxCombinationLength Then
			CombinationLength = CountOfNamesInCombination-1;
		Else
			CombinationLength = MaxCombinationLength;
		EndIf;
		
		NamesPositionsInCombination = New Array;
		For Counter = 1 To CombinationLength Do
			NamesPositionsInCombination.Add(Counter);
		EndDo;
		
		While CombinationLength > 0 Do
			While True Do
				// 
				TotalRow = New Array;
				TotalRow.Add(FirstName);
				For IndexOf = 0 To CombinationLength-1 Do
					TotalRow.Add(NamesArray[NamesPositionsInCombination[IndexOf]-1]);
				EndDo;
				TotalRow.Add(LatestName);
				RowTotal.Add(TotalRow);
				// 
				IndexOf = CombinationLength-1;
				While IndexOf >= 0 Do
					If NamesPositionsInCombination[IndexOf] < CountOfNamesInCombination - (CombinationLength - (IndexOf+1)) Then
						NamesPositionsInCombination[IndexOf] = NamesPositionsInCombination[IndexOf] + 1;
						// Filling senior positions with initial values.
						For SeniorPositionIndex = IndexOf+1 To CombinationLength-1 Do
							NamesPositionsInCombination[SeniorPositionIndex] =
								NamesPositionsInCombination[IndexOf] + SeniorPositionIndex - IndexOf;
						EndDo;
						Break;
					Else
						IndexOf = IndexOf - 1;
					EndIf;
				EndDo;
				If IndexOf < 0 Then
					Break;
				EndIf;
			EndDo;
			CombinationLength = CombinationLength - 1;
			For IndexOf = 0 To CombinationLength - 1 Do
				NamesPositionsInCombination[IndexOf] = IndexOf + 1;
			EndDo;
		EndDo;
	EndIf;
	
	TotalRow = New Array;
	TotalRow.Add(FirstName);
	TotalRow.Add(LatestName);
	RowTotal.Add(TotalRow);
	
	Return RowsGroupsInLine(RowTotal);
	
EndFunction

Function RowsGroupsInLine(RowsGroups)
	
	RowTotal = New Array;
	
	For Each TotalRow In RowsGroups Do
		RowTotal.Add(StrConcat(TotalRow, ","));
	EndDo;
	
	Rows = StrConcat(
		RowTotal,
		",
		|,");
	
	Template =
		"%2%1%2
		|";
	
	Return StringFunctionsClientServer.SubstituteParametersToString(Template, Rows, ",");
	
EndFunction

// For the UpdateAccessValuesSets, OnChangeAccessValuesSets procedures.

// Checks whether sets in a tabular section differ from the new sets.
Function AccessValuesSetsOfTabularSectionChanged(ObjectReference, NewSets)
	
	OldSets = Common.ObjectAttributeValue(
		ObjectReference, "AccessValuesSets").Unload();
	
	If OldSets.Count() <> NewSets.Count() Then
		Return True;
	EndIf;
	
	OldSets.Columns.Add("AccessKind", New TypeDescription("String"));
	AccessManagement.AddAccessValuesSets(
		OldSets, AccessManagement.AccessValuesSetsTable(), False, True);
	
	SearchFields = "SetNumber, AccessValue, Refinement, Read, Update";
	
	NewSets.Indexes.Add(SearchFields);
	Filter = New Structure(SearchFields);
	
	For Each String In OldSets Do
		FillPropertyValues(Filter, String);
		If NewSets.FindRows(Filter).Count() <> 1 Then
			Return True;
		EndIf;
	EndDo;
	
	Return False;
	
EndFunction

// This method is required by AllowedDynamicListValues.
Procedure AddQueryToPackage(PackageText, QueryText)
	
	Separator =
	"
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|";
	
	PackageText = PackageText + Separator + QueryText;
	
EndProcedure

// This method is required by AllowedDynamicListValues.
Procedure UnionQueryWithQuery(QueryText, QueryTextToAdd)
	
	Combiner =
	"
	|
	|UNION ALL
	|
	|"; // @query-part-1
	
	QueryText = QueryText + Combiner + QueryTextToAdd;
	
EndProcedure

// Updating access kind properties.

// For functions 
// 
//
// Returns:
//   ValueTable:
//     * Name - String
//     * Presentation - String
//     * ValuesType - Type
//     * ValuesGroupsType - Type
//     * MultipleValuesGroups - Boolean
//     * AdditionalTypes - See NewAdditionalAccessKindTypesTable
// 
Function FilledSessionAccessTypes()
	
	// 1. Populate the data specified during integration.
	
	AccessKinds = New ValueTable;
	AccessKinds.Columns.Add("Name",                    New TypeDescription("String"));
	AccessKinds.Columns.Add("Presentation",          New TypeDescription("String"));
	AccessKinds.Columns.Add("ValuesType",            New TypeDescription("Type"));
	AccessKinds.Columns.Add("ValuesGroupsType",       New TypeDescription("Type"));
	AccessKinds.Columns.Add("MultipleValuesGroups", New TypeDescription("Boolean"));
	AccessKinds.Columns.Add("AdditionalTypes",     New TypeDescription("ValueTable"));
	
	SSLSubsystemsIntegration.OnFillAccessKinds(AccessKinds);
	AccessManagementOverridable.OnFillAccessKinds(AccessKinds);
	
	Return AccessKinds;
	
EndFunction

// For the FilledAccessKinds function and
// the AddExtraAccessKindTypes procedure of the AccessManagement common module.
//
// Returns:
//  ValueTable:
//    * ValuesType - Type
//    * ValuesGroupsType - Type
//    * MultipleValuesGroups - Boolean
//
Function NewAdditionalAccessKindTypesTable() Export
	
	AdditionalTypes = New ValueTable;
	AdditionalTypes.Columns.Add("ValuesType",            New TypeDescription("Type"));
	AdditionalTypes.Columns.Add("ValuesGroupsType",       New TypeDescription("Type"));
	AdditionalTypes.Columns.Add("MultipleValuesGroups", New TypeDescription("Boolean"));
	
	Return AdditionalTypes;
	
EndFunction

// For procedures OnFillAllExtensionParameters an
// UpdateAuxiliaryRegisterDataByConfigurationChanges.
//
Procedure UpdateGroupsAndSetsOfAccessValuesWhenGroupTypesAndValuesChange()
	
	Cache = AccessManagementInternalCached.DescriptionPropertiesAccessTypesSession();
	NewValue = Cache.HashAmounts;
	
	ParameterName = "StandardSubsystems.AccessManagement.GroupAndAccessValueTypes";
	PreviousValue2 = StandardSubsystemsServer.ExtensionParameter(ParameterName, True);
	PreviousValue2 = NewHashSumAccessTypeProperties(PreviousValue2);
	
	If PreviousValue2.HashSumGroupTypesFromAccessValues
	    = NewValue.HashSumGroupTypesFromAccessValues Then
		Return;
	EndIf;
	
	Block = New DataLock;
	LockItem = Block.Add("InformationRegister.ExtensionVersionParameters");
	LockItem.SetValue("ExtensionsVersion", Catalogs.ExtensionsVersions.EmptyRef());
	LockItem.SetValue("ParameterName", ParameterName);
	
	BeginTransaction();
	Try
		Block.Lock();
		IsAlreadyModified = False;
		PreviousValue2 = StandardSubsystemsServer.ExtensionParameter(ParameterName, True, IsAlreadyModified);
		PreviousValue2 = NewHashSumAccessTypeProperties(PreviousValue2);
		If PreviousValue2.HashSumGroupTypesFromAccessValues
		    <> NewValue.HashSumGroupTypesFromAccessValues Then
			If IsAlreadyModified Then
				CheckWhetherTheMetadataIsUpToDate();
			EndIf;
			InformationRegisters.AccessValuesGroups.UpdateAuxiliaryRegisterDataByConfigurationChanges1();
			InformationRegisters.AccessValuesSets.UpdateAuxiliaryRegisterDataByConfigurationChanges1();
			StandardSubsystemsServer.SetExtensionParameter(ParameterName, NewValue, True);
		EndIf;
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

// 
// 
//
// Returns:
//   FixedStructure:
//     * Array - FixedArray of See AccessKindProperties
//     * ByNames - FixedMap of KeyAndValue:
//         ** Key - String
//         ** Value - See AccessKindProperties
//     * ByRefs - FixedMap of KeyAndValue:
//         ** Key - CatalogRef
//         ** Value - See AccessKindProperties
//     * ByValuesTypes - FixedMap of KeyAndValue:
//         ** Key - Type
//         ** Value - See AccessKindProperties
//     * ByGroupsAndValuesTypes - FixedMap of KeyAndValue:
//         ** Key - Type
//         ** Value - See AccessKindProperties
//     * ByValuesTypesWithHierarchy - FixedMap of KeyAndValue:
//         ** Key - Type
//         ** Value - See AccessKindProperties
//     * AccessValuesWithGroups - FixedMap of KeyAndValue:
//         ** Key - Type
//         ** Value - See AccessValuesWithGroups
//     * NoGroupsForAccessValue - FixedArray of String
//     * WithOneGroupForAccessValue - FixedArray of String
//     * AccessValuesTypesWithGroups - FixedMap of KeyAndValue:
//         ** Key - Type
//         ** Value - CatalogRef
//
Function AccessKindsProperties() Export
	
	Cache = AccessManagementInternalCached.DescriptionPropertiesAccessTypesSession();
	
	CurrentSessionDate = CurrentSessionDate();
	If Cache.Validation.Date + 3 > CurrentSessionDate Then
		Return Cache.SessionProperties;
	EndIf;
	
	NewValue = Cache.HashAmounts;
	
	ParameterName = "StandardSubsystems.AccessManagement.AccessKindsProperties";
	PreviousValue2 = StandardSubsystemsServer.ExtensionParameter(ParameterName, True);

	PreviousValue2 = NewHashSumAccessTypeProperties(PreviousValue2);
	
	If PreviousValue2.HashSum <> NewValue.HashSum Then
		Block = New DataLock;
		LockItem = Block.Add("InformationRegister.ExtensionVersionParameters");
		LockItem.SetValue("ExtensionsVersion", Catalogs.ExtensionsVersions.EmptyRef());
		LockItem.SetValue("ParameterName", ParameterName);
		BeginTransaction();
		Try
			Block.Lock();
			IsAlreadyModified = False;
			PreviousValue2 = StandardSubsystemsServer.ExtensionParameter(ParameterName, True, IsAlreadyModified);
			PreviousValue2 = NewHashSumAccessTypeProperties(PreviousValue2);
			If PreviousValue2.HashSum <> NewValue.HashSum Then
				If IsAlreadyModified Then
					CheckWhetherTheMetadataIsUpToDate();
				EndIf;
				SetSafeModeDisabled(True);
				SetPrivilegedMode(True);
				StandardSubsystemsServer.SetExtensionParameter(ParameterName, NewValue, True);
				SetPrivilegedMode(False);
				SetSafeModeDisabled(False);
			EndIf;
			CommitTransaction();
		Except
			RollbackTransaction();
			Raise;
		EndTry;
	EndIf;
	
	Cache.Validation.Date = CurrentSessionDate;
	
	Return Cache.SessionProperties;
	
EndFunction

// 
// 
// 
//
// 
//
// Returns:
//   See AccessKindsProperties
//
Function CheckedSessionAccessViewProperties() Export
	
	AccessKinds = FilledSessionAccessTypes();
	
	// 
	// 
	// 
	// 
	// 
	// 
	// 
	
	// 
	PropertiesArray         = New Array; // Array of See AccessKindProperties
	ByRefs             = New Map;
	ByNames              = New Map;
	ByValuesTypes       = New Map;
	ByGroupsAndValuesTypes = New Map;
	
	AccessValuesWithGroups = AccessValuesWithGroups();
	
	Parameters = New Structure;
	Parameters.Insert("DefinedAccessValuesTypes",
		AccessManagementInternalCached.TableFieldTypes("DefinedType.AccessValue"));
	
	ErrorTitle = StringFunctionsClientServer.SubstituteParametersToString(
		NStr("en = 'Error in procedure %1 of common module %2.';"),
		"OnFillAccessKinds", "AccessManagementOverridable")
		+ Chars.LF
		+ Chars.LF;
	
	Parameters.Insert("ErrorTitle", ErrorTitle);
	
	AllAccessKindsNames = New Map;
	AllAccessKindsNames.Insert(Upper("Object"),         True);
	AllAccessKindsNames.Insert(Upper("Condition"),        True);
	AllAccessKindsNames.Insert(Upper("RightsSettings"),  True);
	AllAccessKindsNames.Insert(Upper("ReadRight1"),    True);
	AllAccessKindsNames.Insert(Upper("EditRight"), True);
	
	AllValuesTypes      = New Map;
	AllValuesGroupsTypes = New Map;
	
	For Each AccessKind In AccessKinds Do
		If AllAccessKindsNames[Upper(AccessKind.Name)] <> Undefined Then
			ErrorText = ErrorTitle + StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'The access kind name ""%1"" is already defined.';"),
				AccessKind.Name);
			Raise ErrorText;
		EndIf;
		
		// Checking for duplicate value types and group types.
		ValidateType(AccessKind, AccessKind.ValuesType,      AllValuesTypes,      Parameters);
		ValidateType(AccessKind, AccessKind.ValuesGroupsType, AllValuesGroupsTypes, Parameters, True);
		// Checking for intersection of value types and group types.
		ValidateType(AccessKind, AccessKind.ValuesType,      AllValuesGroupsTypes, Parameters,       , True);
		ValidateType(AccessKind, AccessKind.ValuesGroupsType, AllValuesTypes,      Parameters, True, True);
		
		AdditionalTypes = AccessKind.AdditionalTypes; // See NewAdditionalAccessKindTypesTable
		
		For Each String In AdditionalTypes Do
			// Checking for duplicate value types and group types.
			ValidateType(AccessKind, String.ValuesType,      AllValuesTypes,      Parameters);
			ValidateType(AccessKind, String.ValuesGroupsType, AllValuesGroupsTypes, Parameters, True);
			// Checking for intersection of value types and group types.
			ValidateType(AccessKind, String.ValuesType,      AllValuesGroupsTypes, Parameters,       , True);
			ValidateType(AccessKind, String.ValuesGroupsType, AllValuesTypes,      Parameters, True, True);
		EndDo;
		
		ValueTypeBlankRef = Common.ObjectManagerByFullName(
			Metadata.FindByType(AccessKind.ValuesType).FullName()).EmptyRef();
		
		Properties = NewAccessKindProperties(AccessKind, ValueTypeBlankRef);
		PropertiesArray.Add(Properties);
		ByNames.Insert(Properties.Name, Properties);
		ByRefs.Insert(ValueTypeBlankRef, Properties);
		ByValuesTypes.Insert(Properties.ValuesType, Properties);
		ByGroupsAndValuesTypes.Insert(Properties.ValuesType, Properties);
		If Properties.ValuesGroupsType <> Type("Undefined") Then
			ByGroupsAndValuesTypes.Insert(Properties.ValuesGroupsType, Properties);
		EndIf;
		FillAccessValuesWithGroups(Properties, AccessValuesWithGroups, Properties, Parameters);
		
		For Each String In AccessKind.AdditionalTypes Do
			Properties.AdditionalTypes.Add(AdditionalAccessKindType(String));
			ByValuesTypes.Insert(String.ValuesType, Properties);
			ByGroupsAndValuesTypes.Insert(String.ValuesType, Properties);
			If String.ValuesGroupsType <> Type("Undefined") Then
				ByGroupsAndValuesTypes.Insert(String.ValuesGroupsType, Properties);
			EndIf;
			FillAccessValuesWithGroups(String, AccessValuesWithGroups, Properties, Parameters);
		EndDo;
		
	EndDo;
	
	NoGroupsForAccessValue      = New Array;
	WithOneGroupForAccessValue = New Array;
	AccessValuesTypesWithGroups    = New Map;
	
	AccessKindsWithGroups = New Map;
	
	For Each KeyAndValue In AccessValuesWithGroups.ByRefsTypes Do
		AccessKind = KeyAndValue.Value; // See AccessKindProperties
		AccessKindName = AccessKind.Name;
		AccessKindsWithGroups.Insert(AccessKindName, True);
		
		EmptyRef = MetadataObjectEmptyRef(KeyAndValue.Key);
		AccessValuesTypesWithGroups.Insert(TypeOf(EmptyRef), EmptyRef);
		
		If Not KeyAndValue.Value.MultipleValuesGroups
		   And WithOneGroupForAccessValue.Find(AccessKindName) = Undefined Then
		   
			WithOneGroupForAccessValue.Add(AccessKindName);
		EndIf;
	EndDo;
	
	AccessValuesTypesWithGroups.Insert(Type("CatalogRef.Users"),
		Catalogs.Users.EmptyRef());
	
	AccessValuesTypesWithGroups.Insert(Type("CatalogRef.UserGroups"),
		Catalogs.UserGroups.EmptyRef());
	
	AccessValuesTypesWithGroups.Insert(Type("CatalogRef.ExternalUsers"),
		Catalogs.ExternalUsers.EmptyRef());
	
	AccessValuesTypesWithGroups.Insert(Type("CatalogRef.ExternalUsersGroups"),
		Catalogs.ExternalUsersGroups.EmptyRef());
		
	ByValuesTypesWithHierarchy = New Map;
	For Each KeyAndValue In ByValuesTypes Do
		TypeRef = KeyAndValue.Key;
		If AccessValuesTypesWithGroups[TypeRef] <> Undefined Then
			Continue;
		EndIf;
		
		MetadataObject = Metadata.FindByType(TypeRef);
		If MetadataObject <> Undefined 
			And (Common.IsCatalog(MetadataObject) Or Common.IsChartOfCharacteristicTypes(MetadataObject))
			And MetadataObject.Hierarchical Then
			
			TypeObject = StandardSubsystemsServer.MetadataObjectOrMetadataObjectRecordSetType(MetadataObject);
			ByValuesTypesWithHierarchy.Insert(TypeRef, KeyAndValue.Value);
			ByValuesTypesWithHierarchy.Insert(TypeObject, KeyAndValue.Value);
		EndIf;
	EndDo;
	
	For Each AccessKindProperties In PropertiesArray Do
		If AccessKindsWithGroups.Get(AccessKindProperties.Name) <> Undefined Then
			Continue;
		EndIf;
		If AccessKindProperties.Name = "Users"
		 Or AccessKindProperties.Name = "ExternalUsers" Then
			Continue;
		EndIf;
		NoGroupsForAccessValue.Add(AccessKindProperties.Name);
	EndDo;
	
	AccessKindsProperties = New Structure;
	AccessKindsProperties.Insert("Array",                          PropertiesArray);
	AccessKindsProperties.Insert("ByNames",                        ByNames);
	AccessKindsProperties.Insert("ByRefs",                       ByRefs);
	AccessKindsProperties.Insert("ByValuesTypes",                 ByValuesTypes);
	AccessKindsProperties.Insert("ByValuesTypesWithHierarchy",       ByValuesTypesWithHierarchy);
	AccessKindsProperties.Insert("ByGroupsAndValuesTypes",           ByGroupsAndValuesTypes);
	AccessKindsProperties.Insert("AccessValuesWithGroups",        AccessValuesWithGroups);
	AccessKindsProperties.Insert("NoGroupsForAccessValue",      NoGroupsForAccessValue);
	AccessKindsProperties.Insert("WithOneGroupForAccessValue", WithOneGroupForAccessValue);
	AccessKindsProperties.Insert("AccessValuesTypesWithGroups",    AccessValuesTypesWithGroups);
	
	CheckSubscriptionTypesUpdateAccessValuesGroups(AccessValuesWithGroups);
	
	Return Common.FixedData(AccessKindsProperties);
	
EndFunction

// For the AccessKindsProperties function.
//
// Returns:
//   See AccessKindProperties
// 
Function NewAccessKindProperties(AccessKind, ValueTypeBlankRef)
	
	Properties = New Structure;
	Properties.Insert("Name",                      AccessKind.Name);
	Properties.Insert("Ref",                   ValueTypeBlankRef);
	Properties.Insert("ValuesType",              AccessKind.ValuesType);
	Properties.Insert("ValuesGroupsType",         AccessKind.ValuesGroupsType);
	Properties.Insert("MultipleValuesGroups",   AccessKind.MultipleValuesGroups);
	Properties.Insert("AdditionalTypes",       New Array);
	Properties.Insert("TypesOfValuesToSelect",   New Array);
	
	Return Properties;
	
EndFunction

// For the AccessKindsProperties function.
//
// Returns:
//   Structure:
//     * ByTypes - Map of KeyAndValue:
//         ** Key - Type
//         ** Value - See AccessKindProperties
//     * ByRefsTypes - Map of KeyAndValue:
//         ** Key - Type
//         ** Value - See AccessKindProperties
//     * NamesOfTablesToUpdate - Array of String
//     * ValueGroupTypesForUpdate - Map of KeyAndValue:
//         ** Key - Type
//         ** Value - CatalogRef
//     * ByRefTypesForUpdate - Map of KeyAndValue:
//         ** Key - Type
//         ** Value - See AccessKindProperties
// 
Function AccessValuesWithGroups()
	
	AccessValuesWithGroups = New Structure;
	AccessValuesWithGroups.Insert("ByTypes",                        New Map);
	AccessValuesWithGroups.Insert("ByRefsTypes",                  New Map);
	AccessValuesWithGroups.Insert("NamesOfTablesToUpdate",       New Array);
	AccessValuesWithGroups.Insert("ValueGroupTypesForUpdate", New Map);
	AccessValuesWithGroups.Insert("ByTypesForUpdate",           New Map);
	AccessValuesWithGroups.Insert("ByRefTypesForUpdate",     New Map);
	
	Return AccessValuesWithGroups;
	
EndFunction

// For the AccessKindsProperties function.
//
// Returns:
//   Structure:
//     * ValuesType - Type
//     * ValuesGroupsType - Type
//     * MultipleValuesGroups - Boolean
//
Function AdditionalAccessKindType(String)
	
	Item = New Structure;
	Item.Insert("ValuesType",            String.ValuesType);
	Item.Insert("ValuesGroupsType",       String.ValuesGroupsType);
	Item.Insert("MultipleValuesGroups", String.MultipleValuesGroups);
	
	Return Item;
	
EndFunction

// For the AccessKindsProperties function.
Procedure FillAccessValuesWithGroups(String, AccessValuesWithGroups, Properties, Parameters)
	
	If Properties.Name = "Users" Then
		AddToArray(Properties.TypesOfValuesToSelect, Type("CatalogRef.Users"));
		AddToArray(Properties.TypesOfValuesToSelect, Type("CatalogRef.UserGroups"));
		Return;
	EndIf;
	
	If Properties.Name = "ExternalUsers" Then
		AddToArray(Properties.TypesOfValuesToSelect, Type("CatalogRef.ExternalUsers"));
		AddToArray(Properties.TypesOfValuesToSelect, Type("CatalogRef.ExternalUsersGroups"));
		Return;
	EndIf;
	
	RefType = String.ValuesType;
	
	ValuesTypeMetadata = Metadata.FindByType(String.ValuesType);
	If Common.IsEnum(ValuesTypeMetadata) Then
		ObjectType = RefType;
	Else
		ObjectType = StandardSubsystemsServer.MetadataObjectOrMetadataObjectRecordSetType(
			ValuesTypeMetadata);
	EndIf;
	
	If String.ValuesGroupsType = Type("Undefined") Then
		AddSubscriptionTypesUpdateAccessValuesGroups(RefType,
			ObjectType, ValuesTypeMetadata, AccessValuesWithGroups, Properties, Undefined);
		AddToArray(Properties.TypesOfValuesToSelect, String.ValuesType);
		Return;
	EndIf;
	
	If String.ValuesGroupsType <> Type("Undefined") Then
		AddToArray(Properties.TypesOfValuesToSelect, String.ValuesGroupsType);
	EndIf;
	
	AccessValuesWithGroups.ByTypes.Insert(RefType,  Properties);
	AccessValuesWithGroups.ByTypes.Insert(ObjectType, Properties);
	AccessValuesWithGroups.ByRefsTypes.Insert(RefType, Properties);
	
	MetadataOfValuesGroupsType = Metadata.FindByType(String.ValuesGroupsType);
	
	AddSubscriptionTypesUpdateAccessValuesGroups(RefType,
		ObjectType, ValuesTypeMetadata, AccessValuesWithGroups, Properties, MetadataOfValuesGroupsType);
	
EndProcedure

// For the AccessKindsProperties function and the FillAccessValuesWithGroups procedure.
Procedure AddSubscriptionTypesUpdateAccessValuesGroups(RefType, ObjectType,
			ValuesTypeMetadata, AccessValuesWithGroups, Properties, MetadataOfValuesGroupsType)
	
	ValueTypeBlankRef = PredefinedValue(ValuesTypeMetadata.FullName() + ".EmptyRef");
	
	If MetadataOfValuesGroupsType = Undefined Then
		BlankValuesGroupsTypeRef = ValueTypeBlankRef;
	Else
		BlankValuesGroupsTypeRef = MetadataObjectEmptyRef(MetadataOfValuesGroupsType);
	EndIf;
	
	AccessValuesWithGroups.NamesOfTablesToUpdate.Add(ValuesTypeMetadata.FullName());
	
	AccessValuesWithGroups.ValueGroupTypesForUpdate.Insert(RefType,
		BlankValuesGroupsTypeRef);
	
	AccessValuesWithGroups.ValueGroupTypesForUpdate.Insert(ValueTypeBlankRef,
		BlankValuesGroupsTypeRef);
	
	AccessValuesWithGroups.ByRefTypesForUpdate.Insert(RefType, Properties);
	AccessValuesWithGroups.ByTypesForUpdate.Insert(RefType, Properties);
	AccessValuesWithGroups.ByTypesForUpdate.Insert(ObjectType, Properties);
	
EndProcedure

// For the AccessKindsProperties function.
Procedure CheckSubscriptionTypesUpdateAccessValuesGroups(AccessValuesWithGroups)
	
	CurrentSubscriptionTypes = AccessManagementInternalCached.TableFieldTypes(
		"DefinedType.AccessValueObject");
	
	RequiredSubscriptionTypes = New Map;
	For Each KeyAndValue In AccessValuesWithGroups.ByTypesForUpdate Do
		If AccessValuesWithGroups.ByRefTypesForUpdate.Get(KeyAndValue.Key) <> Undefined Then
			Continue;
		EndIf;
		RequiredSubscriptionTypes.Insert(KeyAndValue.Key, True);
	EndDo;
	
	MissingTypes = New Array;
	
	For Each KeyAndValue In RequiredSubscriptionTypes Do
		If CurrentSubscriptionTypes.Get(KeyAndValue.Key) = Undefined Then
			MissingTypes.Add(KeyAndValue.Key);
		EndIf;
	EndDo;
	
	If MissingTypes.Count() = 0 Then
		Return;
	EndIf;
	
	ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
		NStr("en = 'According to data retrieved from procedure ""%1""
		           |of common module ""%2"",
		           |type collection ""%3"" is missing mandatory types:
		           |- %4';"),
		"OnFillAccessKinds",
		"AccessManagementOverridable",
		"AccessValueObject",
		StrConcat(MissingTypes, "," + Chars.LF + "- "));
	
	Raise ErrorText;
	
EndProcedure

// For the AccessKindsProperties function.
Procedure ValidateType(AccessKind, Type, AllTypes, Parameters, CheckGroupsTypes = False, IntersectionCheck = False)
	
	If Type = Type("Undefined") Then
		If CheckGroupsTypes Then
			Return;
		EndIf;
		ErrorText = Parameters.ErrorTitle + StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'The Access Value type is not specified for the ""%1"" access kind.';"),
			AccessKind.Name);
		Raise ErrorText;
	EndIf;
	
	// Checking whether a reference type is specified.
	If Not Common.IsReference(Type) Then
		If CheckGroupsTypes Then
			ErrorDescription =
				NStr("en = 'The ""%1"" type is specified as a value group type for the ""%2"" access kind.
				           |However, it is not a reference type.';");
		Else
			ErrorDescription =
				NStr("en = 'The ""%1"" type is specified as a value type for the ""%2"" access kind.
				           |However, it is not a reference type.';");
		EndIf;
		ErrorText = Parameters.ErrorTitle + StringFunctionsClientServer.SubstituteParametersToString(
			ErrorDescription, Type, AccessKind.Name);
		Raise ErrorText;
	EndIf;
	
	// Checking for duplication and intersection of value types and value groups.
	ForSameAccessKindNoError = False;
	
	If CheckGroupsTypes Then
		If IntersectionCheck Then
			ErrorDescription =
				NStr("en = 'The ""%1"" type is specified as a value type for the ""%2"" access kind.
				           |It cannot be specified as a value group type for the ""%3"" access kind.';");
		Else
			ForSameAccessKindNoError = True;
			ErrorDescription =
				NStr("en = 'The ""%1"" value group type is already specified for the ""%2"" access kind.
				           |It cannot be specified for the ""%3"" access kind.';");
		EndIf;
	Else
		If IntersectionCheck Then
			ErrorDescription =
				NStr("en = 'The ""%1"" type is specified as a value group type for the ""%2"" access kind.
				           |It cannot be specified as a value type for the ""%3"" access kind.';");
		Else
			ErrorDescription =
				NStr("en = 'The ""%1"" value type is already specified for the ""%2"" access kind.
				           |It cannot be specified for the ""%3"" access kind.';");
		EndIf;
	EndIf;
	
	If AllTypes.Get(Type) <> Undefined Then
		If Not (ForSameAccessKindNoError And AccessKind.Name = AllTypes.Get(Type)) Then
			ErrorText = Parameters.ErrorTitle + StringFunctionsClientServer.SubstituteParametersToString(
				ErrorDescription, Type, AllTypes.Get(Type), AccessKind.Name);
			Raise ErrorText;
		EndIf;
	ElsIf Not IntersectionCheck Then
		AllTypes.Insert(Type, AccessKind.Name);
	EndIf;
	
	// 
	ErrorDescription = "";
	If Parameters.DefinedAccessValuesTypes.Get(Type) = Undefined Then
		If CheckGroupsTypes Then
			ErrorDescription =
				NStr("en = 'The ""%1"" access value group type of the ""%2"" access kind
				           |is not specified in the ""%3"" type collection.';");
		Else
			ErrorDescription =
				NStr("en = 'The ""%1"" access value type of the ""%2"" access kind
				           |is not specified in the ""%3"" type collection.';");
		EndIf;
	EndIf;
	
	If ValueIsFilled(ErrorDescription) Then
		ErrorText = Parameters.ErrorTitle + StringFunctionsClientServer.SubstituteParametersToString(
			ErrorDescription, Type, AccessKind.Name, "AccessValue");
		Raise ErrorText;
	EndIf;
	
EndProcedure

// Returns:
//  FixedMap of KeyAndValue:
//    * Key - Type
//    * Value - String
//
Function AccessKindsPresentation() Export
	
	AccessKinds = FilledSessionAccessTypes();
	
	AccessKindsPresentation = New Map;
	
	For Each AccessKind In AccessKinds Do
		AccessKindsPresentation.Insert(AccessKind.ValuesType, AccessKind.Presentation);
	EndDo;
	
	Return New FixedMap(AccessKindsPresentation);
	
EndFunction

Function AccessKindPresentation(AccessKindProperties) Export
	
	AccessKindsPresentation = AccessManagementInternalCached.AccessKindsPresentation();
	
	Presentation = AccessKindsPresentation.Get(AccessKindProperties.ValuesType);
	
	If Not ValueIsFilled(Presentation) Then
		Presentation = AccessKindProperties.Name;
	EndIf;
	
	Return Presentation;
	
EndFunction

// For the FillAccessValuesWithGroups procedure.
Procedure AddToArray(Array, Value)
	
	If Array.Find(Value) = Undefined Then
		Array.Add(Value);
	EndIf;
	
EndProcedure

// 
// 
// 
//
// Returns:
//   See HashSumAccessTypeProperties
//
Function NewHashSumAccessTypeProperties(Value = Undefined)
	
	Result = New Structure;
	Result.Insert("HashSum", "");
	Result.Insert("HashSumGroupTypesFromAccessValues", "");
	
	If TypeOf(Value) = Type("FixedStructure") Then
		FillPropertyValues(Result, Value);
	EndIf;
	
	Return Result;
	
EndFunction

// 
//
// Parameters:
//  AccessKindsProperties - See AccessKindsProperties
//
// Returns:
//  Structure:
//   * HashSum - String
//   * HashSumGroupTypesFromAccessValues - String
//
Function HashSumAccessTypeProperties(AccessKindsProperties) Export
	
	Result = NewHashSumAccessTypeProperties();
	Result.HashSum = HashAmountsData(AccessKindsProperties);
	Result.HashSumGroupTypesFromAccessValues =
		HashSumGroupTypesFromAccessValues(AccessKindsProperties);
	
	Return New FixedStructure(Result);
	
EndFunction

// For procedure AddAccessValuesSets.
Function HashSumGroupTypesFromAccessValues(AccessKindsProperties)
	
	Data = New Array;
	Data.Add(TypeDescriptionFromMatchKeys(AccessKindsProperties.ByValuesTypes));
	Data.Add(TypeDescriptionFromMatchKeys(AccessKindsProperties.AccessValuesTypesWithGroups));
	
	NamesOfTablesToUpdate = New ValueList;
	NamesOfTablesToUpdate.LoadValues(New Array(
		AccessKindsProperties.AccessValuesWithGroups.NamesOfTablesToUpdate));
	NamesOfTablesToUpdate.SortByValue();
	
	Data.Add(NamesOfTablesToUpdate.UnloadValues());
	
	Data.Add(Metadata.DefinedTypes.AccessValuesSetsOwnerObject.Type);
	
	Return HashAmountsData(Data);
	
EndFunction

// 
Function TypeDescriptionFromMatchKeys(Data)
	
	Types = New Array;
	For Each KeyAndValue In Data Do
		Types.Add(KeyAndValue.Key);
	EndDo;
	
	Return New TypeDescription(Types);
	
EndFunction

Function HashAmountsData(Data) Export
	
	HashString = DataStringForHashing(Data);
	 
	Hashing = New DataHashing(HashFunction.SHA256);
	Hashing.Append(HashString);
	HashSum = Hashing.HashSum;
	StringHashSum = Base64String(HashSum);
	
	Return StringHashSum;
	
EndFunction

Function AccessGroupsUsingAccessValuesHierarchy(AccessKindValueType)
	
	SetPrivilegedMode(True);
	
	QueryText =
	"SELECT
	|	AccessGroups.Ref AS Ref,
	|	AccessGroups.Profile AS Profile
	|INTO AccessGroups
	|FROM
	|	Catalog.AccessGroups AS AccessGroups
	|		INNER JOIN Catalog.AccessGroupProfiles AS AccessGroupProfiles
	|		ON AccessGroups.Profile = AccessGroupProfiles.Ref
	|			AND (AccessGroups.Profile <> &ProfileAdministrator)
	|			AND (NOT AccessGroups.DeletionMark)
	|			AND (NOT AccessGroupProfiles.DeletionMark)
	|			AND (TRUE IN
	|				(SELECT TOP 1
	|					TRUE AS TrueValue
	|				FROM
	|					Catalog.AccessGroups.Users AS AccessGroupsMembers
	|				WHERE
	|					AccessGroupsMembers.Ref = AccessGroups.Ref))
	|
	|INDEX BY
	|	Ref,
	|	AccessGroups.Profile
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT DISTINCT
	|	AccessGroups.Ref AS Ref
	|FROM
	|	Catalog.AccessGroups.AccessValues AS AccessGroupsAccessValues
	|		INNER JOIN AccessGroups AS AccessGroups
	|		ON AccessGroupsAccessValues.Ref = AccessGroups.Ref
	|WHERE
	|	AccessGroupsAccessValues.IncludeSubordinateAccessValues
	|	AND VALUETYPE(AccessGroupsAccessValues.AccessValue) = &AccessKindValueType
	|
	|UNION ALL
	|
	|SELECT DISTINCT
	|	AccessGroups.Ref
	|FROM
	|	Catalog.AccessGroupProfiles.AccessValues AS AccessGroupProfilesAccessValues
	|		INNER JOIN AccessGroups AS AccessGroups
	|		ON AccessGroupProfilesAccessValues.Ref = AccessGroups.Profile
	|WHERE
	|	AccessGroupProfilesAccessValues.IncludeSubordinateAccessValues
	|	AND VALUETYPE(AccessGroupProfilesAccessValues.AccessValue) = &AccessKindValueType";
	
	Query = New Query(QueryText);
	Query.SetParameter("AccessKindValueType", AccessKindValueType);
	Query.SetParameter("ProfileAdministrator", AccessManagement.ProfileAdministrator());
	
	Return Query.Execute().Unload().UnloadColumn("Ref");
	
EndFunction

// Returns the value table containing an access restriction kind for each
// metadata object right.
//  If no record is returned for a right, no restrictions exist for this right.
//  The table contains only the access kinds specified by the developer
//  based on their usage in restriction texts.
//  To receive all access kinds including the ones used in access value sets,
// the current state
// of the AccessValuesSets information register can be used.
//
// Parameters:
//  ForCheck - Boolean - return text description of right restrictions filled
//                         in overridable modules without checking.
//
// Returns:
//  ValueTable:
//   * ForExternalUsers - Boolean - If False, restrict the access for internal users.
//                                 If True, restrict the access for external users.
//                                 This column is applicable only to universal restrictions.
//   * FullName      - String - a full table name.
//   * Table        - CatalogRef.MetadataObjectIDs
//                    - CatalogRef.ExtensionObjectIDs - 
//   * AccessKind     - AnyRef - Empty Ref to the main access kind value type.
//                              Empty Ref to the access right settings owner.
//   * Right          - String - Read, Modify.
//                    - Undefined - 
//   * ObjectTable - AnyRef - Empty reference of the metadata object used to restrict access with access value sets.
//                      For example, Catalog.FilesFolders.
//                    - Undefined - 
//                      
//
//  
//
Function PermanentMetadataObjectsRightsRestrictionsKinds(ForCheck = False) Export
	
	SetPrivilegedMode(True);
	
	UniversalRestriction = LimitAccessAtRecordLevelUniversally(True, True);
	
	If ForCheck Or Not UniversalRestriction Then
		RightsRestrictions = "";
		SSLSubsystemsIntegration.OnFillMetadataObjectsAccessRestrictionKinds(RightsRestrictions);
		AccessManagementOverridable.OnFillMetadataObjectsAccessRestrictionKinds(RightsRestrictions);
		If ForCheck Then
			Return RightsRestrictions;
		EndIf;
	EndIf;
	
	IDsTypes = New Array;
	IDsTypes.Add(Type("CatalogRef.MetadataObjectIDs"));
	IDsTypes.Add(Type("CatalogRef.ExtensionObjectIDs"));
	
	AccessRestrictionKinds = New ValueTable;
	AccessRestrictionKinds.Columns.Add("ForExternalUsers", New TypeDescription("Boolean"));
	AccessRestrictionKinds.Columns.Add("FullName",  New TypeDescription("String", , New StringQualifiers(430)));
	AccessRestrictionKinds.Columns.Add("Table",    New TypeDescription(IDsTypes));
	AccessRestrictionKinds.Columns.Add("Right",      New TypeDescription("String", , New StringQualifiers(20)));
	AccessRestrictionKinds.Columns.Add("AccessKind", AccessManagementInternalCached.DetailsOfAccessValuesTypesAndRightsSettingsOwners());
	AccessRestrictionKinds.Columns.Add("ObjectTable",
		Metadata.InformationRegisters.AccessValuesSets.Dimensions.Object.Type);
	AccessRestrictionKinds.Columns.Add("LeadingRight", New TypeDescription("String", , New StringQualifiers(20)));
	
	AccessKindsByNames = AccessKindsProperties().ByNames;
	
	If UniversalRestriction Then
		AllRestrictionsKinds = AllRightsRestrictionsKindsForAccessRightsReport();
		AddViewsRestrictionsRights(AccessRestrictionKinds,
			AllRestrictionsKinds.ForUsers, AccessKindsByNames, True, False);
		AddViewsRestrictionsRights(AccessRestrictionKinds,
			AllRestrictionsKinds.ForExternalUsers, AccessKindsByNames, True, True);
	Else
		AddViewsRestrictionsRights(AccessRestrictionKinds,
			RightsRestrictions, AccessKindsByNames, False);
	EndIf;
	
	FullNames = AccessRestrictionKinds.UnloadColumn("FullName");
	NameIdentifiers = Common.MetadataObjectIDs(FullNames);
	For Each String In AccessRestrictionKinds Do
		String.Table = NameIdentifiers.Get(String.FullName);
	EndDo;
	
	// Adding object access kinds defined not only using access value sets.
	If Not UniversalRestriction Then
		Query = New Query;
		Query.Text =
		"SELECT
		|	AccessRightsDependencies.SubordinateTable,
		|	AccessRightsDependencies.LeadingTableType
		|FROM
		|	InformationRegister.AccessRightsDependencies AS AccessRightsDependencies";
		RightsDependencies = Query.Execute().Unload();
	EndIf;
	
	Context = New Structure;
	Context.Insert("UniversalRestriction", UniversalRestriction);
	Context.Insert("AccessRestrictionKinds",      AccessRestrictionKinds);
	Context.Insert("RightsDependencies",          RightsDependencies);
	Context.Insert("CurrentDependentTables",  New Map);
	Context.Insert("AccessTypesLeadingTables", New Map);
	Filter = New Structure("AccessKind", Undefined);
	AccessKindsObject = AccessRestrictionKinds.FindRows(Filter);
	Filter = New Structure("ForExternalUsers, FullName, Table, Right, AccessKind");
	For Each StringAccessTypeObject In AccessKindsObject Do
		AccessKinds = LeadingTableAccessKinds(Context, StringAccessTypeObject);
		For Each AccessKind In AccessKinds Do
			FillPropertyValues(Filter, StringAccessTypeObject);
			Filter.AccessKind = AccessKind;
			If AccessRestrictionKinds.FindRows(Filter).Count() = 0 Then
				FillPropertyValues(AccessRestrictionKinds.Add(), Filter);
			EndIf;
		EndDo;
	EndDo;
	
	AccessRestrictionKinds.Columns.Delete("LeadingRight");
	If UniversalRestriction Then
		AccessRestrictionKinds.Columns.Delete("ObjectTable");
	Else
		AccessRestrictionKinds.Columns.Delete("ForExternalUsers");
	EndIf;
	
	Return AccessRestrictionKinds;
	
EndFunction

// For the CurrentDataSourcesForPeriodClosingCheck function.
Function LeadingTableAccessKinds(Context, StringAccessTypeObject)
	
	TableID = Common.MetadataObjectID(
		TypeOf(StringAccessTypeObject.ObjectTable));
	
	If Context.UniversalRestriction Then
		LeadingRight = StringAccessTypeObject.LeadingRight;
	Else
		Filter = New Structure;
		Filter.Insert("SubordinateTable", StringAccessTypeObject.Table);
		Filter.Insert("LeadingTableType", StringAccessTypeObject.ObjectTable);
		If Context.RightsDependencies.FindRows(Filter).Count() = 0 Then
			LeadingRight = StringAccessTypeObject.Right;
		Else
			LeadingRight = "Read";
		EndIf;
	EndIf;
	
	Var_Key = ?(StringAccessTypeObject.ForExternalUsers, "1:", "0:")
		+ String(TableID.UUID()) + ":" + LeadingRight;
	
	If Context.CurrentDependentTables.Get(Var_Key) <> Undefined Then
		Return New Array;
	EndIf;
	
	AccessKinds = Context.AccessTypesLeadingTables.Get(Var_Key);
	If AccessKinds <> Undefined Then
		Return AccessKinds;
	EndIf;
	
	Context.CurrentDependentTables.Insert(Var_Key, True);
	AccessKinds = New Array;
	
	Filter = New Structure("ForExternalUsers, Table, Right",
		StringAccessTypeObject.ForExternalUsers, TableID, LeadingRight);
	LeadingTableAccessKinds = Context.AccessRestrictionKinds.FindRows(Filter);
	
	For Each AccessKindDetails In LeadingTableAccessKinds Do
		If AccessKindDetails.AccessKind = Undefined Then
			AccessTypesNestedMasterTable = LeadingTableAccessKinds(Context,
				AccessKindDetails);
			For Each AccessKind In AccessTypesNestedMasterTable Do
				AddAccessTypeHostTable(AccessKinds, AccessKind);
			EndDo;
		Else
			AddAccessTypeHostTable(AccessKinds, AccessKindDetails.AccessKind);
		EndIf;
	EndDo;
	
	Context.CurrentDependentTables.Delete(Var_Key);
	Context.AccessTypesLeadingTables.Insert(Var_Key, AccessKinds);
	
	Return AccessKinds;
	
EndFunction

// For the LeadingTableAccessKinds function.
Procedure AddAccessTypeHostTable(AccessKinds, AccessKind)
	
	If AccessKinds.Find(AccessKind) = Undefined Then
		AccessKinds.Add(AccessKind);
	EndIf;
	
EndProcedure

// For the CurrentDataSourcesForPeriodClosingCheck function.
Procedure AddViewsRestrictionsRights(AccessRestrictionKinds, RightsRestrictions, AccessKindsByNames,
			UniversalRestriction, ForExternalUsers = Undefined)
	
	For LineNumber = 1 To StrLineCount(RightsRestrictions) Do
		CurrentRow = TrimAll(StrGetLine(RightsRestrictions, LineNumber));
		If ValueIsFilled(CurrentRow) Then
			ErrorNote = "";
			StringParts1 = StrSplit(CurrentRow, ".");
			If Not UniversalRestriction
			   And StringParts1.Count() <> 4
			   And StringParts1.Count() <> 6 Then
				ErrorNote = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("en = 'Line must have the following format: %1.';"),
					"<FullTableName>.<NameOfRight>.<AccessKindName>[.<FullObjectTableName>]");
			ElsIf UniversalRestriction
			   And StringParts1.Count() <> 4
			   And StringParts1.Count() <> 7 Then
				ErrorNote = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("en = 'Line must have the following format: %1.';"),
					"<FullTableName>.<NameOfRight>.<AccessKindName>[.<FullObjectTableName>.<HostRightName>]");
			Else
				Table    = StringParts1[0] + "." + StringParts1[1];
				Right      = StringParts1[2];
				AccessKind = StringParts1[3];
				If StringParts1.Count() = 4 Then
					ObjectTable = "";
					LeadingRight   = "";
				Else
					ObjectTable = StringParts1[4] + "." + StringParts1[5];
					LeadingRight   = ?(UniversalRestriction, StringParts1[6], "");
				EndIf;
				
				TableMetadataObject = Common.MetadataObjectByFullName(Table);
				If TableMetadataObject = Undefined Then
					If UniversalRestriction Then
						Continue;
					EndIf;
					ErrorNote = StringFunctionsClientServer.SubstituteParametersToString(
						NStr("en = 'Table ""%1"" does not exist.';"), Table);
				
				ElsIf Right <> "Read" And Right <> "Update" Then
					ErrorNote = StringFunctionsClientServer.SubstituteParametersToString(
						NStr("en = 'Right ""%1"" does not exist.';"), Right);
				
				ElsIf Upper(AccessKind) = Upper("Object") Then
					If Common.MetadataObjectByFullName(ObjectTable) = Undefined Then
						If UniversalRestriction Then
							Continue;
						EndIf;
						ErrorNote = StringFunctionsClientServer.SubstituteParametersToString(
							NStr("en = 'Object table ""%1"" does not exist.';"),
							ObjectTable);
					Else
						AccessKindRef = Undefined;
						ObjectTableRef = MetadataObjectEmptyRef(ObjectTable);
						If UniversalRestriction
						   And LeadingRight <> "Read"
						   And LeadingRight <> "Update" Then
							ErrorNote = StringFunctionsClientServer.SubstituteParametersToString(
								NStr("en = 'Master right ""%1"" does not exist.';"), LeadingRight);
						EndIf;
					EndIf;
					
				ElsIf Upper(AccessKind) = Upper("RightsSettings") Then
					If Common.MetadataObjectByFullName(ObjectTable) = Undefined Then
						If UniversalRestriction Then
							Continue;
						EndIf;
						ErrorNote = StringFunctionsClientServer.SubstituteParametersToString(
							NStr("en = 'Right settings owner table ""%1"" does not exist.';"),
							ObjectTable);
					Else
						AccessKindRef = MetadataObjectEmptyRef(ObjectTable);
						ObjectTableRef = Undefined;
					EndIf;
				
				ElsIf AccessKindsByNames.Get(AccessKind) = Undefined Then
					If UniversalRestriction Then
						Continue;
					EndIf;
					ErrorNote = StringFunctionsClientServer.SubstituteParametersToString(
						NStr("en = 'Access kind ""%1"" does not exist.';"), AccessKind);
				Else
					AccessKindProperties = AccessKindsByNames.Get(AccessKind); // See AccessKindProperties
					AccessKindRef = AccessKindProperties.Ref;
					ObjectTableRef = Undefined;
				EndIf;
			EndIf;
			
			If ValueIsFilled(ErrorNote) Then
				ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
						NStr("en = 'Error in the details of the right restriction kind of a metadata object:
						           |""%1"".';")
						+ Chars.LF
						+ Chars.LF,
						CurrentRow)
					+ ErrorNote;
				
				If Not UniversalRestriction Then
					ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
							NStr("en = 'Subsystem ""%1"" misintegrated
							           |into procedure ""%2""
							           |of common module ""%3"".
							           |
							           |%4';"),
							"AccessManagement",
							"OnFillMetadataObjectsAccessRestrictionKinds",
							"AccessManagementOverridable",
							ErrorText);
				EndIf;
				Raise ErrorText;
			Else
				NewDetails = AccessRestrictionKinds.Add();
				NewDetails.ForExternalUsers = ForExternalUsers;
				NewDetails.FullName      = TableMetadataObject.FullName();
				NewDetails.Right          = Right;
				NewDetails.AccessKind     = AccessKindRef;
				NewDetails.ObjectTable = ObjectTableRef;
				NewDetails.LeadingRight   = LeadingRight;
			EndIf;
		EndIf;
	EndDo;
	
EndProcedure

// For internal use only.
//
// Returns:
//   FixedMap of KeyAndValue:
//     * Key - Type
//     * Value - String
//
Function AccessKindsGroupsAndValuesTypes() Export
	
	AccessKindsProperties = AccessKindsProperties();
	
	AccessKindsGroupsAndValuesTypes = New ValueTable;
	AccessKindsGroupsAndValuesTypes.Columns.Add("AccessKind",        Metadata.DefinedTypes.AccessValue.Type);
	AccessKindsGroupsAndValuesTypes.Columns.Add("GroupAndValueType", Metadata.DefinedTypes.AccessValue.Type);
	
	For Each KeyAndValue In AccessKindsProperties.ByGroupsAndValuesTypes Do
		String = AccessKindsGroupsAndValuesTypes.Add();
		AccessKindProperties = KeyAndValue.Value; // See AccessKindProperties
		String.AccessKind = AccessKindProperties.Ref;
		
		Types = New Array;
		Types.Add(KeyAndValue.Key);
		TypeDetails = New TypeDescription(Types);
		
		String.GroupAndValueType = TypeDetails.AdjustValue(Undefined);
	EndDo;
	
	Return AccessKindsGroupsAndValuesTypes;
	
EndFunction

// For internal use only.
//
// Returns:
//   ValueTable:
//     * AccessKind - AnyRef
//     * ValuesType - AnyRef
//
Function ValuesTypesOfAccessKindsAndRightsSettingsOwners() Export
	
	ValuesTypesOfAccessKindsAndRightsSettingsOwners = New ValueTable;
	
	ValuesTypesOfAccessKindsAndRightsSettingsOwners.Columns.Add("AccessKind",
		AccessManagementInternalCached.DetailsOfAccessValuesTypesAndRightsSettingsOwners());
	
	ValuesTypesOfAccessKindsAndRightsSettingsOwners.Columns.Add("ValuesType",
		AccessManagementInternalCached.DetailsOfAccessValuesTypesAndRightsSettingsOwners());
	
	AccessKindsValuesTypes = AccessKindsValuesTypes();
	
	For Each String In AccessKindsValuesTypes Do
		FillPropertyValues(ValuesTypesOfAccessKindsAndRightsSettingsOwners.Add(), String);
	EndDo;
	
	AvailableRights = RightsForObjectsRightsSettingsAvailable();
	RightsOwners = AvailableRights.ByRefsTypes;
	
	For Each KeyAndValue In RightsOwners Do
		
		Types = New Array;
		Types.Add(KeyAndValue.Key);
		TypeDetails = New TypeDescription(Types);
		
		String = ValuesTypesOfAccessKindsAndRightsSettingsOwners.Add();
		String.AccessKind  = TypeDetails.AdjustValue(Undefined);
		String.ValuesType = TypeDetails.AdjustValue(Undefined);
	EndDo;
	
	Return ValuesTypesOfAccessKindsAndRightsSettingsOwners;
	
EndFunction

// For the ValuesTypesOfAccessKindsAndRightsSettingsOwners function.
Function AccessKindsValuesTypes()
	
	AccessKindsProperties = AccessKindsProperties();
	
	AccessKindsValuesTypes = New ValueTable;
	AccessKindsValuesTypes.Columns.Add("AccessKind",  Metadata.DefinedTypes.AccessValue.Type);
	AccessKindsValuesTypes.Columns.Add("ValuesType", Metadata.DefinedTypes.AccessValue.Type);
	
	For Each KeyAndValue In AccessKindsProperties.ByValuesTypes Do
		String = AccessKindsValuesTypes.Add();
		AccessKindProperties = KeyAndValue.Value; // See AccessKindProperties
		String.AccessKind = AccessKindProperties.Ref;
		
		Types = New Array;
		Types.Add(KeyAndValue.Key);
		TypeDetails = New TypeDescription(Types);
		
		String.ValuesType = TypeDetails.AdjustValue(Undefined);
	EndDo;
	
	Return AccessKindsValuesTypes;
	
EndFunction

// See AccessManagementOverridable.OnFillAvailableRightsForObjectsRightsSettings.
// Also, see function values in InformationRegisters.ObjectsRightsSettings.
//
// Returns:
//   Structure:
//     * ByTypes - FixedMap of KeyAndValue:
//         ** Key - Type - the type of reference or object from the definable Type.Vladimirenergosbyt
//         ** Value - FixedMap of KeyAndValue:
//             *** Key - String - name of the possible right
//             *** Value - See InformationRegisters.ObjectsRightsSettings.AvailableRightProperties
//     * ByRefsTypes - FixedMap of KeyAndValue:
//         ** Key - Type -
//         ** Value - FixedArray of See InformationRegisters.ObjectsRightsSettings.AvailableRightProperties
//     * ByFullNames - FixedMap of KeyAndValue:
//         ** Key - String -
//         ** Value - See InformationRegisters.ObjectsRightsSettings.AvailableRightProperties
//     * OwnersTypes - FixedArray of DefinedType.RightsSettingsOwner
//     * SeparateTables - FixedMap of KeyAndValue:
//         ** Key - CatalogRef.MetadataObjectIDs
//                - CatalogRef.ExtensionObjectIDs - 
//         ** Value - String - full name of the table
//     * HierarchicalTables - FixedMap of KeyAndValue:
//         ** Key - Type - the type of reference or object from the definable Type.Vladimirenergosbyt
//         ** Value - Boolean - Truth.
// 
Function RightsForObjectsRightsSettingsAvailable() Export
	
	Return InformationRegisters.ObjectsRightsSettings.RightsForObjectsRightsSettingsAvailable();
	
EndFunction

// See AccessManagementOverridable.OnFillSuppliedAccessGroupProfiles.
// See also population in function Catalogs.AccessGroupProfiles.???
//
// Returns:
//   FixedStructure:
//     * ProfilesDetails - FixedMap of KeyAndValue:
//         ** Key - String
//         ** Value - See Catalogs.AccessGroupProfiles.SuppliedProfileProperties
//     * ProfilesDetailsArray - FixedArray of See Catalogs.AccessGroupProfiles.SuppliedProfileProperties
//     * FoldersByParents - FixedMap
//     * ParametersOfUpdate - FixedStructure:
//         ** UpdateModifiedProfiles - Boolean
//         ** DenyProfilesChange - Boolean
//         ** UpdatingAccessGroups - Boolean
//         ** UpdatingAccessGroupsWithObsoleteSettings - Boolean
//
Function SuppliedProfiles() Export
	
	Return Catalogs.AccessGroupProfiles.SuppliedProfiles();
	
EndFunction

// 
//
// Returns:
//  FixedStructure:
//   * CommonRights                       - FixedArray of String - Role names <ExtentionPrefix>CommonRights.
//   * FullAccess                      - FixedArray of String - Role names <ExtentionPrefix>FullAccess.
//   * BasicAccess                     - FixedArray of String - Role names <ExtentionPrefix>BasicRights.
//   * BasicAccessExternalUsers - FixedArray of String - Role names <ExtentionPrefix>ExternalUsersBasicRights.
//   * SystemAdministrator             - FixedArray of String - Role names <ExtentionPrefix>SystemAdministrator.
//   * All                              - FixedMap of KeyAndValue:
//       ** Key     - String - Extension role name (from the ones mentioned above).
//       ** Value - String - Role type name (structure property name).
//   * AdditionalAdministratorRoles - FixedMap of KeyAndValue:
//       ** Key     - String - Name of the extension roles that can be assigned to Administrator.
//       ** Value - Boolean - True.
//   * HashSum                         - String
//
Function StandardExtensionRoles() Export
	
	Return Catalogs.AccessGroupProfiles.StandardExtensionRoles();
	
EndFunction

#Region UniversalRestriction

////////////////////////////////////////////////////////////////////////////////
// Event subscription handlers.

// The CheckAccessBeforeWrite* subscription handler checks access to the old object version and checks
// object field changes of the additional tables attached in access restrictions of the lists.
// If changes are found, need to update access keys
// for the lists, which have additional tables attached in the access restrictions, is registered.
//
// Parameters:
//  Source        - CatalogObject
//                  - DocumentObject
//                  - ChartOfCharacteristicTypesObject
//                  - ChartOfAccountsObject
//                  - ChartOfCalculationTypesObject
//                  - BusinessProcessObject
//                  - TaskObject
//                  - ExchangePlanObject - a data object that is passed to the pre-Recording event subscription.
//
//  Cancel           - Boolean - a parameter passed to the BeforeWrite event subscription.
//
//  WriteMode     - DocumentWriteMode - a parameter passed to the BeforeWrite event subscription
//                    when Source is DocumentObject.
//
//  PostingMode - DocumentPostingMode - a parameter passed to the BeforeWrite event subscription
//                    when Source is DocumentObject.
//
Procedure CheckAccessBeforeWrite(Source, Cancel, WriteMode = Undefined, PostingMode = Undefined) Export
	
	// DataExchange.Import is processed inside the procedure in a non-standard way (considering rights check).
	CheckAccessBeforeWriteSource(Source, Cancel, False, False);
	
EndProcedure

// The CheckAccessBeforeWriteRecordsSet* subscription handler checks access to the old record set version,
// and checks changes of record set fields of the additional tables attached in access restrictions of the lists.
// If changes are found, need to update access keys
// for the lists, which have additional tables attached in access restrictions, is registered.
//
// Parameters:
//  Source        - InformationRegisterRecordSet
//                  - AccumulationRegisterRecordSet
//                  - AccountingRegisterRecordSet
//                  - CalculationRegisterRecordSet
//                  - RecalculationRecordSet - 
//                                             
//
//  Cancel           - Boolean - a parameter passed to the BeforeWrite event subscription.
//  Replacing       - Boolean - a parameter passed to the BeforeWrite event subscription.
//
//  WriteOnly    - Boolean - a parameter passed to the BeforeWrite event subscription
//                    when the Source is CalculationRegisterRecordSet.
//
//  WriteActualActionPeriod - Boolean - a parameter passed to the BeforeWrite event subscription
//                    when the Source is CalculationRegisterRecordSet.
//
//  WriteRecalculations - Boolean - a parameter passed to the BeforeWrite event subscription
//                    when the Source is CalculationRegisterRecordSet.
//
Procedure CheckAccessBeforeWriteRecordsSet(Source, Cancel, Replacing,
				WriteOnly = Undefined,
				WriteActualActionPeriod = Undefined,
				WriteRecalculations = Undefined) Export
	
	// DataExchange.Import is processed inside the procedure in a non-standard way (considering rights check).
	CheckAccessBeforeWriteSource(Source, Cancel, True, Replacing);
	
EndProcedure

// The CheckAccessOnWrite* subscription handler checks whether the access key
// of the new object version is up-to-date. Updates the obsolete access key and
// checks the Read and Update rights of the new object version.
//
// Parameters:
//  Source        - CatalogObject
//                  - DocumentObject
//                  - ChartOfCharacteristicTypesObject
//                  - ChartOfAccountsObject
//                  - ChartOfCalculationTypesObject
//                  - BusinessProcessObject
//                  - TaskObject
//                  - ExchangePlanObject - 
//
//  Cancel           - Boolean - a parameter passed to the OnWrite event subscription.
//
Procedure CheckAccessOnWrite(Source, Cancel) Export
	
	// DataExchange.Import is processed inside the procedure in a non-standard way (considering rights check).
	CheckAccessOnWriteSource(Source, Cancel, False, False);
	
EndProcedure

// The CheckAccessOnWriteRecordsSet* subscription handler checks whether the access keys
// of the new record set version are up-to-date. Updates the obsolete access keys and
// checks the Read and Update rights of the new record set version.
//
// Parameters:
//  Source        - InformationRegisterRecordSet
//                  - AccumulationRegisterRecordSet
//                  - AccountingRegisterRecordSet
//                  - CalculationRegisterRecordSet
//                  - RecalculationRecordSet - 
//                                             
//
//  Cancel           - Boolean - a parameter passed to the OnWrite event subscription.
//  Replacing       - Boolean - a parameter passed to the OnWrite event subscription.
//
//  WriteOnly    - Boolean - a parameter passed to the OnWrite event subscription
//                    when the Source is CalculationRegisterRecordSet.
//
//  WriteActualActionPeriod - Boolean - a parameter passed to the OnWrite event subscription
//                    when the Source is CalculationRegisterRecordSet.
//
//  WriteRecalculations - Boolean - a parameter passed to the OnWrite event subscription
//                    when the Source is CalculationRegisterRecordSet.
//
Procedure CheckAccessOnWriteRecordsSet(Source, Cancel, Replacing,
				WriteOnly = Undefined,
				WriteActualActionPeriod = Undefined,
				WriteRecalculations = Undefined) Export
	
	// DataExchange.Import is processed inside the procedure in a non-standard way (considering rights check).
	CheckAccessOnWriteSource(Source, Cancel, True, Replacing);
	
EndProcedure

// The CheckAccessBeforeDelete* subscription handler checks
// object field changes of the additional tables attached in access restrictions of the lists.
// If changes are found, need to update access keys
// for the lists, which have additional tables attached in the access restrictions, is registered.
//
// Parameters:
//  Source - CatalogObject
//           - DocumentObject
//           - ChartOfCharacteristicTypesObject
//           - ChartOfAccountsObject
//           - ChartOfCalculationTypesObject
//           - BusinessProcessObject
//           - TaskObject
//           - ExchangePlanObject - 
//
//  Cancel    - Boolean - a parameter passed to the BeforeDelete event subscription.
//
Procedure CheckAccessBeforeDelete(Source, Cancel) Export
	
	// DataExchange.Import is processed inside the procedure in a non-standard way (considering rights check).
	CheckAccessBeforeDeleteSource(Source, Cancel);
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Universal access restriction.

// Parameters:
//  DataDetails - See AccessManagement.EditionAllowed.DataDetails
//  RightUpdate - Boolean
//  RaiseException1 - Boolean
//  CheckOldVersionOnly - Boolean
//  User   - CatalogRef.Users
//                 - CatalogRef.ExternalUsers
//                 - Undefined - 
//
// Returns:
//  Boolean
//
Function AccessAllowed(DataDetails, RightUpdate, RaiseException1 = False,
			CheckOldVersionOnly = False, Val User = Undefined) Export
	
	ForPrivilegedMode = True;
	IBUser = Undefined;
	
	If User <> Undefined
	   And User = Users.AuthorizedUser() Then
		
		User = Undefined;
		ForPrivilegedMode = False;
		IBUser = InfoBaseUsers.CurrentUser();
	EndIf;
	
	If User = Undefined
	   And Users.IsFullUser(,, ForPrivilegedMode) Then
		Return True;
	EndIf;
	
	MetadataObject = Metadata.FindByType(TypeOf(DataDetails));
	If MetadataObject = Undefined Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Invalid value of the %1 parameter in %2.
			           |A reference, object, record key, or record set expected.
			           |Passed value: %3 (type %4).';"),
			"DataDetails",
			?(RaiseException1,
				?(RightUpdate, "AccessManagement.CheckChangeAllowed",
					"AccessManagement.CheckReadAllowed"),
				?(RightUpdate, "AccessManagement.EditionAllowed",
					"AccessManagement.ReadingAllowed")),
			String(DataDetails),
			String(TypeOf(DataDetails)));
		Raise ErrorText;
	EndIf;
	
	ProductiveOption = AccessManagement.ProductiveOption();
	
	If User <> Undefined Then
		CommonClientServer.CheckParameter(
			?(RaiseException1,
				?(RightUpdate, "AccessManagement.CheckChangeAllowed",
					"AccessManagement.CheckReadAllowed"),
				?(RightUpdate, "AccessManagement.EditionAllowed",
					"AccessManagement.ReadingAllowed")),
				"User",
				User,
				New TypeDescription("CatalogRef.Users, CatalogRef.ExternalUsers"));
		
		If Not ProductiveOption Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'Invalid value of the %1 parameter in %2.
				           |Only %3 is supported in the standard access restriction option.
				           |Value passed: %4 (the %5 type).';"),
				"User",
				?(RaiseException1,
					?(RightUpdate, "AccessManagement.CheckChangeAllowed",
						"AccessManagement.CheckReadAllowed"),
					?(RightUpdate, "AccessManagement.EditionAllowed",
						"AccessManagement.ReadingAllowed")),
				"Undefined",
				String(User),
				String(TypeOf(User)));
			Raise ErrorText;
		EndIf;
		
		If RaiseException1 Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'An exception can be thrown for the current user only.
				           |In %1,
				           |- either the %2 parameter value is invalid
				           |value passed: %3 (the %4 type),
				           |- or the %5 parameter value is invalid
				           |value passed: %6 (the %7 type).';"),
				"AccessManagement.AccessAllowed",
				"RaiseException1",
				String(RaiseException1),
				String(TypeOf(RaiseException1)),
				"User",
				String(User),
				String(TypeOf(User)));
			Raise ErrorText;
		EndIf;
		
		If Users.IsFullUser(User,, ForPrivilegedMode) Then
			Return True;
		EndIf;
		
		IBUserID = Common.ObjectAttributeValue(User,
			"IBUserID");
		
		If TypeOf(IBUserID) <> Type("UUID") Then
			Return False;
		EndIf;
		
		IBUser = InfoBaseUsers.FindByUUID(
			IBUserID);
		
		If IBUser = Undefined Then
			Return False;
		EndIf;
	EndIf;
	
	AnyObject = DataDetails; // CatalogObject
	
	If Not RightUpdate Then
		AccessRightName = "Read";
		
	ElsIf Common.IsRefTypeObject(MetadataObject)
	        And Not Common.IsReference(TypeOf(AnyObject))
	        And AnyObject.IsNew() Then
		
		AccessRightName = "Create";
	Else
		AccessRightName = "Update";
	EndIf;
	
	HasRight = True;
	If RaiseException1 Then
		VerifyAccessRights(AccessRightName, MetadataObject);
		
	ElsIf IBUser = Undefined Then
		HasRight = AccessRight(AccessRightName, MetadataObject);
		
	ElsIf User = Undefined Then
		SetSafeModeDisabled(True);
		SetPrivilegedMode(True);
		
		HasRight = AccessRight(AccessRightName, MetadataObject, IBUser);
		
		SetPrivilegedMode(False);
		SetSafeModeDisabled(False);
	Else
		HasRight = AccessRight(AccessRightName, MetadataObject, IBUser);
	EndIf;
	If Not HasRight Then
		Return False;
	EndIf;
	
	If AccessManagementInternalCached.IsUserWithUnlimitedAccess(User) Then
		Return True;
	EndIf;
	
	FullName = MetadataObject.FullName();
	
	If Not ProductiveOption Then
		Return ReadAllowed(FullName, MetadataObject, DataDetails, RaiseException1);
	EndIf;
	
	If ValueIsFilled(User) Then
		ForExternalUsers = TypeOf(User) = Type("CatalogRef.ExternalUsers");
	Else
		ForExternalUsers = Undefined;
	EndIf;
	TransactionID = New UUID;
	RestrictionParameters = RestrictionParameters(FullName, TransactionID, ForExternalUsers);
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	UpdateAllowedSetsInSessionParameters();
	
	If RestrictionParameters.RestrictionDisabled
	 Or Not RightUpdate
	   And RestrictionParameters.RightToWriteRestrictionDisabled Then
		
		Return True;
	EndIf;
	
	OldVersion = True;
	EditRight = False;
	IsNew = False;
	
	If RestrictionParameters.AccessDenied Then
		AccessAllowed = False;
	Else
		Query = New Query;
		SetAllowedSetsInQueryParameters(Query, User);
		
		Query.Text = ?(RightUpdate, RestrictionParameters.ReadEditRightsCheckQueryText,
			RestrictionParameters.ReadRightsCheckQueryText);
		
		If RestrictionParameters.IsReferenceType Then
			ObjectReference = ?(Common.IsReference(TypeOf(DataDetails)),
				DataDetails, DataDetails.Ref);
			Query.SetParameter("Object", ObjectReference);
			If RestrictionParameters.UsesRestrictionByOwner Then
				Query.SetParameter("RightSettingsTableID",
					RestrictionParameters.RightSettingsTableID);
			EndIf;
			If DataDetails = ObjectReference Or ValueIsFilled(ObjectReference) Then
				AccessAllowed = Not Query.Execute().IsEmpty();
			Else
				AccessAllowed = True;
			EndIf;
			
			If Not AccessAllowed Then
				DataToPresent = ObjectReference;
				
			ElsIf DataDetails <> ObjectReference And Not CheckOldVersionOnly Then
				OldVersion = False;
				If RestrictionParameters.UsesRestrictionByOwner Then
					FieldsSeparatedByAPoint = StrSplit(RestrictionParameters.OwnerField.Name, ".", False);
					ObjectField = FieldsSeparatedByAPoint[0];
					ObjectFieldValue = DataDetails[ObjectField];
					If FieldsSeparatedByAPoint.Count() = 1 Then
						ParameterFromMemory = "&Owner";
					Else
						MetadataObjectByType = Metadata.FindByType(TypeOf(ObjectFieldValue));
						If MetadataObjectByType = Undefined Then
							ParameterFromMemory = "&Owner";
							ObjectFieldValue = Null;
						Else
							FieldsSeparatedByAPoint.Delete(0);
							ParameterFromMemory = "CAST(&Owner AS " + MetadataObjectByType.FullName() // @query-part-1
								+ ")." + StrConcat(FieldsSeparatedByAPoint, ".");
						EndIf;
					EndIf;
					Query.Text = StrReplace(Query.Text,
						RestrictionParameters.OwnerObjectFieldInRightsValidationQuery, ParameterFromMemory);
					Query.SetParameter("Owner", ObjectFieldValue);
				Else
					InMemoryObjectsModel = InMemoryObjectsModel(DataDetails, RestrictionParameters);
					ParametersOfUpdate = New Structure(RestrictionParameters);
					ParametersOfUpdate.Insert("InMemoryObjectsModel", InMemoryObjectsModel);
					ParametersOfUpdate.Insert("TransactionID", TransactionID);
					ParametersOfUpdate.Insert("ListID",
						Common.MetadataObjectID(RestrictionParameters.List));
					UpdateAccessKeysOfListDataItemsBatch(InMemoryObjectsModel.DataItems, ParametersOfUpdate);
					Query.SetParameter("AccessKeysForObjects", InMemoryObjectsModel.AccessKeysForObjects);
					Query.SetParameter("Object", InMemoryObjectsModel.DataItems[0].CurrentRef);
					QueryText =
					"SELECT
					|	AccessKeysForObjects.Object AS Object,
					|	AccessKeysForObjects.UsersAccessKey AS UsersAccessKey,
					|	AccessKeysForObjects.ExternalUsersAccessKey AS ExternalUsersAccessKey
					|INTO InformationRegister_AccessKeysForObjects
					|FROM
					|	&AccessKeysForObjects AS AccessKeysForObjects";
					Query.Text = StrReplace(Query.Text, "InformationRegister.AccessKeysForObjects",
						"InformationRegister_AccessKeysForObjects");
					Query.Text = QueryText + Common.QueryBatchSeparator() + Query.Text;
				EndIf;
				AdditionCheck = False;
				QueryTextChanges = Query.Text;
				IsNew = DataDetails.IsNew();
				ClarifyInsertRight(Query, IsNew, RestrictionParameters, AdditionCheck);
				AccessAllowed = Not Query.Execute().IsEmpty();
				If Not AccessAllowed And AdditionCheck Then
					Query.Text = QueryTextChanges;
					EditRight = Not Query.Execute().IsEmpty();
				EndIf;
				DataToPresent = DataDetails;
			EndIf;
		Else
			RecordSet = Common.ObjectManagerByFullName(FullName).CreateRecordSet();
			
			If TypeOf(DataDetails) = TypeOf(RecordSet) Then
				RecordSet = DataDetails;
			Else // RecordKey.
				For Each FilterElement In RecordSet.Filter Do
					FilterElement.Value = DataDetails[FilterElement.Name];
					FilterElement.Use = True;
				EndDo;
			EndIf;
			
			FilterByDimensions = FilterByRecordSetDimensions(RecordSet, Query);
			QueryText = Query.Text;
			Query.Text = StrReplace(Query.Text, "&FilterByDimensions", FilterByDimensions);
			AccessAllowed = Query.Execute().IsEmpty();
			
			If AccessAllowed
			   And TypeOf(DataDetails) = TypeOf(RecordSet)
			   And Not CheckOldVersionOnly Then
				
				OldVersion = False;
				If RestrictionParameters.UsesRestrictionByOwner Then
					OwnerField = RestrictionParameters.OwnerField.Name;
					Combinations = DataDetails.Unload(, OwnerField); // ValueTable
					Combinations.GroupBy(OwnerField);
					Query.SetParameter("BasicFieldsValuesCombinations", Combinations);
					CombinationsPreparationQueryText = // @query-part-1
					"SELECT CurrentTable." + OwnerField + "
					|INTO BasicFieldsValuesCombinations
					|FROM &BasicFieldsValuesCombinations AS CurrentTable"; // @query-part-1
				Else
					CombinationsPreparationQueryText = // @query-part-1
					"SELECT CurrentTable." + StrConcat(RestrictionParameters.BasicFields.UsedItems, ",
					|	CurrentTable.") + "
					|INTO BasicFieldsValuesCombinations
					|FROM &BasicFieldsValuesCombinations AS CurrentTable"; // @query-part-1
					DataDetails.AdditionalProperties.Insert("AccessManagementTransactionID",
						TransactionID);
					UpdateRecordSetAccessKeys(DataDetails, False, False,
						TransactionID, RestrictionParameters, "", Query);
					DataDetails.AdditionalProperties.Delete("AccessManagementTransactionID");
				EndIf;
				Query.Text = StrReplace(QueryText, "&FilterByDimensions", "TRUE");
				FullRegisterName = Metadata.FindByType(TypeOf(DataDetails)).FullName();
				Query.Text = CombinationsPreparationQueryText + Common.QueryBatchSeparator()
					+ StrReplace(Query.Text, FullRegisterName + " AS CurrentTable", // @query-part-1 @query-part-2
						"BasicFieldsValuesCombinations AS CurrentTable");
				
				AccessAllowed = Query.Execute().IsEmpty();
			EndIf;
			DataToPresent = RecordSet;
		EndIf;
	EndIf;
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
	If AccessAllowed Or Not RaiseException1 Then
		Return AccessAllowed;
	EndIf;
	
	If RightUpdate Then
		ReadRight1 = AccessAllowed(DataDetails, False);
	Else
		ReadRight1 = False;
	EndIf;
	
	ReportAccessError(DataToPresent, OldVersion, ReadRight1, EditRight, IsNew);
	
	Return False;
	
EndFunction

// For the AccessAllowed function.
Function ReadAllowed(FullName, MetadataObject, DataDetails, RaiseException1)
	
	Query = New Query;
	
	If IsReferenceTableType(FullName) Then
		ObjectReference = ?(Common.IsReference(TypeOf(DataDetails)),
			DataDetails, DataDetails.Ref);
		
		Query.SetParameter("Ref", ObjectReference);
		QueryText =
		"SELECT ALLOWED TOP 1
		|	TRUE AS TrueValue
		|FROM
		|	&CurrentTable AS CurrentTable
		|WHERE
		|	CurrentTable.Ref = &Ref";
		Query.Text = StrReplace(QueryText, "&CurrentTable", FullName);
		If Not Query.Execute().IsEmpty() Then
			Return True;
		EndIf;
		DataToPresent = ObjectReference;
	Else
		RecordSet = Common.ObjectManagerByFullName(FullName).CreateRecordSet();
		
		If TypeOf(DataDetails) = TypeOf(RecordSet) Then
			RecordSet = DataDetails;
		Else // RecordKey.
			For Each FilterElement In RecordSet.Filter Do
				FilterElement.Value = DataDetails[FilterElement.Name];
				FilterElement.Use = True;
			EndDo;
		EndIf;
		
		FilterByDimensions = FilterByRecordSetDimensions(RecordSet, Query);
		QueryText =
		"SELECT ALLOWED
		|	COUNT(1) AS DataVolume
		|FROM
		|	&CurrentTable AS CurrentTable
		|WHERE
		|	&FilterByDimensions";
		QueryText = StrReplace(QueryText, "&FilterByDimensions", FilterByDimensions);
		Query.Text = StrReplace(QueryText, "&CurrentTable", FullName);
		
		SetPrivilegedMode(True);
		Selection = Query.Execute().Select();
		SetPrivilegedMode(False);
		TotalData = ?(Selection.Next(), Selection.DataVolume, 0);
		
		Selection = Query.Execute().Select();
		DataAvailable = ?(Selection.Next(), Selection.DataVolume, 0);
		
		If TotalData = DataAvailable Then
			Return True;
		EndIf;
		DataToPresent = RecordSet;
	EndIf;
	
	If Not RaiseException1 Then
		Return False;
	EndIf;
	
	ReportAccessError(DataToPresent, False, False, False, False);
	
	Return False;
	
EndFunction

// It is required as a maximum start date when scheduling an initial access update.
//
// Returns:
//  Date
//
Function MaxDate() Export
	
	Return '39991231235959';
	
EndFunction

// It is required as a maximum start date when scheduling to continue an access update.
Function MaxDateOnContinue()
	
	Return '39990101000000';
	
EndFunction

// For the ImplementationSettings function.
Function XMLFullName(FullName, TablesTypesByNames)
	
	NameContent = StrSplit(FullName, ".", False);
	Properties = TablesTypesByNames.Get(Upper(NameContent[0]));
	
	Return Properties.LanguageEnglish + "." + NameContent[1];
	
EndFunction

// For the AddTypesRequiredInDefinedType procedure.
Function RefTypeName1(FullName, TablesTypesByNames)
	
	NameContent = StrSplit(FullName, ".", False);
	Properties = TablesTypesByNames.Get(Upper(NameContent[0]));
	
	If Not Properties.IsReferenceType Then
		Return "";
	EndIf;
	
	If Upper(Properties.LanguageRussian) = Upper(NameContent[0]) Then
		TypeName = Properties.LanguageRussian + "Ссылка." + NameContent[1]; // @Non-NLS
	Else
		TypeName = Properties.LanguageEnglish + "Ref." + NameContent[1];
	EndIf;
	
	Return TypeName;
	
EndFunction

// For the ImplementationSettings function.
Function XMLRefTypeName(FullName, TablesTypesByNames)
	
	NameContent = StrSplit(FullName, ".", False);
	Properties = TablesTypesByNames.Get(Upper(NameContent[0]));
	
	If Properties.IsReferenceType Then
		Return Properties.LanguageEnglish + "Ref." + NameContent[1];
	EndIf;
	
	Return "";
	
EndFunction

// For the AddTypesRequiredInDefinedType function.
Function ObjectTypeOrRecordSetName(FullName, TablesTypesByNames)
	
	NameContent = StrSplit(FullName, ".", False);
	Properties = TablesTypesByNames.Get(Upper(NameContent[0]));
	TypeName = "";
	
	If Properties.IsReferenceType Then
		If Upper(Properties.LanguageRussian) = Upper(NameContent[0]) Then
			TypeName = Properties.LanguageRussian + "Объект." + NameContent[1]; // @Non-NLS
		Else
			TypeName = Properties.LanguageEnglish + "Object." + NameContent[1];
		EndIf;
	EndIf;
	
	If StrStartsWith(Properties.CollectionName, "Registers") Then
		If Upper(Properties.LanguageRussian) = Upper(NameContent[0]) Then
			TypeName = Properties.LanguageRussian + "НаборЗаписей." + NameContent[1]; // @Non-NLS
		Else
			TypeName = Properties.LanguageEnglish + "RecordSet." + NameContent[1];
		EndIf;
	EndIf;
	
	Return TypeName;
	
EndFunction

// For the ImplementationSettings function.
Function ObjectTypeOrXMLRecordSetName(FullName, TablesTypesByNames)
	
	NameContent = StrSplit(FullName, ".", False);
	Properties = TablesTypesByNames.Get(Upper(NameContent[0]));
	
	If Properties.IsReferenceType Then
		Return Properties.LanguageEnglish + "Object." + NameContent[1];
	EndIf;
	
	If StrStartsWith(Properties.CollectionName, "Registers") Then
		Return Properties.LanguageEnglish + "RecordSet." + NameContent[1];
	EndIf;
	
	Return "";
	
EndFunction

// For the ImplementationSettings function.
Procedure AddObjectToOwners(XMLObjectTypeName, AccessKeysValuesOwners)
	
	If StrStartsWith(XMLObjectTypeName, "DocumentObject.") Then
		AccessKeysValuesOwners.Documents.Add(XMLObjectTypeName);
		
	ElsIf StrStartsWith(XMLObjectTypeName, "CalculationRegisterRecordSet.") Then
		AccessKeysValuesOwners.CalculationRegisterRecordSets.Add(XMLObjectTypeName);
		
	ElsIf StrFind(XMLObjectTypeName, "RecordSet.") > 0 Then
		AccessKeysValuesOwners.RecordSets.Add(XMLObjectTypeName);
		
	ElsIf StrFind(XMLObjectTypeName, "Object.") > 0 Then
		AccessKeysValuesOwners.Objects.Add(XMLObjectTypeName);
	EndIf;
	
EndProcedure

// For the ImplementationSettings function.
Procedure AddRestrictionsInRoles(XMLFullName, FullName, RestrictionsInRoles,
			RestrictionsProperties, KeysRegistersDimensionsTypes, TablesTypesByNames, PredefinedIDs)
	
	Properties = RestrictionsProperties.Get(FullName);
	If Properties <> Undefined And Properties.AccessDenied Then
		Return;
	EndIf;
	
	RestrictionInRole = New Structure("TemplateForObject, Parameters", True, New Array);
	RestrictionsInRoles.Insert(XMLFullName, RestrictionInRole);
	
	If Properties = Undefined Then
		Return;
	EndIf;
	
	If Properties.OwnerField <> Undefined Then
		OwnerField = Properties.OwnerField; // See NewOwnerField
		RestrictionInRole.Parameters.Add(OwnerField.Name);
		Return;
	EndIf;
	
	If Properties.BasicFields = Undefined
	 Or Not ValueIsFilled(Properties.BasicFields) Then
		Return;
	EndIf;
	
	RestrictionInRole.TemplateForObject = False;
	
	If ValueIsFilled(Properties.SeparateKeysRegisterName) Then
		FirstParameter = Properties.SeparateKeysRegisterName;
		
		AddDimensionTypes(Properties.SeparateKeysRegisterName,
			Properties.BasicFields, KeysRegistersDimensionsTypes, TablesTypesByNames, FullName);
	Else
		FirstParameter =
			AccessManagementInternalCached.PredefinedMetadataObjectIDDetails(FullName);
		
		AddDimensionTypes("AccessKeysForRegisters",
			Properties.BasicFields, KeysRegistersDimensionsTypes, TablesTypesByNames, FullName);
		
		PredefinedIDs.Insert(FirstParameter, FullName);
	EndIf;
	
	RestrictionInRole.Parameters.Add(FirstParameter);
	
	For Each BasicField In Properties.BasicFields.All Do
		RestrictionInRole.Parameters.Add(BasicField);
	EndDo;
	
EndProcedure

// For the AddRestrictionsInRoles procedure.
Procedure AddDimensionTypes(KeysRegisterName, BasicFields, KeysRegistersDimensionsTypes,
			TablesTypesByNames, SourceRegisterName)
	
	If BasicFields.All.Count() = 0 Then
		Return;
	EndIf;
	
	DimensionsTypes = KeysRegisterDimensionsTypes(KeysRegistersDimensionsTypes, KeysRegisterName);
	
	TypesNames           = DimensionsTypes.TypesNames;
	RegistersFieldsByTypes = DimensionsTypes.RegistersFieldsByTypes;
	
	RegisterFields = New Array;
	DimensionsTypes.RegistersFields.Insert(SourceRegisterName, RegisterFields);
	
	For Each FieldName In BasicFields.All Do
		FieldTypesStorage = BasicFields.AllItemsTypes[BasicFields.All.Find(FieldName)]; // ValueStorage
		FieldTypes = FieldTypesStorage.Get();
		RegisterFields.Add(New Structure("Field, Type", FieldName, FieldTypes));
		For Each Type In FieldTypes.Types() Do
			MetadataObject = Metadata.FindByType(Type);
			If MetadataObject = Undefined Then
				TypeName = XMLType(Type).TypeName;
			Else
				TypeName = XMLRefTypeName(Metadata.FindByType(Type).FullName(), TablesTypesByNames);
			EndIf;
			If TypesNames.Find(TypeName) = Undefined Then
				TypesNames.Add(TypeName);
			EndIf;
			RegistersFieldsByType = RegistersFieldsByTypes.Get(TypeName);
			If RegistersFieldsByType = Undefined Then
				RegistersFieldsByType = New Array;
				RegistersFieldsByTypes.Insert(TypeName, RegistersFieldsByType);
			EndIf;
			FullFieldName1 = SourceRegisterName + "." + FieldName;
			If RegistersFieldsByType.Find(FullFieldName1) = Undefined Then
				RegistersFieldsByType.Add(FullFieldName1);
			EndIf;
		EndDo;
	EndDo;
	
EndProcedure

// For the DeploymentSettings function and AddDimensionTypes procedure.
Function KeysRegisterDimensionsTypes(KeysRegistersDimensionsTypes, KeysRegisterName)
	
	DimensionsTypes = KeysRegistersDimensionsTypes.Get(KeysRegisterName);
	If DimensionsTypes = Undefined Then
		DimensionsTypes = New Structure;
		DimensionsTypes.Insert("TypesNames", New Array);
		DimensionsTypes.Insert("RegistersFields", New Map);
		DimensionsTypes.Insert("RegistersFieldsByTypes", New Map);
		KeysRegistersDimensionsTypes.Insert(KeysRegisterName, DimensionsTypes);
		DimensionsTypes.TypesNames.Add("EnumRef.AdditionalAccessValues");
	EndIf;
	
	Return DimensionsTypes;
	
EndFunction

// For function LimitAccessAtRecordLevelUniversally.
Function ConstantFirstAccessUpdateCompleted()
	
	Return Not ScriptVariantRussian()
		Or Constants.FirstAccessUpdateCompleted.Get();
	
EndFunction

#Region CheckAccessOnChange

// 
Procedure PreliminaryLockBeforeNewRecordToFileInfobase()
	
	Block = New DataLock;
	Block.Add("InformationRegister.AccessKeysForObjects");
	Block.Add("InformationRegister.AccessGroupsAccessKeys");
	Block.Add("InformationRegister.AccessGroupSetsAccessKeys");
	Block.Add("InformationRegister.UsersAccessKeys");
	Block.Add("InformationRegister.ExternalUsersAccessKeys");
	Block.Add("Catalog.AccessKeys");
	Block.Add("InformationRegister.ExtensionVersionParameters");
	LockItem = Block.Add("Catalog.SetsOfAccessGroups");
	LockItem.Mode = DataLockMode.Shared;
	LockItem = Block.Add("Catalog.AccessGroupProfiles");
	LockItem.Mode = DataLockMode.Shared;
	LockItem = Block.Add("Catalog.AccessGroups");
	LockItem.Mode = DataLockMode.Shared;
	LockItem = Block.Add("InformationRegister.AccessGroupsTables");
	LockItem.Mode = DataLockMode.Shared;
	LockItem = Block.Add("InformationRegister.AccessValuesGroups");
	LockItem.Mode = DataLockMode.Shared;
	LockItem = Block.Add("InformationRegister.AccessGroupsValues");
	LockItem.Mode = DataLockMode.Shared;
	LockItem = Block.Add("InformationRegister.DefaultAccessGroupsValues");
	LockItem.Mode = DataLockMode.Shared;
	LockItem = Block.Add("InformationRegister.ObjectsRightsSettings");
	LockItem.Mode = DataLockMode.Shared;
	LockItem = Block.Add("InformationRegister.ObjectRightsSettingsInheritance");
	LockItem.Mode = DataLockMode.Shared;
	Block.Lock();
	
EndProcedure

// For the BeforeWrite event subscription handlers.
Procedure CheckAccessBeforeWriteSource(Source, Cancel, IsRecordSet, Replacing)
	
	If SkipAccessCheck(Cancel, Source) Then
		Return;
	EndIf;
	
	If Not IsRecordSet
	   And Source.IsNew()
	   And Common.FileInfobase() Then
		
		PreliminaryLockBeforeNewRecordToFileInfobase();
	EndIf;
	
	IsFullUser = Users.IsFullUser()
		Or AccessManagementInternalCached.IsUserWithUnlimitedAccess()
		Or Not AccessManagement.ProductiveOption();
	
	Source.AdditionalProperties.Insert("AccessManagementTransactionID",
		New UUID);
	
	HasOldVersion =  IsRecordSet And Replacing
	             Or Not IsRecordSet And Not Source.IsNew();
	
	If HasOldVersion Then
		RememberDataAffectingDependentAccessKeys(Source, IsRecordSet, Replacing);
		CheckAccessToSource(Source, True, IsRecordSet, Replacing, IsFullUser);
		
	ElsIf Not IsRecordSet Then
		SetAllowedAccessKeyForNewObject(Source, IsFullUser);
	EndIf;
	
	If IsRecordSet Then
		WriteAccessKeysOfNewBasicFieldsCombinationsValuesBeforeWrite(Source, IsFullUser);
	EndIf;
	
EndProcedure

// For the OnWrite event subscription handlers.
Procedure CheckAccessOnWriteSource(Source, Cancel, IsRecordSet, Replacing)
	
	If SkipAccessCheck(Cancel, Source) Then
		Return;
	EndIf;
	
	IsFullUser = Users.IsFullUser()
		Or AccessManagementInternalCached.IsUserWithUnlimitedAccess()
		Or Not AccessManagement.ProductiveOption();
	
	// Checking access to a new version.
	CheckAccessToSource(Source, False, IsRecordSet, Replacing, IsFullUser);
	
	ScheduleUpdateOfDependentObsoleteAccessKeys(Source, IsRecordSet, False);
	
EndProcedure

// For the BeforeDelete event subscription handlers.
Procedure CheckAccessBeforeDeleteSource(Source, Cancel)
	
	If SkipAccessCheck(Cancel, Source) Then
		Return;
	EndIf;
	
	Source.AdditionalProperties.Insert("AccessManagementTransactionID",
		New UUID);
	
	RememberDataAffectingDependentAccessKeys(Source, False, False);
	ScheduleUpdateOfDependentObsoleteAccessKeys(Source, False, True);
	
EndProcedure


// For the CheckAccessBeforeWriteSource and CheckAccessOnWriteSource procedures.
Function SkipAccessCheck(Cancel, Source)
	
	If StandardSubsystemsServer.IsMetadataObjectID(Source) Then
		Return True;
	EndIf;
	
	If AccessManagementInternalCached.SeparatedDataUnavailable() Then
		Return True;
	EndIf;
	
	If Not LimitAccessAtRecordLevelUniversally(False) Then
		Return True;
	EndIf;
	
	DisableUpdate = SessionParameters.DIsableAccessKeysUpdate;  // See NewDisableOfAccessKeysUpdate
	If DisableUpdate.Full Then
		Return True;
	EndIf;
	
	If DisableUpdate.Regularly Then
		Cache = AccessManagementInternalCached.ChangedListsCacheOnDisabledAccessKeysUpdate();
		SourceType = TypeOf(Source);
		If Cache.Get(SourceType) <> Undefined Then
			Return True;
		EndIf;
		DisableUpdate = New Structure(DisableUpdate);
		EditedLists = DisableUpdate.EditedLists.Get();
		EditedLists.Insert(SourceType, True);
		DisableUpdate.EditedLists = New ValueStorage(EditedLists);
		
		SetSafeModeDisabled(True);
		SetPrivilegedMode(True);
		SessionParameters.DIsableAccessKeysUpdate = New FixedStructure(DisableUpdate);
		SetPrivilegedMode(True);
		SetSafeModeDisabled(True);
		
		Cache.Insert(SourceType, True);
		Return True;
	EndIf;
	
	If Cancel Then
		Return True;
	EndIf;
	
	Return False;
	
EndFunction

// For the CheckAccessBeforeWriteSource procedure.
Procedure RememberDataAffectingDependentAccessKeys(Source, IsRecordSet, Replacing)
	
	FullName = Source.Metadata().FullName();
	ListPropertiesAsLeadingOne = ListPropertiesAsLeadingOne(FullName,
		Source.AdditionalProperties.AccessManagementTransactionID);
	
	If ListPropertiesAsLeadingOne = Undefined
	 Or ListPropertiesAsLeadingOne.ByFieldsValues = Undefined Then
		
		Source.AdditionalProperties.Insert(
			"FieldValueAccessManagementForChangeCheckOnWrite");
		Return;
	EndIf;
	
	Query = New Query;
	
	If IsRecordSet Then
		FilterByDimensions = FilterByRecordSetDimensions(Source, Query);
		Query.Text = StrReplace(ListPropertiesAsLeadingOne.ByFieldsValues.QueryText,
			"&FilterByDimensions", FilterByDimensions);
	Else
		Query.Text = ListPropertiesAsLeadingOne.ByFieldsValues.QueryText;
		Query.SetParameter("ObjectReference", Source.Ref);
	EndIf;
	
	Source.AdditionalProperties.Insert(
		"FieldValueAccessManagementForChangeCheckOnWrite",
		Query.ExecuteBatch());
	
EndProcedure

// For the RememberDataAffectingDependentAccessKeys and CheckAccessToRecordSet procedures.
Function FilterByRecordSetDimensions(RecordSet, Query, NewCombinationsQuery = Undefined)
	
	FilterByDimensions = "";
	
	For Each FilterElement In RecordSet.Filter Do
		If Not FilterElement.Use Then
			Continue;
		EndIf;
		FilterByDimensions = FilterByDimensions + ?(FilterByDimensions = "", "", "
		|	AND ") + "CurrentTable." + FilterElement.Name + " = &Simple" + FilterElement.Name; // @query-part-1
		
		If Query <> Undefined Then
			Query.SetParameter("Simple" + FilterElement.Name, FilterElement.Value);
		EndIf;
		If NewCombinationsQuery <> Undefined Then
			NewCombinationsQuery.SetParameter("Simple" + FilterElement.Name, FilterElement.Value);
		EndIf;
	EndDo;
	
	If FilterByDimensions = "" Then
		FilterByDimensions = "TRUE";
	EndIf;
	
	Return FilterByDimensions;
	
EndFunction

// For the CheckAccessBeforeWriteSource procedure.
Procedure SetAllowedAccessKeyForNewObject(Source, IsFullUser)
	
	If IsFullUser Then
		Return;
	EndIf;
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	RefToNew = UsersInternal.ObjectRef2(Source);
	AllowedAccessKey = AccessManagementInternalCached.AllowedAccessKey();
	
	RecordSet = InformationRegisters.AccessKeysForObjects.CreateRecordSet();
	RecordSet.Filter.Object.Set(RefToNew);
	
	Record = RecordSet.Add();
	Record.Object = RefToNew;
	Record.UsersAccessKey        = AllowedAccessKey;
	Record.ExternalUsersAccessKey = AllowedAccessKey;
	
	RecordSet.Write();
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
EndProcedure

// For the CheckAccessBeforeWriteSource and CheckAccessOnWriteSource procedures.
Procedure CheckAccessToSource(Source, BeforeWrite, IsRecordSet, Replacing, IsFullUser)
	
	If BeforeWrite And IsFullUser Then
		Return;
	EndIf;
	
	FullName = Source.Metadata().FullName();
	TransactionID = Source.AdditionalProperties.AccessManagementTransactionID;
	AllRestrictionParameters = RectrictionParametersOnAccessCheck(Source, FullName, TransactionID);
	
	If Users.IsExternalUserSession() Then
		RestrictionParameters               = AllRestrictionParameters.ForExternalUsers;
		RestrictionParametersAdditional = AllRestrictionParameters.ForUsers
	Else
		RestrictionParameters               = AllRestrictionParameters.ForUsers;
		RestrictionParametersAdditional = AllRestrictionParameters.ForExternalUsers
	EndIf;
	
	If RestrictionParameters.AccessDenied And Not IsFullUser Then
		If RestrictionParameters.ForExternalUsers Then
			ErrorTemplate =
				NStr("en = 'External users cannot access the data of the
				           |""%1"" list.';");
		Else
			ErrorTemplate =
				NStr("en = 'Users cannot access the data of the
				           |""%1"" list.';");
		EndIf;
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(ErrorTemplate,
			Source.Metadata().Presentation());
		Raise ErrorText;
	EndIf;
	
	If IsRecordSet Then
		CheckAccessToRecordSet(Source, BeforeWrite, Replacing, IsFullUser,
			TransactionID, RestrictionParameters, RestrictionParametersAdditional);
	Else
		CheckAccessToObject(Source, BeforeWrite, IsFullUser,
			TransactionID, RestrictionParameters, RestrictionParametersAdditional);
	EndIf;
	
EndProcedure

// For the CheckAccessToSource procedure.
//
// Returns:
//   See CalculatedRestrictionParameters
//
Function RectrictionParametersOnAccessCheck(Source, FullName, TransactionID)
	
	Return RestrictionParameters(FullName, TransactionID, Null);
	
EndFunction

// For the CheckAccessToSource procedure.
Procedure CheckAccessToObject(Source, BeforeWrite, IsFullUser,
			TransactionID, RestrictionParameters, RestrictionParametersAdditional)
	
	IsNew = Not Source.AdditionalProperties.Property(
		"FieldValueAccessManagementForChangeCheckOnWrite");
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	If Not BeforeWrite Then
		AccessKeyUpdated = False;
		
		UpdateObjectAccessKeyOnWrite(Source, IsNew, TransactionID,
			RestrictionParameters, AccessKeyUpdated);
		
		UpdateObjectAccessKeyOnWrite(Source, IsNew, TransactionID,
			RestrictionParametersAdditional);
		
		If Not AccessKeyUpdated Then
			Return;
		EndIf;
	EndIf;
	
	If RestrictionParameters.RestrictionDisabled Or IsFullUser Then
		Return;
	EndIf;
	
	Query = New Query;
	Query.Text = RestrictionParameters.ReadEditRightsCheckQueryText;
	
	AdditionCheck = False;
	If Not BeforeWrite Then
		ClarifyInsertRight(Query, IsNew, RestrictionParameters, AdditionCheck);
	EndIf;
	
	UpdateAllowedSetsInSessionParameters();
	
	Query.SetParameter("Object", Source.Ref);
	SetAllowedSetsInQueryParameters(Query);
	
	If RestrictionParameters.UsesRestrictionByOwner Then
		Query.SetParameter("RightSettingsTableID",
			RestrictionParameters.RightSettingsTableID);
	EndIf;
	
	If Not AccessCheckQueryResult(Query, Source).IsEmpty() Then
		Return; // Access is allowed.
	EndIf;
	
	If AdditionCheck Then
		Query.Text = RestrictionParameters.ReadEditRightsCheckQueryText;
		EditRight = Not Query.Execute().IsEmpty();
	Else
		EditRight = False;
	EndIf;
	
	If RestrictionParameters.RightToWriteRestrictionDisabled Then
		ReadRight1 = True;
	Else
		Query.Text = RestrictionParameters.ReadRightsCheckQueryText;
		ReadRight1 = Not Query.Execute().IsEmpty();
	EndIf;
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
	Data = ?(BeforeWrite, Source.Ref, Source);
	ReportAccessError(Data, BeforeWrite, ReadRight1, EditRight, IsNew);
	
EndProcedure

// For the CheckAccessToObject procedure and the AccessAllowed function.
Procedure ClarifyInsertRight(Query, IsNew, RestrictionParameters, AdditionCheck)
	
	AdditionCheck = IsNew And Not RestrictionParameters.UsesRestrictionByOwner;
	If Not AdditionCheck Then
		Return;
	EndIf;
	
	Query.Text = StrReplace(Query.Text,
		"AllowedAccessKeys.RightUpdate", "AllowedAccessKeys.AddRight");
	
EndProcedure

// For the CheckAccessToObject procedure.
Procedure UpdateObjectAccessKeyOnWrite(Source, IsNew, TransactionID,
			RestrictionParameters, AccessKeyUpdated = False)
	
	If RestrictionParameters.AccessDenied
	 Or (RestrictionParameters.RestrictionDisabled
	      And Not RestrictionParameters.WithAccessKeyEntryForDependentListsWithoutKeys) Then
		Return;
	EndIf;
	
	If Not IsNew And Not SourceAccessKeyObsolete(Source.Ref, RestrictionParameters, Source) Then
		Return;
	EndIf;
	
	UpdateAccessKeysOfDataItemsOnWrite(Source.Ref,
		RestrictionParameters, TransactionID,,, Source);
	
	AccessKeyUpdated = True;
	
EndProcedure

// For the CheckAccessToObject and the CheckAccessToRecordSet procedures.
Function AccessCheckQueryResult(Query, Source)
	
	Return Query.Execute();
	
EndFunction

// For the CheckAccessToSource procedure.
Procedure CheckAccessToRecordSet(Source, BeforeWrite, Replacing, IsFullUser,
			TransactionID, RestrictionParameters, RestrictionParametersAdditional)
	
	If    BeforeWrite And (Not Replacing Or IsFullUser)
	 Or Not BeforeWrite And Source.Count() = 0 Then
		Return;
	EndIf;
	
	FilterByDimensions = "";
	Query = ?(RestrictionParameters.RestrictionDisabled Or IsFullUser,
		Undefined, New Query);
	
	UpdateRecordSetAccessKeys(Source, BeforeWrite, Replacing,
		TransactionID, RestrictionParameters, FilterByDimensions, Query);
	
	UpdateRecordSetAccessKeys(Source, BeforeWrite, Replacing,
		TransactionID, RestrictionParametersAdditional, "", Undefined);
	
	If Query = Undefined Then
		Return;
	EndIf;
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	Query.Text = StrReplace(RestrictionParameters.ReadEditRightsCheckQueryText,
		"&FilterByDimensions", FilterByDimensions);
	
	UpdateAllowedSetsInSessionParameters();
	SetAllowedSetsInQueryParameters(Query);
	
	If AccessCheckQueryResult(Query, Source).IsEmpty() Then
		Return; // Access is allowed.
	EndIf;
	
	If RestrictionParameters.RightToWriteRestrictionDisabled Then
		ReadRight1 = True;
	Else
		Query.Text = StrReplace(RestrictionParameters.ReadRightsCheckQueryText,
			"&FilterByDimensions", FilterByDimensions);
		ReadRight1 = Query.Execute().IsEmpty();
	EndIf;
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
	ReportAccessError(Source, BeforeWrite, ReadRight1, False, False);
	
EndProcedure

// For the CheckAccessToRecordSet procedure and the AccessAllowed function.
Procedure UpdateRecordSetAccessKeys(Source, BeforeWrite, Replacing,
			TransactionID, RestrictionParameters, FilterByDimensions, Query)
	
	If RestrictionParameters.AccessDenied
	 Or RestrictionParameters.RestrictionDisabled
	 Or RestrictionParameters.UsesRestrictionByOwner
	   And Query = Undefined Then
		
		Return;
	EndIf;
	
	If Not BeforeWrite Then
		NewCombinationsQuery = New Query;
	EndIf;
	
	If Replacing Then
		FilterByDimensions = FilterByRecordSetDimensions(Source, Query, NewCombinationsQuery);
	Else
		BasicFieldsValuesCombinations = BasicFieldsValuesCombinations(Source,
			FilterByDimensions, RestrictionParameters);
		
		If Query <> Undefined Then
			Query.SetParameter("BasicFieldsValuesCombinations", BasicFieldsValuesCombinations);
		EndIf;
		NewCombinationsQuery.SetParameter("BasicFieldsValuesCombinations", BasicFieldsValuesCombinations);
	EndIf;
	
	If BeforeWrite Or RestrictionParameters.UsesRestrictionByOwner Then
		Return;
	EndIf;
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	UpdateAccessKeysOfNewBasicFieldsCombinationsValues(NewCombinationsQuery,
		FilterByDimensions, Source, RestrictionParameters);
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
EndProcedure

// For the CheckAccessBeforeWriteSource procedure.
Procedure WriteAccessKeysOfNewBasicFieldsCombinationsValuesBeforeWrite(Source, IsFullUser)
	
	If IsFullUser Or Source.Count() = 0 Then
		Return;
	EndIf;
	
	FullName = Source.Metadata().FullName();
	TransactionID = Source.AdditionalProperties.AccessManagementTransactionID;
	RestrictionParameters = RestrictionParameters(FullName, TransactionID);
	
	If RestrictionParameters.RestrictionDisabled
	 Or RestrictionParameters.UsesRestrictionByOwner Then
		Return;
	EndIf;
	
	NewCombinationsQuery = New Query;
	FilterByDimensions = "";
	
	NewCombinationsQuery.SetParameter("BasicFieldsValuesCombinations",
		BasicFieldsValuesCombinations(Source, FilterByDimensions, RestrictionParameters));
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	UpdateAccessKeysOfNewBasicFieldsCombinationsValues(NewCombinationsQuery,
			FilterByDimensions, Source, RestrictionParameters);
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
EndProcedure

// For the CheckAccessToRecordSet and
// WriteAccessKeysOfNewBasicFieldsCombinationsValuesBeforeWrite procedures.
//
Function BasicFieldsValuesCombinations(Source, FilterByDimensions, RestrictionParameters)
	
	Fields = StrConcat(RestrictionParameters.BasicFields.UsedItems, ",");
	Fields = AccessManagementInternalCached.FieldsInMetadataCharsRegister(RestrictionParameters.List, Fields);
	BasicFieldsValuesCombinations = Source.Unload(, Fields);
	BasicFieldsValuesCombinations.GroupBy(Fields);
	
	FilterFields = "";
	For Each Field In RestrictionParameters.BasicFields.UsedItems Do
		FilterFields = FilterFields + ?(FilterFields = "", "", ", ") + "CurrentTable." + Field;
	EndDo;
	FilterByDimensions = "(" + FilterFields + ") IN (&BasicFieldsValuesCombinations)"; // @query-part-2
	
	Return BasicFieldsValuesCombinations;
	
EndFunction

// For the CheckAccessToRecordSet and
// WriteAccessKeysOfNewBasicFieldsCombinationsValuesBeforeWrite procedures.
//
Procedure UpdateAccessKeysOfNewBasicFieldsCombinationsValues(NewCombinationsQuery,
			FilterByDimensions, Source, RestrictionParameters)
	
	DataItems = DataItemsOfNewBasicFieldsCombinationsValues(NewCombinationsQuery,
		FilterByDimensions, Source, RestrictionParameters);
	
	If DataItems.Count() = 0 Then
		Return;
	EndIf;
	
	UpdateAccessKeysOfDataItemsOnWrite(DataItems, RestrictionParameters,
		Source.AdditionalProperties.AccessManagementTransactionID,,, Source);
	
EndProcedure

// For the UpdateAccessKeysOfNewBasicFieldsCombinationsValues procedure.
Function DataItemsOfNewBasicFieldsCombinationsValues(NewCombinationsQuery,
			FilterByDimensions, Source, RestrictionParameters)
	
	If NewCombinationsQuery.Parameters.Property("BasicFieldsValuesCombinations") Then
		NewCombinationsQuery.Text =
			RestrictionParameters.NewBasicFieldsValuesCombinationsQueryTextForNewRecords;
	Else
		NewCombinationsQuery.Text = StrReplace(
			RestrictionParameters.NewBasicFieldsValuesCombinationsQueryTextForExistingRecords,
			"&FilterByDimensions",
			FilterByDimensions);
	EndIf;
	
	NewCombinationsQueryResult = NewCombinationsQuery.Execute();
	If NewCombinationsQueryResult.IsEmpty() Then
		Return New Array;
	EndIf;
	
	DataItems = NewCombinationsQueryResult.Unload();
	DataItems.Columns.Add("CurrentRef", New TypeDescription("Number"));
	IndexOf = 0;
	For Each DataElement In DataItems Do
		DataElement.CurrentRef = IndexOf;
		IndexOf = IndexOf + 1;
	EndDo;
	
	Return DataItems;
	
EndFunction

// For the CheckAccessToObject and the CheckAccessToRecordSet procedures.
Procedure ReportAccessError(Data, OldVersion, HasReadRight, HasUpdateRight, IsNew)
	
	If OldVersion Then
		If HasReadRight Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'Insufficient rights to edit data:
				           |%1';"), DataPresentation(Data));
		Else
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'Insufficient rights to read data:
				           |%1';"), DataPresentation(Data));
		EndIf;
	Else
		If HasReadRight And HasUpdateRight Then
			If IsNew Then
				ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("en = 'Insufficient rights to add data (no Add right):
					           |%1';"), DataPresentation(Data));
			Else
				ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("en = 'Insufficient rights to add data (no Add right for the latest changes):
					           |%1';"), DataPresentation(Data));
			EndIf;
		ElsIf HasReadRight Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'Insufficient rights to add data (you will be unable to change it):
				           |%1';"), DataPresentation(Data));
		Else
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'Insufficient rights to add data (no Read right):
				           |%1.';"), DataPresentation(Data));
		EndIf;
	EndIf;
	
	Raise ErrorText;
	
EndProcedure

// For the ReportAccessError procedure.
Function DataPresentation(Data)
	
	If TypeOf(Data) = Type("String") Then
		Return TrimAll(Data);
	EndIf;
	
	If TypeOf(Data) = Type("Structure") Then
		IsRegister = True;
		If TypeOf(Data.Register) = Type("String") Then
			MetadataObject = Common.MetadataObjectByFullName(Data.Register);
		Else
			MetadataObject = Metadata.FindByType(TypeOf(Data.Register));
		EndIf;
	Else
		MetadataObject = Metadata.FindByType(TypeOf(Data));
		IsRegister = Common.IsRegister(MetadataObject);
	EndIf;
	
	If MetadataObject = Undefined Then
		Return "";
	EndIf;
	
	If IsRegister Then
		DataPresentation = MetadataObject.Presentation();
		
		FieldsCount = 0;
		For Each FilterElement In Data.Filter Do
			If FilterElement.Use Then
				FieldsCount = FieldsCount + 1;
			EndIf;
		EndDo;
		
		If FieldsCount = 1 Then
			DataPresentation = DataPresentation
				+ " " + NStr("en = 'with the following field:';")  + " " + String(Data.Filter);
			
		ElsIf FieldsCount > 1 Then
			DataPresentation = DataPresentation
				+ " " + NStr("en = 'with the following fields:';") + " " + String(Data.Filter);
		EndIf;
	Else
		DataPresentation = String(Data);
		MetadataPresentation = Common.ObjectPresentation(MetadataObject);
		
		If Not StrEndsWith(DataPresentation, "(" + MetadataPresentation + ")")
		   And Not StrStartsWith(DataPresentation, MetadataPresentation) Then
			
			DataPresentation = StringFunctionsClientServer.SubstituteParametersToString("%1 (%2)",
				DataPresentation, MetadataPresentation);
		EndIf;
	EndIf;
		
	Return DataPresentation;
	
EndFunction

// For the CheckAccessToObject procedure and the AccessUpdateManualControl form.
//
// Returns:
//  Boolean
//
Function SourceAccessKeyObsolete(ObjectReference, RestrictionParameters, Source = Undefined) Export
	
	If RestrictionParameters.DoNotWriteAccessKeys Then
		Return False;
	EndIf;
	
	Query = New Query;
	Query.SetParameter("Ref", ObjectReference);
	
	If Not ValueIsFilled(RestrictionParameters.FieldsComposition) Then
		Query.SetParameter("List",
			Common.MetadataObjectID(RestrictionParameters.List));
	EndIf;
	
	Query.Text = RestrictionParameters.DataItemWithObsoleteKeysQueryText;
	
	If RestrictionParameters.ListWithDate Then
		Query.Text = StrReplace(Query.Text,
			"CurrentList.Date BETWEEN &StartDate AND &EndDate", "CurrentList.Ref = &Ref"); // @query-part-1 @query-part-2
	Else
		Query.Text = StrReplace(Query.Text,
			"CurrentList.Ref >= &LastProcessedRef", "CurrentList.Ref = &Ref"); // @query-part-1 @query-part-2
	EndIf;
	SetQueryPlanClarification(Query.Text);
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	If Query.Execute().IsEmpty() Then
		Return False;
	EndIf;
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
	Return True;
	
EndFunction

// For the CheckAccessToObject and CheckAccessToRecordSet procedures, and the AccessUpdateManualControl form.
Procedure UpdateAccessKeysOfDataItemsOnWrite(DataItemsDetails, RestrictionParameters,
			TransactionID, UpdateRightsToKeys = False, HasRightsChanges = False, Source = Undefined) Export
	
	If RestrictionParameters.DoNotWriteAccessKeys Then
		Return;
	EndIf;
	
	If TypeOf(DataItemsDetails) = Type("ValueTable") Then
		DataItems = DataItemsDetails;
	Else
		DataItems = New ValueTable;
		DataItems.Columns.Add("CurrentRef");
		DataItems.Add().CurrentRef = DataItemsDetails;
	EndIf;
	
	ListPropertiesAsLeadingOne = ListPropertiesAsLeadingOne(RestrictionParameters.List,
		TransactionID);
	UsersKindPropertyName = ?(RestrictionParameters.ForExternalUsers,
		"ForExternalUsers", "ForUsers");
	
	ParametersOfUpdate = New Structure(RestrictionParameters);
	ParametersOfUpdate.Insert("HasRightsChanges",       HasRightsChanges);
	ParametersOfUpdate.Insert("UpdateRightsToKeys",    UpdateRightsToKeys);
	ParametersOfUpdate.Insert("TransactionID", TransactionID);
	ParametersOfUpdate.Insert("ListID",
		Common.MetadataObjectID(RestrictionParameters.List));
	
	If ListPropertiesAsLeadingOne = Undefined
	 Or ListPropertiesAsLeadingOne.ByAccessKeys = Undefined
	 Or ListPropertiesAsLeadingOne.ByAccessKeys[UsersKindPropertyName] = Undefined Then
		
		ParametersOfUpdate.Insert("DependentListsByAccessKeys", New Array);
	Else
		ParametersOfUpdate.Insert("DependentListsByAccessKeys",
			ListPropertiesAsLeadingOne.ByAccessKeys[UsersKindPropertyName]);
	EndIf;
	
	UpdateAccessKeysOfListDataItemsBatch(DataItems, ParametersOfUpdate);
	
	HasRightsChanges = ParametersOfUpdate.HasRightsChanges;
	
EndProcedure

// For the AccessValuesGroups information register.
Procedure ScheduleUpdateOfDependentListsByValuesWithGroups(ValuesWithChangesByTypes) Export
	
	If Not LimitAccessAtRecordLevelUniversally() Then
		Return;
	EndIf;
	
	TransactionID = New UUID;
	
	ListsToUpdate = New Map;
	For Each ValuesDetails In ValuesWithChangesByTypes Do
		FullLeadingListName = Metadata.FindByType(ValuesDetails.Key).FullName();
		ListPropertiesAsLeadingOne = ListPropertiesAsLeadingOne(FullLeadingListName, TransactionID);
		If ListPropertiesAsLeadingOne = Undefined
		 Or ListPropertiesAsLeadingOne.ByValuesWithGroups = Undefined Then
			Continue;
		EndIf;
		AddListsForUsersKindUpdate(ListsToUpdate,
			ListPropertiesAsLeadingOne.ByValuesWithGroups, "ForUsers");
		
		AddListsForUsersKindUpdate(ListsToUpdate,
			ListPropertiesAsLeadingOne.ByValuesWithGroups, "ForExternalUsers");
	EndDo;
	
	ScheduleUpdateOfObsoleteAccessKeys(ListsToUpdate,
		TransactionID,
		"ScheduleUpdateOfDependentListsByValuesWithGroups",
		?(ValuesWithChangesByTypes.Count() <> 1 Or ValuesDetails.Value = True,
			Undefined, New Structure("ByValuesWithGroups", ValuesDetails.Value)));
	
EndProcedure

// For the ScheduleUpdateOfDependentListsByValuesWithGroups procedure.
Procedure AddListsForUsersKindUpdate(ListsToUpdate, ByValuesWithGroups, UsersKindName)
	
	FullNames = ByValuesWithGroups[UsersKindName];
	If FullNames = Undefined Then
		Return;
	EndIf;
	
	For Each FullName In FullNames Do
		ListForUpdate = ListsToUpdate.Get(FullName);
		If ListForUpdate = Undefined Then
			ListForUpdate = New Structure("ForUsers, ForExternalUsers", False, False);
			ListsToUpdate.Insert(FullName, ListForUpdate);
		EndIf;
		ListForUpdate[UsersKindName] = True;
	EndDo;
	
EndProcedure

// For the ScheduleUpdateOfDependentObsoleteAccessKeys, WriteObjectsAccessKeys,
// ScheduleUpdateOfDependentListsByValuesWithGroups procedures.
//
Procedure ScheduleUpdateOfObsoleteAccessKeys(ListsToUpdate, TransactionID,
			LongDesc, LeadingObject = Undefined, IsUpdateContinuation = False)
	
	If TypeOf(ListsToUpdate) = Type("Map")
	   And ListsToUpdate.Count() = 0
	 Or TypeOf(ListsToUpdate) = Type("Structure")
	   And ListsToUpdate.ListsNames.Count() = 0 Then
		
		Return;
	EndIf;
	
	Lists = New Array;
	ListsForUsers = New Array;
	ListsForExternalUsers = New Array;
	
	If TypeOf(ListsToUpdate) = Type("Map") Then
		For Each ListDetails In ListsToUpdate Do
			FullName = ListDetails.Key;
			Properties  = ListDetails.Value;
			
			If Properties.ForUsers Then
				RestrictionParameters = RestrictionParameters(FullName, TransactionID, False);
				
				If RestrictionParameters.RestrictionDisabled
				 Or RestrictionParameters.AccessDenied
				 Or RestrictionParameters.UsesRestrictionByOwner Then
					
					Properties.ForUsers = False;
				EndIf;
			EndIf;
			
			If Properties.ForExternalUsers Then
				RestrictionParameters = RestrictionParameters(FullName, TransactionID, True);
				
				If RestrictionParameters.RestrictionDisabled
				 Or RestrictionParameters.AccessDenied
				 Or RestrictionParameters.UsesRestrictionByOwner Then
					
					Properties.ForExternalUsers = False;
				EndIf;
			EndIf;
			
			If Properties.ForUsers And Properties.ForExternalUsers Then
				Lists.Add(FullName);
			
			ElsIf Properties.ForUsers Then
				ListsForUsers.Add(FullName);
				
			ElsIf Properties.ForExternalUsers Then
				ListsForExternalUsers.Add(FullName);
			EndIf;
		EndDo;
	Else
		For Each FullName In ListsToUpdate.ListsNames Do
			RestrictionParameters = RestrictionParameters(FullName,
				TransactionID, ListsToUpdate.ForExternalUsers);
			
			If RestrictionParameters.RestrictionDisabled
			 Or RestrictionParameters.AccessDenied
			 Or RestrictionParameters.UsesRestrictionByOwner Then
				
				Continue;
			EndIf;
			
			If ListsToUpdate.ForExternalUsers Then
				ListsForExternalUsers.Add(FullName);
			Else
				ListsForUsers.Add(FullName);
			EndIf;
		EndDo;
	EndIf;
	
	If LongDesc = "FillAccessRestrictionParametersCache" Then
		Return;
	EndIf;
	
	PlanningParameters = AccessUpdatePlanningParameters(False);
	PlanningParameters.AllowedAccessKeys = False;
	PlanningParameters.LongDesc = LongDesc;
	PlanningParameters.LeadingObject = LeadingObject;
	PlanningParameters.IsUpdateContinuation = IsUpdateContinuation;
	ScheduleAccessUpdate(Lists, PlanningParameters);
	
	PlanningParameters.ForExternalUsers = False;
	ScheduleAccessUpdate(ListsForUsers, PlanningParameters);
	
	PlanningParameters.ForUsers = False;
	PlanningParameters.ForExternalUsers = True;
	ScheduleAccessUpdate(ListsForExternalUsers, PlanningParameters);
	
EndProcedure

// For the CheckAccessOnWriteSource, CheckAccessBeforeDeleteSource procedure.
Procedure ScheduleUpdateOfDependentObsoleteAccessKeys(Source, IsRecordSet, Delete)
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	FullName = Source.Metadata().FullName();
	ListPropertiesAsLeadingOne = ListPropertiesAsLeadingOne(FullName,
		Source.AdditionalProperties.AccessManagementTransactionID);
	
	If ListPropertiesAsLeadingOne = Undefined
	 Or ListPropertiesAsLeadingOne.ByFieldsValues = Undefined Then
		Return;
	EndIf;
	
	If Source.AdditionalProperties.Property("FieldValueAccessManagementForChangeCheckOnWrite") Then
		QueryResults = Source.AdditionalProperties.FieldValueAccessManagementForChangeCheckOnWrite;
	Else
		QueryResults = Undefined;
	EndIf;
	
	ChangesByFieldsValues = New Structure;
	ChangesByFieldsValues.Insert("LongDesc", ?(IsRecordSet, Source.Filter, Source.Ref));
	ChangesByFieldsValues.Insert("ChangedTable", FullName);
	ChangesByFieldsValues.Insert("ChangesContent");
	
	LeadingObject = LeadingObjectDetails();
	LeadingObject.Insert("ByFieldsValues", ChangesByFieldsValues);
	
	ByFieldsValues = ListPropertiesAsLeadingOne.ByFieldsValues;
	HeaderFields = ByFieldsValues.HeaderFields;
	
	PlanningParameters = AccessUpdatePlanningParameters(False);
	PlanningParameters.AllowedAccessKeys = False;
	PlanningParameters.LongDesc = "ScheduleUpdateOfDependentObsoleteAccessKeys";
	PlanningParameters.LeadingObject = LeadingObject;
	
	If IsRecordSet Then
		If ValueIsFilled(HeaderFields.AllFields) Then
			QueryResult = ?(QueryResults = Undefined, Undefined, QueryResults[0]);
			ScheduleUpdateOfDependentObsoleteAccessKeysByFieldsValues(QueryResult,
				Source, HeaderFields.FieldsSets, PlanningParameters);
		EndIf;
	Else
		If ValueIsFilled(HeaderFields.AllFields) Then
			QueryResult = ?(QueryResults = Undefined, Undefined, QueryResults[0]);
			NewValues = New ValueTable;
			For Each FieldName In HeaderFields.AllFields Do
				NewValues.Columns.Add(FieldName, HeaderFields.AllFieldsTypes.Get(FieldName).Get());
			EndDo;
			If Not Delete Then
				FillPropertyValues(NewValues.Add(), Source);
			EndIf;
			ScheduleUpdateOfDependentObsoleteAccessKeysByFieldsValues(QueryResult,
				NewValues, HeaderFields.FieldsSets, PlanningParameters);
			IndexOf = 1;
		Else
			IndexOf = 0;
		EndIf;
		For Each TabularSectionDetails In ByFieldsValues.TabularSections Do
			QueryResult = ?(QueryResults = Undefined, Undefined, QueryResults[IndexOf]);
			ChangesByFieldsValues.ChangedTable = FullName + "." + TabularSectionDetails.Name;
			NewValues = NewTabularSectionValues(Source, TabularSectionDetails, Delete);
			// 
			ScheduleUpdateOfDependentObsoleteAccessKeysByFieldsValues(QueryResult,
				NewValues, TabularSectionDetails.FieldsSets, PlanningParameters);
			IndexOf = IndexOf + 1;
		EndDo;
	EndIf;
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
EndProcedure

// Returns:
//   Structure:
//     * ByFieldsValues - Structure:
//         ** LongDesc          - AnyRef
//                              - Filter
//         ** ChangedTable - String - a full list name
//         ** ChangesContent   - See TableChangesContent
//     * ByAccessKeys      - CatalogRef.AccessKeys
//     * ByValuesWithGroups - DefinedType.AccessValue - the access values with groups only.
//     * AccordingToTheRightsCalculationCache - String - a data description for the right calculation cash.
//
Function LeadingObjectDetails()
	
	Return New Structure;
	
EndFunction

// For the ScheduleUpdateOfDependentObsoleteAccessKeys procedure.
Function NewTabularSectionValues(Source, TabularSectionDetails, Delete)
	
	Fields = New Array(TabularSectionDetails.AllFields);
	
	FieldNameRef = "Ссылка"; // @Non-NLS
	IndexOf = Fields.Find(FieldNameRef);
	If IndexOf <> Undefined Then
		Fields.Delete(IndexOf);
	Else
		FieldNameRef = "Ref";
		IndexOf = Fields.Find(FieldNameRef);
		If IndexOf <> Undefined Then
			Fields.Delete(IndexOf);
		EndIf;
	EndIf;
	
	NewValues = Source[TabularSectionDetails.Name].Unload(
		?(Delete, New Array, Undefined), StrConcat(Fields, ", ")); // ValueTable
	
	If IndexOf <> Undefined Then
		Types = New Array;
		Types.Add(TypeOf(Source.Ref));
		NewValues.Columns.Add(FieldNameRef, New TypeDescription(Types));
		NewValues.FillValues(Source.Ref, FieldNameRef);
	EndIf;
	
	Return NewValues;
	
EndFunction

// For the ScheduleUpdateOfDependentObsoleteAccessKeys procedure.
Procedure ScheduleUpdateOfDependentObsoleteAccessKeysByFieldsValues(QueryResult,
			Source, FieldsSetsByUsersKinds, PlanningParameters)
	
	UsersKinds = New Array;
	UsersKinds.Add("ForUsers");
	UsersKinds.Add("ForExternalUsers");
	
	For Each UsersKind In UsersKinds Do
		FieldsSets = FieldsSetsByUsersKinds[UsersKind];
		If FieldsSets = Undefined Then
			Continue;
		EndIf;
		If UsersKind = "ForUsers" Then
			PlanningParameters.ForExternalUsers = False;
			PlanningParameters.ForUsers = True;
		Else
			PlanningParameters.ForExternalUsers = True;
			PlanningParameters.ForUsers = False;
		EndIf;
		For Each FieldsSetDetails In FieldsSets Do
			ChangesContent = TableChangesContent(QueryResult, Source, FieldsSetDetails.Key);
			If ChangesContent = Null Then
				Continue;
			EndIf;
			For Each DependentTablesDetails In FieldsSetDetails.Value Do
				If DependentTablesDetails.Key = FieldsSetDetails.Key
				 Or ChangesContent = Undefined Then
					CurrentChangesContent = ChangesContent;
				Else
					CurrentChangesContent = ChangesContent.Copy(, DependentTablesDetails.Key);
					CurrentChangesContent.GroupBy(DependentTablesDetails.Key);
				EndIf;
				PlanningParameters.LeadingObject.ByFieldsValues.ChangesContent = CurrentChangesContent;
				// 
				ScheduleAccessUpdate(DependentTablesDetails.Value, PlanningParameters);
			EndDo;
		EndDo;
	EndDo;
	
EndProcedure

// For the ScheduleUpdateOfDependentObsoleteAccessKeysByFieldsValues procedure.
//
// Returns:
//   ValueTable
//
Function TableChangesContent(QueryResult, Source, Fields)
	
	MaxCombinations = MaxCombinationsCountOfLeadingFieldsValuesOnCalculateContentOfChangedOnes();
	If QueryResult = Undefined Then
		OldCombinations = New ValueTable;
	Else
		OldCombinations = QueryResult.Unload();
		If StrSplit(Fields, ",").Count() < OldCombinations.Columns.Count() Then
			OldCombinations.GroupBy(Fields);
		EndIf;
	EndIf;
	
	If OldCombinations.Count() >= MaxCombinations Then
		Return Undefined;
	EndIf;
	
	If TypeOf(Source) = Type("ValueTable") Then
		NewCombinations = Source.Copy(, Fields);
	Else
		NewCombinations = Source.Unload(, Fields);
	EndIf;
	NewCombinations.GroupBy(Fields);
	
	If NewCombinations.Count() >= MaxCombinations Then
		Return Undefined;
	EndIf;
	
	ChangesContent = NewCombinations.Copy(New Array);
	
	NewCombinations.Columns.Add("ChangeType", New TypeDescription("Number"));
	NewCombinations.FillValues(1, "ChangeType");
	For Each String In OldCombinations Do
		NewRow = NewCombinations.Add();
		FillPropertyValues(NewRow, String);
		NewRow.ChangeType = -1;
	EndDo;
	NewCombinations.GroupBy(Fields, "ChangeType");
	
	For Each String In NewCombinations Do
		If String.ChangeType <> 0 Then
			FillPropertyValues(ChangesContent.Add(), String);
		EndIf;
	EndDo;
	
	Return ?(ChangesContent.Count() > 0, ChangesContent, Null);
	
EndFunction

Procedure LockRegistersSchedulingUpdateAccessKeysInFileIB()
	
	Block = New DataLock;
	LockItem = Block.Add("InformationRegister.AccessRestrictionParameters");
	LockItem.Mode = DataLockMode.Shared;
	Block.Lock();
	
	Block = New DataLock;
	Block.Add("InformationRegister.DataAccessKeysUpdate");
	Block.Add("InformationRegister.UsersAccessKeysUpdate");
	Block.Lock();
	
EndProcedure

// For call and manager module of the AccessGroups catalog.
Procedure ScheduleAccessUpdateOnChangeAccessGroupMembers(AccessGroup,
			ChangedMembersTypes, OnImport = False) Export
	
	If Not ChangedMembersTypes.Users
	   And Not ChangedMembersTypes.ExternalUsers Then
		Return;
	EndIf;
	
	LongDesc = ?(OnImport,
		"ScheduleAccessUpdateOnChangeAccessGroupMembersOnImport",
		"ScheduleAccessUpdateOnChangeAccessGroupMembers");
	
	ScheduleAnUpdateOfTheRightsCalculationCache(LongDesc, "AccessGroupsMembers");
	
	Query = New Query;
	Query.SetParameter("AccessGroup", AccessGroup);
	Query.Text =
	"SELECT
	|	AccessGroupsTables.Table AS Table
	|FROM
	|	InformationRegister.AccessGroupsTables AS AccessGroupsTables
	|WHERE
	|	AccessGroupsTables.AccessGroup = &AccessGroup";
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	Tables = Query.Execute().Unload();
	
	ScheduleAccessKeysUsersUpdate(Tables, LongDesc,
		ChangedMembersTypes.Users, ChangedMembersTypes.ExternalUsers, True);
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
EndProcedure

// For the AfterUpdateUserGroupsCompositions procedure and
// the manager module of the AccessGroups catalog.
//
Procedure ScheduleAccessUpdateOnIndirectChangeOfAccessGroupMembers(ChangedMembers,
			OnImport = False, AfterSetIBUser = False) Export
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	LongDesc = ?(AfterSetIBUser,
		"ScheduleAnAccessUpdateIfTheAccessGroupMembersChangeIndirectlyAfterTheIBUserIsInstalled",
		?(OnImport,
			"ScheduleAccessUpdateOnIndirectChangeAccessGroupMembersOnImport",
			"ScheduleAccessUpdateOnIndirectChangeOfAccessGroupMembers"));
	
	ScheduleAnUpdateOfTheRightsCalculationCache(LongDesc, "UserGroupCompositions");
	
	If ChangedMembers = Undefined Then
		ForUsers        = True;
		ForExternalUsers = True;
		
		Query = New Query;
		Query.Text =
		"SELECT DISTINCT
		|	AccessGroupsTables.Table AS Table
		|FROM
		|	InformationRegister.AccessGroupsTables AS AccessGroupsTables";
	Else
		ForUsers        = False;
		ForExternalUsers = False;
		
		For Each Member In ChangedMembers Do
			If TypeOf(Member) = Type("CatalogRef.Users")
			 Or TypeOf(Member) = Type("CatalogRef.UserGroups") Then
				
				ForUsers = True;
			
			ElsIf TypeOf(Member) = Type("CatalogRef.ExternalUsers")
			      Or TypeOf(Member) = Type("CatalogRef.ExternalUsersGroups") Then
				
				ForExternalUsers = True;
			EndIf;
		EndDo;
		
		Query = New Query;
		Query.SetParameter("ChangedMembers", ChangedMembers);
		If AfterSetIBUser Then
			Query.Text =
			"SELECT DISTINCT
			|	AccessGroupsTables.Table AS Table
			|FROM
			|	InformationRegister.AccessGroupsTables AS AccessGroupsTables
			|		INNER JOIN Catalog.AccessGroups.Users AS AccessGroupsMembers
			|		ON AccessGroupsTables.AccessGroup = AccessGroupsMembers.Ref
			|		INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
			|		ON (UserGroupCompositions.User IN (&ChangedMembers))
			|			AND (UserGroupCompositions.UsersGroup = AccessGroupsMembers.User)";
		Else
			Query.Text =
			"SELECT DISTINCT
			|	AccessGroupsTables.Table AS Table
			|FROM
			|	InformationRegister.AccessGroupsTables AS AccessGroupsTables
			|		INNER JOIN Catalog.AccessGroups.Users AS AccessGroupsMembers
			|		ON AccessGroupsTables.AccessGroup = AccessGroupsMembers.Ref
			|			AND (AccessGroupsMembers.User IN (&ChangedMembers))";
		EndIf;
	EndIf;
	
	Tables = Query.Execute().Unload();
	
	ScheduleAccessKeysUsersUpdate(Tables,
		LongDesc, ForUsers, ForExternalUsers, True);
	
	ScheduleAccessGroupsSetsUpdate(LongDesc, ForUsers, ForExternalUsers);
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
EndProcedure

// For calling the AccessGroupsTables register from manager module.
Procedure ScheduleAccessUpdateOnChangeAccessGroupsTables(Tables) Export
	
	LongDesc = "ScheduleAccessUpdateOnChangeAccessGroupsTables";
	
	ScheduleAnUpdateOfTheRightsCalculationCache(LongDesc, "AccessGroupsTables");
	
	ScheduleAccessKeysUsersUpdate(Tables, LongDesc, True, True);
	
EndProcedure

// For calling the AccessGroupProfiles catalog from the object module and manager module.
Procedure ScheduleAccessUpdatesWhenProfileRolesChange(LongDesc, ModifiedRoles) Export
	
	ScheduleAnUpdateOfTheRightsCalculationCache(LongDesc, "RolesOfAccessGroupProfiles");
	
	If ModifiedRoles = Undefined
	 Or ModifiedRoles.Count() > 0 Then
		
		ScheduleAccessUpdatesWhenRolesChange(LongDesc, ModifiedRoles);
	EndIf;
	
EndProcedure

// For calling the AccessGroups catalog from the object module and manager module.
Procedure ScheduleAnAccessUpdateWhenTheAccessGroupProfileChanges(LongDesc, ModifiedRoles, ProfileChanged) Export
	
	If ProfileChanged Then
		ScheduleAnUpdateOfTheRightsCalculationCache(LongDesc, "ProfilesAccessGroups");
	EndIf;
	
	If ModifiedRoles = Undefined
	 Or ModifiedRoles.Count() > 0 Then
		
		ScheduleAccessUpdatesWhenRolesChange(LongDesc, ModifiedRoles);
	EndIf;
	
EndProcedure

// For the ScheduleAccessUpdateOnChangeProfileRoles and
//  ScheduleAccessUpdateOnChangeAccessGroupProfile procedures.
//
Procedure ScheduleAccessUpdatesWhenRolesChange(LongDesc, ModifiedRoles)
	
	ActiveParameters = ActiveAccessRestrictionParameters(Undefined, Undefined, False);
	If Not ValueIsFilled(ActiveParameters.LeadingRoles) Then
		Return;
	EndIf;
	
	If ModifiedRoles <> Undefined Then
		RolesMetadata = Common.MetadataObjectsByIDs(ModifiedRoles, False);
		RolesNames = New Map;
		For Each KeyAndValue In RolesMetadata Do
			If TypeOf(KeyAndValue.Value) = Type("MetadataObject") Then
				RolesNames.Insert(KeyAndValue.Value.Name, True);
			EndIf;
		EndDo;
	EndIf;
	
	ListsForUsers = New Array;
	ListsForExternalUsers = New Array;
	AddedListsForUsers = New Map;
	AddedListsForExternalUsers = New Map;
	
	For Each DescriptionOfTheLeadingRole In ActiveParameters.LeadingRoles Do
		If ModifiedRoles <> Undefined
		   And RolesNames.Get(DescriptionOfTheLeadingRole.Key) = Undefined Then
			Continue;
		EndIf;
		AddListsOfTheLeadingRoleToUpdateTheRights(ListsForUsers,
			DescriptionOfTheLeadingRole.Value.ForUsers, AddedListsForUsers);
		AddListsOfTheLeadingRoleToUpdateTheRights(ListsForExternalUsers,
			DescriptionOfTheLeadingRole.Value.ForExternalUsers, AddedListsForExternalUsers);
	EndDo;
	
	PlanningParameters = AccessUpdatePlanningParameters(False);
	PlanningParameters.DataAccessKeys = False;
	PlanningParameters.LongDesc = LongDesc;
	
	PlanningParameters.ForExternalUsers = False;
	ScheduleAccessUpdate(ListsForUsers, PlanningParameters);
	
	PlanningParameters.ForUsers = False;
	PlanningParameters.ForExternalUsers = True;
	ScheduleAccessUpdate(ListsForExternalUsers, PlanningParameters);
	
EndProcedure

// For the ScheduleAccessUpdateOnChangeRoles procedure.
Procedure AddListsOfTheLeadingRoleToUpdateTheRights(Lists, ListsOfTheLeadingRole, AddedLists)
	
	If Not ValueIsFilled(ListsOfTheLeadingRole) Then
		Return;
	EndIf;
	
	For Each ListDetails In ListsOfTheLeadingRole Do
		If AddedLists.Get(ListDetails.Key) <> Undefined Then
			Continue;
		EndIf;
		AddedLists.Insert(ListDetails.Key, True);
		Lists.Add(ListDetails.Key);
	EndDo;

EndProcedure

// For calling the AccessGroupsValues register from the manager module.
Procedure ScheduleAccessUpdateOnChangeAllowedValues(AccessGroupsAndValuesTypes) Export
	
	LongDesc = "ScheduleAccessUpdateOnChangeAllowedValues";
	
	ScheduleAnUpdateOfTheRightsCalculationCache(LongDesc, "AccessGroupsValues");
	
	Query = New Query;
	Query.SetParameter("AccessGroupsAndValuesTypes", AccessGroupsAndValuesTypes);
	Query.Text =
	"SELECT
	|	AccessGroupsAndValuesTypes.AccessGroup AS AccessGroup,
	|	AccessGroupsAndValuesTypes.AccessValuesType AS AccessValuesType
	|INTO AccessGroupsAndValuesTypes
	|FROM
	|	&AccessGroupsAndValuesTypes AS AccessGroupsAndValuesTypes
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT DISTINCT
	|	AccessGroupsTables.Table AS Table,
	|	VALUETYPE(AccessGroupsAndValuesTypes.AccessValuesType) AS AccessValuesType
	|FROM
	|	InformationRegister.AccessGroupsTables AS AccessGroupsTables
	|		INNER JOIN AccessGroupsAndValuesTypes AS AccessGroupsAndValuesTypes
	|		ON AccessGroupsTables.AccessGroup = AccessGroupsAndValuesTypes.AccessGroup
	|TOTALS BY
	|	Table";
	
	TablesAndAccessValuesTypes = Query.Execute().Unload(QueryResultIteration.ByGroups);
	
	ScheduleAccessKeysUsersUpdate(TablesAndAccessValuesTypes.Rows,
		LongDesc, True, True);
	
EndProcedure

// For the ScheduleAccessUpdate, ScheduleAccessRestrictionParametersUpdate procedure.
Function InternalID(FullName)
	
	Query = New Query;
	Query.SetParameter("FullName", FullName);
	Query.Text =
	"SELECT
	|	MetadataObjectIDs.Ref AS Ref
	|FROM
	|	Catalog.MetadataObjectIDs AS MetadataObjectIDs
	|WHERE
	|	MetadataObjectIDs.FullName = &FullName
	|
	|ORDER BY
	|	MetadataObjectIDs.DeletionMark";
	
	Selection = Query.Execute().Select();
	If Selection.Next() Then
		Return Selection.Ref;
	EndIf;
	
	Return Null;
	
EndFunction

// For the ScheduleAccessUpdateOnChangeAccessGroupMembers,
// ScheduleAccessUpdateOnIndirectChangeOfAccessGroupMembers,
// ScheduleAccessUpdateOnChangeAccessGroupsTables,
// ScheduleAccessUpdateOnChangeAllowedValues.
//
Procedure ScheduleAccessKeysUsersUpdate(ListsDetails, LongDesc, ForUsers,
				ForExternalUsers, OnChangeAccessGroupMembers = False, LeadingObject = Undefined)
	
	If ListsDetails.Count() = 0 Then
		Return;
	EndIf;
	
	Context = New Structure;
	Context.Insert("OnChangeAccessGroupMembers", OnChangeAccessGroupMembers);
	Context.Insert("TransactionID",             New UUID);
	Context.Insert("List",                              Undefined);
	Context.Insert("FullName",                           Undefined);
	Context.Insert("AccessValuesTypes",                 Undefined);
	
	If TypeOf(ListsDetails) = Type("FixedArray") Then
		ListsIDsByFullNames = Common.MetadataObjectIDs(ListsDetails);
	Else
		FullNames = ListsDetails.UnloadColumn("Table");
		ListsMetadataObjects = Common.MetadataObjectsByIDs(FullNames, False);
	EndIf;
	
	Lists = New Array;
	ListsForUsers = New Array;
	ListsForExternalUsers = New Array;
	
	For Each ListDetails In ListsDetails Do
		If ListsIDsByFullNames <> Undefined Then
			Context.FullName = ListDetails;
			Context.List = ListsIDsByFullNames.Get(Context.FullName);
		Else
			MetadataObject = ListsMetadataObjects.Get(ListDetails.Table);
			Context.FullName = ?(TypeOf(MetadataObject) = Type("MetadataObject"), MetadataObject.FullName(), "");
			Context.List    = ListDetails.Table;
			If TypeOf(ListDetails) = Type("ValueTreeRow") Then
				Context.AccessValuesTypes = ListDetails.Rows;
			EndIf;
		EndIf;
		If Not ValueIsFilled(Context.FullName) Then
			Continue;
		EndIf;
		PlanForUsers = ForUsers
			And UsersAccessKeysUpdateRequired(Context, False);
		
		PlanForExternalUsers = ForExternalUsers
			And UsersAccessKeysUpdateRequired(Context, True);
		
		If PlanForUsers And PlanForExternalUsers Then
			Lists.Add(Context.FullName);
			
		ElsIf PlanForUsers Then
			ListsForUsers.Add(Context.FullName);
			
		ElsIf PlanForExternalUsers Then
			ListsForExternalUsers.Add(Context.FullName);
		EndIf;
	EndDo;
	
	PlanningParameters = AccessUpdatePlanningParameters(False);
	PlanningParameters.DataAccessKeys = False;
	PlanningParameters.LeadingObject = LeadingObject;
	PlanningParameters.LongDesc = LongDesc;
	ScheduleAccessUpdate(Lists, PlanningParameters);
	
	PlanningParameters.ForExternalUsers = False;
	ScheduleAccessUpdate(ListsForUsers, PlanningParameters);
	
	PlanningParameters.ForUsers = False;
	PlanningParameters.ForExternalUsers = True;
	ScheduleAccessUpdate(ListsForExternalUsers, PlanningParameters);
	
EndProcedure

// For the ScheduleAccessKeysUsersUpdate procedure.
Function UsersAccessKeysUpdateRequired(Context, ForExternalUsers)
	
	ActiveParameters = ActiveAccessRestrictionParameters(Context.TransactionID, Undefined, False);
	If ForExternalUsers Then
		AdditionalContext = ActiveParameters.AdditionalContext.ForExternalUsers;
	Else
		AdditionalContext = ActiveParameters.AdditionalContext.ForUsers;
	EndIf;
	
	If Not Context.OnChangeAccessGroupMembers
	   And AdditionalContext.ListsWithDisabledRestriction.Get(Context.FullName) <> Undefined
	   And AdditionalContext.ListsWithKeysRecordForDependentListsWithoutKeys.Get(Context.FullName) <> Undefined Then
		Return True;
	EndIf;
	
	RestrictionProperties = AdditionalContext.ListRestrictionsProperties.Get(Context.FullName);
	
	If AdditionalContext.ListsWithDisabledRestriction.Get(Context.FullName) <> Undefined
	 Or RestrictionProperties = Undefined
	 Or RestrictionProperties.AccessDenied
	 Or RestrictionProperties.OwnerField <> Undefined
	   And Not RestrictionProperties.OwnerField.Disabled
	 Or Context.OnChangeAccessGroupMembers
	   And Not RestrictionProperties.CalculateUserRights Then
		
		Return False;
	EndIf;
	
	If RestrictionProperties <> Undefined
	   And Context.AccessValuesTypes <> Undefined
	   And Not Context.OnChangeAccessGroupMembers Then
		
		NoUsedTypesAmongChangedAccessValuesTypes = True;
		UsedAccessValuesTypes = RestrictionProperties.UsedAccessValuesTypes.Get(); // Array of Type
		For Each String In Context.AccessValuesTypes Do
			If UsedAccessValuesTypes.Find(String.AccessValuesType) <> Undefined Then
				NoUsedTypesAmongChangedAccessValuesTypes = False;
				Break;
			EndIf;
		EndDo;
		If NoUsedTypesAmongChangedAccessValuesTypes Then
			Return False;
		EndIf;
	EndIf;
	
	Return True;
	
EndFunction

// For the ScheduleAccessUpdateOnIndirectChangeOfAccessGroupMembers procedure, and
// manager modules, and the AccessGroups catalog object.
//
Procedure ScheduleAccessGroupsSetsUpdate(LongDesc, ForUsers = True, ForExternalUsers = True) Export
	
	If Not ForUsers And Not ForExternalUsers Then
		Return;
	EndIf;
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	RecordSet = ServiceRecordSet(InformationRegisters.DataAccessKeysUpdate);
	
	List = "Catalog.SetsOfAccessGroups";
	UniqueKey = New UUID;
	ListID = Common.MetadataObjectID(List);
	CurrentDate = CurrentSessionDate();
	MaxDate = MaxDate();
	
	// Update only by changes (not a full update).
	JobParameters = New Structure;
	SetDataKeyKind(JobParameters, "NewSingleUserSets");
	JobParametersStorage = New ValueStorage(JobParameters);
	
	If ForUsers Then
		NewRecord = RecordSet.Add();
		NewRecord.UniqueKey                   = UniqueKey;
		NewRecord.List                             = ListID;
		NewRecord.ForExternalUsers            = False;
		NewRecord.LatestUpdatedItemDate = MaxDate;
		NewRecord.JobParameters                   = JobParametersStorage;
		NewRecord.JobSize                      = 3;
		NewRecord.RegisterRecordChangeDate        = CurrentDate;
	EndIf;
	
	If ForExternalUsers Then
		NewRecord = RecordSet.Add();
		NewRecord.UniqueKey                   = UniqueKey;
		NewRecord.List                             = ListID;
		NewRecord.ForExternalUsers            = True;
		NewRecord.LatestUpdatedItemDate = MaxDate;
		NewRecord.JobParameters                   = JobParametersStorage;
		NewRecord.JobSize                      = 3;
		NewRecord.RegisterRecordChangeDate        = CurrentDate;
	EndIf;
	
	RecordSet.Write(False);
	
	PlanningParameters = AccessUpdatePlanningParameters(False);
	PlanningParameters.AllowedAccessKeys = False;
	PlanningParameters.ForUsers        = ForUsers;
	PlanningParameters.ForExternalUsers = ForExternalUsers;
	PlanningParameters.LongDesc = LongDesc;
	
	ListsByIDs = New Map;
	ListsByIDs.Insert(ListID, List);
	
	RegisterAccessUpdatePlanning(ListsByIDs, PlanningParameters);
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
EndProcedure

// For the ScheduleAccessUpdateOnChangeAccessGroupMembers,
// ScheduleAccessUpdateOnIndirectChangeOfAccessGroupMembers,
// ScheduleAccessUpdateOnChangeAccessGroupsTables,
// ScheduleAccessUpdateOnChangeAllowedValues.
//
Procedure ScheduleAnUpdateOfTheRightsCalculationCache(LongDesc, NameOfTheChangedData)
	
	PlanningParameters = AccessUpdatePlanningParameters(False);
	PlanningParameters.DataAccessKeys = False;
	PlanningParameters.ForExternalUsers = False;
	PlanningParameters.LongDesc = LongDesc;
	PlanningParameters.LeadingObject = New Structure("AccordingToTheRightsCalculationCache", NameOfTheChangedData);
	ScheduleAccessUpdate(ListForPlanningTheUpdateOfTheRightsCalculationCache(), PlanningParameters);
	
EndProcedure

// For the PrepareUpdatePlan, ScheduleRightsCalculationCacheUpdate procedures
// and the DataVersionForRightsCalculationCache function.
//
Function ListForPlanningTheUpdateOfTheRightsCalculationCache()
	
	Return "InformationRegister.ExtensionVersionParameters";
	
EndFunction

// Returns:
//  Structure:
//    * AccessGroupsTables       - String
//                                - Undefined
//    * AccessGroupsValues      - String
//                                - Undefined
//    * AccessGroupsMembers     - String
//                                - Undefined
//    * UserGroupCompositions - String
//                                - Undefined
//    * RolesOfAccessGroupProfiles  - String
//                                - Undefined
//    * ProfilesAccessGroups     - String
//                                - Undefined
//
Function NewVersionOfTheDataForTheRightsCalculationCache(Version = Undefined) Export
	
	NewVersionOfTheData = New Structure;
	NewVersionOfTheData.Insert("AccessGroupsTables",       Version);
	NewVersionOfTheData.Insert("AccessGroupsValues",      Version);
	NewVersionOfTheData.Insert("AccessGroupsMembers",     Version);
	NewVersionOfTheData.Insert("UserGroupCompositions", Version);
	NewVersionOfTheData.Insert("RolesOfAccessGroupProfiles",  Version);
	NewVersionOfTheData.Insert("ProfilesAccessGroups",     Version);
	
	Return NewVersionOfTheData;
	
EndFunction

// For the ProcessRightsCalculationCacheUpdatePlan procedure.
Function NameOfTheDataVersionParameterForTheRightsCalculationCache()
	
	Return "StandardSubsystems.AccessManagement.DataVersionForTheRightsCalculationCache";
	
EndFunction

#EndRegion

#Region AccessUpdate

// Starts an access update background job instead of a scheduled job.
//
// Parameters:
//  IsManualStart - Boolean - if False is passed, the description will begin with "Autorun",
//                              otherwise, it will begin with "Manual run".
//                              Access update lock will be removed,
//                              execution will continue until the full completion.
//  ThisIsARestart    - Boolean - if True, the current session of background job will not
//                              be considered incomplete.
//
// Returns:
//  - Undefined - 
//  - Structure:
//   * AlreadyRunning - Boolean - if the update is already running.
//
//   * BackgroundJobIdentifier - Undefined - f the update is not running or
//                                      running not in a background job.
//                                  - UUID - ID of the background task.
//
//   * SessionProperties - Undefined - if a background job never started or was just added to the queue.
//                    - Structure - 
//                        ** ComputerName - String - properties of the session information Database object of the same name.
//                        ** SessionNumber   - Number  - properties of the session information Database object of the same name.
//                        ** SessionStarted  - String - properties of the session information Database object of the same name.
//
//   * WarningText - Undefined - if a background job never started or a new background job was started.
//                         - String - 
//
Function StartAccessUpdateAtRecordLevel(IsManualStart = False, ThisIsARestart = False) Export
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	If Not LimitAccessAtRecordLevelUniversally(True) Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Cannot start record-level access update.
			           |Constant ""%1"" is disabled.';"),
			"LimitAccessAtRecordLevelUniversally");
		Raise ErrorText;
	EndIf;
	
	If TransactionActive() Then
		ErrorText =
			NStr("en = 'Cannot start record-level access update in an open transaction.';");
		Raise ErrorText;
	EndIf;
	
	If Not IsManualStart And Not AccessUpdateScheduled() Then
		Return Undefined;
	EndIf;
	
	LastAccessUpdate = LastAccessUpdate();
	If Not IsManualStart And LastAccessUpdate.AccessUpdateProhibited Then
		Return Undefined;
	EndIf;
	
	IDOfJobToExclude = Undefined;
	If ThisIsARestart Then
		CurrentBackgroundJob = GetCurrentInfoBaseSession().GetBackgroundJob();
		If CurrentBackgroundJob <> Undefined Then
			IDOfJobToExclude = CurrentBackgroundJob.UUID;
		EndIf;
	EndIf;
	Result = New Structure("AlreadyRunning, WarningText, BackgroundJobIdentifier, SessionProperties", True, "");
	Performer = AccessUpdateAssignee(LastAccessUpdate, IDOfJobToExclude);
	
	If Performer = Undefined Then
		Result.AlreadyRunning = False;
		If Common.FileInfobase() Then
			Try
				// 
				// 
				StandardSubsystemsServer.CheckApplicationVersionDynamicUpdate();
			Except
				Result.WarningText = ErrorProcessing.BriefErrorDescription(ErrorInfo());
				Return Result;
			EndTry;
		EndIf;
		If IsManualStart Then
			DenyAccessUpdate(False);
			JobParameters = New Array;
			JobParameters.Add(True);
		Else
			JobParameters = Undefined;
		EndIf;
		
		CurrentSession = GetCurrentInfoBaseSession();
		JobDescription =
			?(IsManualStart,
				NStr("en = 'Manual start';", Common.DefaultLanguageCode()),
				NStr("en = 'Autostart';", Common.DefaultLanguageCode()))
			+ ": " + Metadata.ScheduledJobs.AccessUpdateOnRecordsLevel.Synonym + " ("
			+ StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'from the %1 session started on %2';", Common.DefaultLanguageCode()),
				Format(CurrentSession.SessionNumber, "NG="),
				Format(CurrentSession.SessionStarted, "DLF=DT")) + ")";
		
		BackgroundJob = ConfigurationExtensions.ExecuteBackgroundJobWithDatabaseExtensions(
			NameOfTheAccessUpdateTaskMethod(), JobParameters,, JobDescription);
		
		Result.BackgroundJobIdentifier = BackgroundJob.UUID;
		
	ElsIf TypeOf(Performer) = Type("BackgroundJob")
	        And Performer.UUID <> LastAccessUpdate.BackgroundJobIdentifier Then
		
		Result.WarningText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Cannot start the access update as it has already been started on %1 at %2';"),
			Format(Performer.Begin, "DLF=D"),
			Format(Performer.Begin, "DLF=T"));
	Else
		SessionProperties = New Structure("ComputerName, SessionNumber, SessionStarted");
		If TypeOf(Performer) = Type("BackgroundJob") Then
			FillPropertyValues(SessionProperties, LastAccessUpdate);
		Else
			FillPropertyValues(SessionProperties, Performer);
		EndIf;
		Result.SessionProperties = SessionProperties;
		Result.WarningText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'The access update is already running
			           |(computer: %1, session: %2, started on %3 at %4).';"),
			SessionProperties.ComputerName,
			SessionProperties.SessionNumber,
			Format(SessionProperties.SessionStarted, "DLF=D"),
			Format(SessionProperties.SessionStarted, "DLF=T"));
	EndIf;
	
	If TypeOf(Performer) = Type("BackgroundJob") Then
		Result.BackgroundJobIdentifier = Performer.UUID;
	EndIf;
	
	Return Result;
	
EndFunction

// Cancel access update that is running in the background job.
Procedure CancelAccessUpdateAtRecordLevel() Export
	
	Performer = AccessUpdateAssignee(LastAccessUpdate());
	
	If TypeOf(Performer) = Type("InfoBaseSession") Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Cannot cancel full access update
			           |(computer: %1, session: %2, started on %3 at %4).';"),
			Performer.ComputerName,
			Performer.SessionNumber,
			Format(Performer.SessionStarted, "DLF=D"),
			Format(Performer.SessionStarted, "DLF=T"));
		Raise ErrorText;
	EndIf;
	
	Running = TypeOf(Performer) = Type("BackgroundJob");
	
	CompleteAccessUpdateThreads(True);
	DenyAccessUpdate(True, Running);
	
	If Running Then
		Performer = Performer.WaitForExecutionCompletion(BackgroundJobCompletionWaitSeconds());
		If Performer.State = BackgroundJobState.Active Then
			Performer.Cancel();
		EndIf;
	EndIf;
	
	Filter = New Structure;
	Filter.Insert("State", BackgroundJobState.Active);
	Filter.Insert("MethodName", NameOfTheAccessUpdateTaskMethod());
	MainJobs = BackgroundJobs.GetBackgroundJobs(Filter);
	
	For Each MainJob In MainJobs Do
		MainJob = MainJob.WaitForExecutionCompletion(1);
		If MainJob.State = BackgroundJobState.Active Then
			MainJob.Cancel();
		EndIf;
	EndDo;
	
	CancelAccessUpdateThreadsBackgroundJobs();
	
EndProcedure

// For the SetAccessUpdate procedure.
Procedure EnableAccessUpdateScheduledJob() Export
	
	ChangeAccessUpdateScheduledJob(True);
	
EndProcedure

// For the SetAccessUpdate procedure.
Procedure DisableAccessUpdateScheduledJob() Export
	
	ChangeAccessUpdateScheduledJob(False);
	
EndProcedure

// For the SetAccessUpdate procedure.
Procedure ChangeAccessUpdateScheduledJob(EnableJob)
	
	Filter = New Structure("Metadata", Metadata.ScheduledJobs.AccessUpdateOnRecordsLevel);
	
	RequiredToChange = False;
	If Common.FileInfobase() Then
		RequiredToChange = True;
	Else
		SetPrivilegedMode(True);
		Jobs = ScheduledJobsServer.FindJobs(Filter);
		For Each Job In Jobs Do
			If EnableJob <> Job.Use Then
				RequiredToChange = True;
				Break;
			EndIf;
		EndDo;
		SetPrivilegedMode(False);
	EndIf;
	
	If Not RequiredToChange Then
		Return;
	EndIf;
	
	Block = New DataLock;
	Block.Add("Constant.AccessUpdateThreadsCount");
	
	IsLockError = False;
	NumberOfTheBlockingAttempt = 0;
	While True Do
		NumberOfTheBlockingAttempt = NumberOfTheBlockingAttempt + 1;
		BeginTransaction();
		Try
			IsLockError = True;
			Block.Lock();
			IsLockError = False;
			SetPrivilegedMode(True);
			Jobs = ScheduledJobsServer.FindJobs(Filter);
			For Each Job In Jobs Do
				If EnableJob = Job.Use Then
					Continue;
				EndIf;
				ScheduledJobsServer.ChangeJob(Job,
					New Structure("Use", EnableJob));
			EndDo;
			SetPrivilegedMode(False);
			CommitTransaction();
		Except
			RollbackTransaction();
			If IsLockError
			   And NumberOfTheBlockingAttempt <= 3
			   And Not TransactionActive() Then
				Continue;
			EndIf;
			Raise;
		EndTry;
		Break;
	EndDo;
	
EndProcedure

// Enables or disables the prohibition of updating access during startup
// using a scheduled job or during application startup.
//
// When calling the AccessUpdateOnRecordsLevel procedure
// with the UpdateAll flag, the prohibition is ignored.
// 
// When calling the StartAccessUpdateAtRecordLevel procedure
// with the IsManualStart flag, the prohibition is removed automatically.
//
Procedure DenyAccessUpdate(Use, CancelUpdate = False) Export
	
	DataLock = New DataLock;
	DataLock.Add("Constant.LastAccessUpdate");
	
	HasExternalTransaction = TransactionActive();
	BeginTransaction();
	Try
		DataLock.Lock();
		ConstantValue = Constants.LastAccessUpdate.Get();
		LastAccessUpdate = LastAccessUpdate(ConstantValue);
		
		Write = False;
		If LastAccessUpdate.AccessUpdateProhibited <> Use Then
			LastAccessUpdate.AccessUpdateProhibited = Use;
			Write = True;
		EndIf;
		
		If CancelUpdate
		   And LastAccessUpdate.StartDateAtServer > LastAccessUpdate.EndDateAtServer
		   And ( Not LastAccessUpdate.RefreshEnabledCanceled
		      Or LastAccessUpdate.CompletionErrorText <> "") Then
			
			LastAccessUpdate.RefreshEnabledCanceled = True;
			LastAccessUpdate.CompletionErrorText = "";
			LastAccessUpdate.FullCompletionDate = '00010101';
			LastAccessUpdate.EndDateAtServer = CurrentDateAtServer();
			LastAccessUpdate.LastExecutionSeconds =
				LastAccessUpdate.EndDateAtServer - LastAccessUpdate.StartDateAtServer
					+ BackgroundJobCompletionWaitSeconds() + 1;
			Write = True;
		EndIf;
		
		If Write Then
			InstallTheLatestAccessUpdate(LastAccessUpdate, HasExternalTransaction);
		EndIf;
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

// For the CancelAccessUpdateAtRecordLevel, DenyAccessUpdate procedures.
Function BackgroundJobCompletionWaitSeconds()
	
	If Common.FileInfobase() Then
		Return 3;
	Else
		Return 15;
	EndIf;
	
EndFunction

// AccessUpdateOnRecordsLevel scheduled job handler.
Procedure AccessUpdateOnRecordsLevel(UpdateAll = False, RaiseExceptiopnInsteadErrorRegistration = False) Export
	
	// 
	// 
	// 
	// 
	// 
	// 
	// 
	
	Common.OnStartExecuteScheduledJob(
		Metadata.ScheduledJobs.AccessUpdateOnRecordsLevel);
	
	ExecuteAccessUpdateAtRecordLevel(UpdateAll, RaiseExceptiopnInsteadErrorRegistration, 0);
	
EndProcedure

// Updates access if it is scheduled.
Procedure ExecuteAccessUpdateAtRecordLevel(UpdateAll,
			RaiseExceptiopnInsteadErrorRegistration, SecondsNotMore, AfterIBUpdate = False)
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	CurrentSession = GetCurrentInfoBaseSession();
	MainSessionDetails = MainSessionDetails();
	MainSessionDetails.Insert("SessionNumber",  CurrentSession.SessionNumber);
	MainSessionDetails.Insert("SessionStarted", CurrentSession.SessionStarted);
	
	If CurrentSession.ApplicationName <> "BackgroundJob" Then
		If UpdateAll Then
			BackgroundJobIdentifier = ArbitrarySessionID();
		Else
			ErrorText = NStr("en = 'Cannot update access in batches. The batch update is available only in background jobs.';");
			Raise ErrorText;
		EndIf;
		MainSessionID = String(New UUID);
	Else
		CurrentBackgroundJob = CurrentSession.GetBackgroundJob();
		If CurrentBackgroundJob = Undefined Then
			ErrorText = NStr("en = 'Cannot get the background job of the current session.';");
			Raise ErrorText;
		EndIf;
		BackgroundJobIdentifier = CurrentBackgroundJob.UUID;
		MainSessionDetails.BackgroundJob = CurrentBackgroundJob;
		MainSessionDetails.BackgroundJobIdentifier = BackgroundJobIdentifier;
		MainSessionID = String(BackgroundJobIdentifier);
	EndIf;
	MainSessionDetails.Insert("Id", MainSessionID
		+ " (" + NStr("en = 'Main session ID';") + ")");
	
	DataLock = New DataLock;
	DataLock.Add("Constant.LastAccessUpdate");
	
	HasExternalTransaction = TransactionActive();
	BeginTransaction();
	Try
		DataLock.Lock();
		ConstantValue = Constants.LastAccessUpdate.Get();
		LastAccessUpdate = LastAccessUpdate(ConstantValue);
		
		If UpdateAll Or Not LastAccessUpdate.AccessUpdateProhibited Then
			Performer = AccessUpdateAssignee(LastAccessUpdate, BackgroundJobIdentifier);
			
			If Performer = Undefined Then
				LastAccessUpdate.RefreshEnabledCanceled   = False;
				LastAccessUpdate.StartDateAtServer = CurrentDateAtServer();
				LastAccessUpdate.SessionNumber          = CurrentSession.SessionNumber;
				LastAccessUpdate.SessionStarted         = CurrentSession.SessionStarted;
				LastAccessUpdate.ComputerName        = CurrentSession.ComputerName;
				LastAccessUpdate.BackgroundJobIdentifier = BackgroundJobIdentifier;
				
				InstallTheLatestAccessUpdate(LastAccessUpdate, HasExternalTransaction);
			EndIf;
		EndIf;
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
	If Not UpdateAll And LastAccessUpdate.AccessUpdateProhibited Then
		If CurrentBackgroundJob.ScheduledJob <> Undefined Then
			SetAccessUpdate(False);
		EndIf;
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'The access update is denied.
			           |To allow it, in the ""Update access at record level"" window, click ""Allow"".
			           |You can open the window from the ""Users and rights settings"" panel. You can also open it using the following URL:
			           |%1';"),
			"e1cib/app/InformationRegister.DataAccessKeysUpdate.Form.AccessUpdateOnRecordsLevel");
		Raise ErrorText;
	EndIf;
	
	If Performer <> Undefined Then
		If Not UpdateAll Or AfterIBUpdate Then
			Return;
		EndIf;
		
		If TypeOf(Performer) = Type("BackgroundJob")
		   And Performer.UUID <> LastAccessUpdate.BackgroundJobIdentifier Then
			
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'Cannot start the access update as it has already been started on %1 at %2.';"),
				Format(Performer.Begin, "DLF=D"),
				Format(Performer.Begin, "DLF=T"));
		Else
			SessionProperties = ?(TypeOf(Performer) = Type("BackgroundJob"),
				LastAccessUpdate, Performer);
			
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'Cannot start the access update as it is already running
				           |(computer: %1, session: %2, started on %3 at %4).';"),
				SessionProperties.ComputerName,
				SessionProperties.SessionNumber,
				Format(SessionProperties.SessionStarted, "DLF=D"),
				Format(SessionProperties.SessionStarted, "DLF=T"));
		EndIf;
		Raise ErrorText;
	EndIf;
	
	LastAccessUpdate.RefreshEnabledCanceled = False;
	LastAccessUpdate.CompletionErrorText = "";
	LastAccessUpdate.BackgroundJobIdentifier =
		CommonClientServer.BlankUUID();
	
	RestartIsPossible = CurrentBackgroundJob <> Undefined
		And Not UpdateAll
		And Not RaiseExceptiopnInsteadErrorRegistration
		And SecondsNotMore = 0
		And Not AfterIBUpdate;
	
	PlanningErrorText = "";
	AllErrorsText = "";
	CompletionErrorText = "";
	FullCompletionDate = LastAccessUpdate.FullCompletionDate;
	Try
		If LimitAccessAtRecordLevelUniversally() Then
			CheckUpdateActiveAccessRestrictionParameters();
			ScheduleObsoleteItemsProcessing(PlanningErrorText,
				LastAccessUpdate.LastObsoleteItemsProcessingPlanning);
			ExecuteAccessUpdate(UpdateAll, MainSessionDetails,
				LastAccessUpdate.RefreshEnabledCanceled, CompletionErrorText, SecondsNotMore,
				LastAccessUpdate.FullCompletionDate);
			If Not RestartIsPossible Then
				StandardSubsystemsServer.SessionRestartRequired(AllErrorsText);
			EndIf;
		Else
			SetAccessUpdate(False);
		EndIf;
	Except
		If TransactionActive() Then
			Raise;
		EndIf;
		ErrorInfo = ErrorInfo();
		AllErrorsText = ErrorProcessing.DetailErrorDescription(ErrorInfo);
		If RestartIsPossible
		   And StandardSubsystemsServer.ThisErrorRequirementRestartSession(ErrorInfo) Then
			AllErrorsText = "";
		EndIf;
	EndTry;
	
	Try
		CompleteAccessUpdateThreads();
	Except
		ErrorInfo = ErrorInfo();
		AddCompletionErrorText(AllErrorsText, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Cannot close access update threads. Reason:
			           |%1';"),
			ErrorProcessing.DetailErrorDescription(ErrorInfo)));
	EndTry;
	
	Try
		CancelAccessUpdateThreadsBackgroundJobs(2);
	Except
		ErrorInfo = ErrorInfo();
		AddCompletionErrorText(AllErrorsText, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Cannot cancel background jobs of access update threads. Reason:
			           |%1';"),
			ErrorProcessing.DetailErrorDescription(ErrorInfo)));
	EndTry;
	
	AddCompletionErrorText(AllErrorsText, PlanningErrorText);
	AddCompletionErrorText(AllErrorsText, CompletionErrorText);
	
	LastAccessUpdate.EndDateAtServer = CurrentDateAtServer();
	If ValueIsFilled(AllErrorsText) Then
		LastAccessUpdate.FullCompletionDate = '00010101';
	EndIf;
	If Not ValueIsFilled(FullCompletionDate)
	 Or LastAccessUpdate.FullCompletionDate <> FullCompletionDate Then
	
		LastAccessUpdate.CompletionErrorText = AllErrorsText;
		LastAccessUpdate.LastExecutionSeconds =
			LastAccessUpdate.EndDateAtServer - LastAccessUpdate.StartDateAtServer;
	EndIf;
	
	BeginTransaction();
	Try
		DataLock.Lock();
		ConstantValue = Constants.LastAccessUpdate.Get();
		CurrentLastAccessUpdate = LastAccessUpdate(ConstantValue);
		
		LastAccessUpdate.AccessUpdateProhibited =
			CurrentLastAccessUpdate.AccessUpdateProhibited;
		
		InstallTheLatestAccessUpdate(LastAccessUpdate, HasExternalTransaction);
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
	If RestartIsPossible And StandardSubsystemsServer.SessionRestartRequired() Then
		StartAccessUpdateAtRecordLevel(, True);
	EndIf;
	
	If Not ValueIsFilled(AllErrorsText) Then
		Return;
	EndIf;
	
	AllErrorsText = StringFunctionsClientServer.SubstituteParametersToString(
		NStr("en = 'Cannot perform the access update. Reason:
		           |%1';"), AllErrorsText);
	
	If RaiseExceptiopnInsteadErrorRegistration Then
		Raise AllErrorsText;
	Else
		RegisterAccessUpdateError(AllErrorsText,
			New Structure("MainSessionDetails", MainSessionDetails));
	EndIf;
	
EndProcedure

// Returns:
//   Structure:
//     * BackgroundJobIdentifier - UUID
//     * BackgroundJob               - BackgroundJob
//     * SessionNumber                  - Number
//     * SessionStarted                 - Date
//     * Id                - String - session presentation
//
Function MainSessionDetails()
	
	Return New Structure("BackgroundJobIdentifier, BackgroundJob");
	
EndFunction

// For the StartAccessUpdateAtRecordLevel function.
Function AccessUpdateScheduled()
	
	Query = New Query;
	Query.Text =
	"SELECT TOP 1
	|	TRUE AS TrueValue
	|FROM
	|	InformationRegister.DataAccessKeysUpdate AS DataAccessKeysUpdate
	|
	|UNION ALL
	|
	|SELECT TOP 1
	|	TRUE
	|FROM
	|	InformationRegister.UsersAccessKeysUpdate AS UsersAccessKeysUpdate";
	
	Return Not Query.Execute().IsEmpty();
	
EndFunction

// For the StartAccessUpdateAtRecordLevel function,
// the AccessUpdateOnRecordsLevel and CancelAccessUpdateAtRecordLevel procedures,
// and the AccessUpdateOnRecordsLevel form.
//
// Returns:
//  Structure:
//   * StartDateAtServer - Date
//   * EndDateAtServer - Date
//   * RefreshEnabledCanceled - Boolean
//   * LastExecutionSeconds - Number
//   * FullCompletionDate - Date
//   * CompletionErrorText - String
//   * SessionNumber - Number
//   * ComputerName - String
//   * AccessUpdateProhibited - Boolean
//   * DiskLoadBalancing - Boolean
//   * BackgroundJobIdentifier - UUID
//   * LastObsoleteItemsProcessingPlanning - Date
//
Function LastAccessUpdate(CurrentValue = Undefined) Export
	
	If CurrentValue = Undefined Then
		Query = New Query;
		Query.Text =
		"SELECT
		|	LastAccessUpdate.Value AS Value
		|FROM
		|	Constant.LastAccessUpdate AS LastAccessUpdate";
		
		Selection = Query.Execute().Select();
		CurrentValue = ?(Selection.Next(), Selection.Value, Undefined);
	EndIf;
	
	Properties = New Structure;
	Properties.Insert("StartDateAtServer",      '00010101');
	Properties.Insert("EndDateAtServer",   '00010101');
	Properties.Insert("RefreshEnabledCanceled",        False);
	Properties.Insert("LastExecutionSeconds", 0);
	Properties.Insert("FullCompletionDate",     '00010101');
	Properties.Insert("CompletionErrorText",     "");
	Properties.Insert("SessionNumber",               0);
	Properties.Insert("SessionStarted",              '00010101');
	Properties.Insert("ComputerName",             "");
	Properties.Insert("AccessUpdateProhibited", False);
	Properties.Insert("DiskLoadBalancing", True);
	Properties.Insert("AccessID");
	Properties.Insert("BackgroundJobIdentifier",
		CommonClientServer.BlankUUID());
	Properties.Insert("LastObsoleteItemsProcessingPlanning", '00010101');
	
	If TypeOf(CurrentValue) <> Type("ValueStorage") Then
		Return Properties;
	EndIf;
	
	CurrentProperties = CurrentValue.Get();
	
	If TypeOf(CurrentProperties) <> Type("Structure") Then
		Return Properties;
	EndIf;
	
	FillPropertyValues(Properties, CurrentProperties);
	
	Return Properties;
	
EndFunction

// For the ExecuteAccessUpdateAtRecordLevel,
// DenyAccessUpdate and SetDiskLoadBalancing procedures.
// 
Procedure InstallTheLatestAccessUpdate(Properties, HasExternalTransaction)
	
	If Not ValueIsFilled(Properties.AccessID) And Not HasExternalTransaction Then
		Properties.AccessID = New UUID;
	EndIf;
	
	ValueManager = ServiceValueManager(Constants.LastAccessUpdate);
	ValueManager.Value = New ValueStorage(Properties);
	ValueManager.Write();
	
EndProcedure

// For the LimitAccessAtRecordLevelUniversally constant.
Procedure ClearLastAccessUpdate() Export
	
	Properties = LastAccessUpdate(Null);
	FillPropertyValues(Properties, LastAccessUpdate(),
		"AccessID, AccessUpdateProhibited, DiskLoadBalancing");
	
	ValueManager = ServiceValueManager(Constants.LastAccessUpdate);
	ValueManager.Value = New ValueStorage(Properties);
	ValueManager.Write();
	
EndProcedure

// For the StartAccessUpdateAtRecordLevel function,
// the AccessUpdateOnRecordsLevel and CancelAccessUpdateAtRecordLevel procedures,
// and the AccessUpdateOnRecordsLevel form.
//
// Parameters:
//  LastAccessUpdate - See LastAccessUpdate
//  IDOfJobToExclude - UUID
//                                   - Undefined
// 
// Returns:
//  - BackgroundJob
//  - InfoBaseSession
//  - Undefined
//
Function AccessUpdateAssignee(LastAccessUpdate, IDOfJobToExclude = Undefined) Export
	
	If ValueIsFilled(LastAccessUpdate.BackgroundJobIdentifier) Then
		If LastAccessUpdate.BackgroundJobIdentifier = ArbitrarySessionID() Then
			Sessions = GetInfoBaseSessions();
			For Each Session In Sessions Do
				If Session.SessionNumber  = LastAccessUpdate.SessionNumber
				   And Session.SessionStarted = LastAccessUpdate.SessionStarted Then
					Return Session;
				EndIf;
			EndDo;
		Else
			ActiveBackgroundJob = BackgroundJobs.FindByUUID(
				LastAccessUpdate.BackgroundJobIdentifier);
		
			If ActiveBackgroundJob <> Undefined
			   And ActiveBackgroundJob.State = BackgroundJobState.Active Then
				
				Return ActiveBackgroundJob;
			EndIf;
		EndIf;
	EndIf;
	
	Filter = New Structure("State, MethodName", BackgroundJobState.Active,
		NameOfTheAccessUpdateTaskMethod());
	
	FoundJobs = BackgroundJobs.GetBackgroundJobs(Filter);
	For Each FoundJob In FoundJobs Do
		If FoundJob.UUID <> IDOfJobToExclude Then
			Return FoundJob;
		EndIf;
	EndDo;
	
	Return Undefined;
	
EndFunction

// For the AccessUpdateOnRecordsLevel and AccessUpdateAssignee procedures.
Function ArbitrarySessionID()
	
	Return New UUID("ba4730f7-0493-402d-b5d3-8052c80fb125");
	
EndFunction

// For AccessUpdateOnRecordsLevel, AddAccessUpdateJobs procedures.
Procedure CheckUpdateActiveAccessRestrictionParameters()
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	InformationRegisters.UsedAccessKinds.UpdateRegisterData(, True);
	
	ExtensionsVersionUpdateDate = Catalogs.ExtensionsVersions.LastExtensionsVersion().UpdateDate;
	
	AllApplicationParametersUpdateDate =
		InformationRegisters.ApplicationRuntimeParameters.AllApplicationParametersUpdateDate();
	
	LastFillingDateOfAllExtensionsParameters =
		InformationRegisters.ExtensionVersionParameters.LastFillingDateOfAllExtensionsParameters();
	
	ActiveParameters = ActiveAccessRestrictionParameters(Undefined, Undefined, False);
	AccessRestrictionParametersCreationDate = SessionParameters.AccessRestrictionParameters.CreationDate;
	
	ParameterName = "StandardSubsystems.AccessManagement.AccessRestrictionParametersCheckDate";
	AccessRestrictionParametersCheckDate = StandardSubsystemsServer.ExtensionParameter(ParameterName, True);
	If TypeOf(AccessRestrictionParametersCheckDate) <> Type("Date") Then
		AccessRestrictionParametersCheckDate = '00010101';
	EndIf;
	
	If AccessRestrictionParametersCheckDate > AccessRestrictionParametersCreationDate Then
		AccessRestrictionParametersRelevanceDate = AccessRestrictionParametersCheckDate;
	Else
		AccessRestrictionParametersRelevanceDate = AccessRestrictionParametersCreationDate;
	EndIf;
	
	AccessKindsUsageChanged = AccessKindsUsageChanged(ActiveParameters);
	
	If ExtensionsVersionUpdateDate                         > AccessRestrictionParametersRelevanceDate
	 Or AllApplicationParametersUpdateDate            > AccessRestrictionParametersRelevanceDate
	 Or LastFillingDateOfAllExtensionsParameters > AccessRestrictionParametersRelevanceDate
	 Or AccessKindsUsageChanged Then
		
		If Common.FileInfobase() Then
			// 
			Common.SubsystemExists("StandardSubsystems.AccessManagement"); // StandardSubsystemsПовтИсп.ИменаПодсистем
			AccessManagementInternalCached.ConstantLimitAccessAtRecordLevel();
			AccessManagementInternalCached.ConstantLimitAccessAtRecordLevelUniversally();
		EndIf;
		
		If AccessKindsUsageChanged Then
			Try
				InformationRegisters.UsedAccessKinds.WhenChangingTheUseOfAccessTypes();
			Except
				InformationRegisters.UsedAccessKinds.WhenChangingTheUseOfAccessTypes();
			EndTry;
		EndIf;
		Try
			UpdateAccessGroupsTablesForEnabledExtensions();
		Except
			UpdateAccessGroupsTablesForEnabledExtensions();
		EndTry;
		If SessionParameters.AccessRestrictionParameters.Version > 100000000000000 Then
			Try
				ReduceVersionNumbersOfAccessRestrictionParameters();
			Except
				ReduceVersionNumbersOfAccessRestrictionParameters();
			EndTry;
		EndIf;
		NewDateForCheckingAccessRestrictionSettings = CurrentSessionDate();
		Try
			ActiveAccessRestrictionParameters(Undefined, Undefined, True);
		Except
			ActiveAccessRestrictionParameters(Undefined, Undefined, True);
		EndTry;
		Try
			StandardSubsystemsServer.SetExtensionParameter(ParameterName,
				NewDateForCheckingAccessRestrictionSettings, True);
		Except
			StandardSubsystemsServer.SetExtensionParameter(ParameterName,
				NewDateForCheckingAccessRestrictionSettings, True);
		EndTry;
	EndIf;
	
	// Deleting obsolete parameters of access restriction.
	Query = New Query;
	Query.SetParameter("CurrentVersion",   SessionParameters.AccessRestrictionParameters.Version);
	Query.SetParameter("ExpirationDate", CurrentSessionDate() - 2 * 24 * 60 *60);
	Query.Text =
	"SELECT
	|	AccessRestrictionParameters.Version AS Version,
	|	AccessRestrictionParameters.CreationDate AS CreationDate
	|FROM
	|	InformationRegister.AccessRestrictionParameters AS AccessRestrictionParameters
	|WHERE
	|	AccessRestrictionParameters.Version < &CurrentVersion
	|	AND AccessRestrictionParameters.CreationDate <= &ExpirationDate
	|
	|ORDER BY
	|	Version DESC,
	|	CreationDate DESC";
	
	// 
	// 
	// 
	// 
	// 
	// 
	// 
	// 
	QueryResult = Query.Execute();
	// ACC:1328-on.
	If QueryResult.IsEmpty() Then
		Return;
	EndIf;
	
	RecordSet = InformationRegisters.AccessRestrictionParameters.CreateRecordSet();
	
	Selection = QueryResult.Select();
	While Selection.Next() Do
		RecordSet.Filter.Version.Set(Selection.Version);
		Try
			RecordSet.Write();
		Except
			RecordSet.Write();
		EndTry;
	EndDo;
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
EndProcedure

// For the CheckUpdateActiveAccessRestrictionParameters procedure.
Procedure ReduceVersionNumbersOfAccessRestrictionParameters()
	
	Block = New DataLock;
	Block.Add("InformationRegister.AccessRestrictionParameters");
	
	BeginTransaction();
	Try
		Block.Lock();
		RecordSet = InformationRegisters.AccessRestrictionParameters.CreateRecordSet();
		RecordSet.Read();
		Upload0 = RecordSet.Unload();
		Upload0.Sort("Version");
		CurrentVersion = 1;
		For Each String In Upload0 Do
			String.Version = CurrentVersion;
			CurrentVersion = CurrentVersion + 1;
		EndDo;
		RecordSet.Load(Upload0);
		RecordSet.Write();
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

// For the CheckUpdateActiveAccessRestrictionParameters procedure.
Function AccessKindsUsageChanged(ActiveParameters)
	
	If ActiveParameters.ExternalUsersEnabled
	        <> Constants.UseExternalUsers.Get()
	 Or ActiveParameters.AccessRestrictionEnabled
	        <> Constants.LimitAccessAtRecordLevel.Get() Then
		Return True;
	EndIf;
	
	AccessKindsProperties = AccessKindsProperties();
	CurrentUsedValuesTypes = UsedValuesTypes(AccessKindsProperties,,, True);
	
	UsedValuesTypes = ActiveParameters.UsedValuesTypes.Get();
	
	If TypeOf(UsedValuesTypes) <> Type("Structure")
	 Or Not UsedValuesTypes.Property("HashSum")
	 Or UsedValuesTypes.HashSum <> CurrentUsedValuesTypes.HashSum Then
		Return True;
	EndIf;
	
	Return False;
	
EndFunction

// For the AccessUpdateOnRecordsLevel, RunAccessUpdate,
// CancelAccessUpdateAtRecordLevel, CompleteAccessUpdate procedures.
//
Procedure CompleteAccessUpdateThreads(CancelUpdate = False)
	
	RecordSet = ServiceRecordSet(InformationRegisters.UsersAccessKeysCurrentJobs);
	
	If CancelUpdate Then
		RecordSet.Add().ThreadID = CancelUpdateAtRecordLevelID();
	Else
		Query = New Query;
		Query.Text =
		"SELECT TOP 1
		|	TRUE AS TrueValue
		|FROM
		|	InformationRegister.UsersAccessKeysCurrentJobs AS UsersAccessKeysCurrentJobs";
		
		If Query.Execute().IsEmpty() Then
			Return;
		EndIf;
	EndIf;
	
	RecordSet.Write();
	
EndProcedure

// For the ProcessCompletedJob, CompleteAccessUpdateThreads procedures.
Function CancelUpdateAtRecordLevelID()
	
	Return New UUID("06cc4b5f-a2f9-4622-bef0-df4870ab5dd5");
	
EndFunction

// For the AccessUpdateOnRecordsLevel, RunAccessUpdate,
// CancelAccessUpdateAtRecordLevel, CompleteAccessUpdate procedures.
//
Procedure CancelAccessUpdateThreadsBackgroundJobs(WaitSeconds = 5)
	
	Filter = New Structure;
	Filter.Insert("State", BackgroundJobState.Active);
	Filter.Insert("MethodName", AccessUpdateThreadMethodName());
	
	ThreadsBackgroundJobs = BackgroundJobs.GetBackgroundJobs(Filter);
	If ThreadsBackgroundJobs.Count() = 0 Then
		Return;
	EndIf;
	
	ThreadsBackgroundJobs = BackgroundJobs.WaitForExecutionCompletion(ThreadsBackgroundJobs, WaitSeconds);
	For Each ThreadBackgroundJob In ThreadsBackgroundJobs Do
		If ThreadBackgroundJob.State = BackgroundJobState.Active Then
			ThreadBackgroundJob.Cancel();
		EndIf;
	EndDo;
	
EndProcedure

// Updates access keys to data based on the records of the DataAccessKeysUpdate information register
// and user access keys based on the records
// of the UsersAccessKeysUpdate information register.
//
// Data batch for each table is updated starting from the most recent data.
// The procedure must be called again until the data processor is completed,
// while the scheduled job is stopped.
//
// The procedure is designed to function in a single copy without parallel
// operation (call from the AccessUpdateAtRecordLevel scheduled job procedure).
// Parallel operation is ensured by the procedure itself by running up to two background jobs
// for each list, but not more than the AccessUpdateThreadsCount constant value.
//
Procedure ExecuteAccessUpdate(Val UpdateAll, MainSessionDetails,
				RefreshEnabledCanceled, CompletionErrorText, SecondsNotMore, FullCompletionDate)
	
	If SecondsNotMore > 0 Then
		UpdateAll = False;
	EndIf;
	
	Context = AccessUpdateNewContext();
	Context.Insert("MainSessionDetails",  MainSessionDetails);
	Context.Insert("CurrentBackgroundJob",    MainSessionDetails.BackgroundJob);
	Context.Insert("Jobs",                  UpdateJobsTable());
	Context.Insert("JobsForStartup",        New Array);
	Context.Insert("LockedThreads",            New Map);
	Context.Insert("FreeThreads",          New Array);
	Context.Insert("JobsUpdateBoundary", '00010101');
	Context.Insert("CommonUpdateParameters", CommonUpdateParametersDetails());
	Context.Insert("UpdateInThisSession",    False);
	Context.Insert("ThreadsCount",        0);
	Context.Insert("FullCompletionDate",    FullCompletionDate);
	Context.Insert("CompletionErrorText",    "");
	Context.Insert("HasDeferredJobs",    False);
	Context.Insert("HasStartedJob",    True);
	Context.Insert("ProcessingCompleted",       False);
	Context.Insert("RefreshEnabledCanceled",       False);
	Context.Insert("SessionRestartRequired",False);
	Context.Insert("MaxBatchesFromOriginalItem", 0);
	Context.Insert("AdditionalBatchesCount", 0);
	Context.Insert("HasLongRunningJobOfReceivingDataItemsBatches", False);
	Context.Insert("MaxSecondsCountOfQuickDataItemsBatchReceipt", 0);
	Context.Insert("DisabledMetadataObjectsIDs", New Map);
	Context.Insert("AccessGroupsSetsCatalogID",
		Common.MetadataObjectID("Catalog.SetsOfAccessGroups"));
	MainSessionDetails.Delete("BackgroundJob");
	
	Query = New Query;
	Query.Text = JobsQueryText();
	Query.SetParameter("MaxDate", MaxDate());
	Query.SetParameter("BlankID",
		CommonClientServer.BlankUUID());
	
	CompleteAccessUpdateThreads();
	CancelAccessUpdateThreadsBackgroundJobs(1);
	
	Jobs = Context.Jobs;
	LockedThreads = Context.LockedThreads;
	
	If SecondsNotMore > 0 Then
		ExecutionEnd = CurrentSessionDate() + SecondsNotMore;
	Else
		ExecutionEnd = CurrentSessionDate()
			+ MaxCountOfMinutesToPerformBackgroundAccessUpdateJob() * 60;
	EndIf;
	
	FillThreadsCount(Context);
	Context.Insert("Indicators", LeadingThreadUpdateIndicators(Context));
	
	While True Do
		If Not UpdateAll And CurrentSessionDate() > ExecutionEnd
		 Or ValueIsFilled(Context.CompletionErrorText) Then
			Break;
		EndIf;
		Context.ProcessingCompleted = True;
		
		FillThreadsCount(Context);
		// 
		ProcessExecutedJobs(Context);
		
		If Context.RefreshEnabledCanceled Or Context.SessionRestartRequired Then
			Context.ProcessingCompleted = False;
			Break;
		EndIf;
		
		QueryResults = Query.ExecuteBatch();
		AddAccessUpdateJobs(QueryResults, Context);
		
		If Context.SessionRestartRequired Then
			Context.ProcessingCompleted = False;
			Break;
		ElsIf Context.ProcessingCompleted Then
			UpdateTheListOfUsedVersionsOfTemplateParameters(Context);
			If Not Context.ProcessingCompleted Then
				Continue;
			EndIf;
			Break;
		EndIf;
		Context.FullCompletionDate = '00010101';
		
		CurrentStartupCompletion = CurrentSessionDate() + 5;
		Context.Insert("FirstPass", True);
		
		While True Do
			
			If Not UpdateAll And CurrentSessionDate() > ExecutionEnd
			 Or CurrentSessionDate() > CurrentStartupCompletion
			 Or ValueIsFilled(Context.CompletionErrorText)
			 Or Jobs.Count() = 0
			 Or Context.RefreshEnabledCanceled
			 Or Context.SessionRestartRequired Then
				Break;
			EndIf;
			
			AbortPass = False;
			PassAbortionMoment = CurrentUniversalDateInMilliseconds() + 1000;
			FillCommonUpdateParameters(Context);
			Context.HasStartedJob = False;
			JobsForStartup = Context.JobsForStartup;
			
			For Each Job In JobsForStartup Do
				
				While LockedThreads.Count() >= Context.ThreadsCount Do
					// 
					ProcessExecutedJobs(Context);
					
					If Context.RefreshEnabledCanceled Or Context.SessionRestartRequired Then
						AbortPass = True;
						Break;
					EndIf;
					
					If LockedThreads.Count() >= Context.ThreadsCount Then
						If Not UpdateAll And CurrentSessionDate() > ExecutionEnd
						 Or CurrentSessionDate() > CurrentStartupCompletion Then
							AbortPass = True;
							Break;
						EndIf;
						// 
						WaitForThreadToUnlock(Context, True);
						If Not Context.FirstPass
						   And CurrentUniversalDateInMilliseconds() > PassAbortionMoment Then
							AbortPass = True;
							Break;
						EndIf;
					EndIf;
				EndDo;
				If AbortPass Then
					Break;
				EndIf;
				If LockedThreads.Count() < Context.ThreadsCount Then
					// 
					StartListAccessUpdate(Job, Context);
					If ValueIsFilled(Context.CompletionErrorText)
					 Or Context.RefreshEnabledCanceled
					 Or Context.SessionRestartRequired Then
						Break;
					EndIf;
				EndIf;
			EndDo;
			If Not Context.HasStartedJob
			   And (LockedThreads.Count() >= Context.ThreadsCount
			      Or Not Context.HasDeferredJobs) Then
				// 
				WaitForThreadToUnlock(Context, True);
			EndIf;
			// 
			ProcessExecutedJobs(Context);
			Context.FirstPass = False;
		EndDo;
	EndDo;
	
	If Not Context.ProcessingCompleted
	   And Not ValueIsFilled(Context.CompletionErrorText)
	   And Not Context.RefreshEnabledCanceled
	   And Not Context.SessionRestartRequired Then
		
		UpdateTheListOfUsedVersionsOfTemplateParameters(Context);
	EndIf;
	
	CompleteAccessUpdate(Context);
	
	CompletionErrorText = Context.CompletionErrorText;
	RefreshEnabledCanceled    = Context.RefreshEnabledCanceled;
	FullCompletionDate = Context.FullCompletionDate;
	
EndProcedure

// Returns:
//  Structure:
//   * MainSessionDetails - See MainSessionDetails
//   * CurrentBackgroundJob - BackgroundJob
//   * Jobs - See UpdateJobsTable
//   * JobsForStartup - Array of ValueTableRow: см. ТаблицаЗаданийОбновления
//   * LockedThreads - Map of KeyAndValue:
//      ** Key - UUID
//      ** Value - See NewThread
//   * FreeThreads - Array of See NewThread
//   * JobsUpdateBoundary - Date
//   * CommonUpdateParameters - See CommonUpdateParametersDetails
//   * UpdateInThisSession - Boolean
//   * ThreadsCount - Number
//   * FullCompletionDate - Date
//   * CompletionErrorText - String
//   * HasDeferredJobs - Boolean
//   * HasStartedJob - Boolean
//   * ProcessingCompleted - Boolean
//   * RefreshEnabledCanceled - Boolean
//   * SessionRestartRequired - Boolean
//   * MaxBatchesFromOriginalItem - Number
//   * AdditionalBatchesCount - Number
//   * HasLongRunningJobOfReceivingDataItemsBatches - Boolean
//   * MaxSecondsCountOfQuickDataItemsBatchReceipt - Number
//   * DisabledMetadataObjectsIDs - Map
//   * AccessGroupsSetsCatalogID - CatalogRef.MetadataObjectIDs
//
Function AccessUpdateNewContext()
	
	Return New Structure;
	
EndFunction

// For the RunAccessUpdateAtRecordLevel procedure.
Procedure ScheduleObsoleteItemsProcessing(PlanningErrorText,
			LastObsoleteItemsProcessingPlanning)
	
	If Not ValueIsFilled(LastObsoleteItemsProcessingPlanning) Then
		LastObsoleteItemsProcessingPlanning = CurrentSessionDate();
	EndIf;
	Try
		WaitBoundary = CurrentSessionDate() - HoursCountBetweenPlanningToProcessObsoleteItems() * 60 * 60;
		If LastObsoleteItemsProcessingPlanning < WaitBoundary Then
			PlanningParameters = AccessUpdatePlanningParameters(False);
			PlanningParameters.IsObsoleteItemsDataProcessor = True;
			PlanningParameters.LongDesc = "AccessUpdateOnRecordsLevel";
			ScheduleAccessUpdate(, PlanningParameters);
			LastObsoleteItemsProcessingPlanning = CurrentSessionDate();
		EndIf;
	Except
		ErrorInfo = ErrorInfo();
		PlanningErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Cannot schedule processing of obsolete access restriction items. Reason:
			           |%1';"),
			ErrorProcessing.DetailErrorDescription(ErrorInfo));
	EndTry;
	
EndProcedure

// For the FillThreadsCount procedure and the AccessUpdateOnRecordsLevel form.
//
// Returns:
//  Boolean
//
Function DiskLoadBalancingAvailable() Export
	
	Return MaxSecondsCountOfQuickDataItemsBatchReceipt() > 0
		And AccessManagementInternalCached.DiskLoadBalancingAvailable();
	
EndFunction

// For the FillThreadsCount procedure and the AccessUpdateOnRecordsLevel form.
//
// Returns:
//  Boolean
//
Function DiskLoadBalancing() Export
	
	ConstantValue = Constants.LastAccessUpdate.Get();
	LastAccessUpdate = LastAccessUpdate(ConstantValue);
	Return LastAccessUpdate.DiskLoadBalancing;
	
EndFunction

// For the AccessUpdateOnRecordsLevel form.
Procedure SetDiskLoadBalancing(Use) Export
	
	DataLock = New DataLock;
	DataLock.Add("Constant.LastAccessUpdate");
	
	HasExternalTransaction = TransactionActive();
	BeginTransaction();
	Try
		DataLock.Lock();
		ConstantValue = Constants.LastAccessUpdate.Get();
		LastAccessUpdate = LastAccessUpdate(ConstantValue);
		
		If LastAccessUpdate.DiskLoadBalancing <> Use Then
			LastAccessUpdate.DiskLoadBalancing = Use;
			InstallTheLatestAccessUpdate(LastAccessUpdate, HasExternalTransaction);
		EndIf;
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

// For the ExecuteAccessUpdate procedure.
// Returns:
//  ValueTable:
//   * HasSpotJob - Boolean
//   * HasInitialUpdateOfSpotJob - Date
//   * SpotJobLastRunDate - Date
//   * SpotJobAddedOn - Date
//   * DependencyLevel - Number
//   * DependentLists - Array
//                     - String
//   * HasInitialUpdate - Boolean
//   * HasRestart - Boolean
//   * CommonJobLastRunDate - Date
//   * HasLastUpdatedItemDate - Boolean
//   * LatestUpdatedItemDate - Date
//   * CommonJobAddedOn - Date
//   * ListID - CatalogRef.MetadataObjectIDs
//                         - CatalogRef.ExtensionObjectIDs
//   * ForExternalUsers - Boolean
//   * IsRightsUpdate - Boolean
//   * Run - Boolean
//   * LockedThreads - Map of KeyAndValue:
//      ** Key - UUID
//      ** Value - See NewThread
//   * BatchesSet - Array of See BatchFromSet
//   * BatchesToProcessCount - Number
//   * IndexOfLastBatchToProcess - Number
//   * Ignore - Boolean
//   * Delete - Boolean
//   * DataKeyKindOrder - Number
//   * IsObsoleteItemsDataProcessor - Boolean
//   * UpdateDependencyLevel - Boolean
// 
Function UpdateJobsTable()
	
	IDsTypes = New Array;
	IDsTypes.Add(Type("CatalogRef.MetadataObjectIDs"));
	IDsTypes.Add(Type("CatalogRef.ExtensionObjectIDs"));
	
	Jobs = New ValueTable;
	Jobs.Columns.Add("HasSpotJob",                    New TypeDescription("Boolean"));
	Jobs.Columns.Add("HasInitialUpdateOfSpotJob",New TypeDescription("Date"));
	Jobs.Columns.Add("SpotJobLastRunDate",  New TypeDescription("Date"));
	Jobs.Columns.Add("SpotJobAddedOn",         New TypeDescription("Date"));
	Jobs.Columns.Add("DependencyLevel",                     New TypeDescription("Number"));
	Jobs.Columns.Add("DependentLists",                        New TypeDescription("Array,String"));
	Jobs.Columns.Add("HasInitialUpdate",                New TypeDescription("Boolean"));
	Jobs.Columns.Add("HasRestart",                         New TypeDescription("Boolean"));
	Jobs.Columns.Add("CommonJobLastRunDate",     New TypeDescription("Date"));
	Jobs.Columns.Add("HasLastUpdatedItemDate", New TypeDescription("Boolean"));
	Jobs.Columns.Add("LatestUpdatedItemDate",     New TypeDescription("Date"));
	Jobs.Columns.Add("CommonJobAddedOn",            New TypeDescription("Date"));
	Jobs.Columns.Add("ListID",                    New TypeDescription(IDsTypes));
	Jobs.Columns.Add("ForExternalUsers",                New TypeDescription("Boolean"));
	Jobs.Columns.Add("IsRightsUpdate",                      New TypeDescription("Boolean"));
	Jobs.Columns.Add("Run",                              New TypeDescription("Boolean"));
	Jobs.Columns.Add("LockedThreads",                          New TypeDescription("Map"));
	Jobs.Columns.Add("BatchesSet",                            New TypeDescription("Array"));
	Jobs.Columns.Add("BatchesToProcessCount",           New TypeDescription("Number"));
	Jobs.Columns.Add("IndexOfLastBatchToProcess",      New TypeDescription("Number"));
	Jobs.Columns.Add("Ignore",                             New TypeDescription("Boolean"));
	Jobs.Columns.Add("Delete",                                New TypeDescription("Boolean"));
	Jobs.Columns.Add("DataKeyKindOrder",                 New TypeDescription("Number"));
	Jobs.Columns.Add("IsObsoleteItemsDataProcessor",        New TypeDescription("Boolean"));
	Jobs.Columns.Add("UpdateDependencyLevel",             New TypeDescription("Boolean"));
	
	Jobs.Indexes.Add(
		"HasSpotJob,
		|HasInitialUpdateOfSpotJob,
		|SpotJobLastRunDate,
		|SpotJobAddedOn,
		|HasInitialUpdate,
		|CommonJobLastRunDate,
		|HasLastUpdatedItemDate,
		|LatestUpdatedItemDate,
		|CommonJobAddedOn");
	
	Jobs.Indexes.Add("ListID, ForExternalUsers, IsRightsUpdate");
	Jobs.Indexes.Add("ListID, ForExternalUsers, IsRightsUpdate, IsObsoleteItemsDataProcessor");
	Jobs.Indexes.Add("Delete, IsObsoleteItemsDataProcessor");
	Jobs.Indexes.Add("DependencyLevel");
	
	Return Jobs;
	
EndFunction

// For the AddAccessUpdateJobs procedure.
Function JobsKeysTable()
	
	IDsTypes = New Array;
	IDsTypes.Add(Type("CatalogRef.MetadataObjectIDs"));
	IDsTypes.Add(Type("CatalogRef.ExtensionObjectIDs"));
	
	Jobs = New ValueTable;
	Jobs.Columns.Add("ListID",     New TypeDescription(IDsTypes));
	Jobs.Columns.Add("ForExternalUsers", New TypeDescription("Boolean"));
	Jobs.Columns.Add("IsRightsUpdate",       New TypeDescription("Boolean"));
	
	Jobs.Indexes.Add("ListID, ForExternalUsers, IsRightsUpdate");
	
	Return Jobs;
	
EndFunction

// For the ExecuteAccessUpdate procedure.
//
// Returns:
//  Structure:
//   * ThreadID - UUID
//   * BackgroundJob - BackgroundJob
//   * Job - ValueTableRow of See UpdateJobsTable
//   * CancelJob - Boolean
//   * BatchFromSet - See BatchFromSet
//   * ReleaseDate - Date
//
Function NewThread()
	
	Stream = New Structure;
	Stream.Insert("ThreadID");
	Stream.Insert("BackgroundJob");
	Stream.Insert("Job");
	Stream.Insert("CancelJob", False);
	Stream.Insert("BatchFromSet");
	Stream.Insert("ReleaseDate", '00010101');
	
	Return Stream;
	
EndFunction

// For the ExecuteAccessUpdate procedure.
//
// Returns:
//   Structure:
//     * IsRightsUpdate               - Boolean
//     * ListID             - CatalogRef.MetadataObjectIDs
//                                       - CatalogRef.ExtensionObjectIDs
//     * ForExternalUsers         - Boolean
//     * IsObsoleteItemsDataProcessor - Boolean
//     * StartDate                      - Date
//     * EndDate                   - Date
//     * InitialUpdate             - Boolean
//     * ProcessingCompleted              - Boolean
//     * MaxProcessingMilliseconds    - Number
//     * AccessGroupsSetsCatalogID - CatalogRef.MetadataObjectIDs
//     * Cache                             - See NewCacheContext
//     * MaxBatchesFromOriginalItem        - Number
//
Function CommonUpdateParametersDetails(Context = Undefined)
	
	CommonUpdateParameters = New Structure;
	CommonUpdateParameters.Insert("IsRightsUpdate",            False);
	CommonUpdateParameters.Insert("ListID",          Undefined);
	CommonUpdateParameters.Insert("ForExternalUsers",      False);
	CommonUpdateParameters.Insert("IsObsoleteItemsDataProcessor", False);
	CommonUpdateParameters.Insert("StartDate",                   '00010101');
	CommonUpdateParameters.Insert("EndDate",                '00010101');
	CommonUpdateParameters.Insert("InitialUpdate",          False);
	CommonUpdateParameters.Insert("ProcessingCompleted",           True);
	CommonUpdateParameters.Insert("MaxProcessingMilliseconds", 1000);
	
	If Context = Undefined Then
		CommonUpdateParameters.Insert("AccessGroupsSetsCatalogID",
			Common.MetadataObjectID("Catalog.SetsOfAccessGroups"));
	Else
		CommonUpdateParameters.Insert("AccessGroupsSetsCatalogID",
			Context.AccessGroupsSetsCatalogID);
		
		If Context.UpdateInThisSession Then
			CommonUpdateParameters.Insert("Cache", Context.Cache);
		EndIf;
		CommonUpdateParameters.Insert("MaxBatchesFromOriginalItem", Context.MaxBatchesFromOriginalItem);
	EndIf;
	
	Return CommonUpdateParameters;
	
EndFunction

// For the ExecuteAccessUpdate procedure.
Function JobsQueryText()
	
	Return
	"SELECT
	|	FALSE AS IsRightsUpdate,
	|	Lists.List AS ListID,
	|	Lists.ForExternalUsers AS ForExternalUsers,
	|	MAX(Lists.SpotJob) AS HasSpotJob,
	|	MAX(Lists.SpotJob
	|			AND Lists.LatestUpdatedItemDate = &MaxDate) AS HasInitialUpdateOfSpotJob,
	|	MAX(CASE
	|			WHEN Lists.SpotJob
	|					AND Lists.UniqueKey <> &BlankID
	|				THEN Lists.RegisterRecordChangeDate
	|			ELSE DATETIME(1, 1, 1)
	|		END) AS SpotJobAddedOn,
	|	MAX(Lists.JobSize = 2) AS HasObsoleteItemsProcessing,
	|	MAX(Lists.JobSize = 3) AS HasFullUpdate,
	|	MAX((NOT Lists.SpotJob
	|			OR Lists.UniqueKey = &BlankID)
	|			AND Lists.LatestUpdatedItemDate = &MaxDate) AS HasInitialUpdate,
	|	MAX(NOT Lists.SpotJob
	|			AND Lists.UniqueKey <> &BlankID) AS HasRestart,
	|	MAX(CASE
	|			WHEN NOT Lists.SpotJob
	|					OR Lists.UniqueKey = &BlankID
	|				THEN Lists.LatestUpdatedItemDate
	|			ELSE DATETIME(1, 1, 1)
	|		END) AS LatestUpdatedItemDate,
	|	MAX(CASE
	|			WHEN NOT Lists.SpotJob
	|					AND Lists.UniqueKey <> &BlankID
	|				THEN Lists.RegisterRecordChangeDate
	|			ELSE DATETIME(1, 1, 1)
	|		END) AS CommonJobAddedOn
	|FROM
	|	InformationRegister.DataAccessKeysUpdate AS Lists
	|
	|GROUP BY
	|	Lists.List,
	|	Lists.ForExternalUsers
	|
	|UNION ALL
	|
	|SELECT
	|	TRUE,
	|	Lists.List,
	|	Lists.ForExternalUsers,
	|	MAX(Lists.SpotJob),
	|	FALSE,
	|	MAX(CASE
	|			WHEN Lists.SpotJob
	|					AND Lists.UniqueKey <> &BlankID
	|				THEN Lists.RegisterRecordChangeDate
	|			ELSE DATETIME(1, 1, 1)
	|		END),
	|	MAX(Lists.JobSize = 2),
	|	MAX(Lists.JobSize = 3),
	|	FALSE,
	|	MAX(NOT Lists.SpotJob
	|			AND Lists.UniqueKey <> &BlankID),
	|	DATETIME(1, 1, 1),
	|	MAX(CASE
	|			WHEN NOT Lists.SpotJob
	|					AND Lists.UniqueKey <> &BlankID
	|				THEN Lists.RegisterRecordChangeDate
	|			ELSE DATETIME(1, 1, 1)
	|		END)
	|FROM
	|	InformationRegister.UsersAccessKeysUpdate AS Lists
	|
	|GROUP BY
	|	Lists.List,
	|	Lists.ForExternalUsers";
	
EndFunction

// For the ExecuteAccessUpdate procedure.
Procedure FillThreadsCount(Context)
	
	If Context.UpdateInThisSession Then
		Return;
	EndIf;
	
	If Common.FileInfobase() Then
		ThreadsCount = 1;
		Context.MaxBatchesFromOriginalItem = 5;
	Else
		ThreadsCount = Constants.AccessUpdateThreadsCount.Get();
		Context.MaxBatchesFromOriginalItem = 5 + (ThreadsCount - 1) * 2;
	EndIf;
	
	If ThreadsCount < 1 Then
		ThreadsCount = 1;
	EndIf;
	
	If Context.ThreadsCount = 0 Then
		Context.UpdateInThisSession = ThreadsCount = 1;
	EndIf;
	
	Context.ThreadsCount = ThreadsCount;
	
	If Context.UpdateInThisSession Then
		Return;
	EndIf;
	
	If DiskLoadBalancingAvailable() And DiskLoadBalancing() Then
		Context.MaxSecondsCountOfQuickDataItemsBatchReceipt =
			MaxSecondsCountOfQuickDataItemsBatchReceipt();
	Else
		Context.MaxSecondsCountOfQuickDataItemsBatchReceipt = 0;
	EndIf;
	
EndProcedure

// For the ExecuteAccessUpdate procedure.
Procedure AddAccessUpdateJobs(QueryResults, Context)
	
	If Context.Property("Cache") Then
		Cache = Context.Cache; // See NewCacheContext
	Else
		Cache = NewCacheContext();
		Context.Insert("Cache", Cache);
		Context.Insert("IDsByFullNames", New Map);
		Context.Insert("RestrictionParametersVersion");
		Context.Insert("RestrictionParametersHashsum");
	EndIf;
	If Not Cache.Property("MetadataObjectsByIDs") Then
		Cache.Insert("MetadataObjectsByIDs", New Map);
	EndIf;
	
	Try
		CheckUpdateActiveAccessRestrictionParameters();
	Except
		If StandardSubsystemsServer.SessionRestartRequired() Then
			Context.SessionRestartRequired = True;
			If StandardSubsystemsServer.ThisErrorRequirementRestartSession(ErrorInfo()) Then
				Return;
			EndIf;
		EndIf;
		Raise;
	EndTry;
	ActiveParameters = ActiveAccessRestrictionParameters(Undefined, Undefined, False);
	Jobs = Context.Jobs;
	ListsIDs = New Array;
	
	If Context.RestrictionParametersVersion   <> SessionParameters.AccessRestrictionParameters.Version
	 Or Context.RestrictionParametersHashsum <> SessionParameters.AccessRestrictionParameters.HashSum Then
		
		Jobs.FillValues(-1, "DependencyLevel");
		Jobs.FillValues(Undefined, "DependentLists");
		Context.Insert("IDsByFullNames", New Map);
		Context.Insert("LeadingListsByDependentOnes", JobsKeysTable());
		Context.LeadingListsByDependentOnes.Columns.Add("LeadingLists");
		
		CurrentListIDs = Jobs.Copy(, "ListID");
		CurrentListIDs.GroupBy("ListID");
		ListsIDs = CurrentListIDs.UnloadColumn("ListID");
		
		Context.RestrictionParametersVersion   = SessionParameters.AccessRestrictionParameters.Version;
		Context.RestrictionParametersHashsum = SessionParameters.AccessRestrictionParameters.HashSum;
	EndIf;
	
	Jobs.FillValues(True, "Delete");
	Filter = New Structure("ListID, ForExternalUsers, IsRightsUpdate");
	
	Upload0 = QueryResults[0].Unload();
	
	For Each String In Upload0 Do
		If Context.DisabledMetadataObjectsIDs.Get(String.ListID) <> Undefined Then
			Continue;
		EndIf;
		FillPropertyValues(Filter, String);
		Rows = Jobs.FindRows(Filter);
		If Rows.Count() = 0 Then
			Job = Jobs.Add();
			Job.DependencyLevel = -1; // 
			If String.ListID <> Undefined
			   And Cache.MetadataObjectsByIDs.Get(String.ListID) = Undefined Then
				ListsIDs.Add(String.ListID);
			EndIf;
			If String.HasObsoleteItemsProcessing And Not String.HasSpotJob And Not String.HasFullUpdate Then
				Job.DataKeyKindOrder = DataKeyKindOrder("ObsoleteItems");
			EndIf;
		Else
			Job = Rows[0];
		EndIf;
		FillPropertyValues(Job, String);
		Job.Delete = False;
		UpdateIsObsoleteItemsDataProcessorProperty(Job, False);
		Job.HasLastUpdatedItemDate
			= ValueIsFilled(Job.LatestUpdatedItemDate);
		
		If Job.HasRestart Then
			CancelJob(Job);
		EndIf;
	EndDo;
	
	If ListsIDs.Count() > 0 Then
		MetadataObjectsByIDs =
			Common.MetadataObjectsByIDs(ListsIDs, False);
		For Each KeyAndValue In MetadataObjectsByIDs Do
			Cache.MetadataObjectsByIDs.Insert(KeyAndValue.Key, KeyAndValue.Value);
			If TypeOf(KeyAndValue.Value) = Type("MetadataObject") Then
				Context.IDsByFullNames.Insert(KeyAndValue.Value.FullName(), KeyAndValue.Key);
			ElsIf KeyAndValue.Value = Undefined Then
				Context.DisabledMetadataObjectsIDs.Insert(KeyAndValue.Key, True);
				Rows = Jobs.FindRows(New Structure("ListID", KeyAndValue.Key));
				For Each String In Rows Do
					Jobs.Delete(String);
				EndDo;
			EndIf;
		EndDo;
	EndIf;
	
	If Jobs.Count() > 0 Then
		Context.ProcessingCompleted = False;
	EndIf;
	
	FillJobsDependencyLevels(Context, ActiveParameters.LeadingLists);
	
EndProcedure

// 
// 
// Returns:
//  Structure:
//   * MetadataObjectsByIDs - Map
//
Function NewCacheContext()
	
	Return New Structure;
	
EndFunction

// For the AddAccessUpdateJobs and UpdateJobProperties procedures and
// the StartListAccessUpdate function.
//
Procedure UpdateIsObsoleteItemsDataProcessorProperty(Job, DependencyLevelOnChangeUpdateRequired = True)
	
	IsObsoleteItemsDataProcessor = Not Job.HasSpotJob
		And Job.DataKeyKindOrder >= DataKeyKindOrder("ObsoleteItems")
		And Job.DataKeyKindOrder < DataKeyKindOrder("NoData1");
	
	If Job.IsObsoleteItemsDataProcessor <> IsObsoleteItemsDataProcessor Then
		Job.IsObsoleteItemsDataProcessor = IsObsoleteItemsDataProcessor;
		Job.UpdateDependencyLevel = DependencyLevelOnChangeUpdateRequired;
	EndIf;
	
EndProcedure

// For the FillCommonUpdateParameters procedure.
Function IsAccessGroupsSetsCompositionUpdate(Job, Context)
	
	Return Job.ListID = Context.AccessGroupsSetsCatalogID
	      And Job.DataKeyKindOrder <= DataKeyKindOrder("GroupSetsAllowedForUsers");
	
EndFunction

// For the AddAccessUpdateJobs procedure.
Procedure FillJobsDependencyLevels(Context, LeadingListsProperties)
	
	Jobs = Context.Jobs;
	MetadataObjectsByIDs = Context.Cache.MetadataObjectsByIDs;
	IDsByFullNames       = Context.IDsByFullNames;
	
	JobsForFilling = Jobs.FindRows(New Structure("DependencyLevel", -1));
	LeadingListsByDependentOnes = Context.LeadingListsByDependentOnes;
	FilterJobs = New Structure("ListID, ForExternalUsers, IsRightsUpdate");
	
	For Each Job In JobsForFilling Do
		SetDependencyLevelByLeadingLists(Job, Jobs, LeadingListsByDependentOnes);
		
		MetadataObject = MetadataObjectsByIDs.Get(Job.ListID);
		If TypeOf(MetadataObject) <> Type("MetadataObject") Then
			Continue;
		EndIf;
		FullName = MetadataObject.FullName();
		LeadingListProperties1 = LeadingListsProperties.Get(FullName);
		If LeadingListProperties1 = Undefined
		 Or LeadingListProperties1.ByAccessKeys = Undefined Then
			Continue;
		EndIf;
		If Job.ForExternalUsers Then
			DependentLists = LeadingListProperties1.ByAccessKeys.ForExternalUsers;
		Else
			DependentLists = LeadingListProperties1.ByAccessKeys.ForUsers;
		EndIf;
		If DependentLists = Undefined Then
			Continue;
		EndIf;
		FillPropertyValues(FilterJobs, Job);
		For Each DependentList In DependentLists Do
			DependentListID = IDsByFullNames.Get(DependentList);
			If Job.DependentLists = Undefined Then
				Job.DependentLists = New Array;
			EndIf;
			JobDependentLists = Job.DependentLists;
			JobDependentLists.Add(DependentListID);
			FilterJobs.ListID = DependentListID;
			FoundItems = LeadingListsByDependentOnes.FindRows(FilterJobs);
			If FoundItems.Count() = 0 Then
				LeadingLists = New Map;
				NewRow = LeadingListsByDependentOnes.Add();
				FillPropertyValues(NewRow, FilterJobs);
				NewRow.LeadingLists = LeadingLists;
			Else
				LeadingLists = FoundItems[0].LeadingLists;
			EndIf;
			LeadingLists.Insert(Job.ListID, True);
			DependentJobs = Jobs.FindRows(FilterJobs);
			If DependentJobs.Count() > 0 Then
				SetDependencyLevelByLeadingLists(DependentJobs[0], Jobs, LeadingListsByDependentOnes);
			EndIf;
		EndDo;
	EndDo;
	
EndProcedure

// For the FillJobsDependencyLevels, UpdateDependencyLevel procedures.
Procedure SetDependencyLevelByLeadingLists(Job, Jobs, LeadingListsByDependentOnes)
	
	Job.DependencyLevel = 0;
	If Job.IsObsoleteItemsDataProcessor Then
		Return;
	EndIf;
	
	FilterJobs = New Structure("ListID, ForExternalUsers, IsRightsUpdate",
		Job.ListID, Job.ForExternalUsers, Job.IsRightsUpdate);
	
	FoundItems = LeadingListsByDependentOnes.FindRows(FilterJobs);
	If FoundItems.Count() = 0 Then
		Return;
	EndIf;
	
	FilterJobs.Insert("IsObsoleteItemsDataProcessor", False);
	
	For Each LeadingListDetails In FoundItems[0].LeadingLists Do
		FilterJobs.ListID = LeadingListDetails.Key;
		LeadingJobs = Jobs.FindRows(FilterJobs);
		If LeadingJobs.Count() = 0 Then
			Continue;
		EndIf;
		If Job.DependencyLevel < LeadingJobs[0].DependencyLevel + 1 Then
			Job.DependencyLevel = LeadingJobs[0].DependencyLevel + 1;
		EndIf;
	EndDo;
	
EndProcedure

// For the FillCommonUpdateParameters procedure.
Procedure UpdateDependencyLevel(JobProperties, Jobs, LeadingListsByDependentOnes)
	
	If Not ValueIsFilled(JobProperties.DependentLists) Then
		Return;
	EndIf;
	FilterJobs = New Structure("ListID, ForExternalUsers, IsRightsUpdate");
	FillPropertyValues(FilterJobs, JobProperties);
	
	For Each DependentList In JobProperties.DependentLists Do
		FilterJobs.ListID = DependentList;
		DependentJobs = Jobs.FindRows(FilterJobs);
		If DependentJobs.Count() = 0 Then
			Continue;
		EndIf;
		SetDependencyLevelByLeadingLists(DependentJobs[0], Jobs, LeadingListsByDependentOnes);
		UpdateDependencyLevel(DependentJobs[0], Jobs, LeadingListsByDependentOnes);
	EndDo;
	
EndProcedure

// For the ExecuteAccessUpdate procedure.
Procedure FillCommonUpdateParameters(Context)
	
	Jobs = Context.Jobs;
	Jobs.Sort(
		"HasSpotJob Desc,
		|HasInitialUpdateOfSpotJob Desc,
		|SpotJobLastRunDate Asc,
		|SpotJobAddedOn Desc,
		|HasInitialUpdate Desc,
		|CommonJobLastRunDate Asc,
		|HasLastUpdatedItemDate Asc,
		|LatestUpdatedItemDate Desc,
		|CommonJobAddedOn Desc");
	
	JobsToDelete = Jobs.FindRows(New Structure("Delete", True));
	For Each Job In JobsToDelete Do
		If Not Job.Delete Or Job.LockedThreads.Count() > 0 Then
			Continue;
		EndIf;
		JobProperties = New Structure("ListID,
		|ForExternalUsers, IsRightsUpdate, DependentLists");
		FillPropertyValues(JobProperties, Job);
		Jobs.Delete(Job);
		UpdateDependencyLevel(JobProperties, Jobs, Context.LeadingListsByDependentOnes);
	EndDo;
	JobsToUpdateLevel = Jobs.FindRows(New Structure("UpdateDependencyLevel", True));
	For Each Job In JobsToUpdateLevel Do
		SetDependencyLevelByLeadingLists(Job, Jobs, Context.LeadingListsByDependentOnes);
		UpdateDependencyLevel(Job, Jobs, Context.LeadingListsByDependentOnes);
		Job.UpdateDependencyLevel = False;
	EndDo;
	
	LevelsFilter = New Structure("Delete, IsObsoleteItemsDataProcessor", False, False);
	Levels = Jobs.Copy(LevelsFilter, "DependencyLevel");
	Levels.GroupBy("DependencyLevel");
	Levels.Sort("DependencyLevel");
	LowestDependencyLevel = ?(Levels.Count() > 0, Levels[0].DependencyLevel, 0);
	IsObsoleteItemsDataProcessor = Levels.Count() = 0;
	LastDependentCommonJobStartupDate = '00010101';
	If Levels.Count() > 1 Or Not IsObsoleteItemsDataProcessor Then
		For Each Job In Jobs Do
			If Job.Delete
			 Or Job.HasSpotJob Then
				Continue;
			EndIf;
			If Job.DependencyLevel > LowestDependencyLevel
			   And LastDependentCommonJobStartupDate < Job.CommonJobLastRunDate Then
				LastDependentCommonJobStartupDate = Job.CommonJobLastRunDate;
			EndIf;
		EndDo;
	EndIf;
	CommonDependentJobToStart =
		?(LastDependentCommonJobStartupDate > CurrentSessionDate() - 10, Null, Undefined);
	
	CommonUpdateParameters = Context.CommonUpdateParameters;
	CommonUpdateParameters.IsObsoleteItemsDataProcessor = IsObsoleteItemsDataProcessor;
	CommonUpdateParameters.InitialUpdate = False;
	LastDate = '00010101';
	AccessGroupsSetsCatalogJob = Undefined;
	WaitBoundaryForDependentJobs = CurrentSessionDate() - 3;
	
	For Each Job In Jobs Do
		If Job.Delete Then
			Continue;
		EndIf;
		If IsAccessGroupsSetsCompositionUpdate(Job, Context) Then
			AccessGroupsSetsCatalogJob = Job;
		EndIf;
		Job.Ignore = False;
		If Job.HasInitialUpdate Then
			CommonUpdateParameters.InitialUpdate = True;
		Else
			If Job.DependencyLevel > LowestDependencyLevel Then
				If Job.HasSpotJob Then
					If Job.SpotJobLastRunDate > WaitBoundaryForDependentJobs Then
						Job.Ignore = True;
						Continue;
					EndIf;
				ElsIf CommonDependentJobToStart <> Undefined Then
					Job.Ignore = True;
					Continue;
				Else
					CommonDependentJobToStart = Job;
				EndIf;
			EndIf;
			If Not IsObsoleteItemsDataProcessor And Job.IsObsoleteItemsDataProcessor Then
				Job.Ignore = True;
				Continue;
			EndIf;
		EndIf;
		If Job.HasRestart Then
			CommonUpdateParameters.InitialUpdate = True;
		EndIf;
		If Job.LatestUpdatedItemDate > LastDate Then
			LastDate = Job.LatestUpdatedItemDate;
		EndIf;
	EndDo;
	
	If CommonUpdateParameters.InitialUpdate Then
		// 
		CommonUpdateParameters.StartDate = BegOfDay(CurrentSessionDate()) - 7 * (60 * 60 * 24); // 
	Else
		// Continue update.
		MaximumPeriod = MaxGettingBatchesByQueryPeriod();
		
		If MaximumPeriod = "Week" Then
			StartDate = BegOfWeek(LastDate);
			
		ElsIf MaximumPeriod = "Month" Then
			StartDate = BegOfMonth(LastDate);
		Else
			ThisYear = Year(CurrentSessionDate()) - Year(LastDate) = 0;
			MonthOffset = Month(CurrentSessionDate()) - Month(LastDate);
			
			If ThisYear And MonthOffset = 0 Then
				StartDate = BegOfMonth(LastDate);
				
			ElsIf ThisYear And MonthOffset < 3 Or MaximumPeriod = "Quarter" Then
				StartDate = BegOfQuarter(LastDate);
			Else
				StartDate = BegOfYear(LastDate);
			EndIf;
		EndIf;
		
		CommonUpdateParameters.StartDate = StartDate;
	EndIf;
	CommonUpdateParameters.EndDate = LastDate;
	
	JobsForStartup = New Array;
	Context.JobsForStartup = JobsForStartup;
	Context.HasDeferredJobs = False;
	
	For Each Job In Jobs Do
		If Job.Delete Or Job.Ignore Then
			Job.Run = False;
			If Job.Ignore Then
				Context.HasDeferredJobs = True;
			EndIf;
			Continue;
		EndIf;
		
		If AccessGroupsSetsCatalogJob <> Undefined Then
			If Job.HasSpotJob Or Job = AccessGroupsSetsCatalogJob Then
				Job.Run = True;
			ElsIf CommonUpdateParameters.InitialUpdate Then
				Job.Run = Job.HasInitialUpdate Or Job.HasRestart;
			EndIf;
			
		ElsIf Job.HasSpotJob Or Job.IsRightsUpdate Then
			Job.Run = True;
			
		ElsIf CommonUpdateParameters.InitialUpdate Then
			Job.Run = Job.HasInitialUpdate Or Job.HasRestart;
		Else
			Job.Run = Not UpdatePeriodToDataPeriod(CommonUpdateParameters.StartDate,
				Job.LatestUpdatedItemDate);
		EndIf;
		
		If Job.Run Then
			JobsForStartup.Add(Job);
		Else
			Context.HasDeferredJobs = True;
		EndIf;
	EndDo;
	
	If Not LoadFreeThreadsWithNextJobsAtLongQueries() Then
		Context.HasDeferredJobs = False;
	EndIf;
	
	If Not Context.HasStartedJob
	   And Context.HasDeferredJobs
	   And Context.LockedThreads.Count() < Context.ThreadsCount Then
		
		Context.HasDeferredJobs = False;
		FreeThreadsCount = Context.ThreadsCount - Context.LockedThreads.Count();
		AdditionalJobsCount = 0;
		
		For Each Job In Jobs Do
			If Job.Delete
			 Or Job.Run
			 Or Not IsObsoleteItemsDataProcessor
			   And Job.IsObsoleteItemsDataProcessor Then
				Continue;
			EndIf;
			If AdditionalJobsCount >= FreeThreadsCount Then
				Context.HasDeferredJobs = True;
				Break;
			EndIf;
			Job.Run = True;
			JobsForStartup.Add(Job);
			AdditionalJobsCount = AdditionalJobsCount + 1;
		EndDo;
	EndIf;
	
	MainJobsCount = JobsForStartup.Count();
	If MainJobsCount > 0 Then
		Context.AdditionalBatchesCount = Int(Context.ThreadsCount / MainJobsCount);
	Else
		Context.AdditionalBatchesCount = 0;
	EndIf;
	
	JobsCount = Jobs.Count();
	If JobsCount = 0 Then
		ThreadsSufficiency = 0;
	ElsIf Context.ThreadsCount > JobsCount Then
		ThreadsSufficiency = 1;
	Else
		ThreadsSufficiency = Context.ThreadsCount / JobsCount;
	EndIf;
	LoadFromThreads = Context.ThreadsCount * 0.025;
	If LoadFromThreads > 1 Then
		LoadFromThreads = 1;
	EndIf;
	CommonUpdateParameters.MaxProcessingMilliseconds =
		Int(MinSecondsCountOfBatchProcessingInSingleThread() * 1000
		* (1 + LoadFromThreads) * (1 + ThreadsSufficiency));
	
EndProcedure

// For the AddAccessUpdateJob, StartListAccessUpdate,
// UpdateListAccess procedures.
//
Function UpdatePeriodToDataPeriod(StartDate, LatestUpdatedItemDate)
	
	// ДатаНачала - 
	// 
	// 
	Return ValueIsFilled(LatestUpdatedItemDate)
		  And StartDate > LatestUpdatedItemDate;
	
EndFunction

// For the ExecuteAccessUpdate procedure.
Procedure UpdateTheListOfUsedVersionsOfTemplateParameters(Context)
	
	If Not Context.ProcessingCompleted
	   And SessionParameters.AccessRestrictionParameters.CreationDate > CurrentSessionDate() - 5 * 60 Then
		
		Return;
	EndIf;
	
	Try
		CheckUpdateActiveAccessRestrictionParameters();
		ActiveParameters = ActiveAccessRestrictionParameters(Undefined, Undefined, False);
	Except
		If StandardSubsystemsServer.SessionRestartRequired() Then
			Context.SessionRestartRequired = True;
			If StandardSubsystemsServer.ThisErrorRequirementRestartSession(ErrorInfo()) Then
				Return;
			EndIf;
		EndIf;
		Raise;
	EndTry;
	
	AdditionalContext = ActiveParameters.AdditionalContext;
	
	If OneAccessOptionIsUsed(AdditionalContext.ForUsers)
	   And OneAccessOptionIsUsed(AdditionalContext.ForExternalUsers) Then
		
		Return;
	EndIf;
	
	CommonContext = CommonContextOfRestrictionParametersCalculation();
	CommonContext.Insert("ListsWithOutdatedAccessOptions", New Array);
	
	Try
		ActiveAccessRestrictionParameters(Undefined, CommonContext, True);
	Except
		If StandardSubsystemsServer.SessionRestartRequired() Then
			Context.SessionRestartRequired = True;
			If StandardSubsystemsServer.ThisErrorRequirementRestartSession(ErrorInfo()) Then
				Return;
			EndIf;
		EndIf;
		Raise;
	EndTry;
	
	If ValueIsFilled(CommonContext.ListsWithOutdatedAccessOptions) Then
		Context.ProcessingCompleted = False;
	EndIf;
	
EndProcedure

// For the ExecuteAccessUpdate procedure.
Procedure CompleteAccessUpdate(Context)
	
	If Not Context.RefreshEnabledCanceled And Not Context.SessionRestartRequired Then
		If ValueIsFilled(Context.CompletionErrorText) Then
			WaitBoundary = CurrentSessionDate() + 3;
		Else
			WaitBoundary = CurrentSessionDate() + 15;
		EndIf;
		While Context.LockedThreads.Count() > 0 Do
			// 
			WaitForThreadToUnlock(Context);
			// 
			ProcessExecutedJobs(Context);
			If CurrentSessionDate() > WaitBoundary Then
				Break;
			EndIf;
		EndDo;
	EndIf;
	
	CompleteAccessUpdateThreads();
	CancelAccessUpdateThreadsBackgroundJobs();
	
	Try
		If Context.ProcessingCompleted Then
			Context.Insert("DataLockWaitError", False);
			Try
				DisableScheduledJobIfNoNewJobs(Context);
			Except
				If Not Context.DataLockWaitError Then
					Raise;
				EndIf;
			EndTry;
			If Not Constants.FirstAccessUpdateCompleted.Get() Then
				Constants.FirstAccessUpdateCompleted.Set(True);
			EndIf;
		EndIf;
	Except
		RegisterMainThreadUpdateIndicators(Context);
		Raise;
	EndTry;
	
	RegisterMainThreadUpdateIndicators(Context);
	
EndProcedure

// For the UpdateUsedTemplatesParametersVersionsComposition procedure.
Function OneAccessOptionIsUsed(AdditionalContext)
	
	SeveralOptionsAreUsed = False;
	
	For Each KeyAndValue In AdditionalContext.BasicAccessOptions Do
		If KeyAndValue.Value.Count() > 1 Then
			SeveralOptionsAreUsed = True;
			Break;
		EndIf;
	EndDo;
	
	Return Not SeveralOptionsAreUsed;
	
EndFunction

// For the EndAccessUpdate procedure.
Procedure DisableScheduledJobIfNoNewJobs(Context)
	
	Query = New Query;
	Query.SetParameter("UnavailableListsForDataAccessKeyUpdate",       New Array);
	Query.SetParameter("UnavailableListsForUserAccessKeyUpdate", New Array);
	Query.Text =
	"SELECT DISTINCT
	|	DataAccessKeysUpdate.List AS List
	|FROM
	|	InformationRegister.DataAccessKeysUpdate AS DataAccessKeysUpdate
	|WHERE
	|	NOT DataAccessKeysUpdate.List IN (&UnavailableListsForDataAccessKeyUpdate)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT DISTINCT
	|	UsersAccessKeysUpdate.List AS List
	|FROM
	|	InformationRegister.UsersAccessKeysUpdate AS UsersAccessKeysUpdate
	|WHERE
	|	NOT UsersAccessKeysUpdate.List IN (&UnavailableListsForUserAccessKeyUpdate)";
	QueryResults = Query.ExecuteBatch();
	
	If Not QueryResults[0].IsEmpty() Then
		SetUnavailableLists(QueryResults[0],
			Query.Parameters.UnavailableListsForDataAccessKeyUpdate);
	EndIf;
	
	If Not QueryResults[1].IsEmpty() Then
		SetUnavailableLists(QueryResults[1],
			Query.Parameters.UnavailableListsForDataAccessKeyUpdate);
	EndIf;
	
	If Query.Parameters.UnavailableListsForDataAccessKeyUpdate.Count() > 0
	 Or Query.Parameters.UnavailableListsForUserAccessKeyUpdate.Count() > 0 Then
		
		QueryResults = Query.ExecuteBatch();
	EndIf;
	
	If QueryResults[0].IsEmpty()
	   And QueryResults[1].IsEmpty() Then
		
		Block = New DataLock;
		Block.Add("InformationRegister.DataAccessKeysUpdate");
		Block.Add("InformationRegister.UsersAccessKeysUpdate");
		BeginTransaction();
		Try
			Context.DataLockWaitError = True;
			If Common.FileInfobase() Then
				ScheduledJobsServer.BlockARoutineTask(New UUID);
			EndIf;
			Block.Lock();
			Context.DataLockWaitError = False;
			
			QueryResults = Query.ExecuteBatch();
			
			If QueryResults[0].IsEmpty()
			   And QueryResults[1].IsEmpty() Then
				
				If ValueIsFilled(Context.FullCompletionDate) Then
					DisableBoundary = CurrentSessionDate()
						- SecondsCountBeforeDisableScheduledJobAfterUpdateCompletion();
					If Context.FullCompletionDate < DisableBoundary Then
						SetAccessUpdate(False);
					EndIf;
				Else
					Context.FullCompletionDate = CurrentSessionDate();
				EndIf;
			Else
				Context.ProcessingCompleted = False;
				Context.FullCompletionDate = '00010101';
			EndIf;
			CommitTransaction();
		Except
			RollbackTransaction();
			Context.ProcessingCompleted = False;
			Raise;
		EndTry;
	Else
		Context.ProcessingCompleted = False;
	EndIf;
	
EndProcedure

// For the DisableScheduledJobIfNoNewJobs procedure.
//
// Parameters:
//  QueryResult  - QueryResult
//  UnavailableLists - Array
//
Procedure SetUnavailableLists(QueryResult, UnavailableLists)
	
	MetadataObjectsByIDs = Common.MetadataObjectsByIDs(
		QueryResult.Unload().UnloadColumn("List"), False);
	
	For Each KeyAndValue In MetadataObjectsByIDs Do
		If KeyAndValue.Value = Undefined Then
			UnavailableLists.Add(KeyAndValue.Key);
		EndIf;
	EndDo;
	
EndProcedure

// For the ExecuteAccessUpdate procedure.
Function StartListAccessUpdate(Job, Context)
	
	Indicators = Context.Indicators;
	If Indicators <> Undefined Then
		Indicators.JobAssignmentStart = CurrentUniversalDateInMilliseconds();
	EndIf;
	
	ProcessExecutedJobs(Context, Job.LockedThreads);
	
	If ValueIsFilled(Context.CompletionErrorText) Then
		Return False;
	EndIf;
	
	If Job.LockedThreads.Count() > 0 And Context.FirstPass Then
		Return True; // Already started.
	EndIf;
	
	If CommonJobBeingExecuted(Job)
	   And Not StartGotBatchesUpdateOnGetNewBatches() Then
		Return True;
	EndIf;
	
	If Job.IsObsoleteItemsDataProcessor
	   And Not Context.CommonUpdateParameters.IsObsoleteItemsDataProcessor Then
		Return False;
	EndIf;
	
	CommonUpdateParameters = CommonUpdateParametersDetails(Context);
	FillPropertyValues(CommonUpdateParameters, Context.CommonUpdateParameters);
	CommonUpdateParameters.IsRightsUpdate       = Job.IsRightsUpdate;
	CommonUpdateParameters.ListID     = Job.ListID;
	CommonUpdateParameters.ForExternalUsers = Job.ForExternalUsers;
	
	BatchesSet = Job.BatchesSet;
	LastIndex = BatchesSet.Count() - 1;
	
	IndexOfLastBatchToProcess = Job.IndexOfLastBatchToProcess;
	BatchToProcess = Undefined;
	For IndexOf = IndexOfLastBatchToProcess To LastIndex Do
		ItemsBatch = BatchesSet.Get(IndexOf);
		If Not ItemsBatch.Processed1 And Not ItemsBatch.InProcessing Then
			BatchToProcess = ItemsBatch;
			Job.IndexOfLastBatchToProcess = IndexOf;
			IndexOfLastBatchToProcess = IndexOf + 1;
			Break;
		EndIf;
	EndDo;
	
	If BatchToProcess = Undefined Then
		Job.IndexOfLastBatchToProcess = LastIndex + 1;
		PreviousBatch = Undefined;
		
	ElsIf IndexOf > 0 Then
		PreviousBatch = BatchesSet.Get(IndexOf - 1);
	Else
		PreviousBatch = Undefined;
	EndIf;
	
	If Not Job.HasSpotJob And BatchToProcess <> Undefined Then
		If UpdatePeriodToDataPeriod(CommonUpdateParameters.StartDate,
		         ?(PreviousBatch = Undefined, Job.LatestUpdatedItemDate,
		             PreviousBatch.LatestBatchItemDate)) Then
			Return True;
		EndIf;
		CommonUpdateParameters.Insert("BatchFromSet", BatchToProcess);
		BatchToProcess.InProcessing = True;
		Job.IndexOfLastBatchToProcess = IndexOfLastBatchToProcess;
	Else
		LastBatch = ?(LastIndex > -1, BatchesSet[LastIndex], Undefined);
		
		If LastBatch <> Undefined
		   And (LastBatch.LastBatchItem.DataKeyKind
		       <> LastBatch.NewLastBatchItem.DataKeyKind
		      Or LastBatch.NewLastBatchItem.DataKey = Null
		      Or Not CommonUpdateParameters.IsRightsUpdate
		        And UpdatePeriodToDataPeriod(CommonUpdateParameters.StartDate,
		              LastBatch.LatestBatchItemDate)) Then
			
			GetBatches = 0;
		Else
			BatchesToProcessCount = Job.BatchesToProcessCount;
			GetBatches = (Context.AdditionalBatchesCount + 2) * 2;
			If Job.HasSpotJob Then
				GetBatches = GetBatches - BatchesToProcessCount;
				If GetBatches - BatchesToProcessCount < Int(GetBatches / 3) Then
					GetBatches = Int(GetBatches / 3);
				Else
					GetBatches = GetBatches - BatchesToProcessCount;
				EndIf;
			EndIf;
		EndIf;
		
		If Not Job.HasSpotJob And GetBatches = 0 Then
			Return True;
		EndIf;
		
		CommonUpdateParameters.Insert("GetBatches", GetBatches);
		If LastBatch <> Undefined Then
			CommonUpdateParameters.Insert("NewLastBatchItem",
				LastBatch.NewLastBatchItem);
		EndIf;
	EndIf;
	
	If Not CommonUpdateParameters.Property("BatchFromSet") And CommonJobBeingExecuted(Job) Then
		Return True;
	EndIf;
	
	If Context.HasLongRunningJobOfReceivingDataItemsBatches
	   And Not Job.IsRightsUpdate
	   And Not Job.IsObsoleteItemsDataProcessor
	   And CommonUpdateParameters.Property("GetBatches")
	   And CommonUpdateParameters.GetBatches > 0 Then
		
		If Not Job.HasSpotJob Then
			Return False;
		EndIf;
		CommonUpdateParameters.GetBatches = 0;
	EndIf;
	
	If Job.HasSpotJob Then
		Job.HasSpotJob = False;
		UpdateIsObsoleteItemsDataProcessorProperty(Job);
		Job.SpotJobLastRunDate = CurrentSessionDate();
	Else
		Job.CommonJobLastRunDate = CurrentSessionDate();
	EndIf;
	
	If Context.UpdateInThisSession Then
		UpdateListAccessWithRetryAttempts(CommonUpdateParameters, Context);
		ProcessJobResult(Context, CommonUpdateParameters, Job);
	Else
		For Each FreeThread In Context.FreeThreads Do
			Break;
		EndDo;
		If FreeThread = Undefined Then
			If Context.LockedThreads.Count() >= Context.ThreadsCount Then
				Return True;
			EndIf;
			FreeThread = NewThread();
			Parameters = New Array;
			Parameters.Add(Context.MainSessionDetails);
			FreeThread.BackgroundJob = BackgroundJobs.Execute(AccessUpdateThreadMethodName(), Parameters,,
				NStr("en = 'Access management: Record-level update access thread';",
					Common.DefaultLanguageCode()));
			FreeThread.ThreadID = FreeThread.BackgroundJob.UUID;
			Context.FreeThreads.Add(FreeThread);
		EndIf;
		
		ThreadID = FreeThread.ThreadID;
		RecordSet = ServiceRecordSet(InformationRegisters.UsersAccessKeysCurrentJobs);
		RecordSet.Filter.ThreadID.Set(ThreadID);
		SetRecord = RecordSet.Add();
		SetRecord.ThreadID = ThreadID;
		SetRecord.IsStart = True;
		SetRecord.Parameters = New ValueStorage(CommonUpdateParameters);
		SetRecord.RegisterRecordChangeDate = CurrentSessionDate();
		
		RecordSet.Write();
		
		FreeThread.Job = Job;
		If CommonUpdateParameters.Property("BatchFromSet") Then
			FreeThread.BatchFromSet = CommonUpdateParameters.BatchFromSet;
		EndIf;
		Job.LockedThreads.Insert(ThreadID, FreeThread);
		Context.LockedThreads.Insert(ThreadID, FreeThread);
		Context.FreeThreads.Delete(0);
		If Indicators <> Undefined Then
			RemoveJobsIssueIndicators(Indicators);
		EndIf;
		Context.HasStartedJob = True;
	EndIf;
	
	Return True;
	
EndFunction

// For the StartListAccessUpdate function and the ProcessJobResult procedure.
Function CommonJobBeingExecuted(Job)
	
	For Each LockedThreadDetails In Job.LockedThreads Do
		If LockedThreadDetails.Value.BatchFromSet = Undefined Then
			Return True;
		EndIf;
	EndDo;
	
	Return False;
	
EndFunction

// For the StartListAccessUpdate function and the CancelBackgroundAccessUpdateThreadsJobs procedure.
Function AccessUpdateThreadMethodName()
	
	Return "AccessManagementInternal.UpdateListAccessInBackground";
	
EndFunction

// For the SetAccessUpdate, StartAccessUpdateAtRecordLevel,
// CancelAccessUpdateAtRecordLevel procedures and the AccessUpdateAssignee function.
// 
Function NameOfTheAccessUpdateTaskMethod()
	
	Return Metadata.ScheduledJobs.AccessUpdateOnRecordsLevel.MethodName;
	
EndFunction

// For the RunAccessUpdate, EndAccessUpdate procedure.
Procedure WaitForThreadToUnlock(Context, WaitForJobToComplete = False)
	
	If Context.UpdateInThisSession Then
		Return;
	EndIf;
	
	Indicators = Context.Indicators;
	If Indicators <> Undefined Then
		WaitStart = CurrentUniversalDateInMilliseconds();
	EndIf;
	
	ExecuteJob = True;
	
	If WaitForJobToComplete Then
		Query = New Query;
		Query.SetParameter("ThreadsIDs", ThreadsIDs(Context.LockedThreads));
		Query.SetParameter("ThreadsCount", Context.ThreadsCount);
		Query.Text =
		"SELECT TOP 1
		|	TRUE AS TrueValue
		|FROM
		|	InformationRegister.UsersAccessKeysCurrentJobs AS CurrentJobs
		|WHERE
		|	CurrentJobs.ThreadID IN(&ThreadsIDs)
		|
		|GROUP BY
		|	CurrentJobs.ThreadID
		|
		|HAVING
		|	(MIN(CurrentJobs.IsStart) = FALSE
		|		OR COUNT(CurrentJobs.IsStart) < &ThreadsCount)";
		If Not Query.Execute().IsEmpty() Then
			ExecuteJob = False;
		EndIf;
		WaitBoundary = CurrentSessionDate() + 5;
	EndIf;
	
	While ExecuteJob Do
		If Context.CurrentBackgroundJob <> Undefined Then
			BackgroundJob = Context.CurrentBackgroundJob;
		Else
			BackgroundJob = Undefined;
			For Each ThreadDetails In Context.LockedThreads Do
				Stream = ThreadDetails.Value;
				UpdateBackgroundJobProperties(Stream, Context);
				If Stream.BackgroundJob <> Undefined
				   And Stream.BackgroundJob.State = BackgroundJobState.Active Then
					
					BackgroundJob = Stream.BackgroundJob;
					Break;
				EndIf;
			EndDo;
		EndIf;
		If BackgroundJob = Undefined Then
			Break;
		EndIf;
		BackgroundJob.WaitForExecutionCompletion(0.025);
		If Not WaitForJobToComplete
		 Or CurrentSessionDate() > WaitBoundary
		 Or Context.LockedThreads.Count() = 0 Then
			Break;
		EndIf;
		// 
		If Not Query.Execute().IsEmpty() Then
			Break;
		EndIf;
	EndDo;
	
	If Indicators <> Undefined Then
		Indicators.FreeThreadWaitsTime = Indicators.FreeThreadWaitsTime
			+ (CurrentUniversalDateInMilliseconds() - WaitStart);
	EndIf;
	
EndProcedure

// For the WaitForThreadToUnlock and ProcessExecutedJobs procedures.
Function ThreadsIDs(LockedThreads)
	
	ThreadsIDs = New Array;
	
	For Each ThreadDetails In LockedThreads Do
		ThreadsIDs.Add(ThreadDetails.Key);
	EndDo;
	
	Return ThreadsIDs;
	
EndFunction

// For the WaitForThreadToUnlock and DeleteStoppedThreads procedures.
Procedure UpdateBackgroundJobProperties(Stream, Context)
	
	BackgroundJob = BackgroundJobs.FindByUUID(Stream.ThreadID);
	
	If BackgroundJob = Undefined Then
		If RegisterAccessUpdateIndicators() Then
			RegisterAccessUpdateError(UpdateErrorTextWithContext(
				NStr("en = 'Cannot find the started background job.';"), Stream.Job, True), Context);
		EndIf;
		Context.ProcessingCompleted = False;
		Return;
	EndIf;
	Stream.BackgroundJob = BackgroundJob;
	
EndProcedure

// For the EndAccessUpdate procedure.
Procedure CancelThreadBackgroundJob(Stream, Context)
	
	UpdateBackgroundJobProperties(Stream, Context);
	BackgroundJob = Stream.BackgroundJob;
	
	If BackgroundJob = Undefined
	 Or BackgroundJob.State <> BackgroundJobState.Active Then
		
		Return;
	EndIf;
	
	Try
		BackgroundJob.Cancel();
	Except
		ErrorPresentation = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Cannot cancel the thread''s background job. Reason:
			           |%1';"), ErrorProcessing.BriefErrorDescription(ErrorInfo()));
		RegisterAccessUpdateError(UpdateErrorTextWithContext(
			ErrorPresentation, Stream.Job, True), Context);
	EndTry;
	
	Context.ProcessingCompleted = False;
	
EndProcedure

// For the ExecuteAccessUpdate and ProcessJobResult procedure.
Procedure ProcessExecutedJobs(Context, LockedThreads = Undefined)
	
	If Context.UpdateInThisSession Then
		If AccessUpdateCanceled() Then
			Context.RefreshEnabledCanceled = True;
		EndIf;
		Return;
	EndIf;
	
	Indicators = Context.Indicators;
	If Indicators <> Undefined Then
		ProcessingStart = CurrentUniversalDateInMilliseconds();
	EndIf;
	
	If LockedThreads = Undefined Then
		LockedThreads = Context.LockedThreads;
	EndIf;
	ThreadsDetails = New Map(New FixedMap(LockedThreads));
	
	Query = New Query;
	Query.SetParameter("CancelID", CancelUpdateAtRecordLevelID());
	Query.SetParameter("ThreadsIDs", ThreadsIDs(ThreadsDetails));
	Query.SetParameter("ExecutionExpectationLimit", CurrentSessionDate()
		- MaxWaitSecondsCountOfWaitingForOneJobInThreadToBeProcessed());
	
	Query.Text =
	"SELECT
	|	CurrentJobs.ThreadID AS ThreadID,
	|	CurrentJobs.Result AS Result,
	|	CurrentJobs.IsStart
	|			AND &ExecutionExpectationLimit > CurrentJobs.RegisterRecordChangeDate
	|		OR CurrentJobs.ThreadID = &CancelID AS RunTimeExceeded,
	|	CurrentJobs.RegisterRecordChangeDate AS RegisterRecordChangeDate
	|FROM
	|	InformationRegister.UsersAccessKeysCurrentJobs AS CurrentJobs
	|WHERE
	|	(NOT CurrentJobs.IsStart
	|				AND CurrentJobs.ThreadID IN (&ThreadsIDs)
	|			OR CurrentJobs.IsStart
	|				AND &ExecutionExpectationLimit > CurrentJobs.RegisterRecordChangeDate
	|			OR CurrentJobs.ThreadID = &CancelID)";
	
	ResultsDetails = New Map;
	Selection = Query.Execute().Select();
	
	While Selection.Next() Do
		If Selection.RunTimeExceeded = True Then
			If Selection.ThreadID = CancelUpdateAtRecordLevelID() Then
				Context.RefreshEnabledCanceled = True;
				Return;
			EndIf;
			Stream = Context.LockedThreads.Get(Selection.ThreadID);
			If Stream = Undefined Then
				For Each FreeThread In Context.FreeThreads Do
					If FreeThread.ThreadID = Selection.ThreadID Then
						Stream = FreeThread;
						Break;
					EndIf;
				EndDo;
			EndIf;
			If Stream = Undefined Then
				Continue;
			EndIf;
			If Stream.Job.ListID = Context.AccessGroupsSetsCatalogID
			   And Selection.RegisterRecordChangeDate > (Query.Parameters.ExecutionExpectationLimit
			       - MaxWaitSecondsCountOfWaitingForOneJobInThreadToBeProcessed()) Then
				Continue;
			EndIf;
			
			ErrorPresentation = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'The thread''s job execution timeout is exceeded (%1 sec).
				           |The thread''s background job is canceled and restarted.';"),
				MaxWaitSecondsCountOfWaitingForOneJobInThreadToBeProcessed());
			
			RegisterAccessUpdateError(UpdateErrorTextWithContext(
				ErrorPresentation, Stream.Job, True), Context);
			
			CancelThreadBackgroundJob(Stream, Context);
			DeleteThread(Stream, Context);
			ThreadsDetails.Delete(Stream.ThreadID);
			
			If Indicators <> Undefined Then
				Indicators.ThreadsExceedingExecutionTimeCount =
					Indicators.ThreadsExceedingExecutionTimeCount + 1;
			EndIf;
			
		ElsIf TypeOf(Selection.Result) = Type("ValueStorage") Then
			ResultDetails = New Structure;
			ResultDetails.Insert("CompletedOn", Selection.RegisterRecordChangeDate);
			ResultDetails.Insert("Result",      Selection.Result.Get());
			ResultsDetails.Insert(Selection.ThreadID, ResultDetails);
		EndIf;
	EndDo;
	
	For Each ThreadDetails In ThreadsDetails Do
		Stream = ThreadDetails.Value;
		ResultDetails = ResultsDetails.Get(Stream.ThreadID);
		ProcessCompletedJobResult(Stream, ResultDetails, Context);
	EndDo;
	
	ThreadsCount = Context.LockedThreads.Count() + Context.FreeThreads.Count();
	If ThreadsCount > Context.ThreadsCount Then
		IndexOf = Context.FreeThreads.Count() - 1;
		While IndexOf >= 0 Do
			FreeThread = Context.FreeThreads.Get(IndexOf);
			DeleteThread(FreeThread, Context);
			IndexOf = IndexOf - 1;
			ThreadsCount = ThreadsCount - 1;
			If ThreadsCount <= Context.ThreadsCount Then
				Break;
			EndIf;
		EndDo;
	EndIf;
	
	Context.HasLongRunningJobOfReceivingDataItemsBatches = False;
	QueryDelay = Context.MaxSecondsCountOfQuickDataItemsBatchReceipt;
	If QueryDelay > 0 Then
		CurrentOccupiedThreads = New Map(New FixedMap(Context.LockedThreads));
		For Each ThreadDetails In CurrentOccupiedThreads Do
			Stream = ThreadDetails.Value; // See NewThread
			If Stream.BatchFromSet <> Undefined
			 Or Stream.Job.IsRightsUpdate
			 Or Stream.Job.IsObsoleteItemsDataProcessor Then
				Continue;
			EndIf;
			If CurrentSessionDate() - Stream.Job.CommonJobLastRunDate < QueryDelay Then
				Continue;
			EndIf;
			If Not Context.HasLongRunningJobOfReceivingDataItemsBatches Then
				Context.HasLongRunningJobOfReceivingDataItemsBatches = True;
				QueryDelay = QueryDelay / 2;
				Continue;
			EndIf;
			CancelThreadBackgroundJob(Stream, Context);
			DeleteThread(Stream, Context);
			Context.LockedThreads.Delete(Stream.ThreadID);
		EndDo;
	EndIf;
	
	If CurrentSessionDate() > Context.JobsUpdateBoundary Then
		Context.JobsUpdateBoundary = CurrentSessionDate() + 2;
		DeleteStoppedThreads(Context, Context.LockedThreads);
		DeleteStoppedThreads(Context, Context.FreeThreads);
		DeleteNotUsedFreeThreads(Context);
	EndIf;
	
	If Indicators <> Undefined Then
		Indicators.JobsResultsProcessingTime = Indicators.JobsResultsProcessingTime
			+ (CurrentUniversalDateInMilliseconds() - ProcessingStart);
	EndIf;
	
EndProcedure

// For the ProcessCompletedJobs, RunListAccessUpdateWithRetryAttempts procedures.
Function AccessUpdateCanceled()
	
	Query = New Query;
	Query.SetParameter("ThreadID", CancelUpdateAtRecordLevelID());
	Query.Text =
	"SELECT TOP 1
	|	TRUE AS TrueValue
	|FROM
	|	InformationRegister.UsersAccessKeysCurrentJobs AS CurrentJobs
	|WHERE
	|	CurrentJobs.ThreadID = &ThreadID";
	
	Return Not Query.Execute().IsEmpty();
	
EndFunction

// For the ProcessCompletedJobs procedure.
Procedure ProcessCompletedJobResult(Stream, ResultDetails, Context)
	
	If Not Stream.CancelJob
	   And Not Stream.Job.Delete Then
		
		If ResultDetails = Undefined Then
			Return;
		ElsIf TypeOf(ResultDetails.Result) <> Type("Structure") Then
			Context.ProcessingCompleted = False;
		Else
			Result = ResultDetails.Result;
			If Result.Property("BatchFromSet") Then
				Result.BatchFromSet = Stream.BatchFromSet;
			EndIf;
			Indicators = Context.Indicators;
			If Indicators <> Undefined Then
				Indicators.JobProcessingStart = CurrentUniversalDateInMilliseconds();
			EndIf;
			ProcessJobResult(Context, Result, Stream.Job);
			If Indicators <> Undefined Then
				RemoveJobResultProcessingIndicators(Indicators);
			EndIf;
		EndIf;
	EndIf;
	
	If ResultDetails = Undefined Then
		CompletedOn = Undefined;
	Else
		CompletedOn = ResultDetails.CompletedOn;
	EndIf;
	
	UnlockThread(Stream, Context, CompletedOn);
	
EndProcedure

// For the ProcessCompletedJobResult and DeleteThread procedures.
Procedure UnlockThread(Stream, Context, CompletedOn = Undefined)
	
	InsertPosition = 0;
	If CompletedOn = Undefined Then
		Stream.ReleaseDate = CurrentSessionDate();
	Else
		Stream.ReleaseDate = CompletedOn;
		Count = Context.FreeThreads.Count();
		While InsertPosition < Count Do
			CurrentThread = Context.FreeThreads.Get(InsertPosition);
			If CurrentThread.ReleaseDate <= CompletedOn Then
				Break;
			EndIf;
			InsertPosition = InsertPosition + 1;
		EndDo;
	EndIf;
	
	Context.FreeThreads.Insert(InsertPosition, Stream);
	Context.LockedThreads.Delete(Stream.ThreadID);
	Stream.Job.LockedThreads.Delete(Stream.ThreadID);
	If Stream.BatchFromSet <> Undefined Then
		RemoveBeingProcessedFlagForBatch(Stream, Stream.Job);
		Stream.BatchFromSet = Undefined;
	EndIf;
	Stream.Job = Undefined;
	Stream.CancelJob = False;
	
EndProcedure

// For the StartListAccessUpdate, ProcessCompletedJobResult, UnlockThread procedures.
Procedure RemoveBeingProcessedFlagForBatch(ThreadOrResult, Job)
	
	BatchFromSet = Undefined;
	
	If Not ThreadOrResult.Property("BatchFromSet", BatchFromSet)
	 Or BatchFromSet = Undefined
	 Or Not BatchFromSet.InProcessing Then
		Return;
	EndIf;
	
	If Not BatchFromSet.Processed1 Then
		BatchIndex = Job.BatchesSet.Find(BatchFromSet);
		
		If BatchIndex = Undefined Then
			Job.IndexOfLastBatchToProcess = 0;
			
		ElsIf Job.IndexOfLastBatchToProcess > BatchIndex Then
			Job.IndexOfLastBatchToProcess = BatchIndex;
		EndIf;
	EndIf;
	
	BatchFromSet.InProcessing = False;
	
EndProcedure

// For the ProcessCompletedJobResult, CompleteAccessUpdate procedures.
Procedure DeleteThread(Stream, Context)
	
	RecordSet = ServiceRecordSet(InformationRegisters.UsersAccessKeysCurrentJobs);
	RecordSet.Filter.ThreadID.Set(Stream.ThreadID);
	RecordSet.Write();
	
	If Context.LockedThreads.Get(Stream.ThreadID) <> Undefined Then
		UnlockThread(Stream, Context);
	EndIf;
	
	IndexOf = Context.FreeThreads.Find(Stream);
	If IndexOf <> Undefined Then
		Context.FreeThreads.Delete(IndexOf);
	EndIf;
	
EndProcedure

// For the ProcessCompletedJobResult, CompleteAccessUpdate procedures.
Procedure DeleteStoppedThreads(Context, ThreadsDetails)
	
	If TypeOf(ThreadsDetails) = Type("Map") Then
		InitialThreadsDetails = New FixedMap(ThreadsDetails);
	Else
		InitialThreadsDetails = New FixedArray(ThreadsDetails);
	EndIf;
	
	For Each ThreadDetails In InitialThreadsDetails Do
		If TypeOf(ThreadDetails) = Type("KeyAndValue") Then
			Stream = ThreadDetails.Value;
		Else
			Stream = ThreadDetails;
		EndIf;
		UpdateBackgroundJobProperties(Stream, Context);
		BackgroundJob = Stream.BackgroundJob;
		
		If BackgroundJob <> Undefined
		   And BackgroundJob.State = BackgroundJobState.Active Then
			Continue;
		EndIf;
		Context.ProcessingCompleted = False;
		
		DeleteThread(Stream, Context);
		
		If BackgroundJob <> Undefined
		   And BackgroundJob.State = BackgroundJobState.Failed Then
			
			RegisterAccessUpdateError(UpdateErrorTextWithContext(
				BackgroundJob.ErrorInfo, Stream.Job, True), Context);
			
			If Context.Indicators <> Undefined Then
				Context.Indicators.ThreadsWithNonStandardCompletionCount =
					Context.Indicators.ThreadsWithNonStandardCompletionCount + 1;
			EndIf;
		EndIf;
	EndDo;
	
EndProcedure

// For the ProcessCompletedJobs procedure.
Procedure DeleteNotUsedFreeThreads(Context)
	
	Count = Context.FreeThreads.Count();
	If Count = 0 Then
		Return;
	EndIf;
	
	FreeThreads = Context.FreeThreads;
	IndexOf = Count - 1;
	CurrentSessionDate = CurrentSessionDate();
	
	While IndexOf >= 0 Do
		Stream = FreeThreads.Get(IndexOf);
		If CurrentSessionDate > Stream.ReleaseDate + 15 Then
			DeleteThread(Stream, Context);
		EndIf;
		IndexOf = IndexOf - 1;
	EndDo;
	
EndProcedure

// For the AddAccessUpdateJobs and ProcessJobResult procedures.
Procedure CancelJob(Job)
	
	Job.BatchesSet = New Array;
	Job.BatchesToProcessCount = 0;
	Job.IndexOfLastBatchToProcess = 0;
	
	For Each ThreadDetails In Job.LockedThreads Do
		ThreadDetails.Value.CancelJob = True;
	EndDo;
	
EndProcedure

// For the StartListAccessUpdate and ProcessCompletedJobResult procedures.
Procedure ProcessJobResult(Context, Result, Job)
	
	If Result.Property("NoJobs") Or Result.Property("UpdateRestart") Then
		If Result.Property("UpdateRestart") Then
			Job.HasRestart = True;
			If Result.Property("RestartUpdateFromBeginning") Then
				Job.HasInitialUpdate = True;
			EndIf;
		EndIf;
		CancelJob(Job);
		If Result.Property("NoJobs") Then
			RemoveBeingProcessedFlagForBatch(Result, Job);
			UpdateJobProperties(Job, New Structure("DataKey", Null));
			If Result.NoJobs = "MetadataObjectDisabled" Then
				Context.DisabledMetadataObjectsIDs.Insert(Job.ListID, True);
			EndIf;
		EndIf;
	EndIf;
	
	If Result.Property("SessionRestartRequired") Then
		Context.SessionRestartRequired = True;
		Context.ProcessingCompleted = False;
		StandardSubsystemsServer.InstallRequiresSessionRestart(Result.SessionRestartRequired);
		RemoveBeingProcessedFlagForBatch(Result, Job);
		Return;
	EndIf;
	
	If Result.Property("CompletionErrorText") Then
		If Not Result.ProcessingCompleted Then
			Context.ProcessingCompleted = False;
		EndIf;
		If ValueIsFilled(Result.CompletionErrorText) Then
			RemoveBeingProcessedFlagForBatch(Result, Job);
			AddCompletionErrorText(Context.CompletionErrorText, Result.CompletionErrorText);
			Return;
		EndIf;
	EndIf;
	
	If Result.Property("NoJobs") Then
		Return;
	EndIf;
	
	If Result.Property("InitialUpdateCompleted") Then
		Job.HasInitialUpdate = False;
		Job.HasRestart = False;
	EndIf;
	
	If Result.Property("BatchFromSet") Then
		InitialBatchFromSet = Result.BatchFromSet;
		If Result.Property("BatchesSet") Then
			IndexOf = Job.BatchesSet.Find(InitialBatchFromSet);
			If Job.IndexOfLastBatchToProcess > IndexOf Then
				Job.IndexOfLastBatchToProcess = IndexOf + 1;
			EndIf;
			For Each NewBatchFromSourceOne In Result.BatchesSet Do
				IndexOf = IndexOf + 1;
				Job.BatchesSet.Insert(IndexOf, NewBatchFromSourceOne);
			EndDo;
			Job.BatchesToProcessCount = Job.BatchesToProcessCount
				+ Result.BatchesSet.Count();
			InitialBatchFromSet.LastBatchItem      = Result.NewLastUpdatedItem;
			InitialBatchFromSet.NewLastBatchItem = Result.NewLastUpdatedItem;
		EndIf;
		InitialBatchFromSet.Processed1 = True;
		RemoveBeingProcessedFlagForBatch(Result, Job);
		
	ElsIf Result.Property("BatchesSet") Then
		For Each NewBatch In Result.BatchesSet Do
			Job.BatchesSet.Add(NewBatch);
		EndDo;
		Job.BatchesToProcessCount = Job.BatchesToProcessCount
			+ Result.BatchesSet.Count();
		
	ElsIf Result.Property("NewLastUpdatedItem") Then
		UpdateJobProperties(Job, Result.NewLastUpdatedItem);
	EndIf;
	
	If Result.Property("BatchFromSet") And CommonJobBeingExecuted(Job) Then
		Return;
	EndIf;
	
	Commit = False;
	While Job.BatchesSet.Count() > 0 Do
		BatchFromSet = Job.BatchesSet[0];
		If Not BatchFromSet.Processed1 Then
			Break;
		EndIf;
		Commit = True;
		NewLastUpdatedItem = BatchFromSet.NewLastBatchItem;
		Job.BatchesSet.Delete(0);
		If Job.IndexOfLastBatchToProcess > 0 Then
			Job.IndexOfLastBatchToProcess = Job.IndexOfLastBatchToProcess - 1;
		EndIf;
	EndDo;
	
	If Commit Then
		WriteLastUpdatedItem(Result, NewLastUpdatedItem);
		UpdateJobProperties(Job, NewLastUpdatedItem);
		If Not Result.ProcessingCompleted Then
			Context.ProcessingCompleted = False;
		EndIf;
	EndIf;
	
EndProcedure

// For the ProcessJobResult procedure.
Procedure UpdateJobProperties(Job, NewLastUpdatedItem)
	
	If NewLastUpdatedItem.DataKey = Null Then
		Job.Delete = True;
	Else
		If NewLastUpdatedItem.Property("Date") Then
			Job.LatestUpdatedItemDate = NewLastUpdatedItem.Date;
		Else
			Job.LatestUpdatedItemDate = '00010101';
		EndIf;
		Job.HasLastUpdatedItemDate
			= ValueIsFilled(Job.LatestUpdatedItemDate);
		
		Job.DataKeyKindOrder = NewLastUpdatedItem.DataKeyKindOrder;
		UpdateIsObsoleteItemsDataProcessorProperty(Job);
	EndIf;
	
EndProcedure

// For the StartListAccessUpdate function.
Procedure UpdateListAccessInBackground(ParentSessionDetails) Export
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	Context = New Structure;
	Context.Insert("Indicators", ActiveThreadUpdateIndicators());
	Context.Insert("ParentSessionDetails", ParentSessionDetails);
	
	If Not PerformingThreadStarted(Context) Then
		Return;
	EndIf;
	Cache = New Structure;
	
	While True Do
		Query = Context.Query; // Query
		Selection = Query.Execute().Select();
		If Not Selection.Next() Then
			Break;
		EndIf;
		If TypeOf(Selection.Parameters) <> Type("ValueStorage") Then
			If ContinueWaitForNewJob(Context) Then
				Continue;
			Else
				Break;
			EndIf;
		EndIf;
		Result = CommonUpdateParametersDetails();
		Result.Insert("ProcessingCompleted", False);
		Result.Insert("CompletionErrorText", "");
		Try
			CommonUpdateParameters = Selection.Parameters.Get(); // See CommonUpdateParametersDetails
			FillPropertyValues(Result, CommonUpdateParameters);
			CommonUpdateParameters.Insert("Cache", Cache);
			Context.WaitSecondsCountTillNewJobSearch =
				Int(0.025 * Result.MaxProcessingMilliseconds) / 1000;
			
			UpdateListAccessWithRetryAttempts(CommonUpdateParameters, Context);
			Result.ProcessingCompleted = CommonUpdateParameters.ProcessingCompleted;
			
			PropertiesToReturn = "NoJobs, UpdateRestart, RestartUpdateFromBeginning,
				|BatchesSet, NewLastUpdatedItem, InitialUpdateCompleted,
				|CompletionErrorText, SessionRestartRequired";
			For Each KeyAndValue In New Structure(PropertiesToReturn) Do
				If CommonUpdateParameters.Property(KeyAndValue.Key) Then
					Result.Insert(KeyAndValue.Key, CommonUpdateParameters[KeyAndValue.Key]);
				EndIf;
			EndDo;
			If CommonUpdateParameters.Property("BatchFromSet") Then
				Result.Insert("BatchFromSet");
			EndIf;
		Except
			AddCompletionErrorText(Result.CompletionErrorText, UpdateErrorTextWithContext(
				ErrorProcessing.DetailErrorDescription(ErrorInfo()), Result));
		EndTry;
		WriteResultOfListAccessUpdateInBackground(Result, Selection.Parameters, Context);
	EndDo;
	
	If RegisterAccessUpdateIndicators() Then
		RegisterActiveThreadUpdateIndicators(Context);
	EndIf;
	
EndProcedure

// For the RunListAccessUpdateInBackground procedure.
Function PerformingThreadStarted(Context)
	
	CurrentSession = GetCurrentInfoBaseSession();
	Context.Insert("CurrentSession", CurrentSession);
	
	If CurrentSession.ApplicationName <> "BackgroundJob" Then
		ErrorText = NStr("en = 'Couldn''t process an access update batch outside of a background job.';");
		Raise ErrorText;
	EndIf;
	
	Context.Insert("CurrentBackgroundJob", CurrentSession.GetBackgroundJob());
	ThreadID = Context.CurrentBackgroundJob.UUID;
	
	Query = New Query;
	Query.SetParameter("ThreadID", ThreadID);
	Query.Text =
	"SELECT
	|	CASE
	|		WHEN CurrentJobs.IsStart
	|			THEN CurrentJobs.Parameters
	|		ELSE UNDEFINED
	|	END AS Parameters
	|FROM
	|	InformationRegister.UsersAccessKeysCurrentJobs AS CurrentJobs
	|WHERE
	|	CurrentJobs.ThreadID = &ThreadID";
	Context.Insert("Query", Query);
	
	Block = New("DataLock");
	LockItem = Block.Add("InformationRegister.UsersAccessKeysCurrentJobs");
	LockItem.SetValue("ThreadID", ThreadID);
	Context.Insert("Block", Block);
	
	RecordSet = ServiceRecordSet(InformationRegisters.UsersAccessKeysCurrentJobs);
	RecordSet.Filter.ThreadID.Set(ThreadID);
	Context.Insert("RecordSet", RecordSet);
	
	SetRecord = RecordSet.Add();
	SetRecord.ThreadID = ThreadID;
	SetRecord.IsStart = False;
	Context.Insert("SetRecord", SetRecord);
	
	// Waiting for startup flag.
	WaitBoundary = CurrentUniversalDateInMilliseconds() + 1000;
	While True Do
		If Not Query.Execute().IsEmpty() Then
			Break;
		EndIf;
		If CurrentUniversalDateInMilliseconds() > WaitBoundary Then
			Return False;
		EndIf;
		Context.CurrentBackgroundJob.WaitForExecutionCompletion(0.025);
	EndDo;
	
	Context.Insert("ParentSessionCheckBoundary", CurrentUniversalDateInMilliseconds() + 1000);
	Context.Insert("WaitSecondsCountTillNewJobSearch", 0.025);
	
	Return True;
	
EndFunction

// For the RunListAccessUpdateInBackground procedure.
Function ContinueWaitForNewJob(Context)
	
	If CurrentUniversalDateInMilliseconds() > Context.ParentSessionCheckBoundary Then
		If AccessUpdateCanceled() Then
			Return False;
		EndIf;
		Context.ParentSessionCheckBoundary = CurrentUniversalDateInMilliseconds() + 1000;
		If Not SessionExists(Context.ParentSessionDetails) Then
			Return False;
		EndIf;
	EndIf;
	
	Indicators = Context.Indicators;
	If Indicators <> Undefined Then
		Indicators.WaitsForNewJobsCount = Indicators.WaitsForNewJobsCount + 1;
	EndIf;
	
	WaitStart = CurrentUniversalDateInMilliseconds();
	
	Context.CurrentBackgroundJob.WaitForExecutionCompletion(
		Context.WaitSecondsCountTillNewJobSearch);
	
	If Indicators <> Undefined Then
		Indicators.NewJobsWaitTime = Indicators.NewJobsWaitTime
			+ (CurrentUniversalDateInMilliseconds() - WaitStart);
	EndIf;
	If Context.WaitSecondsCountTillNewJobSearch < 1 Then
		Context.WaitSecondsCountTillNewJobSearch =
			Context.WaitSecondsCountTillNewJobSearch + 0.010;
	EndIf;
	
	Return True;
	
EndFunction

// For the ContinueWaitForNewJob function.
Function SessionExists(SessionDetails)
	
	If ValueIsFilled(SessionDetails.BackgroundJobIdentifier) Then
		BackgroundJob = BackgroundJobs.FindByUUID(
			SessionDetails.BackgroundJobIdentifier);
		
		Return BackgroundJob <> Undefined
		      And BackgroundJob.State = BackgroundJobState.Active;
	EndIf;
	
	MainSessionFound = False;
	Sessions = GetInfoBaseSessions();
	
	For Each Session In Sessions Do
		
		If Session.SessionStarted = SessionDetails.SessionStarted
		   And Session.SessionNumber  = SessionDetails.SessionNumber Then
			
			MainSessionFound = True;
			Break;
		EndIf;
	EndDo;
	
	Return MainSessionFound;
	
EndFunction

// For the RunListAccessUpdateInBackground procedure.
Procedure WriteResultOfListAccessUpdateInBackground(Result, InitialParameters, Context)
	
	BeginTransaction();
	Try
		Context.Block.Lock();
		Query = Context.Query; // Query - 
		Selection = Query.Execute().Select();
		
		If Selection.Next()
		   And XMLString(Selection.Parameters) = XMLString(InitialParameters) Then
			
			Context.SetRecord.Parameters = InitialParameters;
			Context.SetRecord.Result = New ValueStorage(Result);
			Context.SetRecord.RegisterRecordChangeDate = CurrentSessionDate();
			RecordSet = Context.RecordSet; // InformationRegisterRecordSet - 
			RecordSet.Write();
		EndIf;
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

// For the RunListAccessUpdateInBackground procedure.
Function LeadingThreadUpdateIndicators(Context)
	
	If Not RegisterAccessUpdateIndicators() Then
		Return Undefined;
	EndIf;
	
	Indicators = New Structure;
	
	// Variables.
	Indicators.Insert("WorkStartInMilliseconds", CurrentUniversalDateInMilliseconds());
	Indicators.Insert("JobAssignmentStart");
	
	If Context.UpdateInThisSession Then
		AddJobsExecutionIndicators(Indicators);
	Else
		Indicators.Insert("FreeThreadWaitsTime", 0);
		
		Indicators.Insert("IssuedJobsCount", 0);
		Indicators.Insert("JobsIssueTime", 0);
		Indicators.Insert("MinJobAssignmentTime", 0);
		Indicators.Insert("MaxJobAssignmentTime", 0);
		
		Indicators.Insert("JobsResultsProcessingTime", 0);
		Indicators.Insert("MinJobResultProcessingTime", 0);
		Indicators.Insert("MaxJobResultProcessingTime", 0);
		
		Indicators.Insert("ThreadsExceedingExecutionTimeCount", 0);
		Indicators.Insert("ThreadsWithNonStandardCompletionCount", 0);
		
		// Variables.
		Indicators.Insert("JobProcessingStart", 0);
	EndIf;
	
	Return Indicators;
	
EndFunction

// For the RunListAccessUpdateInBackground procedure.
Function ActiveThreadUpdateIndicators()
	
	If Not RegisterAccessUpdateIndicators() Then
		Return Undefined;
	EndIf;
	
	Indicators = New Structure;
	
	Indicators.Insert("WorkStartInMilliseconds", CurrentUniversalDateInMilliseconds());
	Indicators.Insert("WaitsForNewJobsCount", 0);
	Indicators.Insert("NewJobsWaitTime", 0);
	
	AddJobsExecutionIndicators(Indicators);
	
	Return Indicators;
	
EndFunction

// For the ControlThreadUpdateFunctions, ExecutingThreadUpdateFunctions functions.
Procedure AddJobsExecutionIndicators(Indicators)
	
	// Variables.
	Indicators.Insert("JobWithGetBatches", True);
	Indicators.Insert("StartFirstAttemptToExecuteJob", 0);
	Indicators.Insert("JobExecutionStart", 0);
	
	// 
	Indicators.Insert("CountOfJobsWithRetriesDueToErrors", 0);
	Indicators.Insert("JobsExecutionTimeWithRetriesDueToErrors", 0);
	Indicators.Insert("CountOfJobsRetriesDueToErrors", 0);
	Indicators.Insert("MaxJobRetriesOnErrorCount", 0);
	Indicators.Insert("ErrorsTextOnRetryAttempts", "");
	
	// 
	Indicators.Insert("CompletedJobsWithGetBatchesCount", 0);
	Indicators.Insert("JobsWithGettingBatchesExecutionTime", 0);
	Indicators.Insert("JobsWithGettingBatchesMinExecutionTime", 0);
	Indicators.Insert("JobsWithGettingBatchesMaxExecutionTime", 0);
	
	// 
	Indicators.Insert("CompletedJobsWithoutGettingBatchesCount", 0);
	Indicators.Insert("JobsWithoutGettingBatchesExecutionTime", 0);
	Indicators.Insert("JobsWithoutGettingBatchesMinExecutionTime", 0);
	Indicators.Insert("JobsWithoutGettingBatchesMaxExecutionTime", 0);
	
EndProcedure

// For the StartListAccessUpdate function.
Procedure RemoveJobsIssueIndicators(Indicators)
	
	JobIssueTime = CurrentUniversalDateInMilliseconds() - Indicators.JobAssignmentStart;
	
	Indicators.IssuedJobsCount = Indicators.IssuedJobsCount + 1;
	Indicators.JobsIssueTime = Indicators.JobsIssueTime + JobIssueTime;
	
	If Indicators.MinJobAssignmentTime = 0 Then
		Indicators.MinJobAssignmentTime = JobIssueTime;
	EndIf;
	If JobIssueTime < Indicators.MinJobAssignmentTime Then
		Indicators.MinJobAssignmentTime = JobIssueTime;
	EndIf;
	
	If JobIssueTime > Indicators.MaxJobAssignmentTime Then
		Indicators.MaxJobAssignmentTime = JobIssueTime;
	EndIf;
	
EndProcedure

// For the StartListAccessUpdate function.
Procedure RemoveJobResultProcessingIndicators(Indicators)
	
	JobProcessingTime = CurrentUniversalDateInMilliseconds() - Indicators.JobProcessingStart;
	
	Indicators.JobsResultsProcessingTime =
		Indicators.JobsResultsProcessingTime + JobProcessingTime;
	
	If Indicators.MinJobResultProcessingTime = 0 Then
		Indicators.MinJobResultProcessingTime = JobProcessingTime;
	EndIf;
	If JobProcessingTime < Indicators.MinJobResultProcessingTime Then
		Indicators.MinJobResultProcessingTime = JobProcessingTime;
	EndIf;
	
	If JobProcessingTime > Indicators.MaxJobResultProcessingTime Then
		Indicators.MaxJobResultProcessingTime = JobProcessingTime;
	EndIf;
	
EndProcedure

// For the RunListAccessUpdateInBackground procedure.
Procedure RemoveJobExecutionIndicators(Indicators)
	
	JobExecutionTime = CurrentUniversalDateInMilliseconds() - Indicators.JobExecutionStart;
	
	If Indicators.JobWithGetBatches Then
		Indicators.CompletedJobsWithGetBatchesCount =
			Indicators.CompletedJobsWithGetBatchesCount + 1;
		
		Indicators.JobsWithGettingBatchesExecutionTime =
			Indicators.JobsWithGettingBatchesExecutionTime + JobExecutionTime;
		
		If Indicators.JobsWithGettingBatchesMinExecutionTime = 0 Then
			Indicators.JobsWithGettingBatchesMinExecutionTime = JobExecutionTime;
		EndIf;
		If JobExecutionTime < Indicators.JobsWithGettingBatchesMinExecutionTime Then
			Indicators.JobsWithGettingBatchesMinExecutionTime = JobExecutionTime;
		EndIf;
		
		If JobExecutionTime > Indicators.JobsWithGettingBatchesMaxExecutionTime Then
			Indicators.JobsWithGettingBatchesMaxExecutionTime = JobExecutionTime;
		EndIf;
	Else
		Indicators.CompletedJobsWithoutGettingBatchesCount =
			Indicators.CompletedJobsWithoutGettingBatchesCount + 1;
		
		Indicators.JobsWithoutGettingBatchesExecutionTime =
			Indicators.JobsWithoutGettingBatchesExecutionTime + JobExecutionTime;
		
		If Indicators.JobsWithoutGettingBatchesMinExecutionTime = 0 Then
			Indicators.JobsWithoutGettingBatchesMinExecutionTime = JobExecutionTime;
		EndIf;
		If JobExecutionTime < Indicators.JobsWithoutGettingBatchesMinExecutionTime Then
			Indicators.JobsWithoutGettingBatchesMinExecutionTime = JobExecutionTime;
		EndIf;
		
		If JobExecutionTime > Indicators.JobsWithoutGettingBatchesMaxExecutionTime Then
			Indicators.JobsWithoutGettingBatchesMaxExecutionTime = JobExecutionTime;
		EndIf;
	EndIf;
	
EndProcedure

// For the RunListAccessUpdateInBackground procedure.
Procedure RemoveJobExecutionErrorsIndicators(Indicators, ErrorsText, ErrorsCount);
	
	If ErrorsCount = 0 Then
		Return;
	EndIf;
	
	Indicators.CountOfJobsWithRetriesDueToErrors = Indicators.CountOfJobsWithRetriesDueToErrors + 1;
	
	Indicators.JobsExecutionTimeWithRetriesDueToErrors = Indicators.JobsExecutionTimeWithRetriesDueToErrors
		+ (CurrentUniversalDateInMilliseconds() - Indicators.StartFirstAttemptToExecuteJob);
	
	Indicators.CountOfJobsRetriesDueToErrors =
		Indicators.CountOfJobsRetriesDueToErrors + ErrorsCount;
	
	If ErrorsCount > Indicators.MaxJobRetriesOnErrorCount Then
		Indicators.MaxJobRetriesOnErrorCount = ErrorsCount;
	EndIf;
	
	AddCompletionErrorText(Indicators.ErrorsTextOnRetryAttempts, ErrorsText);
	
EndProcedure

// For the RegisterMainThreadUpdateFunctions,
// RegisterActiveThreadUpdateIndicators,
// AddSessionOperationIndicatorsValues,
// AddJobsCompletionFunctionsValues procedures.
//
Function SecondsFormat(SecondsCount1)
	
	If SecondsCount1 = 0 Then
		Return StrReplace(Format(1.111), "1", "0");
	EndIf;
	
	Return Format(SecondsCount1, "NFD=3; NG=");
	
EndFunction

// For the RegisterMainThreadUpdateFunctions,
// RegisterActiveThreadUpdateIndicators,
// AddJobsCompletionFunctionsValues procedures.
//
Function CountFormat(CountNumber)
	
	Return Format(CountNumber, "NZ=0; NG=");
	
EndFunction

// For the EndAccessUpdate procedure.
Procedure RegisterMainThreadUpdateIndicators(Context)
	
	Indicators = Context.Indicators;
	SessionDetails = Context.MainSessionDetails; // See MainSessionDetails
	
	If Context.UpdateInThisSession Then
		Comment = NStr("en = 'The access update session is completed.';");
		AddSessionOperationIndicatorsValues(Comment, Indicators, SessionDetails);
		AddJobsExecutionIndicatorsValues(Comment, Indicators);
	Else
		FreeThreadWaitsTime = Indicators.FreeThreadWaitsTime / 1000;
		
		JobsIssueTime             = Indicators.JobsIssueTime / 1000;
		MinJobAssignmentTime  = Indicators.MinJobAssignmentTime / 1000;
		MaxJobAssignmentTime = Indicators.MaxJobAssignmentTime / 1000;
		
		JobsResultsProcessingTime            = Indicators.JobsResultsProcessingTime / 1000;
		MinJobResultProcessingTime  = Indicators.MinJobResultProcessingTime / 1000;
		MaxJobResultProcessingTime = Indicators.MaxJobResultProcessingTime / 1000;
		
		Comment = NStr("en = 'The access update''s thread-of-control session is completed.';");
		AddSessionOperationIndicatorsValues(Comment, Indicators, SessionDetails);
		
		Comment = Comment + Chars.LF + Chars.LF + StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Total time of waiting for an available thread: %1 sec.
			           |
			           |Jobs issued: %2.
			           |Job issue time: %3 sec.
			           |Minimum job issue time: %4 sec.
			           |Maximum job issue time: %5 sec.';"),
			SecondsFormat(FreeThreadWaitsTime),
			CountFormat(Indicators.IssuedJobsCount),
			SecondsFormat(JobsIssueTime),
			SecondsFormat(MinJobAssignmentTime),
			SecondsFormat(MaxJobAssignmentTime));
		
		Comment = Comment + Chars.LF + Chars.LF + StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Total time of processing job results: %1 sec.
			           |Minimum time of processing job results: %2 sec.
			           |Maximum time of processing job results: %3 sec.
			           |
			           |Threads with execution timeout exceeded: %4.
			           |Abnormally terminated threads: %5.';"),
			SecondsFormat(JobsResultsProcessingTime),
			SecondsFormat(MinJobResultProcessingTime),
			SecondsFormat(MaxJobResultProcessingTime),
			CountFormat(Indicators.ThreadsExceedingExecutionTimeCount),
			CountFormat(Indicators.ThreadsWithNonStandardCompletionCount));
	EndIf;
	Data = SessionDetails.Id;
	
	WriteLogEvent(
		NStr("en = 'Access management.Indicators.Access update';",
		     Common.DefaultLanguageCode()),
		EventLogLevel.Information, , Data, Comment);
		
EndProcedure

// For the RunListAccessUpdateInBackground procedure.
Procedure RegisterActiveThreadUpdateIndicators(Context)
	
	Indicators = Context.Indicators;
	
	NewJobsWaitTime = Indicators.NewJobsWaitTime / 1000;
	
	Comment = NStr("en = 'The access update''s thread-of-execution session is completed.';");
	AddSessionOperationIndicatorsValues(Comment, Indicators, Context.CurrentSession);
	
	SessionDetails = Context.ParentSessionDetails; // See MainSessionDetails
	
	Comment = Comment + Chars.LF + StringFunctionsClientServer.SubstituteParametersToString(
		NStr("en = 'Thread-of-control session number: %1.
		           |Thread-of-control session started at: %2.
		           |
		           |Total pauses due to waiting for an available thread: %3.
		           |Total time of waiting for new jobs: %4 sec.';"),
		SessionDetails.SessionNumber,
		SessionDetails.SessionStarted,
		CountFormat(Indicators.WaitsForNewJobsCount),
		SecondsFormat(NewJobsWaitTime));
	
	AddJobsExecutionIndicatorsValues(Comment, Indicators);
	Data = SessionDetails.Id;
	
	WriteLogEvent(
		NStr("en = 'Access management.Indicators.Access update';",
		     Common.DefaultLanguageCode()),
		EventLogLevel.Information, , Data, Comment);
		
EndProcedure

// For the RegisterControlThreadUpdateFunctions and
// RegisterExecutingThreadUpdateFunctions procedures.
//
Procedure AddSessionOperationIndicatorsValues(Comment, Indicators, SessionDetails)
	
	OperationTime = (CurrentUniversalDateInMilliseconds()
		- Indicators.WorkStartInMilliseconds) / 1000;
	
	Comment = Comment + Chars.LF + Chars.LF + StringFunctionsClientServer.SubstituteParametersToString(
		NStr("en = 'Session ID: %1.
		           |Session started at: %2.
		           |Duration: %3 sec.';"),
		SessionDetails.SessionNumber,
		SessionDetails.SessionStarted,
		SecondsFormat(OperationTime));
	
EndProcedure

// For the RegisterControlThreadUpdateFunctions and
// RegisterExecutingThreadUpdateFunctions procedures.
//
Procedure AddJobsExecutionIndicatorsValues(Comment, Indicators)
	
	JobsWithGettingBatchesExecutionTime              = Indicators.JobsWithGettingBatchesExecutionTime / 1000;
	JobsWithGettingBatchesMaxExecutionTime  = Indicators.JobsWithGettingBatchesMaxExecutionTime / 1000;
	JobsWithGettingBatchesMinExecutionTime   = Indicators.JobsWithGettingBatchesMinExecutionTime / 1000;
	
	JobsWithoutGettingBatchesExecutionTime             = Indicators.JobsWithoutGettingBatchesExecutionTime / 1000;
	JobsWithoutGettingBatchesMaxExecutionTime = Indicators.JobsWithoutGettingBatchesMaxExecutionTime / 1000;
	JobsWithoutGettingBatchesMinExecutionTime  = Indicators.JobsWithoutGettingBatchesMinExecutionTime / 1000;
	
	ExecutedJobsCount = Indicators.CompletedJobsWithGetBatchesCount
		+ Indicators.CompletedJobsWithoutGettingBatchesCount;
	
	JobsExecutionTime = JobsWithGettingBatchesExecutionTime + JobsWithoutGettingBatchesExecutionTime;
	JobsExecutionTimeWithRetriesDueToErrors = Indicators.JobsExecutionTimeWithRetriesDueToErrors / 1000;
	
	Comment = Comment + Chars.LF + Chars.LF + StringFunctionsClientServer.SubstituteParametersToString(
		NStr("en = 'Jobs completed: %1.
		           |Total jobs duration: %2 sec.
		           |
		           |Jobs retried due to errors: %3.
		           |Total duration of retried jobs: %4 sec.
		           |Jobs retried due to errors: %5.
		           |Maximum retries for a single job: %6.';"),
		CountFormat(ExecutedJobsCount),
		SecondsFormat(JobsExecutionTime),
		CountFormat(Indicators.CountOfJobsWithRetriesDueToErrors),
		SecondsFormat(JobsExecutionTimeWithRetriesDueToErrors),
		CountFormat(Indicators.CountOfJobsRetriesDueToErrors),
		CountFormat(Indicators.MaxJobRetriesOnErrorCount));
	
	Comment = Comment + Chars.LF + Chars.LF + StringFunctionsClientServer.SubstituteParametersToString(
		NStr("en = 'Jobs that get batches or process a small batch:
		           |- Jobs completed: %1.
		           |- Total time: %2 sec.
		           |- Minimum job duration: %3 sec.
		           |- Maximum job duration: %4 sec.
		           |
		           |Batch processing jobs:
		           |- Jobs completed: %5.
		           |- Total time: %6 sec.
		           |- Minimum job duration: %7 sec.
		           |- Maximum job duration: %8 sec.';"),
		CountFormat(Indicators.CompletedJobsWithGetBatchesCount),
		SecondsFormat(JobsWithGettingBatchesExecutionTime),
		SecondsFormat(JobsWithGettingBatchesMinExecutionTime),
		SecondsFormat(JobsWithGettingBatchesMaxExecutionTime),
		CountFormat(Indicators.CompletedJobsWithoutGettingBatchesCount),
		SecondsFormat(JobsWithoutGettingBatchesExecutionTime),
		SecondsFormat(JobsWithoutGettingBatchesMinExecutionTime),
		SecondsFormat(JobsWithoutGettingBatchesMaxExecutionTime));
	
	If ValueIsFilled(Indicators.ErrorsTextOnRetryAttempts) Then
		Comment = Comment + Chars.LF + Chars.LF
			+ NStr("en = 'Error messages upon retries:';")
			+ Chars.LF + Chars.LF + Indicators.ErrorsTextOnRetryAttempts;
	EndIf;
	
EndProcedure

// For the AccessUpdateAtRecordLevel, ProcessJobResult, RegisterAccessUpdateError procedures.
Procedure AddCompletionErrorText(CompletionErrorText, ErrorText)
	
	If Not ValueIsFilled(ErrorText) Then
		Return;
	EndIf;
	
	If ValueIsFilled(CompletionErrorText) Then
		If StrFind(CompletionErrorText, ErrorText) > 0 Then
			Return;
		EndIf;
		CompletionErrorText = CompletionErrorText + Chars.LF + Chars.LF;
	EndIf;
	
	CompletionErrorText = CompletionErrorText + ErrorText;
	
EndProcedure

// For the UpdateBackgroundJobProperties, CancelThreadBackgroundJob, ProcessCompletedJobs,
// DeleteStoppedThreads, RunListAccessUpdateInBackground procedures.
//
Function UpdateErrorTextWithContext(ErrorInfo, CommonUpdateParameters, ErrorToFix1 = False)
	
	If TypeOf(ErrorInfo) = Type("ErrorInfo") Then
		ErrorPresentation = ErrorProcessing.DetailErrorDescription(ErrorInfo);
	Else
		ErrorPresentation = String(ErrorInfo);
	EndIf;
	
	If Not ValueIsFilled(ErrorPresentation) Then
		Return "";
	EndIf;
	
	If CommonUpdateParameters = Undefined Then
		ErrorText = ErrorPresentation;
		
	ElsIf Not CommonUpdateParameters.IsRightsUpdate Then
		
		If CommonUpdateParameters.ForExternalUsers Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'Cannot update access keys
				           |for the ""%1"" list data items (for external users)
				           |due to:
				           |%2';"),
				String(CommonUpdateParameters.ListID),
				ErrorPresentation);
		Else
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'Cannot update access keys
				           |for the ""%1"" list data items (for users)
				           |due to:
				           |%2';"),
				String(CommonUpdateParameters.ListID),
				ErrorPresentation);
		EndIf;
		
	Else // UsersAccessKeysUpdate.
		
		If CommonUpdateParameters.ForExternalUsers Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'Cannot update external user access keys
				           |for the ""%1"" list
				           |due to:
				           |%2';"),
				String(CommonUpdateParameters.ListID),
				ErrorPresentation);
		Else
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'Cannot update user access keys
				           |for the ""%1"" list
				           |due to:
				           |%2';"),
				String(CommonUpdateParameters.ListID),
				ErrorPresentation);
		EndIf;
	EndIf;
	
	If ErrorToFix1 Then
		ErrorText = NStr("en = 'A recoverable error occurred (the update continues automatically).';")
			+ Chars.LF + ErrorText;
	EndIf;
	
	Return ErrorText;
	
EndFunction

// For the AccessUpdateOnRecordsLevel, CompleteBackgroundJobs,
// ProcessCompletedJobResult, UpdateBackgroundJobProperties,
// UpdateListAccessInBackground procedures.
//
Procedure RegisterAccessUpdateError(ErrorText, Context)
	
	If Context.Property("ParentSessionDetails") Then
		SessionDetails = Context.ParentSessionDetails; // See MainSessionDetails
	Else
		SessionDetails = Context.MainSessionDetails; // See MainSessionDetails
	EndIf;
	
	Data = SessionDetails.Id;
	
	WriteLogEvent(
		NStr("en = 'Access management.Record-level access update';",
			Common.DefaultLanguageCode()),
		EventLogLevel.Error, , Data, ErrorText);
	
EndProcedure

// For the StartListAccessUpdate function and the RunListAccessUpdateInBackground procedure.
Procedure UpdateListAccessWithRetryAttempts(CommonUpdateParameters, Context)
	
	Indicators = Context.Indicators;
	
	If Indicators <> Undefined Then
		Indicators.StartFirstAttemptToExecuteJob = CurrentUniversalDateInMilliseconds();
	EndIf;
	
	ExecutionAttempt = 1;
	ExecutionAttemptsErrors = New Array;
	While True Do
		CurrentAttemptErrorText = "";
		If Indicators <> Undefined Then
			Indicators.JobWithGetBatches = Not CommonUpdateParameters.Property("BatchFromSet");
			Indicators.JobExecutionStart = CurrentUniversalDateInMilliseconds();
		EndIf;
		Try
			ExecuteUpdateListAccess(CommonUpdateParameters);
		Except
			If TransactionActive() Then
				Raise;
			EndIf;
			ErrorInfo = ErrorInfo();
			CurrentAttemptErrorText = ErrorProcessing.DetailErrorDescription(ErrorInfo);
		EndTry;
		If Indicators <> Undefined And Not ValueIsFilled(CurrentAttemptErrorText) Then
			RemoveJobExecutionIndicators(Indicators);
		EndIf;
		ErrorTextRestartRequired = "";
		If StandardSubsystemsServer.SessionRestartRequired(ErrorTextRestartRequired) Then
			CommonUpdateParameters.Insert("SessionRestartRequired", ErrorTextRestartRequired);
			If StandardSubsystemsServer.ThisErrorRequirementRestartSession(ErrorInfo) Then
				CurrentAttemptErrorText = "";
			EndIf;
		EndIf;
		If ValueIsFilled(CurrentAttemptErrorText) Then
			CurrentAttemptErrorTime = Format(CurrentSessionDate(), "DLF=DT");
			ExecutionAttemptsErrors.Add(CurrentAttemptErrorTime + " " + CurrentAttemptErrorText);
			ExecutionAttempt = ExecutionAttempt + 1;
			If ExecutionAttempt < 9 And Not ValueIsFilled(ErrorTextRestartRequired) Then
				For Counter = 1 To ExecutionAttempt Do
					// 
					If AccessUpdateCanceled() Then
						Break;
					EndIf;
					If Context.CurrentBackgroundJob <> Undefined Then
						Context.CurrentBackgroundJob.WaitForExecutionCompletion(1);
					Else
						WaitBoundary = CurrentUniversalDateInMilliseconds() + 1000;
						While WaitBoundary > CurrentUniversalDateInMilliseconds() Do
							Continue;
						EndDo;
					EndIf;
				EndDo;
				// 
				If Not AccessUpdateCanceled() Then
					Continue;
				EndIf;
			EndIf;
		EndIf;
		ErrorText = StrConcat(ExecutionAttemptsErrors, Chars.LF + "---" + Chars.LF);
		ErrorText = UpdateErrorTextWithContext(ErrorText, CommonUpdateParameters);
		
		If ValueIsFilled(CurrentAttemptErrorText) Then
			CommonUpdateParameters.Insert("CompletionErrorText", "");
			AddCompletionErrorText(CommonUpdateParameters.CompletionErrorText, ErrorText);
		EndIf;
		If Indicators <> Undefined Then
			RemoveJobExecutionErrorsIndicators(Indicators, ErrorText, ExecutionAttemptsErrors.Count());
		EndIf;
		Break;
	EndDo;
	
EndProcedure

// For the RunListAccessUpdateWithRetryAttempts procedure.
Procedure ExecuteUpdateListAccess(CommonUpdateParameters)
	
	If Not CommonUpdateParameters.Property("Cache") Then
		CommonUpdateParameters.Insert("Cache", New Structure);
	EndIf;
	
	If CommonUpdateParameters.ListID = Undefined Then
		MetadataObject = Null;
	ElsIf CommonUpdateParameters.Property("Cache")
	        And CommonUpdateParameters.Cache.Property("MetadataObjectsByIDs") Then
		
		MetadataObject = CommonUpdateParameters.Cache.MetadataObjectsByIDs.Get(
			CommonUpdateParameters.ListID);
	Else
		MetadataObject = Common.MetadataObjectByID(
			CommonUpdateParameters.ListID, False);
	EndIf;
	
	If MetadataObject = Undefined Then
		// 
		// 
		CommonUpdateParameters.Insert("NoJobs", "MetadataObjectDisabled");
		Return;
	EndIf;
	
	IsRightsUpdate = CommonUpdateParameters.IsRightsUpdate;
	
	If Not CommonUpdateParameters.ForExternalUsers
	   And CommonUpdateParameters.ListID
	       = Catalogs.MetadataObjectIDs.EmptyRef() Then
		DeleteObjectsOfInvalidTypesInAccessKeysToObjectsRegister();
	EndIf;
	
	ParametersOfUpdate = ParametersOfUpdate(CommonUpdateParameters, MetadataObject);
	
	// Processing a batch prepared earlier.
	If CommonUpdateParameters.Property("BatchFromSet") Then
		BatchFromSet = CommonUpdateParameters.BatchFromSet; // See BatchFromSet
		BatchItems = BatchFromSet.Items.Get();
		ParametersOfUpdate.Insert("LastUpdatedItem",
			BatchFromSet.LastBatchItem);
		
		UpdateItemsBatch(BatchItems, ParametersOfUpdate);
		
		CommonUpdateParameters.Insert("NewLastUpdatedItem",
			ParametersOfUpdate.NewLastUpdatedItem);
		
		If BatchItems <> Undefined Then
			CommonUpdateParameters.ProcessingCompleted = False;
			SelectedAllItems = BatchFromSet.LastBatchItem.DataKey = Null;
			CommonUpdateParameters.Insert("BatchesSet", ItemsBatchesSet(
				ParametersOfUpdate, BatchItems, SelectedAllItems));
		EndIf;
		Return;
	EndIf;
	
	// Preparing a processing plan for data items.
	PreparationCompleted = False;
	ParametersOfUpdate.Insert("UpdateRestart", False);
	
	While Not PreparationCompleted Do
		PreparationCompleted = True;
		ParametersOfUpdate.Insert("HasJobs", True);
		ParametersOfUpdate.Insert("SpotJob", Undefined);
		ParametersOfUpdate.Insert("LastUpdatedItem", InitialItem(ParametersOfUpdate));
		// 
		PrepareUpdatePlan(ParametersOfUpdate, PreparationCompleted);
	EndDo;
	
	If Not ParametersOfUpdate.HasJobs Then
		CommonUpdateParameters.Insert("NoJobs");
		Return;
	EndIf;
	
	If ParametersOfUpdate.SpotJob <> Undefined Then
		SelectedAllItems = False;
		Items = SpotJobItemsForUpdate(ParametersOfUpdate,
			ItemsInQueryCount(IsRightsUpdate), SelectedAllItems);
		
		If Items <> Undefined Then
			MaxMilliseconds = SpotJobExecutionMinSecondsCount() * 1000;
			If ParametersOfUpdate.ProcessingTimeBoundary - CurrentUniversalDateInMilliseconds() < MaxMilliseconds Then
				ParametersOfUpdate.ProcessingTimeBoundary = CurrentUniversalDateInMilliseconds() + MaxMilliseconds;
			EndIf;
			UpdateItemsBatch(Items, ParametersOfUpdate, True);
		EndIf;
		If Items <> Undefined Or Not SelectedAllItems Then
			RestartUpdateAtNotCompletedSpotUpdate(ParametersOfUpdate);
		EndIf;
	EndIf;
	
	ClarifyLastUpdatedItem(ParametersOfUpdate);
	
	If ParametersOfUpdate.LastUpdatedItem.DataKeyKind = "NoData1" Then
		ParametersOfUpdate.LastUpdatedItem.DataKey = Null;
		WriteLastUpdatedItem(CommonUpdateParameters,
			ParametersOfUpdate.LastUpdatedItem);
		CommonUpdateParameters.Insert("NoJobs");
		Return;
	EndIf;
	
	If ParametersOfUpdate.SpotJob <> Undefined Then
		ParametersOfUpdate.LastUpdatedItem.Insert("ClearSpotJob");
		WriteLastUpdatedItem(CommonUpdateParameters,
			ParametersOfUpdate.LastUpdatedItem);
		ParametersOfUpdate.LastUpdatedItem.Delete("ClearSpotJob");
	EndIf;
	
	If ParametersOfUpdate.UpdateRestart Then
		CommonUpdateParameters.Insert("UpdateRestart");
		If CommonUpdateParameters.Property("NewLastBatchItem") Then
			CommonUpdateParameters.Delete("NewLastBatchItem");
		EndIf;
	EndIf;
	
	If IsObsoleteItemsDataProcessor(ParametersOfUpdate)
	   And Not CommonUpdateParameters.IsObsoleteItemsDataProcessor Then
		
		WriteLastUpdatedItem(CommonUpdateParameters,
			ParametersOfUpdate.LastUpdatedItem);
		CommonUpdateParameters.Insert("NewLastUpdatedItem",
			ParametersOfUpdate.LastUpdatedItem);
		CommonUpdateParameters.Insert("InitialUpdateCompleted");
		Return;
	EndIf;
	
	If CommonUpdateParameters.GetBatches > 0
	   And CommonUpdateParameters.Property("NewLastBatchItem") Then
		
		ParametersOfUpdate.LastUpdatedItem = InitialItem(ParametersOfUpdate);
		FillPropertyValues(ParametersOfUpdate.LastUpdatedItem,
			CommonUpdateParameters.NewLastBatchItem);
	EndIf;
	
	If Not IsRightsUpdate
	   And UpdatePeriodToDataPeriod(CommonUpdateParameters.StartDate,
	         ParametersOfUpdate.LastUpdatedItem.Date) Then
		
		CommonUpdateParameters.Insert("NewLastUpdatedItem",
			ParametersOfUpdate.LastUpdatedItem);
		
		CommonUpdateParameters.ProcessingCompleted = False;
		Return;
	EndIf;
	
	// Single thread update of some access group sets.
	If Not IsRightsUpdate
	   And IsCatalogAccessGroupsSets(ParametersOfUpdate)
	   And ParametersOfUpdate.LastUpdatedItem.DataKey = Undefined Then
		
		If ParametersOfUpdate.LastUpdatedItem.DataKeyKind = "NewSingleUserSets" Then
			EliminateSetsDuplicatesFromOneUserInCatalog(ParametersOfUpdate);
			
		ElsIf ParametersOfUpdate.LastUpdatedItem.DataKeyKind = "AccessGroupsSetsAssignedToUsers" Then
			FillBlankGroupsSetsHashes(ParametersOfUpdate);
			
		ElsIf ParametersOfUpdate.LastUpdatedItem.DataKeyKind = "NewGroupsSetsWithObsoleteRights" Then
			If Not ParametersOfUpdate.ForExternalUsers Then
				UpdateRightsToAllowedAccessKey();
			EndIf;
			ClearBlankAccessGroupsSetRights(ParametersOfUpdate);
			
		ElsIf IsObsoleteItemsDataProcessor(ParametersOfUpdate) Then
			ClearNonExistentAccessGroupsSetsRights(ParametersOfUpdate);
		EndIf;
	EndIf;
	
	// 
	SelectedAllItems = False;
	
	If CommonUpdateParameters.GetBatches > 0 Then
		CountInBatch = ItemsInBatchCount(ParametersOfUpdate);
		CountInQuery = CountInBatch * CommonUpdateParameters.GetBatches;
		Items = ItemsForUpdate(ParametersOfUpdate, CountInQuery, SelectedAllItems);
		
		If CommonUpdateParameters.Property("NewLastBatchItem")
		 Or Items <> Undefined
		   And Items.Count() > CountInBatch * 2 Then
			
			CommonUpdateParameters.ProcessingCompleted = False;
			CommonUpdateParameters.Insert("BatchesSet", ItemsBatchesSet(
				ParametersOfUpdate, Items, SelectedAllItems, CountInBatch));
			Return;
		EndIf;
	Else
		Return;
	EndIf;
	
	// 
	ParametersOfUpdate.Insert("NewLastUpdatedItem",
		InitialItem(ParametersOfUpdate, , True));
	
	CommonUpdateParameters.Insert("InitialUpdateCompleted");
	
	If Items <> Undefined Then
		UpdateItemsBatch(Items, ParametersOfUpdate);
	EndIf;
	
	// Clarifying new last item.
	If Items = Undefined And SelectedAllItems Then
		SetLastBlankItem(ParametersOfUpdate.NewLastUpdatedItem,
			ParametersOfUpdate);
	EndIf;
	
	// Writing new last item.
	WriteLastUpdatedItem(CommonUpdateParameters,
		ParametersOfUpdate.NewLastUpdatedItem);
	
	If ParametersOfUpdate.NewLastUpdatedItem.DataKey = Null Then
		CommonUpdateParameters.Insert("NoJobs");
		Return;
	EndIf;
	
	CommonUpdateParameters.Insert("NewLastUpdatedItem",
		ParametersOfUpdate.NewLastUpdatedItem);
	
	// Preparing the rest of items to continue update.
	If Items <> Undefined Then
		CommonUpdateParameters.Insert("BatchesSet",
			ItemsBatchesSet(ParametersOfUpdate, Items, SelectedAllItems));
	EndIf;
	
EndProcedure

Function IsCatalogAccessGroupsSets(ParametersOfUpdate)
	
	If ParametersOfUpdate.Property("List") Then
		Return ParametersOfUpdate.List = "Catalog.SetsOfAccessGroups";
	EndIf;
	
	Return ParametersOfUpdate.ListID
		= ParametersOfUpdate.AccessGroupsSetsCatalogID;
	
EndFunction

// For the RunListAccessUpdate procedure.
//
// Returns:
//   Structure:
//     * IsRightsUpdate        - Boolean
//     * ListID      - CatalogRef.MetadataObjectIDs
//                                - CatalogRef.ExtensionObjectIDs
//     * ForExternalUsers  - Boolean
//     * Cache                      - See NewCacheContext
//     * StartDate               - Date
//     * EndDate            - Date
//     * MaxBatchesFromOriginalItem - Number
//     * AccessGroupsSetsCatalogID - CatalogRef.MetadataObjectIDs
//     * ProcessingTimeBoundary  - Date
//     
//    
//     * ListWithDate    - Boolean
//     * ListWithPeriod - Boolean
//     * IsReferenceType - Boolean
//     * BlankAccessGroupsSet - CatalogRef.SetsOfAccessGroups
//   
//    
//     * TransactionID - UUID
//     * DependentListsByAccessKeys - Array of String -
//     
//    
//     * HasRightsChanges - Boolean
//     * UpdateRightsToKeys - Boolean
//     * LastUpdatedItem - See InitialItem
//     * NewLastUpdatedItem - See InitialItem
//     * UpdateRestart - Boolean
//     * HasJobs - Boolean
//     * SpotJob - See PreparedSpotJob
//     * BatchesSet - Array of See BatchFromSet
//     * UserType - Type
//     * UserGroupType - Type
//     * AccessGroupType - Type
//     * BlankAccessGroup - CatalogRef.AccessGroups
//     * ListAccessGroupsRights               - See ListAccessGroupNewRights
//     * UserGroupsUsers        - See NewUsersInUserGroups
//     * UserGroupsAsAccessValues - See NewUserGroupsAsAccessVals
//     * AccessGroupsMembers                 - See AccessGroupsNewMembers
//     * AccessGroupsUserGroups       - See AccessGroupsNewUsersGroups
//     * AccessGroupsValues                  - See AccessGroupsNewValues
//     * RolesOfAccessGroupProfiles              - See NewRolesOfAccessGroupProfiles
//     * ProfilesAccessGroups                 - See ProfilesNewAccessGroups
//     * RightsToLeadingAccessKeysLists     - See NewRightsForListsOfMasterAccessKeys
//     * RightsToLeadingAccessKeys            - See NewRightsToMasterAccessKeys
//     * RightsToLeadingLists                  - See NewRightsToMasterLists
//     * RightsByRightsSettingsOwners         - See NewRightsByRightSetupOwners
//     * InMemoryObjectsModel - See InMemoryObjectsModel
//   
//    
//     * List                  - String
//     * ForExternalUsers - Boolean
//     * Version                  - String
//     * LeadingLists           - See NewLeadingLists
//     * AccessDenied          - Boolean
//     * RestrictionDisabled    - Boolean
//     * RightToWriteRestrictionDisabled - Boolean
//     * OwnerField - See NewOwnerField
//     * RestrictionByOwnerRequired    - Boolean
//     * UsesRestrictionByOwner - Boolean
//     * CalculateUserRights     - Boolean
//     * HasDependantListsWithoutAccessKeysRecords
//     * ReadingAllowedForAllUsers - Boolean
//     * EditionAllowedForAllUsers - Boolean
//     * HasMasterAccessKeys                - Boolean
//     * HasHeadRightsLists              - Boolean
//     * ThereIsAFunctionAccessRightOrRoleAvailable - Boolean
//     * RightsSettingsOwnersTypes        - FixedMap
//     * RightSettingsTableID  - CatalogRef.MetadataObjectIDs
//     * HasRightsSettingsOwners         - Boolean
//     * UsedAccessValuesTypes   - Array of Type
//     * AllRightsRestrictionsKinds            - Map
//     * ObjectTablesFields                 - Array of See NewObjectTableFields
//     * SeparateKeysRegisterName       - String
//     * BasicFields                       - See NewBasicFieldsDetails
//     * AccessOption                    - Number
//     * FieldsComposition                       - Number
//     * HasReadRestriction             - Boolean
//     * HasLimitChanges          - Boolean
//     * HasUsersRestriction    - Boolean
//     * ReadRightCalculationStructure       - See RightCalculationStructure
//     * RightCalculationStructureUpdate    - See RightCalculationStructure
//     * Context                          - See ParametersContextByRestrictionStructure
//
//    
//     * ReadEditRightsCheckQueryText - String
//     * ReadRightsCheckQueryText - String
//     * OwnerObjectFieldInRightsValidationQuery - String
//     * ObsoleteDataItemsQueryText - String
//     * KeyTables - Array of String
//     * KeyTablesAttributes - See KeyTableNewAttributes
//     * DataItemWithObsoleteKeysQueryText - String
//     * DataItemsWithoutAccessKeysQueryText - String
//     * NewBasicFieldsValuesCombinationsQueryTextForExistingRecords - String
//     * NewBasicFieldsValuesCombinationsQueryTextForNewRecords - String
//     * DetailsOfObsoleteAccessKeysForLeadingObjects - Map of KeyAndValue:
//        ** Key - String
//        ** Value - Map of KeyAndValue:
//                       *** Key - String
//                       *** Value - Map
//                    - Structure:
//                       *** RefType - ValueStorage
//                       *** QueryKeysByTypes - Map
//                       *** QueriesTextsByKeys - Map
//                       *** QueryTextParameters - String
//                    - String
//     * CurrentRegisterAccessKeysQueryText - String
//     * DataItemValueForAccessKeysQueryText - String
//     * TextOfQueryForInMemoryObjectsValuesForAccessKeys - String
//     * ValueFromAccessKeysInUseForComparisonQueryText - String
//     * ValueFromAllAccessKeysForComparisonQueryText - String
//     * KeysForComparisonExistenceQueryText - String
//     * AccessKeysQueryTextToUpdateRights - String
//     * KeysQueryTextByLeadingKeysToUpdateRights - String
//     * ValueFromAccessKeysForRightsCalculationQueryText - String
//     * ObsoleteAccessKeysQueryText - String
//
Function ParametersOfUpdate(CommonUpdateParameters, MetadataObject)
	
	ParametersOfUpdate = New Structure("IsRightsUpdate,
		|ListID, ForExternalUsers, Cache,
		|StartDate, EndDate, MaxBatchesFromOriginalItem,
		|IsBackgroundAccessUpdate, AccessGroupsSetsCatalogID");
	
	FillPropertyValues(ParametersOfUpdate, CommonUpdateParameters);
	
	If TypeOf(MetadataObject) = Type("MetadataObject") Then
		ParametersOfUpdate.Insert("List", MetadataObject.FullName());
	EndIf;

	ParametersOfUpdate.Insert("ProcessingTimeBoundary",
		CurrentUniversalDateInMilliseconds()
		+ CommonUpdateParameters.MaxProcessingMilliseconds);
	
	AddRestrictionParameters(ParametersOfUpdate);
	
	Return ParametersOfUpdate;
	
EndFunction

// For the RunListAccessUpdate procedure.
Procedure AddRestrictionParameters(ParametersOfUpdate)
	
	If IsCatalogAccessGroupsSets(ParametersOfUpdate) Then
		ParametersOfUpdate.Insert("ListWithDate", False);
		ParametersOfUpdate.Insert("ListWithPeriod", False);
		ParametersOfUpdate.Insert("IsReferenceType", True);
		ParametersOfUpdate.Insert("BlankAccessGroupsSet", Catalogs.SetsOfAccessGroups.EmptyRef());
		Return;
	EndIf;
	
	TransactionID = New UUID;
	List = ?(ParametersOfUpdate.Property("List"), ParametersOfUpdate.List, "");
	ListPropertiesAsLeadingOne = ListPropertiesAsLeadingOne(List, TransactionID);
	RestrictionParameters = RestrictionParameters(List,
		TransactionID, ParametersOfUpdate.ForExternalUsers);
	
	RestrictionParameters = New Structure(RestrictionParameters);
	For Each KeyAndValue In ParametersOfUpdate Do
		RestrictionParameters.Insert(KeyAndValue.Key, KeyAndValue.Value);
	EndDo;
	ParametersOfUpdate = RestrictionParameters;
	ParametersOfUpdate.Insert("TransactionID", TransactionID);
	
	UsersKindPropertyName = ?(ParametersOfUpdate.ForExternalUsers,
		"ForExternalUsers", "ForUsers");
	
	If ListPropertiesAsLeadingOne = Undefined
	 Or ListPropertiesAsLeadingOne.ByAccessKeys = Undefined
	 Or ListPropertiesAsLeadingOne.ByAccessKeys[UsersKindPropertyName] = Undefined Then
		
		ParametersOfUpdate.Insert("DependentListsByAccessKeys", New Array);
	Else
		ParametersOfUpdate.Insert("DependentListsByAccessKeys",
			ListPropertiesAsLeadingOne.ByAccessKeys[UsersKindPropertyName]);
	EndIf;
	
EndProcedure

// For the ExecuteListAccessUpdate and PrepareUpdatePlan procedures.
// 
// Returns:
//  Structure:
//    * DataKey                               - AnyRef
//                                               - Null
//                                               - Structure
//    * ProcessObsoleteItems             - Boolean
//    * ProcessGroupsSetsWithObsoleteRights - Boolean
//    * Date                                     - Date
//
Function InitialItem(ParametersOfUpdate, DataKeyKind = Undefined,
			SaveDataKeyKind = False, RestartUpdateFromBeginning = False)
	
	InitialItem = New Structure;
	InitialItem.Insert("DataKey");
	InitialItem.Insert("ProcessObsoleteItems", False);
	InitialItem.Insert("ProcessGroupsSetsWithObsoleteRights", False);
	SaveProperties = False;
	
	If DataKeyKind = Undefined Then
		If SaveDataKeyKind Then
			DataKeyKind = ParametersOfUpdate.LastUpdatedItem.DataKeyKind;
			SaveProperties = True;
			
		ElsIf IsCatalogAccessGroupsSets(ParametersOfUpdate) Then
			DataKeyKind = "NewSingleUserSets";
			
		ElsIf ParametersOfUpdate.IsRightsUpdate Then
			DataKeyKind = "ItemsWithObsoleteRights";
		Else
			DataKeyKind = "ItemsWithObsoleteKeys";
		EndIf;
	ElsIf DataKeyKind <> "NoData1"
	        And ParametersOfUpdate.Property("LastUpdatedItem") Then
		SaveProperties = True;
	EndIf;
	If SaveProperties Then
		If ParametersOfUpdate.LastUpdatedItem.ProcessObsoleteItems Then
			InitialItem.ProcessObsoleteItems = True;
		EndIf;
		If ParametersOfUpdate.LastUpdatedItem.ProcessGroupsSetsWithObsoleteRights Then
			InitialItem.ProcessGroupsSetsWithObsoleteRights = True;
		EndIf;
	EndIf;
	SetDataKeyKind(InitialItem, DataKeyKind);
	
	If Not ParametersOfUpdate.IsRightsUpdate Then
		InitialItem.Insert("Date", ?(RestartUpdateFromBeginning,
			MaxDate(), MaxDateOnContinue()));
	EndIf;
	
	Return InitialItem;
	
EndFunction

// For the RunListAccessUpdate procedure.
Procedure PrepareUpdatePlan(ParametersOfUpdate, PreparationCompleted)
	
	ListID     = ParametersOfUpdate.ListID;
	ForExternalUsers = ParametersOfUpdate.ForExternalUsers;
	IsRightsUpdate       = ParametersOfUpdate.IsRightsUpdate;
	
	Query = New Query;
	Query.SetParameter("List", ListID);
	Query.SetParameter("ForExternalUsers", ForExternalUsers);
	
	Query.Text =
	"SELECT TOP 1000
	|	UniqueKeys.UniqueKey AS UniqueKey,
	|	UniqueKeys.JobParameters AS JobParameters,
	|	UniqueKeys.LatestUpdatedItemDate AS LatestUpdatedItemDate
	|FROM
	|	InformationRegister.DataAccessKeysUpdate AS UniqueKeys
	|WHERE
	|	UniqueKeys.List = &List
	|	AND UniqueKeys.ForExternalUsers = &ForExternalUsers
	|
	|ORDER BY
	|	UniqueKeys.List,
	|	UniqueKeys.ForExternalUsers,
	|	UniqueKeys.UniqueKey";
	
	If IsRightsUpdate Then
		Query.Text = StrReplace(Query.Text,
			"InformationRegister.DataAccessKeysUpdate",
			"InformationRegister.UsersAccessKeysUpdate");
		Query.Text = StrReplace(Query.Text, ",
			|	UniqueKeys.LatestUpdatedItemDate AS LatestUpdatedItemDate", // @query-part-1
			"");
	EndIf;
	
	QueryResult = Query.Execute();
	
	If QueryResult.IsEmpty() Then
		ParametersOfUpdate.HasJobs = False;
		Return;
	EndIf;
	
	Upload0 = QueryResult.Unload();
	
	If Upload0.Count() = 1000 Then
		PreparationCompleted = False;
	EndIf;
	
	If IsRightsUpdate Then
		UpdatePlan = ServiceRecordSet(InformationRegisters.UsersAccessKeysUpdate);
	Else
		UpdatePlan = ServiceRecordSet(InformationRegisters.DataAccessKeysUpdate);
	EndIf;
	
	If ParametersOfUpdate.List = ListForPlanningTheUpdateOfTheRightsCalculationCache() Then
		ProcessAPlanForUpdatingTheRightsCalculationCache(Upload0);
		ClearDownloadedRecords(UpdatePlan, Upload0);
		ParametersOfUpdate.HasJobs = False;
		Return;
	EndIf;
	
	UpdateRestart = False;
	RestartUpdateFromBeginning = False;
	JobParametersToSave = JobParametersToSave(IsRightsUpdate, ParametersOfUpdate);
	
	If Not ValueIsFilled(Upload0[0].UniqueKey) Then
		CurrentTotal = Upload0[0];
		JobParameters = CurrentTotal.JobParameters.Get();
		If TypeOf(JobParameters) = Type("Structure") Then
			JobParametersToSave = JobParametersToSave(IsRightsUpdate,
				ParametersOfUpdate, JobParameters, UpdateRestart);
		Else
			UpdateRestart = True;
		EndIf;
		If Not UpdateRestart And Not IsRightsUpdate Then
			SavedDate = CurrentTotal.LatestUpdatedItemDate;
			If TypeOf(SavedDate) = Type("Date") Then
				JobParametersToSave.LastUpdatedItem.Date = SavedDate;
			Else
				UpdateRestart = True;
			EndIf;
		EndIf;
		Upload0.Delete(0);
		If Not UpdateRestart Then
			ParametersOfUpdate.LastUpdatedItem =
				JobParametersToSave.LastUpdatedItem;
		EndIf;
	EndIf;
	
	If Not UpdateRestart
	   And CurrentTotal <> Undefined
	   And Upload0.Count() = 0 Then
		
		ParametersOfUpdate.SpotJob = PreparedSpotJob(
			IsRightsUpdate, JobParametersToSave.SpotJob, UpdateRestart);
		If Not UpdateRestart Then
			Return;
		EndIf;
	EndIf;
	
	BlankID = CommonClientServer.BlankUUID();
	FullRegisterName = ?(IsRightsUpdate, "InformationRegister.UsersAccessKeysUpdate",
		"InformationRegister.DataAccessKeysUpdate");
	
	Block = New DataLock;
	LockItem = Block.Add(FullRegisterName);
	LockItem.SetValue("List",                  ListID);
	LockItem.SetValue("ForExternalUsers", ForExternalUsers);
	LockItem.SetValue("UniqueKey",        BlankID);
	
	For Each String In Upload0 Do
		LockItem = Block.Add(FullRegisterName);
		LockItem.SetValue("List",                  ListID);
		LockItem.SetValue("ForExternalUsers", ForExternalUsers);
		LockItem.SetValue("UniqueKey",        String.UniqueKey);
		Break;
	EndDo;
	
	MaxDate = MaxDate();
	DataKeyProperties = InitialItem(ParametersOfUpdate, "NoData1");
	DataKeyKindSet = True;
	For Each String In Upload0 Do
		JobParameters = String.JobParameters.Get();
		If TypeOf(JobParameters) = Type("Structure") And JobParameters.Property("SpotJob") Then
			AddLeadingObjectToSpotJob(JobParameters.SpotJob,
				JobParametersToSave.SpotJob, UpdateRestart);
		Else
			UpdateRestart = True;
			If Not IsRightsUpdate And String.LatestUpdatedItemDate = MaxDate Then
				RestartUpdateFromBeginning = True;
			EndIf;
			If HasDataKeyProperties(JobParameters) Then
				If DataKeyProperties.DataKeyKindOrder > JobParameters.DataKeyKindOrder Then
					DataKeyProperties.DataKeyKindOrder = JobParameters.DataKeyKindOrder;
					DataKeyProperties.DataKeyKind         = JobParameters.DataKeyKind;
				EndIf;
				If IsObsoleteItemsDataProcessor(New Structure("LastUpdatedItem", JobParameters)) Then
					DataKeyProperties.ProcessObsoleteItems = True;
				EndIf;
				If JobParameters.Property("ProcessGroupsSetsWithObsoleteRights")
				   And JobParameters.ProcessGroupsSetsWithObsoleteRights = True Then
					DataKeyProperties.ProcessGroupsSetsWithObsoleteRights = True;
				EndIf;
			Else
				DataKeyKindSet = False;
				If IsCatalogAccessGroupsSets(ParametersOfUpdate) Then
					DataKeyProperties.ProcessGroupsSetsWithObsoleteRights = True;
				EndIf;
				If IsRightsUpdate Or RestartUpdateFromBeginning Then
					Break;
				EndIf;
			EndIf;
		EndIf;
	EndDo;
	
	ParametersOfUpdate.SpotJob = PreparedSpotJob(
		IsRightsUpdate, JobParametersToSave.SpotJob, UpdateRestart);
	
	If UpdateRestart Then
		ParametersOfUpdate.UpdateRestart = True;
		If RestartUpdateFromBeginning Then
			ParametersOfUpdate.Insert("RestartUpdateFromBeginning");
		EndIf;
		ParametersOfUpdate.LastUpdatedItem =
			InitialItem(ParametersOfUpdate, , , RestartUpdateFromBeginning);
	EndIf;
	
	LastUpdatedItem = ParametersOfUpdate.LastUpdatedItem;
	If DataKeyKindSet Then
		If CurrentTotal = Undefined Then
			SetDataKeyKind(LastUpdatedItem, DataKeyProperties.DataKeyKind);
			
		ElsIf LastUpdatedItem.DataKeyKindOrder > DataKeyProperties.DataKeyKindOrder  Then
			LastUpdatedItem.DataKeyKindOrder = DataKeyProperties.DataKeyKindOrder;
			LastUpdatedItem.DataKeyKind         = DataKeyProperties.DataKeyKind;
		EndIf;
	EndIf;
	If DataKeyProperties.ProcessObsoleteItems Then
		LastUpdatedItem.ProcessObsoleteItems = True;
	EndIf;
	If DataKeyProperties.ProcessGroupsSetsWithObsoleteRights Then
		LastUpdatedItem.ProcessGroupsSetsWithObsoleteRights = True;
	EndIf;
	JobParametersToSave.LastUpdatedItem = LastUpdatedItem;
	
	If ParametersOfUpdate.LastUpdatedItem.DataKeyKind = "NoData1" Then
		JobSize = 1;
	ElsIf IsObsoleteItemsDataProcessor(New Structure("LastUpdatedItem",
					LastUpdatedItem)) Then
		JobSize = 2;
	Else
		JobSize = 3;
	EndIf;
	
	Query.Text = StrReplace(Query.Text, "SELECT TOP 1000", "SELECT TOP 1"); // @query-part-1 @query-part-2
	JobsDeleted = False;
	
	UpdatePlan.Filter.List.Set(ListID);
	UpdatePlan.Filter.ForExternalUsers.Set(ForExternalUsers);
	UpdatePlan.Filter.UniqueKey.Set(BlankID);
	
	BeginTransaction();
	Try
		Block.Lock();
		QueryResult = Query.Execute();
		If QueryResult.IsEmpty() Then
			JobsDeleted = True;
		Else
			Record = UpdatePlan.Add();
			Record.List                  = ListID;
			Record.ForExternalUsers = ForExternalUsers;
			Record.SpotJob         = ParametersOfUpdate.SpotJob <> Undefined;
			Record.JobParameters        = New ValueStorage(JobParametersToSave);
			Record.JobSize           = JobSize;
			If Not IsRightsUpdate Then
				Record.LatestUpdatedItemDate =
					ParametersOfUpdate.LastUpdatedItem.Date;
			EndIf;
			Record.RegisterRecordChangeDate = CurrentSessionDate();
			UpdatePlan.Write();
		EndIf;
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
	If JobsDeleted Then
		ParametersOfUpdate.HasJobs = False;
		ParametersOfUpdate.SpotJob = Undefined;
		ParametersOfUpdate.LastUpdatedItem = InitialItem(ParametersOfUpdate);
		Return;
	EndIf;
	
	ClearDownloadedRecords(UpdatePlan, Upload0)
	
EndProcedure

// For the PrepareUpdatePlan procedure.
Procedure ClearDownloadedRecords(UpdatePlan, Upload0)
	
	UpdatePlan.Clear();
	For Each String In Upload0 Do
		UpdatePlan.Filter.UniqueKey.Set(String.UniqueKey);
		UpdatePlan.Write();
	EndDo;
	
EndProcedure

// For the PrepareUpdatePlan procedure.
Procedure ProcessAPlanForUpdatingTheRightsCalculationCache(Upload0, NewVersionOfTheDataForTheCache = Undefined)
	
	VersionOfTheDataForTheCache = NewVersionOfTheDataForTheRightsCalculationCache();
	
	For Each String In Upload0 Do
		JobParameters = String.JobParameters.Get();
		If TypeOf(JobParameters) <> Type("Structure")
		 Or Not JobParameters.Property("SpotJob")
		 Or TypeOf(JobParameters.SpotJob) <> Type("Structure")
		 Or Not JobParameters.SpotJob.Property("AccordingToTheRightsCalculationCache") Then
			Continue;
		EndIf;
		NameOfTheChangedData = JobParameters.SpotJob.AccordingToTheRightsCalculationCache;
		ProcessTheTaskOfUpdatingTheRightsCalculationCache(VersionOfTheDataForTheCache,
			NameOfTheChangedData, String.UniqueKey);
	EndDo;
	
	ParameterName = NameOfTheDataVersionParameterForTheRightsCalculationCache();
	
	If NewVersionOfTheDataForTheCache = Undefined Then
		Block = New DataLock;
		LockItem = Block.Add("InformationRegister.ExtensionVersionParameters");
		LockItem.SetValue("ExtensionsVersion", Catalogs.ExtensionsVersions.EmptyRef());
		LockItem.SetValue("ParameterName", ParameterName);
		
		BeginTransaction();
		Try
			Block.Lock();
			CurrentValue = StandardSubsystemsServer.ExtensionParameter(ParameterName, True);
			NewValue = NewVersionOfTheDataForTheCache(CurrentValue, VersionOfTheDataForTheCache);
			StandardSubsystemsServer.SetExtensionParameter(ParameterName, NewValue, True);
			CommitTransaction();
		Except
			RollbackTransaction();
			Raise;
		EndTry;
	Else
		CurrentValue = StandardSubsystemsServer.ExtensionParameter(ParameterName, True);
		NewVersionOfTheDataForTheCache = NewVersionOfTheDataForTheCache(CurrentValue, VersionOfTheDataForTheCache, False);
	EndIf;
	
EndProcedure

// For the ProcessRightsCalculationCacheUpdatePlan procedure.
Procedure ProcessTheTaskOfUpdatingTheRightsCalculationCache(VersionOfTheDataForTheCache, NameOfTheChangedData, UniqueKey)
	
	If TypeOf(NameOfTheChangedData) <> Type("String")
	 Or Not VersionOfTheDataForTheCache.Property(NameOfTheChangedData) Then
		
		For Each KeyAndValue In VersionOfTheDataForTheCache Do
			VersionOfTheDataForTheCache[KeyAndValue.Key] = String(New UUID);
		EndDo;
		Return;
	EndIf;
	
	If TypeOf(VersionOfTheDataForTheCache[NameOfTheChangedData]) = Type("String") Then
		Return;
	EndIf;
	
	If VersionOfTheDataForTheCache[NameOfTheChangedData] = Undefined Then
		VersionOfTheDataForTheCache[NameOfTheChangedData] = New DataHashing(HashFunction.SHA256);
	EndIf;
	
	DataHashing = VersionOfTheDataForTheCache[NameOfTheChangedData]; // DataHashing
	DataHashing.Append(String(UniqueKey));
	
EndProcedure

// For the ProcessRightsCalculationCacheUpdatePlan procedure.
Function NewVersionOfTheDataForTheCache(CurrentValue, VersionOfTheDataForTheCache, ToWrite = True)
	
	NewValue = NewVersionOfTheDataForTheRightsCalculationCache();
	
	If TypeOf(CurrentValue) = Type("Structure") Then
		FillPropertyValues(NewValue, CurrentValue);
	EndIf;
	
	For Each KeyAndValue In VersionOfTheDataForTheCache Do
		If KeyAndValue.Value = Undefined Then
			Continue;
		EndIf;
		If TypeOf(KeyAndValue.Value) = Type("DataHashing") Then
			NewValue[KeyAndValue.Key] = Base64String(KeyAndValue.Value.HashSum);
		Else
			NewValue[KeyAndValue.Key] = KeyAndValue.Value;
		EndIf;
	EndDo;
	
	For Each KeyAndValue In NewValue Do
		If KeyAndValue.Value <> Undefined Then
			Continue;
		EndIf;
		NewValue[KeyAndValue.Key] = ?(ToWrite,
			String(New UUID), "00000000-0000-0000-0000-000000000000");
	EndDo;
	
	Return NewValue;
	
EndFunction

// For the RightsCalculationCacheForUsersKind function.
Function DataVersionForTheRightsCalculationCache()
	
	IDOfThePlanningList = Common.MetadataObjectID(
		ListForPlanningTheUpdateOfTheRightsCalculationCache());
	
	Query = New Query;
	Query.SetParameter("List", IDOfThePlanningList);
	Query.Text =
	"SELECT TOP 1000
	|	UniqueKeys.UniqueKey AS UniqueKey,
	|	UniqueKeys.JobParameters AS JobParameters
	|FROM
	|	InformationRegister.UsersAccessKeysUpdate AS UniqueKeys
	|WHERE
	|	UniqueKeys.List = &List
	|	AND UniqueKeys.ForExternalUsers = FALSE
	|
	|ORDER BY
	|	UniqueKeys.List,
	|	UniqueKeys.ForExternalUsers,
	|	UniqueKeys.UniqueKey";
	
	If TransactionActive() And Common.FileInfobase() Then
		LockRegistersSchedulingUpdateAccessKeysInFileIB();
	EndIf;
	
	Upload0 = Query.Execute().Unload();
	
	VersionOfTheDataForTheCache = New Structure;
	ProcessAPlanForUpdatingTheRightsCalculationCache(Upload0, VersionOfTheDataForTheCache);
	
	Return VersionOfTheDataForTheCache;
	
EndFunction

// For the PrepareUpdatePlan, WriteLastUpdatedItem procedure.
// 
// Returns:
//  Structure:
//    * LastUpdatedItem - See InitialItem
//    * SpotJob - Structure:
//        ** ByAccessKeys - Map
//        ** ByFieldsValues - Map
//        ** ByValuesWithGroups - Map
//
Function JobParametersToSave(IsRightsUpdate, ParametersOfUpdate, JobParameters = Undefined,
			UpdateRestart = False, ClearSpotJob = False)
	
	SpotJob = New Structure;
	SpotJob.Insert("ByAccessKeys", New Map);
	If Not IsRightsUpdate Then
		SpotJob.Insert("ByFieldsValues",     New Map);
		SpotJob.Insert("ByValuesWithGroups", New Map);
	EndIf;
	
	ParametersToSave1 = New Structure;
	ParametersToSave1.Insert("SpotJob", SpotJob);
	ParametersToSave1.Insert("LastUpdatedItem", InitialItem(ParametersOfUpdate));
	
	If TypeOf(JobParameters) <> Type("Structure") Then
		Return ParametersToSave1;
	EndIf;
	
	If JobParameters.Property("LastUpdatedItem") Then
		Order = DataKeyKindOrder(JobParameters.LastUpdatedItem.DataKeyKind);
		If Order <> Undefined Then
			FillPropertyValues(ParametersToSave1.LastUpdatedItem,
				JobParameters.LastUpdatedItem);
		EndIf;
	EndIf;
	
	If ClearSpotJob Or Not JobParameters.Property("SpotJob") Then
		Return ParametersToSave1;
	EndIf;
	
	CurrentSpotJob = JobParameters.SpotJob;
	If TypeOf(CurrentSpotJob) <> Type("Structure") Then
		UpdateRestart = True;
		Return ParametersToSave1;
	EndIf;
	
	For Each JobOption In SpotJob Do
		If Not CurrentSpotJob.Property(JobOption.Key)
		 Or TypeOf(CurrentSpotJob[JobOption.Key]) <> Type("Map") Then
			UpdateRestart = True;
			Continue;
		EndIf;
		SpotJob[JobOption.Key] = CurrentSpotJob[JobOption.Key];
	EndDo;
	
	Return ParametersToSave1;
	
EndFunction

// For the PrepareUpdatePlan procedure.
Procedure AddLeadingObjectToSpotJob(SpotJob, SpotJobToSave,
			UpdateRestart)
	
	If TypeOf(SpotJob) <> Type("Structure") Then
		UpdateRestart = True;
		Return;
	EndIf;
	MaxCount = MaxCombinationsCountOfLeadingFieldsValuesOnCalculateContentOfChangedOnes();
	
	For Each JobOption In SpotJob Do
		If Not SpotJobToSave.Property(JobOption.Key) Then
			UpdateRestart = True;
			Continue;
		EndIf;
		If JobOption.Key <> "ByFieldsValues" Then
			References = ?(TypeOf(JobOption.Value) = Type("Array"), JobOption.Value,
				CommonClientServer.ValueInArray(JobOption.Value));
			RefsToSave = SpotJobToSave[JobOption.Key];
			For Each Ref In References Do
				RefsToSave.Insert(Ref, True);
				If RefsToSave.Count() >= MaxCount Then
					UpdateRestart = True;
					Continue;
				EndIf;
			EndDo;
		Else
			Properties = JobOption.Value;
			TablesToSave = SpotJobToSave[JobOption.Key];
			
			If Not Properties.Property("ChangedTable")
			 Or Not Properties.Property("ChangesContent")
			 Or TypeOf(Properties.ChangesContent) <> Type("ValueTable")
			 Or TypeOf(TablesToSave) <> Type("Map") Then
				
				UpdateRestart = True;
				Continue;
			EndIf;
			TableToSave = TablesToSave.Get(Properties.ChangedTable);
			ChangesContent = Properties.ChangesContent;
			If TableToSave = Undefined Then
				TablesToSave.Insert(Properties.ChangedTable, ChangesContent);
				
			ElsIf TypeOf(TableToSave) <> Type("ValueTable")
			      Or ChangesContent.Columns.Count() <> TableToSave.Columns.Count() Then
				
				UpdateRestart = True;
				Continue;
			Else
				ColumnsNames = New Array;
				For Each Column In TableToSave.Columns Do
					If ChangesContent.Columns.Find(Column.Name) = Undefined Then
						ColumnsNames = Undefined;
						Break;
					EndIf;
					ColumnsNames.Add(Column.Name);
				EndDo;
				If ColumnsNames = Undefined Then
					UpdateRestart = True;
					Continue;
				EndIf;
				ListOfColumnNames = StrConcat(ColumnsNames, ",");
				Filter = New Structure(ListOfColumnNames);
				If TableToSave.Indexes.Count() = 0 Then
					TableToSave.Indexes.Add(ListOfColumnNames);
				EndIf;
				For Each String In ChangesContent Do
					FillPropertyValues(Filter, String);
					If TableToSave.FindRows(Filter).Count() = 0 Then
						If TableToSave.Count() >= MaxCount Then
							UpdateRestart = True;
							Break;
						EndIf;
						FillPropertyValues(TableToSave.Add(), String);
					EndIf;
				EndDo;
			EndIf;
		EndIf;
	EndDo;
	
EndProcedure

// For the PrepareUpdatePlan procedure.
Function HasDataKeyProperties(JobParameters)
	
	If TypeOf(JobParameters) <> Type("Structure")
	 Or Not JobParameters.Property("DataKeyKind")
	 Or Not JobParameters.Property("DataKeyKindOrder") Then
		Return False;
	EndIf;
	
	Order = DataKeyKindOrder(JobParameters.DataKeyKind);
	
	Return Order <> Undefined And Order = JobParameters.DataKeyKindOrder;
	
EndFunction

// For the RunListAccessUpdate, UpdateItemsBatch,
// SetQueryTextAndLastDataItemUpdateParameters, UpdateAccessGroupsSets procedures and
// the ItemsToUpdate, LastItem, DataKey, AccessGroupsSetsToUpdate functions.
//
Function IsObsoleteItemsDataProcessor(ParametersOfUpdate)
	
	Order = DataKeyKindOrder(ParametersOfUpdate.LastUpdatedItem.DataKeyKind);
	
	Return Order >= DataKeyKindOrder("ObsoleteItems")
	      And Order < DataKeyKindOrder("NoData1");
	
EndFunction

// For the JobParametersToSave, HasDataKeyProperties functions and
// the UpdatePropertyIsObsoleteItemsDataProcessor, SetDataKeyKind procedures.
//
Function DataKeyKindOrder(DataKeyKind)
	
	DataKeysKinds = New Map;
	DataKeysKinds.Insert("ItemsWithObsoleteKeys", 0);
	DataKeysKinds.Insert("ItemsWithoutKeysByFieldValues", 1);
	DataKeysKinds.Insert("ItemsWithoutKeysByPeriod", 1);
	
	DataKeysKinds.Insert("ItemsWithObsoleteRights", 0);
	
	DataKeysKinds.Insert("NewSingleUserSets", 0);
	DataKeysKinds.Insert("AccessGroupsSetsAssignedToUsers", 1);
	DataKeysKinds.Insert("UserGroupSetsAssignedToUsers", 2);
	DataKeysKinds.Insert("NewGroupsSetsWithObsoleteRights", 3);
	DataKeysKinds.Insert("GroupSetsAllowedForUsers", 4);
	DataKeysKinds.Insert("GroupsSetsWithObsoleteRights", 5);
	
	DataKeysKinds.Insert("ObsoleteItems", 10);
	DataKeysKinds.Insert("ObsoleteCommonRegisterItems", 11);
	
	DataKeysKinds.Insert("NoData1", 99);
	
	Return DataKeysKinds.Get(DataKeyKind);
	
EndFunction

// For the ScheduleAccessUpdate, ScheduleAccessGroupsSetsUpdate,
// ClarifyEmptyLastItem procedures and the InitialItem function.
//
Procedure SetDataKeyKind(Item, DataKeyKind)
	
	Order = DataKeyKindOrder(DataKeyKind);
	If Order = Undefined Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Invalid name of the data key order kind: ""%1"".';"), DataKeyKind);
		Raise ErrorText;
	EndIf;
	Item.Insert("DataKeyKind", DataKeyKind);
	Item.Insert("DataKeyKindOrder", Order);
	
EndProcedure

// For the PrepareUpdatePlan procedure.
Function PreparedSpotJob(IsRightsUpdate, SpotJobToSave, UpdateRestart)
	
	SpotJob = New Structure;
	If IsRightsUpdate Then
		SpotJob.Insert("ByAccessKeys", New Array);
	Else
		SpotJob.Insert("ByFieldsValues",     New Map);
		SpotJob.Insert("ByAccessKeys",      New ValueTable);
		SpotJob.Insert("ByValuesWithGroups", New ValueTable);
	EndIf;
	
	IsBlankJob = True;
	MaxCount = MaxCombinationsCountOfLeadingFieldsValuesOnCalculateContentOfChangedOnes();
	LeadingObjectsTypes = AccessManagementInternalCached.LeadingObjectsRefTypes();
	
	For Each JobOption In SpotJobToSave Do
		If JobOption.Key = "ByFieldsValues" Then
			If ValueIsFilled(JobOption.Value) Then
				IsBlankJob = False;
				SpotJob.ByFieldsValues = JobOption.Value;
			EndIf;
			Continue;
		EndIf;
		
		RefsToDelete = New Array;
		ReferencesDetails = JobOption.Value;
		If IsRightsUpdate Then
			References = SpotJob[JobOption.Key];
		Else
			References = New Array;
			Types = New Map;
			Table = SpotJob[JobOption.Key]; // ValueTable
		EndIf;
		For Each ReferenceDetails In ReferencesDetails Do
			Ref = ReferenceDetails.Key;
			Type = TypeOf(Ref);
			If LeadingObjectsTypes.Get(Type) = Undefined Then
				UpdateRestart = True;
				RefsToDelete.Add(Ref);
				Continue;
			EndIf;
			References.Add(Ref);
			If Not IsRightsUpdate Then
				Types.Insert(Type, True);
				Table.Add();
			EndIf;
			If References.Count() >= MaxCount Then
				UpdateRestart = True;
				Break;
			EndIf;
		EndDo;
		For Each Ref In RefsToDelete Do
			ReferencesDetails.Delete(Ref);
		EndDo;
		If References.Count() > 0 Then
			IsBlankJob = False;
		Else
			Continue;
		EndIf;
		If Not IsRightsUpdate Then
			ColumnTypes = New Array;
			For Each KeyAndValue In Types Do
				ColumnTypes.Add(KeyAndValue.Key);
			EndDo;
			Table.Columns.Add("Ref", New TypeDescription(ColumnTypes));
			Table.LoadColumn(References, "Ref");
		EndIf;
	EndDo;
	
	If IsBlankJob Then
		Return Undefined;
	EndIf;
	
	Return SpotJob;
	
EndFunction

// For the RunListAccessUpdate procedure.
Function ItemsInBatchCount(ParametersOfUpdate)
	
	If IsCatalogAccessGroupsSets(ParametersOfUpdate) Then
		Return 25;
	ElsIf ParametersOfUpdate.IsRightsUpdate Then
		Return AccessKeysInBatchCount();
	Else
		Return DataItemsInBatchCount();
	EndIf;
	
EndFunction

// For the RunListAccessUpdate procedure.
Function ItemsInQueryCount(IsRightsUpdate)
	
	If IsRightsUpdate Then
		Return AccessKeysInQueryCount();
	Else
		Return DataItemsInQueryCount();
	EndIf;
	
EndFunction

// For the RunListAccessUpdate procedure.
Procedure UpdateItemsBatch(Items, ParametersOfUpdate, IsSpotJob = False)
	
	ParametersOfUpdate.Insert("ProcessedItemsCount", 0);
	
	If IsSpotJob Then
		If ParametersOfUpdate.IsRightsUpdate Then
			UpdateRightsOfListAccessKeysBatch(Items, ParametersOfUpdate);
		Else
			UpdateListDataItemsWithObsoleteKeys(Items, ParametersOfUpdate);
		EndIf;
		
	ElsIf ParametersOfUpdate.IsRightsUpdate Then
		If IsObsoleteItemsDataProcessor(ParametersOfUpdate) Then
			ProcessObsoleteListAccessKeys(Items, ParametersOfUpdate);
		Else
			UpdateRightsOfListAccessKeysBatch(Items, ParametersOfUpdate);
		EndIf;
		
	ElsIf IsCatalogAccessGroupsSets(ParametersOfUpdate) Then
		UpdateAccessGroupsSets(Items, ParametersOfUpdate);
		
	ElsIf IsObsoleteItemsDataProcessor(ParametersOfUpdate) Then
		DeleteObsoleteListDataItems(Items, ParametersOfUpdate);
	Else
		UpdateListDataItemsWithObsoleteKeys(Items, ParametersOfUpdate);
	EndIf;
	
	If Not IsSpotJob And Items.Count() > 0 Then
		ParametersOfUpdate.Insert("NewLastUpdatedItem",
			LastItem(Items, ParametersOfUpdate, True));
	EndIf;
	
	If Items.Count() = ParametersOfUpdate.ProcessedItemsCount Then
		Items = Undefined;
	Else
		For Counter = 1 To ParametersOfUpdate.ProcessedItemsCount Do
			Items.Delete(0);
		EndDo;
	EndIf;
	
EndProcedure

// For the UpdateAccessGroupsSets, DeleteObsoleteListDataItems,
// WriteObjectsAccessKeys, WriteRegistersAccessKeys,
// UpdateListAccessKeysBatchRights, DeleteListAccessKeysBatch,
// DeleteCurrentListAccessKeysBatch procedures.
//
Function ItemsProcessingAbortRequired(ParametersOfUpdate, ProcessedItemsOnStepCount = 1)
	
	If Not ParametersOfUpdate.Property("ProcessedItemsCount")
	 Or Not ParametersOfUpdate.Property("ProcessingTimeBoundary") Then
		Return False;
	EndIf;
	
	ParametersOfUpdate.ProcessedItemsCount =
		ParametersOfUpdate.ProcessedItemsCount + ProcessedItemsOnStepCount;
	
	If CurrentUniversalDateInMilliseconds() > ParametersOfUpdate.ProcessingTimeBoundary Then
		Return True;
	EndIf;
	
	Return False;
	
EndFunction

// For the RunListAccessUpdate, CheckCompleteUpdateByBatches procedures.
Procedure WriteLastUpdatedItem(CommonUpdateParameters, LastUpdatedItem)
	
	IsRightsUpdate       = CommonUpdateParameters.IsRightsUpdate;
	ForExternalUsers = CommonUpdateParameters.ForExternalUsers;
	ListID     = CommonUpdateParameters.ListID;
	
	RegisterManager = ?(IsRightsUpdate, InformationRegisters.UsersAccessKeysUpdate,
		InformationRegisters.DataAccessKeysUpdate);
	
	UpdatePlan = ServiceRecordSet(RegisterManager);
	UpdatePlan.Filter.List.Set(ListID);
	UpdatePlan.Filter.ForExternalUsers.Set(ForExternalUsers);
	UpdatePlan.Filter.UniqueKey.Set(
		CommonClientServer.BlankUUID());
	
	FullRegisterName = ?(IsRightsUpdate, "InformationRegister.UsersAccessKeysUpdate",
		"InformationRegister.DataAccessKeysUpdate");
	
	Block = New DataLock;
	LockItem = Block.Add(FullRegisterName);
	LockItem.SetValue("List", ListID);
	LockItem.SetValue("ForExternalUsers", ForExternalUsers);
	LockItem.SetValue("UniqueKey",
		CommonClientServer.BlankUUID());
	
	BeginTransaction();
	Try
		Block.Lock();
		UpdatePlan.Read();
		If UpdatePlan.Count() > 0 Then
			If LastUpdatedItem.DataKey = Null Then
				UpdatePlan.Clear();
			Else
				Record = UpdatePlan[0];
				If LastUpdatedItem.Property("ClearSpotJob") Then
					Record.SpotJob = False;
				EndIf;
				
				CurrentJobParameters = Record.JobParameters.Get();
				JobParameters = JobParametersToSave(IsRightsUpdate, CommonUpdateParameters,
					CurrentJobParameters, , LastUpdatedItem.Property("ClearSpotJob"));
				
				FillPropertyValues(JobParameters.LastUpdatedItem, LastUpdatedItem);
				
				If Not IsRightsUpdate And LastUpdatedItem.Property("Date") Then
					Record.LatestUpdatedItemDate = LastUpdatedItem.Date;
				EndIf;
				
				Record.JobParameters = New ValueStorage(JobParameters);
				Record.JobSize = ?(IsObsoleteItemsDataProcessor(
					New Structure("LastUpdatedItem", LastUpdatedItem)), 2, 3);
				
				Record.RegisterRecordChangeDate = CurrentSessionDate();
				CommonUpdateParameters.ProcessingCompleted = False;
			EndIf;
			UpdatePlan.Write();
		EndIf;
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

// For the RunListAccessUpdate procedure.
Function ItemsForUpdate(ParametersOfUpdate, CountInQuery, SelectedAllItems)
	
	If IsCatalogAccessGroupsSets(ParametersOfUpdate) Then
		If ParametersOfUpdate.IsRightsUpdate Then
			SelectedAllItems = True;
			Return Undefined;
		EndIf;
		Items = AccessGroupsSetsForUpdate(ParametersOfUpdate, CountInQuery);
	Else
		Query = New Query;
		If ParametersOfUpdate.IsRightsUpdate Then
			Query.SetParameter("List", ParametersOfUpdate.ListID);
			Query.SetParameter("ForExternalUsers", ParametersOfUpdate.ForExternalUsers);
			
			LastAccessKey = ParametersOfUpdate.LastUpdatedItem.DataKey;
			If TypeOf(LastAccessKey) <> Type("CatalogRef.AccessKeys") Then
				LastAccessKey = Undefined;
			EndIf;
			Query.SetParameter("LastAccessKey", LastAccessKey);
			
			If ParametersOfUpdate.DoNotWriteAccessKeys Then
				// 
				// 
				Query.Text =
				"SELECT TOP 995
				|	AccessKeys.Ref AS Ref
				|FROM
				|	Catalog.AccessKeys AS AccessKeys
				|WHERE
				|	AccessKeys.List = &List
				|	AND AccessKeys.ForExternalUsers = &ForExternalUsers
				|	AND AccessKeys.Ref > &LastAccessKey
				|	AND &QueryPlanClarification
				|
				|ORDER BY
				|	AccessKeys.Ref";
				
			ElsIf IsObsoleteItemsDataProcessor(ParametersOfUpdate) Then
				If ParametersOfUpdate.WithAccessKeyEntryForDependentListsWithoutKeys Then
					// 
					Query.Text =
					"SELECT TOP 995
					|	AccessKeys.Ref AS Ref
					|FROM
					|	Catalog.AccessKeys AS AccessKeys
					|WHERE
					|	AccessKeys.List = &List
					|	AND AccessKeys.ForExternalUsers = &ForExternalUsers
					|	AND AccessKeys.FieldsComposition > 0
					|	AND AccessKeys.Ref > &LastAccessKey
					|	AND &QueryPlanClarification
					|
					|ORDER BY
					|	AccessKeys.Ref";
				Else
					Query.SetParameter("ExpirationDate", ExpirationDate());
					Query.Text = ParametersOfUpdate.ObsoleteAccessKeysQueryText;
				EndIf;
			Else
				Query.Text = ParametersOfUpdate.AccessKeysQueryTextToUpdateRights;
			EndIf;
			
		ElsIf ParametersOfUpdate.IsReferenceType
		        And ParametersOfUpdate.ForExternalUsers
		        And IsObsoleteItemsDataProcessor(ParametersOfUpdate)
		        And (Not ParametersOfUpdate.DoNotWriteAccessKeys
		           Or ParametersOfUpdate.DoNotWriteAccessKeysForUsersAndExternalUsers) Then
			
			SelectedAllItems = True;
			Return Undefined;
		Else
			SetQueryTextAndLastUpdatedDataItemParameters(Query, ParametersOfUpdate);
		EndIf;
		
		CountInQuery = ?(CountInQuery < 1000, 1000, ?(CountInQuery > 10000, 10000, CountInQuery));
		Query.Text = StrReplace(Query.Text, "995", Format(CountInQuery, "NG="));
		SetQueryPlanClarification(Query.Text);
		
		Items = Query.Execute().Unload();
	EndIf;
	
	If Items.Count() = 0 Then
		SelectedAllItems = True;
		Return Undefined;
	EndIf;
	
	SelectedAllItems = Items.Count() < CountInQuery;
	
	Return Items;
	
EndFunction

// For the query execution procedures.
Procedure SetQueryPlanClarification(QueryText, UniquePlan = False)
	
	If AccessManagementInternalCached.QueryPlanClarificationRequired() Then
		If UniquePlan Then
			CurrentSessionDate = CurrentSessionDate();
			MinutesTotal   = Int((CurrentSessionDate - '00010101') / 60);
			RemainingMinutes = MinutesTotal - Int(MinutesTotal / 2048) * 2048;
			QueryPlanClarification = AccessManagementInternalCached.QueryPlanClarification(RemainingMinutes, 11);
		Else
			ExactTime = CurrentUniversalDateInMilliseconds();
			TenthsOfSecondsTotal = Int(ExactTime / 100);
			RemainingTenthsOfSeconds = TenthsOfSecondsTotal - Int(TenthsOfSecondsTotal / 1048576) * 1048576;
			QueryPlanClarification = AccessManagementInternalCached.QueryPlanClarification(RemainingTenthsOfSeconds, 20);
		EndIf;
	Else
		QueryPlanClarification = "TRUE";
	EndIf;
	
	QueryText = StrReplace(QueryText, "&QueryPlanClarification", QueryPlanClarification);
	
EndProcedure

// For the RunListAccessUpdate procedure.
Function SpotJobItemsForUpdate(ParametersOfUpdate, CountInQuery, SelectedAllItems)
	
	If IsCatalogAccessGroupsSets(ParametersOfUpdate)
	 Or ParametersOfUpdate.DoNotWriteAccessKeys
	 Or ParametersOfUpdate.WithAccessKeyEntryForDependentListsWithoutKeys Then
		
		Return Undefined;
	EndIf;
	
	Query = New Query;
	If ParametersOfUpdate.IsRightsUpdate Then
		Query.Text = ParametersOfUpdate.KeysQueryTextByLeadingKeysToUpdateRights;
		If Not ValueIsFilled(Query.Text) Then
			Return Undefined;
		EndIf;
		Query.SetParameter("List", ParametersOfUpdate.ListID);
		Query.SetParameter("LeadingAccessKeys", ParametersOfUpdate.SpotJob.ByAccessKeys);
	Else
		If Not ParametersOfUpdate.IsReferenceType Then
			Query.SetParameter("RegisterID", ParametersOfUpdate.ListID);
		EndIf;
		QueriesDetails = ParametersOfUpdate.DetailsOfObsoleteAccessKeysForLeadingObjects;
		PackageQueries = New Array;
		DataQueries = New Array;
		If ValueIsFilled(ParametersOfUpdate.SpotJob.ByFieldsValues) Then
			QueriesDetailsByFieldsValues = QueriesDetails.Get("ByFieldsValues");
			If QueriesDetailsByFieldsValues = Undefined Then
				Return Undefined;
			EndIf;
			For Each ChangesDetails In ParametersOfUpdate.SpotJob.ByFieldsValues Do
				QueryDetails = QueriesDetailsByFieldsValues.Get(ChangesDetails.Key);
				If QueryDetails = Undefined Then
					Return Undefined;
				EndIf;
				ChangesContent = ChangesDetails.Value; // ValueTable
				If QueryDetails.FieldsTypes.Count() <> ChangesContent.Columns.Count() Then
					Return Undefined;
				EndIf;
				For Each Column In ChangesContent.Columns Do
					FieldTypes = QueryDetails.FieldsTypes.Get(Column.Name);
					If TypeOf(FieldTypes) <> Type("ValueStorage") Then
						Return Undefined;
					EndIf;
					ColumnType = New TypeDescription(Column.ValueType,, "Null");
					If FieldTypes.Get() <> ColumnType
					 Or DataStringForHashing(Column.ValueType)
					       <> DataStringForHashing(New TypeDescription(Column.ValueType.Types())) Then
						Return Undefined;
					EndIf;
				EndDo;
				TemporaryTableAndParameterName = StrReplace(ChangesDetails.Key, ".", "_");
				Query.SetParameter(TemporaryTableAndParameterName, ChangesContent);
				PackageQueries.Add(QueryDetails.QueryTextParameters);
				For Each QueryTextdata_ In QueryDetails.DataQueryTexts Do
					DataQueries.Add(QueryTextdata_);
				EndDo;
			EndDo;
		EndIf;
		If Not AddSpotJobQueries("ByAccessKeys",
		            Query, PackageQueries, DataQueries, ParametersOfUpdate)
		 Or Not AddSpotJobQueries("ByValuesWithGroups",
		            Query, PackageQueries, DataQueries, ParametersOfUpdate)
		 Or DataQueries.Count() = 0 Then
			Return Undefined;
		EndIf;
		If DataQueries.Count() = 1 Then
			PackageQueries.Add(StrReplace(DataQueries[0],
			"
			|FROM
			|	", // @query-part-1
			"
			|INTO CurrentListByLeadingObjects
			|FROM
			|	")); // @query-part-1
		Else
			QueriesTexts = StrConcat(DataQueries,
			"
			|
			|UNION ALL
			|
			|"); // @query-part-1
			PackageQueries.Add(StrReplace(QueriesDetails.Get("DataSelectionWrapQueryText"),
				"#DataSelectionRequests", "(" + TextWithIndent(QueriesTexts, "	") + ")"));
		EndIf;
		PackageQueries.Add(QueriesDetails.Get("SpotCheckQueryText"));
		Query.Text = StrConcat(PackageQueries, Common.QueryBatchSeparator());
	EndIf;
	
	CountInQuery = ?(CountInQuery < 1000, 1000, ?(CountInQuery > 4000, 4000, CountInQuery));
	Query.Text = StrReplace(Query.Text, "995", Format(CountInQuery, "NG="));
	SetQueryPlanClarification(Query.Text);
	
	If ParametersOfUpdate.IsRightsUpdate Then
		Items = Query.Execute().Unload();
		SelectedCount = Items.Count();
	Else
		QueryResults = Query.ExecuteBatch();
		SelectedCount = QueryResults[PackageQueries.Count() - 2].Unload()[0].Count;
		Items = QueryResults[PackageQueries.Count() - 1].Unload();
	EndIf;
	
	SelectedAllItems = SelectedCount < CountInQuery;
	
	If Items.Count() = 0 Then
		Return Undefined;
	EndIf;
	
	Return Items;
	
EndFunction

// For the SpotJobItemsForUpdate function.
Function AddSpotJobQueries(JobKind, Query, PackageQueries, DataQueries, ParametersOfUpdate)
	
	Data = SpotJobTable();
	Data = ParametersOfUpdate.SpotJob[JobKind]; // See SpotJobTable
	If Not ValueIsFilled(Data) Then
		Return True;
	EndIf;
	
	QueriesDetails =
		ParametersOfUpdate.DetailsOfObsoleteAccessKeysForLeadingObjects.Get(JobKind);
	
	If QueriesDetails = Undefined Then
		Return False;
	EndIf;
	
	ColumnType = Data.Columns.Ref.ValueType;
	MissingTypes = New TypeDescription(ColumnType, , QueriesDetails.RefType.Get().Types());
	If MissingTypes.Types().Count() > 0 Then
		Return False;
	EndIf;
	
	Query.SetParameter(JobKind, Data);
	PackageQueries.Add(QueriesDetails.QueryTextParameters);
	
	QueriesKeys = New Map;
	For Each Type In ColumnType.Types() Do
		CurrentKeys = QueriesDetails.QueryKeysByTypes.Get(Type);
		If CurrentKeys = Undefined Then
			Return False;
		EndIf;
		For Each Var_Key In CurrentKeys Do
			QueriesKeys.Insert(Var_Key, True);
		EndDo;
	EndDo;
	
	For Each KeyAndValue In QueriesKeys Do
		QueryText = QueriesDetails.QueriesTextsByKeys.Get(KeyAndValue.Key);
		If QueryText = Undefined Then
			Return False;
		EndIf;
		DataQueries.Add(QueryText);
	EndDo;
	
	Return True;
	
EndFunction

// Returns:
//   ValueTable:
//     * Ref - AnyRef
//
Function SpotJobTable()
	
	Return Undefined;
	
EndFunction

// For the RunListAccessUpdate procedure.
Procedure RestartUpdateAtNotCompletedSpotUpdate(ParametersOfUpdate)
	
	ParametersOfUpdate.UpdateRestart = True;
	ParametersOfUpdate.LastUpdatedItem = InitialItem(ParametersOfUpdate);
	
	// Register indirect planning of access update.
	PlanningParameters = AccessUpdatePlanningParameters(False);
	PlanningParameters.AllowedAccessKeys  =    ParametersOfUpdate.IsRightsUpdate;
	PlanningParameters.ForUsers         = Not ParametersOfUpdate.ForExternalUsers;
	PlanningParameters.ForExternalUsers  =    ParametersOfUpdate.ForExternalUsers;
	PlanningParameters.IsUpdateContinuation = True;
	PlanningParameters.LongDesc = "RestartUpdateAtNotCompletedSpotUpdate";
	
	ListsByIDs = New Map;
	ListsByIDs.Insert(ParametersOfUpdate.ListID, ParametersOfUpdate.List);
	
	RegisterAccessUpdatePlanning(ListsByIDs, PlanningParameters);
	
EndProcedure

// For the RunListAccessUpdate procedure.
Function ItemsBatchesSet(ParametersOfUpdate, Items, SelectedAllItems, PortionSize = Undefined)
	
	BatchesSet = New Array;
	
	If Items = Undefined Then
		BatchFromSet = BatchFromSet();
		BatchFromSet.Insert("Processed1", True);
		BatchFromSet.Insert("InProcessing", False);
		BatchFromSet.Insert("Items", New ValueStorage(New ValueTable));
		BatchFromSet.Insert("LatestBatchItemDate", '00010101');
		BatchFromSet.Insert("LastBatchItem", InitialItem(ParametersOfUpdate,, True));
		BatchFromSet.Insert("NewLastBatchItem");
		BatchesSet.Add(BatchFromSet);
		BatchFromSet.LastBatchItem.DataKey = Null;
		If BatchFromSet.LastBatchItem.Property("Date") Then
			BatchFromSet.LastBatchItem.Date = '00010101';
		EndIf;
		SetLastBlankItem(BatchFromSet.NewLastBatchItem,
			ParametersOfUpdate, '00010101');
		Return BatchesSet;
	EndIf;
	
	If PortionSize = Undefined Then
		PortionSize = ParametersOfUpdate.ProcessedItemsCount;
		MaxNewBatches = ParametersOfUpdate.MaxBatchesFromOriginalItem;
		If Items.Count() / PortionSize > MaxNewBatches Then
			PortionSize = Items.Count() / MaxNewBatches;
			If PortionSize <> Int(PortionSize) Then
				PortionSize = Int(PortionSize) + 1;
			EndIf;
		EndIf;
	EndIf;
	
	ParametersOfUpdate.Insert("BatchesSet", BatchesSet);
	IndexOf = 0;
	For Each Item In Items Do
		If IndexOf / PortionSize = Int(IndexOf / PortionSize) Then
			BatchFromSet = New Array;
			BatchesSet.Add(BatchFromSet);
		EndIf;
		BatchFromSet.Add(Item);
		IndexOf = IndexOf + 1;
	EndDo;
	
	For IndexOf = 0 To BatchesSet.Count() - 1 Do
		BatchItems = Items.Copy(BatchesSet[IndexOf]);
		BatchFromSet = BatchFromSet();
		BatchFromSet.Insert("Processed1", False);
		BatchFromSet.Insert("InProcessing", False);
		BatchesSet[IndexOf] = BatchFromSet;
		BatchFromSet.Insert("Items", New ValueStorage(BatchItems));
		BatchFromSet.Insert("LastBatchItem",
			LastItem(BatchItems, ParametersOfUpdate));
		BatchFromSet.Insert("LatestBatchItemDate",
			?(BatchFromSet.LastBatchItem.Property("Date"),
				BatchFromSet.LastBatchItem.Date, '00010101'));
		BatchFromSet.Insert("NewLastBatchItem",
			LastItem(BatchItems, ParametersOfUpdate));
	EndDo;
	
	If SelectedAllItems Then
		BatchFromSet.LastBatchItem.DataKey = Null;
		SetLastBlankItem(BatchFromSet.NewLastBatchItem,
			ParametersOfUpdate, '00010101');
	EndIf;
	
	Return BatchesSet;
	
EndFunction

// Returns:
//  Structure:
//    * Processed1                   - Boolean
//    * InProcessing               - Boolean
//    * Items                     - ValueStorage
//    * LatestBatchItemDate - Date
//    * LastBatchItem       - See InitialItem
//    * NewLastBatchItem  - See InitialItem
//
Function BatchFromSet()
	
	Return New Structure;
	
EndFunction

// For the ExecuteListAccessUpdate, UpdateItemsBatch, and ItemsBatchesSet procedures.
Function LastItem(Items, ParametersOfUpdate, LastProcessedItem = False)
	
	LastItemNumber = ?(LastProcessedItem,
		ParametersOfUpdate.ProcessedItemsCount, Items.Count());
	
	LastItem = Items[LastItemNumber - 1];
	
	DataElement = InitialItem(ParametersOfUpdate, , True);
	
	If ParametersOfUpdate.IsRightsUpdate Then
		DataElement.DataKey = LastItem.Ref;
		Return DataElement;
	EndIf;
	
	If ParametersOfUpdate.ListWithDate
	   And Not IsObsoleteItemsDataProcessor(ParametersOfUpdate) Then
		
		DataElement.Date = LastItem.Date;
		
	ElsIf ParametersOfUpdate.IsReferenceType Then
		DataElement.DataKey = LastItem.CurrentRef;
	Else
		DataElement.DataKey = DataKey(ParametersOfUpdate);
		FillPropertyValues(DataElement.DataKey, LastItem);
		
		If ParametersOfUpdate.ListWithPeriod
		   And DataElement.DataKeyKind = "ItemsWithoutKeysByPeriod" Then
			
			DataElement.Date = LastItem.Period;
		EndIf;
	EndIf;
	
	Return DataElement;
	
EndFunction

// For the RunListAccessUpdate procedure.
Procedure ClarifyLastUpdatedItem(ParametersOfUpdate)
	
	If ParametersOfUpdate.List = "Catalog.SetsOfAccessGroups"
	 Or ParametersOfUpdate.LastUpdatedItem.DataKeyKind = "NoData1" Then
		Return;
	EndIf;
	
	If ParametersOfUpdate.DoNotWriteAccessKeys Then
		If Not ParametersOfUpdate.LastUpdatedItem.ProcessObsoleteItems Then
			ParametersOfUpdate.LastUpdatedItem =
				InitialItem(ParametersOfUpdate, "NoData1");
			
		ElsIf Not IsObsoleteItemsDataProcessor(ParametersOfUpdate) Then
			ParametersOfUpdate.LastUpdatedItem =
				InitialItem(ParametersOfUpdate, "ObsoleteItems");
		EndIf;
	EndIf;
	
EndProcedure

// For the RunListAccessUpdate, UpdateItemsBatch procedures.
Procedure SetLastBlankItem(Item, ParametersOfUpdate, ItemDate = '00010101')
	
	ItemDate = '00010101';
	Item = InitialItem(ParametersOfUpdate, , True);
	Item.DataKey = Null;
	
	// Clarifying new last item.
	If IsCatalogAccessGroupsSets(ParametersOfUpdate) Then
		If ParametersOfUpdate.IsRightsUpdate Then
			Return;
		EndIf;
		NewDataKeyKind = "";
		If Item.DataKeyKind = "NewSingleUserSets" Then
			NewDataKeyKind = "AccessGroupsSetsAssignedToUsers";
			
		ElsIf Item.DataKeyKind = "AccessGroupsSetsAssignedToUsers" Then
			NewDataKeyKind = "UserGroupSetsAssignedToUsers";
			
		ElsIf Item.DataKeyKind = "UserGroupSetsAssignedToUsers" Then
			NewDataKeyKind = "NewGroupsSetsWithObsoleteRights";
			
		ElsIf Item.DataKeyKind = "NewGroupsSetsWithObsoleteRights" Then
			NewDataKeyKind = "GroupSetsAllowedForUsers";
			
		ElsIf Item.DataKeyKind = "GroupSetsAllowedForUsers"
		        And Item.ProcessGroupsSetsWithObsoleteRights Then
			
			NewDataKeyKind = "GroupsSetsWithObsoleteRights";
			
		ElsIf Item.ProcessObsoleteItems
		        And (    Item.DataKeyKind = "GroupSetsAllowedForUsers"
		           Or Item.DataKeyKind = "GroupsSetsWithObsoleteRights") Then
			
			NewDataKeyKind = "ObsoleteItems";
		EndIf;
		If ValueIsFilled(NewDataKeyKind) Then
			Item = InitialItem(ParametersOfUpdate, NewDataKeyKind);
		EndIf;
		Return;
	EndIf;
	
	If ParametersOfUpdate.IsRightsUpdate Then
		If Item.DataKeyKind = "ItemsWithObsoleteRights"
		   And Item.ProcessObsoleteItems Then
			
			Item = InitialItem(ParametersOfUpdate, "ObsoleteItems");
		EndIf;
		Return;
	EndIf;
	
	If Item.DataKeyKind = "ObsoleteCommonRegisterItems" Then
		Return;
	EndIf;
	
	If Item.DataKeyKind = "ObsoleteItems" Then
		If Not ParametersOfUpdate.IsReferenceType
		   And ValueIsFilled(ParametersOfUpdate.SeparateKeysRegisterName) Then
		
			Item = InitialItem(ParametersOfUpdate, "ObsoleteCommonRegisterItems");
		EndIf;
		Return;
	EndIf;
	
	If ParametersOfUpdate.ListWithDate Then
		SetNextPeriodItem(ParametersOfUpdate, Item, ItemDate);
		Return;
	EndIf;
	
	If ParametersOfUpdate.IsReferenceType Then
		If Item.DataKeyKind = "ItemsWithObsoleteKeys"
		   And Item.ProcessObsoleteItems
		   And (ParametersOfUpdate.DoNotWriteAccessKeys
		      Or Not ParametersOfUpdate.ForExternalUsers) Then
			
			Item = InitialItem(ParametersOfUpdate, "ObsoleteItems");
		EndIf;
		Return;
	EndIf;
	
	If ParametersOfUpdate.DoNotWriteAccessKeys Then
		If Item.DataKeyKind = "ItemsWithObsoleteKeys"
		   And Item.ProcessObsoleteItems Then
			
			Item = InitialItem(ParametersOfUpdate, "ObsoleteItems");
		EndIf;
		Return;
	EndIf;
	
	If Item.DataKeyKind = "ItemsWithoutKeysByFieldValues" Then
		If Item.ProcessObsoleteItems Then
			Item = InitialItem(ParametersOfUpdate, "ObsoleteItems");
		EndIf;
		Return;
	EndIf;
	
	If Item.DataKeyKind = "ItemsWithoutKeysByPeriod" Then
		SetNextPeriodItem(ParametersOfUpdate, Item, ItemDate);
		If Item.DataKey = Null And Item.ProcessObsoleteItems Then
			Item = InitialItem(ParametersOfUpdate, "ObsoleteItems");
		EndIf;
		Return;
	EndIf;
	
	If Not ParametersOfUpdate.ListWithPeriod Then
		Item = InitialItem(ParametersOfUpdate, "ItemsWithoutKeysByFieldValues");
		Return;
	EndIf;
	
	Item = InitialItem(ParametersOfUpdate, "ItemsWithoutKeysByPeriod");
	LastUpdatedItem = ParametersOfUpdate.LastUpdatedItem;
	ParametersOfUpdate.LastUpdatedItem = Item;
	SetNextPeriodItem(ParametersOfUpdate, Item, ItemDate, MaxDate());
	ParametersOfUpdate.LastUpdatedItem = LastUpdatedItem;
	
	If Item.DataKey = Null And Item.ProcessObsoleteItems Then
		Item = InitialItem(ParametersOfUpdate, "ObsoleteItems");
	EndIf;
	
EndProcedure

// For the ClarifyBlankLastItem procedure.
Procedure SetNextPeriodItem(ParametersOfUpdate, Item, ItemDate,
			CurrentPeriodStartDate = Undefined)
	
	If CurrentPeriodStartDate = Undefined Then
		CurrentPeriodStartDate = ParametersOfUpdate.StartDate;
	EndIf;
	
	Query = New Query;
	Query.SetParameter("StartDate", CurrentPeriodStartDate);
	
	Query.Text = ParametersOfUpdate.NextDataItemDateQueryText;
	
	QueryResult = Query.Execute();
	
	If QueryResult.IsEmpty() Then
		Item.DataKey = Null;
		Return;
	EndIf;
	
	Item = LastItem(QueryResult.Unload(), ParametersOfUpdate);
	ItemDate = ?(Item.Property("Date"), Item.Date, '00010101');
	
EndProcedure

// For the ItemsToUpdate function.
Procedure SetQueryTextAndLastUpdatedDataItemParameters(Query, ParametersOfUpdate)
	
	If IsObsoleteItemsDataProcessor(ParametersOfUpdate) Then
		If ParametersOfUpdate.LastUpdatedItem.DataKeyKind = "ObsoleteItems" Then
			Query.Text = ParametersOfUpdate.ObsoleteDataItemsQueryText;
		Else
			Query.Text = ParametersOfUpdate.ObsoleteDataItemsFromCommonRegisterQueryText;
		EndIf;
	Else
		Query.Text = ParametersOfUpdate.DataItemWithObsoleteKeysQueryText;
		If Not ValueIsFilled(ParametersOfUpdate.FieldsComposition) Then
			Query.SetParameter("List", ParametersOfUpdate.ListID);
		EndIf;
		If ParametersOfUpdate.ListWithDate Then
			Query.SetParameter("StartDate",    ParametersOfUpdate.StartDate);
			Query.SetParameter("EndDate", ParametersOfUpdate.LastUpdatedItem.Date);
			Return;
		EndIf;
	EndIf;
	
	DataKey = ParametersOfUpdate.LastUpdatedItem.DataKey;
	
	If ParametersOfUpdate.IsReferenceType Then
		SetDataKey = ?(Common.IsReference(TypeOf(DataKey)), DataKey, Undefined);
		Query.SetParameter("LastProcessedRef", SetDataKey);
		Return;
	EndIf;
	
	Query.SetParameter("RegisterID", ParametersOfUpdate.ListID);
	SetDataKey = DataKey(ParametersOfUpdate, DataKey);
	DataKeyKind = ParametersOfUpdate.LastUpdatedItem.DataKeyKind;
	
	If ParametersOfUpdate.ListWithPeriod
	   And StrStartsWith(DataKeyKind, "ItemsWithoutKeys") Then
		
		If DataKeyKind <> "ItemsWithoutKeysByPeriod" Then
			SetDataKeyKind(ParametersOfUpdate.LastUpdatedItem,
				"ItemsWithoutKeysByPeriod");
		EndIf;
		Query.Text = ParametersOfUpdate.DataItemsWithoutAccessKeysQueryText;
		Query.SetParameter("StartDate",    ParametersOfUpdate.StartDate);
		Query.SetParameter("EndDate", ParametersOfUpdate.LastUpdatedItem.Date);
		
	ElsIf StrStartsWith(DataKeyKind, "ItemsWithoutKeys") Then
		If DataKeyKind <> "ItemsWithoutKeysByFieldValues" Then
			SetDataKeyKind(ParametersOfUpdate.LastUpdatedItem,
				"ItemsWithoutKeysByFieldValues");
		EndIf;
		Query.Text = ParametersOfUpdate.DataItemsWithoutAccessKeysQueryText;
	EndIf;
	
	For Each KeyAndValue In SetDataKey Do
		If KeyAndValue.Value = Undefined Then
			FieldName = KeyAndValue.Key;
			Query.Text = StrReplace(Query.Text, " > &" + FieldName, " >= &" + FieldName);
		EndIf;
		Query.SetParameter(KeyAndValue.Key, KeyAndValue.Value);
	EndDo;
	
EndProcedure

// For the LastItem and SetLastUpdatedItemParameters procedures and
// the RemainingRegisterItemsCountQueryText function.
//
// Returns:
//   Structure:
//     * Field1 - AnyRef
//     * Field2 - AnyRef
//     * Field3 - AnyRef
//     * Field4 - AnyRef
//     * Field5 - AnyRef
//
Function DataKey(ParametersOfUpdate, InitialDataKey = Undefined)
	
	FieldsCount = ParametersOfUpdate.BasicFields.UsedItems.Count();
	
	If FieldsCount = 0
	 Or ParametersOfUpdate.UsesRestrictionByOwner
	 Or IsObsoleteItemsDataProcessor(ParametersOfUpdate) Then
		
		FieldsCount = ParametersOfUpdate.BasicFields.MaxCount;
	EndIf;
	
	If TypeOf(InitialDataKey) = Type("Structure")
	   And InitialDataKey.Count() = FieldsCount Then
		
		FieldValues = InitialDataKey;
	Else
		FieldValues = New Structure;
	EndIf;
	
	NewFieldsValues = New Structure;
	
	For Number = 1 To FieldsCount Do
		FieldName = "Field" + Number;
		If FieldValues.Property(FieldName) Then
			NewFieldsValues.Insert(FieldName, FieldValues[FieldName]);
		Else
			NewFieldsValues.Insert(FieldName, Undefined);
		EndIf;
	EndDo;
	
	Return NewFieldsValues;
	
EndFunction

// For the ItemsForUpdate procedure.
Function AccessGroupsSetsForUpdate(ParametersOfUpdate, CountInQuery)
	
	LastUpdatedItem = ParametersOfUpdate.LastUpdatedItem;
	DataKeyKind = LastUpdatedItem.DataKeyKind;
	
	Query = New Query;
	Query.SetParameter("ForExternalUsers", ParametersOfUpdate.ForExternalUsers);
	Query.SetParameter("LastProcessedRef", LastUpdatedItem.DataKey);
	
	If DataKeyKind = "GroupsSetsWithObsoleteRights" Then
		Query.Text =
		"SELECT TOP 995
		|	CurrentList.Ref AS CurrentRef,
		|	CurrentList.SetItemsType = VALUE(Catalog.AccessGroups.EmptyRef) AS IsAccessGroupsSet
		|FROM
		|	Catalog.SetsOfAccessGroups AS CurrentList
		|WHERE
		|	CurrentList.ForExternalUsers = &ForExternalUsers
		|	AND CurrentList.SetItemsType IN (VALUE(Catalog.AccessGroups.EmptyRef), VALUE(Catalog.UserGroups.EmptyRef))
		|	AND CurrentList.Ref > &LastProcessedRef
		|	AND &QueryPlanClarification
		|
		|ORDER BY
		|	CurrentList.Ref";
		
		If ParametersOfUpdate.ForExternalUsers Then
			Query.Text = StrReplace(Query.Text,
				"Catalog.UserGroups", "Catalog.ExternalUsersGroups");
		EndIf;
		
	ElsIf DataKeyKind = "NewSingleUserSets" Then
		Query.SetParameter("BlankUUID",
			CommonClientServer.BlankUUID());
		Query.Text =
		"SELECT TOP 995
		|	UserGroupCompositions.User AS CurrentRef,
		|	UserGroupCompositions.User.Description AS Description,
		|	UserGroupCompositions.Used
		|		AND ISNULL(CAST(UserGroupCompositions.User AS Catalog.Users).IBUserID, &BlankUUID) <> &BlankUUID AS Used,
		|	SetsOfAccessGroups.NotUsedSince AS NotUsedSince
		|FROM
		|	InformationRegister.UserGroupCompositions AS UserGroupCompositions
		|		LEFT JOIN Catalog.SetsOfAccessGroups AS SetsOfAccessGroups
		|		ON (SetsOfAccessGroups.User = UserGroupCompositions.User)
		|			AND (SetsOfAccessGroups.ForExternalUsers = &ForExternalUsers)
		|			AND (SetsOfAccessGroups.SetItemsType = VALUE(Catalog.Users.EmptyRef))
		|			AND (NOT FALSE IN
		|					(SELECT TOP 1
		|						FALSE
		|					FROM
		|						Catalog.SetsOfAccessGroups.Groups AS SetGroups1
		|					WHERE
		|						SetGroups1.Ref = SetsOfAccessGroups.Ref))
		|WHERE
		|	VALUETYPE(UserGroupCompositions.UsersGroup) = TYPE(Catalog.Users)
		|	AND CASE
		|			WHEN UserGroupCompositions.Used
		|					AND CAST(UserGroupCompositions.User AS Catalog.Users).IBUserID <> &BlankUUID
		|				THEN SetsOfAccessGroups.User IS NULL
		|						OR SetsOfAccessGroups.NotUsedSince <> DATETIME(1, 1, 1)
		|			ELSE SetsOfAccessGroups.NotUsedSince = DATETIME(1, 1, 1)
		|		END
		|	AND UserGroupCompositions.User > &LastProcessedRef
		|	AND &QueryPlanClarification
		|
		|ORDER BY
		|	UserGroupCompositions.User";
		
		If ParametersOfUpdate.ForExternalUsers Then
			Query.Text = StrReplace(Query.Text,
				"Catalog.Users", "Catalog.ExternalUsers");
		EndIf;
		
	ElsIf DataKeyKind = "AccessGroupsSetsAssignedToUsers" Then
		Return OneUserSetsToUpdateAssignedAccessGroupsSets(
			ParametersOfUpdate, CountInQuery);
		
	ElsIf DataKeyKind = "UserGroupSetsAssignedToUsers" Then
		Return OneUserSetsToUpdateAssignedUsersGroupsSets(
			ParametersOfUpdate, CountInQuery);
		
	ElsIf DataKeyKind = "NewGroupsSetsWithObsoleteRights" Then
		Query.Text =
		"SELECT TOP 995
		|	CurrentList.Ref AS CurrentRef,
		|	CurrentList.SetItemsType = VALUE(Catalog.AccessGroups.EmptyRef) AS IsAccessGroupsSet
		|FROM
		|	Catalog.SetsOfAccessGroups AS CurrentList
		|WHERE
		|	CurrentList.ForExternalUsers = &ForExternalUsers
		|	AND CurrentList.SetItemsType IN (VALUE(Catalog.AccessGroups.EmptyRef), VALUE(Catalog.UserGroups.EmptyRef))
		|	AND (TRUE IN
		|				(SELECT TOP 1
		|					TRUE
		|				FROM
		|					Catalog.SetsOfAccessGroups AS SetsOfAccessGroups
		|				WHERE
		|					SetsOfAccessGroups.NewAccessGroupsSet = CurrentList.Ref)
		|			OR TRUE IN
		|				(SELECT TOP 1
		|					TRUE
		|				FROM
		|					Catalog.SetsOfAccessGroups AS SetsOfAccessGroups
		|				WHERE
		|					SetsOfAccessGroups.NewUserGroupsSet = CurrentList.Ref))
		|	AND CurrentList.Ref > &LastProcessedRef
		|	AND &QueryPlanClarification
		|
		|ORDER BY
		|	CurrentList.Ref";
		If ParametersOfUpdate.ForExternalUsers Then
			Query.Text = StrReplace(Query.Text,
				"Catalog.UserGroups", "Catalog.ExternalUsersGroups");
		EndIf;
		
	ElsIf DataKeyKind = "GroupSetsAllowedForUsers" Then
		Query.Text =
		"SELECT TOP 995
		|	CurrentList.Ref AS CurrentRef
		|FROM
		|	Catalog.SetsOfAccessGroups AS CurrentList
		|WHERE
		|	CurrentList.ForExternalUsers = &ForExternalUsers
		|	AND CurrentList.SetItemsType = VALUE(Catalog.Users.EmptyRef)
		|	AND (CurrentList.NewAccessGroupsSet <> VALUE(Catalog.SetsOfAccessGroups.EmptyRef)
		|				AND NOT TRUE IN
		|						(SELECT TOP 1
		|							TRUE
		|						FROM
		|							Catalog.SetsOfAccessGroups AS SetsOfAccessGroups
		|						WHERE
		|							SetsOfAccessGroups.Ref = CurrentList.NewAccessGroupsSet
		|							AND SetsOfAccessGroups.NewAccessGroupsSet = CurrentList.NewAccessGroupsSet)
		|			OR CurrentList.NewUserGroupsSet <> VALUE(Catalog.SetsOfAccessGroups.EmptyRef)
		|				AND NOT TRUE IN
		|						(SELECT TOP 1
		|							TRUE
		|						FROM
		|							Catalog.SetsOfAccessGroups AS SetsOfAccessGroups
		|						WHERE
		|							SetsOfAccessGroups.Ref = CurrentList.NewUserGroupsSet
		|							AND SetsOfAccessGroups.NewUserGroupsSet = CurrentList.NewUserGroupsSet))
		|	AND CurrentList.Ref > &LastProcessedRef
		|	AND &QueryPlanClarification
		|
		|ORDER BY
		|	CurrentList.Ref";
		If ParametersOfUpdate.ForExternalUsers Then
			Query.Text = StrReplace(Query.Text,
				"Catalog.Users", "Catalog.ExternalUsers");
		EndIf;
		
	ElsIf IsObsoleteItemsDataProcessor(ParametersOfUpdate) Then
		Return ObsoleteAccessGroupsSetsInCatalog(ParametersOfUpdate, CountInQuery);
	EndIf;
	
	CountInQuery = ?(CountInQuery < 25, 25, ?(CountInQuery > 10000, 10000, CountInQuery));
	Query.Text = StrReplace(Query.Text, "995", Format(CountInQuery, "NG="));
	SetQueryPlanClarification(Query.Text);
	
	DataItems = Query.Execute().Unload();
	
	Return DataItems;
	
EndFunction

// For the UpdateItemsBatch procedure.
Procedure UpdateAccessGroupsSets(DataItems, ParametersOfUpdate)
	
	DataKeyKind = ParametersOfUpdate.LastUpdatedItem.DataKeyKind;
	
	If DataKeyKind = "GroupsSetsWithObsoleteRights" Then
		UpdateGroupsSetsWithObsoleteParameters(DataItems, ParametersOfUpdate);
		
	ElsIf DataKeyKind = "NewSingleUserSets" Then
		UpdateSetsOfOneUserInCatalog(DataItems, ParametersOfUpdate);
		
	ElsIf DataKeyKind = "AccessGroupsSetsAssignedToUsers" Then
		UpdateGroupsSetsAssingedToUsersInCatalog(DataItems, ParametersOfUpdate, True);
		
	ElsIf DataKeyKind = "UserGroupSetsAssignedToUsers" Then
		UpdateGroupsSetsAssingedToUsersInCatalog(DataItems, ParametersOfUpdate, False);
		
	ElsIf DataKeyKind = "NewGroupsSetsWithObsoleteRights" Then
		UpdateGroupsSetsWithObsoleteParameters(DataItems, ParametersOfUpdate, True);
		
	ElsIf DataKeyKind = "GroupSetsAllowedForUsers" Then
		UpdateGroupsSetsAllowedForUsersInCatalog(DataItems, ParametersOfUpdate);
		
	ElsIf IsObsoleteItemsDataProcessor(ParametersOfUpdate) Then
		ProcessObsoleteSetsInCatalog(DataItems, ParametersOfUpdate);
	EndIf;
	
EndProcedure

// For the RunListAccessUpdate procedure.
Procedure ClearBlankAccessGroupsSetRights(ParametersOfUpdate)
	
	If ParametersOfUpdate.ForExternalUsers Then
		Return;
	EndIf;
	
	Query = New Query;
	Query.Text =
	"SELECT TOP 1
	|	TRUE AS TrueValue
	|FROM
	|	InformationRegister.AccessGroupSetsAccessKeys AS AccessGroupSetsAccessKeys
	|WHERE
	|	AccessGroupSetsAccessKeys.AccessGroupsSet = VALUE(Catalog.SetsOfAccessGroups.EmptyRef)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT TOP 1
	|	TRUE AS TrueValue
	|FROM
	|	InformationRegister.UsersAccessKeys AS UsersAccessKeys
	|WHERE
	|	UsersAccessKeys.User = VALUE(Catalog.SetsOfAccessGroups.EmptyRef)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT TOP 1
	|	TRUE AS TrueValue
	|FROM
	|	InformationRegister.ExternalUsersAccessKeys AS ExternalUsersAccessKeys
	|WHERE
	|	ExternalUsersAccessKeys.ExternalUser = VALUE(Catalog.SetsOfAccessGroups.EmptyRef)";
	
	QueryResults = Query.ExecuteBatch();
	
	If Not QueryResults[0].IsEmpty() Then
		RecordSet = ServiceRecordSet(InformationRegisters.AccessGroupSetsAccessKeys);
		RecordSet.Filter.AccessGroupsSet.Set(Catalogs.SetsOfAccessGroups.EmptyRef());
		RecordSet.Write();
	EndIf;
	
	If Not QueryResults[1].IsEmpty() Then
		RecordSet = ServiceRecordSet(InformationRegisters.UsersAccessKeys);
		RecordSet.Filter.User.Set(Catalogs.SetsOfAccessGroups.EmptyRef());
		RecordSet.Write();
	EndIf;
	
	If Not QueryResults[2].IsEmpty() Then
		RecordSet = ServiceRecordSet(InformationRegisters.ExternalUsersAccessKeys);
		RecordSet.Filter.ExternalUser.Set(Catalogs.SetsOfAccessGroups.EmptyRef());
		RecordSet.Write();
	EndIf;
	
EndProcedure

// For the UpdateAccessGroupsSets procedure.
Procedure UpdateGroupsSetsWithObsoleteParameters(DataItems, ParametersOfUpdate, IsNewSets = False)
	
	If IsNewSets Then
		Block = New DataLock;
		LockItem = Block.Add("Catalog.SetsOfAccessGroups");
	EndIf;
	
	For Each DataElement In DataItems Do
		If DataElement.IsAccessGroupsSet Then
			// 
			UpdateGroupsSetsAccessKeys(ParametersOfUpdate, DataElement.CurrentRef,
				"AccessGroupSetsAccessKeys", "AccessGroups", "AccessGroupsSet");
			
		ElsIf Not ParametersOfUpdate.ForExternalUsers Then
			// 
			UpdateGroupsSetsAccessKeys(ParametersOfUpdate, DataElement.CurrentRef,
				"UsersAccessKeys", "UserGroups", "User");
		Else
			// 
			UpdateGroupsSetsAccessKeys(ParametersOfUpdate, DataElement.CurrentRef,
				"ExternalUsersAccessKeys", "ExternalUsersGroups", "ExternalUser");
		EndIf;
		
		If IsNewSets Then
			LockItem.SetValue("Ref", DataElement.CurrentRef);
			BeginTransaction();
			Try
				Block.Lock();
				Object = ServiceItem(Undefined, DataElement.CurrentRef);
				If Object <> Undefined Then
					AttributeName = ?(DataElement.IsAccessGroupsSet,
						"NewAccessGroupsSet", "NewUserGroupsSet");
					If ValueIsFilled(Object[AttributeName]) Then
						Object[AttributeName] = ParametersOfUpdate.BlankAccessGroupsSet;
						Object.Write();
					EndIf;
				EndIf;
				CommitTransaction();
			Except
				RollbackTransaction();
				Raise;
			EndTry;
		EndIf;
		
		If ItemsProcessingAbortRequired(ParametersOfUpdate, 1) Then
			Break;
		EndIf;
	EndDo;
	
EndProcedure

// For the UpdateGroupsSetsWithObsoleteParameters procedure.
Procedure UpdateGroupsSetsAccessKeys(ParametersOfUpdate, AccessGroupsSet, RightsRegisterName,
				GroupsCatalogName, GroupsSetFieldName)
	
	If AccessGroupsSet = AccessManagementInternalCached.AllowedBlankAccessGroupsSet() Then
		BatchForLockSelectionQueryText =
		"SELECT TOP 1000
		|	SUM(AllRows.LineChangeType) AS LineChangeType,
		|	AllRows.AccessKey AS AccessKey
		|FROM
		|	(SELECT
		|		AccessGroupsAccessKeys.AccessKey AS AccessKey,
		|		AccessGroupsAccessKeys.RightUpdate AS RightUpdate,
		|		AccessGroupsAccessKeys.AddRight AS AddRight,
		|		1 AS LineChangeType
		|	FROM
		|		InformationRegister.AccessGroupsAccessKeys AS AccessGroupsAccessKeys
		|	WHERE
		|		AccessGroupsAccessKeys.AccessGroup = VALUE(Catalog.AccessGroups.EmptyRef)
		|		AND &QueryPlanClarification
		|	
		|	UNION ALL
		|	
		|	SELECT
		|		OldData.AccessKey,
		|		OldData.RightUpdate,
		|		OldData.AddRight,
		|		-1
		|	FROM
		|		InformationRegister.AccessGroupSetsAccessKeys AS OldData
		|	WHERE
		|		&GroupRightsFilterCriterion
		|		AND OldData.AccessGroupsSet = &AccessGroupsSet) AS AllRows
		|
		|GROUP BY
		|	AllRows.AccessKey,
		|	AllRows.RightUpdate,
		|	AllRows.AddRight
		|
		|HAVING
		|	SUM(AllRows.LineChangeType) <> 0
		|
		|ORDER BY
		|	LineChangeType,
		|	AccessKey";
		
		BatchForUpdateSelectionQueryText =
		"SELECT TOP 100
		|	AllRows.AccessKey AS AccessKey,
		|	AllRows.RightUpdate AS RightUpdate,
		|	AllRows.AddRight AS AddRight,
		|	TRUE AS AreGroupSetRights,
		|	SUM(AllRows.LineChangeType) AS LineChangeType
		|FROM
		|	(SELECT
		|		AccessGroupsAccessKeys.AccessKey AS AccessKey,
		|		AccessGroupsAccessKeys.RightUpdate AS RightUpdate,
		|		AccessGroupsAccessKeys.AddRight AS AddRight,
		|		1 AS LineChangeType
		|	FROM
		|		InformationRegister.AccessGroupsAccessKeys AS AccessGroupsAccessKeys
		|	WHERE
		|		AccessGroupsAccessKeys.AccessGroup = VALUE(Catalog.AccessGroups.EmptyRef)
		|		AND AccessGroupsAccessKeys.AccessKey IN(&AccessKeys)
		|		AND &QueryPlanClarification
		|	
		|	UNION ALL
		|	
		|	SELECT
		|		OldData.AccessKey,
		|		OldData.RightUpdate,
		|		OldData.AddRight,
		|		-1
		|	FROM
		|		InformationRegister.AccessGroupSetsAccessKeys AS OldData
		|	WHERE
		|		&GroupRightsFilterCriterion
		|		AND OldData.AccessGroupsSet = &AccessGroupsSet
		|		AND OldData.AccessKey IN(&AccessKeys)) AS AllRows
		|
		|GROUP BY
		|	AllRows.AccessKey,
		|	AllRows.RightUpdate,
		|	AllRows.AddRight
		|
		|HAVING
		|	SUM(AllRows.LineChangeType) <> 0
		|
		|ORDER BY
		|	LineChangeType";
	Else
		BatchForLockSelectionQueryText =
		"SELECT TOP 1000
		|	SUM(AllRows.LineChangeType) AS LineChangeType,
		|	AllRows.AccessKey AS AccessKey
		|FROM
		|	(SELECT
		|		AccessGroupsAccessKeys.AccessKey AS AccessKey,
		|		MAX(AccessGroupsAccessKeys.RightUpdate) AS RightUpdate,
		|		MAX(AccessGroupsAccessKeys.AddRight) AS AddRight,
		|		1 AS LineChangeType
		|	FROM
		|		InformationRegister.AccessGroupsAccessKeys AS AccessGroupsAccessKeys
		|			INNER JOIN Catalog.SetsOfAccessGroups.Groups AS GroupsInSets
		|			ON (GroupsInSets.Group = AccessGroupsAccessKeys.AccessGroup)
		|				AND (VALUETYPE(GroupsInSets.Group) = TYPE(Catalog.AccessGroups))
		|				AND (VALUETYPE(AccessGroupsAccessKeys.AccessGroup) = TYPE(Catalog.AccessGroups))
		|				AND (GroupsInSets.Ref = &AccessGroupsSet)
		|				AND (&QueryPlanClarification)
		|	
		|	GROUP BY
		|		AccessGroupsAccessKeys.AccessKey
		|	
		|	UNION ALL
		|	
		|	SELECT
		|		OldData.AccessKey,
		|		OldData.RightUpdate,
		|		OldData.AddRight,
		|		-1
		|	FROM
		|		InformationRegister.AccessGroupSetsAccessKeys AS OldData
		|	WHERE
		|		&GroupRightsFilterCriterion
		|		AND OldData.AccessGroupsSet = &AccessGroupsSet) AS AllRows
		|
		|GROUP BY
		|	AllRows.AccessKey,
		|	AllRows.RightUpdate,
		|	AllRows.AddRight
		|
		|HAVING
		|	SUM(AllRows.LineChangeType) <> 0
		|
		|ORDER BY
		|	LineChangeType,
		|	AccessKey";
		
		BatchForUpdateSelectionQueryText =
		"SELECT TOP 100
		|	AllRows.AccessKey AS AccessKey,
		|	AllRows.RightUpdate AS RightUpdate,
		|	AllRows.AddRight AS AddRight,
		|	TRUE AS AreGroupSetRights,
		|	SUM(AllRows.LineChangeType) AS LineChangeType
		|FROM
		|	(SELECT
		|		AccessGroupsAccessKeys.AccessKey AS AccessKey,
		|		MAX(AccessGroupsAccessKeys.RightUpdate) AS RightUpdate,
		|		MAX(AccessGroupsAccessKeys.AddRight) AS AddRight,
		|		1 AS LineChangeType
		|	FROM
		|		InformationRegister.AccessGroupsAccessKeys AS AccessGroupsAccessKeys
		|			INNER JOIN Catalog.SetsOfAccessGroups.Groups AS GroupsInSets
		|			ON (GroupsInSets.Group = AccessGroupsAccessKeys.AccessGroup)
		|				AND (VALUETYPE(GroupsInSets.Group) = TYPE(Catalog.AccessGroups))
		|				AND (VALUETYPE(AccessGroupsAccessKeys.AccessGroup) = TYPE(Catalog.AccessGroups))
		|				AND (GroupsInSets.Ref = &AccessGroupsSet)
		|				AND (AccessGroupsAccessKeys.AccessKey IN (&AccessKeys))
		|				AND (&QueryPlanClarification)
		|	
		|	GROUP BY
		|		AccessGroupsAccessKeys.AccessKey
		|	
		|	UNION ALL
		|	
		|	SELECT
		|		OldData.AccessKey,
		|		OldData.RightUpdate,
		|		OldData.AddRight,
		|		-1
		|	FROM
		|		InformationRegister.AccessGroupSetsAccessKeys AS OldData
		|	WHERE
		|		&GroupRightsFilterCriterion
		|		AND OldData.AccessGroupsSet = &AccessGroupsSet
		|		AND OldData.AccessKey IN(&AccessKeys)) AS AllRows
		|
		|GROUP BY
		|	AllRows.AccessKey,
		|	AllRows.RightUpdate,
		|	AllRows.AddRight
		|
		|HAVING
		|	SUM(AllRows.LineChangeType) <> 0
		|
		|ORDER BY
		|	LineChangeType";
	EndIf;
	
	BatchForLockSelectionQueryText = StrReplace(BatchForLockSelectionQueryText,
		"TYPE(Catalog.AccessGroups)", "TYPE(Catalog." + GroupsCatalogName + ")"); // @query-part-1 @query-part-2
	
	BatchForUpdateSelectionQueryText = StrReplace(BatchForUpdateSelectionQueryText,
		"TYPE(Catalog.AccessGroups)", "TYPE(Catalog." + GroupsCatalogName + ")"); // @query-part-1 @query-part-2
	
	BatchForUpdateSelectionQueryText = StrReplace(BatchForUpdateSelectionQueryText,
		"OldData.AccessGroupsSet", "OldData." + GroupsSetFieldName);
	
	BatchForLockSelectionQueryText = StrReplace(BatchForLockSelectionQueryText,
		"OldData.AccessGroupsSet", "OldData." + GroupsSetFieldName);
	
	BatchForLockSelectionQueryText = StrReplace(BatchForLockSelectionQueryText,
		"InformationRegister.AccessGroupSetsAccessKeys", "InformationRegister." + RightsRegisterName);
	
	BatchForUpdateSelectionQueryText = StrReplace(BatchForUpdateSelectionQueryText,
		"InformationRegister.AccessGroupSetsAccessKeys", "InformationRegister." + RightsRegisterName);
	
	BatchForLockSelectionQueryText = StrReplace(BatchForLockSelectionQueryText,
		"&GroupRightsFilterCriterion", ?(GroupsCatalogName = "AccessGroups", "TRUE", "OldData.AreGroupSetRights"));
	
	BatchForUpdateSelectionQueryText = StrReplace(BatchForUpdateSelectionQueryText,
		"&GroupRightsFilterCriterion", ?(GroupsCatalogName = "AccessGroups", "TRUE", "OldData.AreGroupSetRights"));
	
	While True Do
		Query = New Query;
		Query.Text = BatchForLockSelectionQueryText;
		SetQueryPlanClarification(Query.Text, True);
		Query.SetParameter("AccessGroupsSet", AccessGroupsSet);
		
		Upload0 = Query.Execute().Unload();
		If Upload0.Count() = 0 Then
			Break;
		EndIf;
		
		AccessKeys = New Array;
		AccessKeysBatches = New Array;
		For Each String In Upload0 Do
			If AccessKeys.Count() > 100 Then
				AccessKeysBatches.Add(AccessKeys);
				AccessKeys = New Array;
			EndIf;
			AccessKeys.Add(String.AccessKey);
		EndDo;
		AccessKeysBatches.Add(AccessKeys);
		
		For Each AccessKeys In AccessKeysBatches Do
			Block = New DataLock;
			For Each AccessKey In AccessKeys Do
				LockItem = Block.Add("InformationRegister." + RightsRegisterName);
				LockItem.SetValue(GroupsSetFieldName, AccessGroupsSet);
				LockItem.SetValue("AccessKey",      AccessKey);
			EndDo;
			
			If Common.FileInfobase() Then
				LockItem = Block.Add("Catalog.SetsOfAccessGroups");
				LockItem.Mode = DataLockMode.Shared;
				LockItem = Block.Add("InformationRegister.AccessGroupsAccessKeys");
				LockItem.Mode = DataLockMode.Shared;
			EndIf;
			
			Query = New Query;
			Query.Text = BatchForUpdateSelectionQueryText;
			SetQueryPlanClarification(Query.Text, True);
			Query.SetParameter("AccessGroupsSet", AccessGroupsSet);
			Query.SetParameter("AccessKeys", AccessKeys);
			
			RecordSet = ServiceRecordSet(InformationRegisters[RightsRegisterName]);
			
			BeginTransaction();
			Try
				Block.Lock();
				// 
				Selection = Query.Execute().Select();
				
				DeletionCompleted = False;
				While Selection.Next() Do
					FilterElement = RecordSet.Filter[GroupsSetFieldName]; // FilterItem
					FilterElement.Set(AccessGroupsSet);
					RecordSet.Filter.AccessKey.Set(Selection.AccessKey);
					If Not DeletionCompleted And Selection.LineChangeType = 1 Then
						DeletionCompleted = True;
						OneRecord = RecordSet.Add();
						OneRecord[GroupsSetFieldName] = AccessGroupsSet;
					EndIf;
					If DeletionCompleted Then
						FillPropertyValues(OneRecord, Selection);
					EndIf;
					RecordSet.Write();
				EndDo;
				
				CommitTransaction();
			Except
				RollbackTransaction();
				Raise;
			EndTry;
		EndDo;
	EndDo;
	
EndProcedure

// For the RunListAccessUpdate procedure.
Procedure EliminateSetsDuplicatesFromOneUserInCatalog(ParametersOfUpdate)
	
	Query = New Query;
	Query.SetParameter("ForExternalUsers", ParametersOfUpdate.ForExternalUsers);
	Query.Text =
	"SELECT
	|	SetsOfAccessGroups.User AS User,
	|	SetsOfAccessGroups.Ref AS Ref
	|FROM
	|	Catalog.SetsOfAccessGroups AS SetsOfAccessGroups
	|WHERE
	|	SetsOfAccessGroups.ForExternalUsers = &ForExternalUsers
	|	AND SetsOfAccessGroups.SetItemsType = VALUE(Catalog.Users.EmptyRef)
	|	AND SetsOfAccessGroups.User IN
	|			(SELECT
	|				CAST(SetsOfAccessGroups.User AS Catalog.Users) AS User
	|			FROM
	|				Catalog.SetsOfAccessGroups AS SetsOfAccessGroups
	|			WHERE
	|				SetsOfAccessGroups.ForExternalUsers = &ForExternalUsers
	|				AND SetsOfAccessGroups.SetItemsType = VALUE(Catalog.Users.EmptyRef)
	|			GROUP BY
	|				SetsOfAccessGroups.User
	|			HAVING
	|				COUNT(SetsOfAccessGroups.User) > 1)";
	
	If ParametersOfUpdate.ForExternalUsers Then
		Query.Text = StrReplace(Query.Text, "Catalog.Users", "Catalog.ExternalUsers");
	EndIf;
	
	Selection = Query.Execute().Select();
	While Selection.Next() Do
		If Selection.Ref.UUID() = Selection.User.UUID() Then
			Continue;
		EndIf;
		Block = New DataLock;
		LockItem = Block.Add("Catalog.SetsOfAccessGroups");
		LockItem.SetValue("Ref", Selection.Ref);
		BeginTransaction();
		Try
			Block.Lock();
			Object = ServiceItem(Undefined, Selection.Ref);
			If Object <> Undefined Then
				Object.SetItemsType = Undefined;
				Object.Write();
			EndIf;
			CommitTransaction();
		Except
			RollbackTransaction();
			Raise;
		EndTry;
	EndDo;
	
EndProcedure

// For the UpdateAccessGroupsSets procedure.
Procedure UpdateSetsOfOneUserInCatalog(DataItems, ParametersOfUpdate)
	
	If ParametersOfUpdate.ForExternalUsers Then
		SetItemsType = Catalogs.ExternalUsers.EmptyRef();
		ItemPresentation = NStr("en = 'External user';", Common.DefaultLanguageCode());
	Else
		SetItemsType = Catalogs.Users.EmptyRef();
		ItemPresentation = NStr("en = 'User';", Common.DefaultLanguageCode());
	EndIf;
	
	For Each String In DataItems Do
		SetRef1 = Catalogs.SetsOfAccessGroups.GetRef(String.CurrentRef.UUID());
		Block = New DataLock;
		LockItem = Block.Add("Catalog.SetsOfAccessGroups");
		LockItem.SetValue("Ref", SetRef1);
		
		BeginTransaction();
		Try
			Block.Lock();
			
			Object = ServiceItem(Undefined, SetRef1);
			If Object = Undefined Then
				Object = ServiceItem(Catalogs.SetsOfAccessGroups);
				Object.SetNewObjectRef(SetRef1);
			Else
				Object.Groups.Clear();
			EndIf;
			If String.Used Then
				Object.NotUsedSince = '00010101';
			ElsIf Not ValueIsFilled(String.NotUsedSince) Then
				Object.NotUsedSince = CurrentSessionDate();
			EndIf;
			Object.ForExternalUsers = ParametersOfUpdate.ForExternalUsers;
			Object.SetItemsType = SetItemsType;
			Object.User = String.CurrentRef;
			ObjectDetails = String; // CatalogObject.Users
			Object.Description = String(ObjectDetails.Description) + " (" + ItemPresentation + ")";
			Object.Write();
			
			CommitTransaction();
		Except
			RollbackTransaction();
			Raise;
		EndTry;
		
		If ItemsProcessingAbortRequired(ParametersOfUpdate, 1) Then
			Break;
		EndIf;
	EndDo;
	
EndProcedure

// For the RunListAccessUpdate procedure.
Procedure FillBlankGroupsSetsHashes(ParametersOfUpdate)
	
	Query = New Query;
	Query.SetParameter("ForExternalUsers", ParametersOfUpdate.ForExternalUsers);
	Query.SetParameter("AllowedBlankSet",
		AccessManagementInternalCached.AllowedBlankAccessGroupsSet());
	Query.Text =
	"SELECT
	|	SetsOfAccessGroups.Ref AS Ref
	|FROM
	|	Catalog.SetsOfAccessGroups AS SetsOfAccessGroups
	|WHERE
	|	SetsOfAccessGroups.ForExternalUsers = &ForExternalUsers
	|	AND SetsOfAccessGroups.SetItemsType IN (VALUE(Catalog.AccessGroups.EmptyRef), VALUE(Catalog.UserGroups.EmptyRef))
	|	AND SetsOfAccessGroups.Hash = 0
	|	AND SetsOfAccessGroups.Ref <> &AllowedBlankSet";
	
	If ParametersOfUpdate.ForExternalUsers Then
		Query.Text = StrReplace(Query.Text, "Catalog.UserGroups", "Catalog.ExternalUsersGroups");
	EndIf;
	
	Selection = Query.Execute().Select();
	While Selection.Next() Do
		Block = New DataLock;
		LockItem = Block.Add("Catalog.SetsOfAccessGroups");
		LockItem.SetValue("Ref", Selection.Ref);
		BeginTransaction();
		Try
			Block.Lock();
			Object = ServiceItem(Undefined, Selection.Ref);
			If Object <> Undefined Then
				FillGroupsSetHash(Object);
				Object.Write();
			EndIf;
			CommitTransaction();
		Except
			RollbackTransaction();
			Raise;
		EndTry;
	EndDo;
	
EndProcedure

// For the AccessGroupsSetsToUpdate function.
Function OneUserSetsToUpdateAssignedAccessGroupsSets(ParametersOfUpdate,
			CountInQuery)
	
	If Not ParametersOfUpdate.ForExternalUsers Then
		GroupsQueryText =
		"SELECT
		|	AccessGroups.Ref AS GroupReference
		|FROM
		|	Catalog.AccessGroups AS AccessGroups
		|WHERE
		|	AccessGroups.Profile <> &ProfileAdministrator
		|	AND NOT AccessGroups.DeletionMark
		|	AND NOT AccessGroups.Profile.DeletionMark
		|	AND TRUE IN
		|			(SELECT TOP 1
		|				TRUE
		|			FROM
		|				Catalog.AccessGroups.Users AS AccessGroupsUsers
		|			WHERE
		|				AccessGroupsUsers.Ref = AccessGroups.Ref)
		|	AND CASE
		|			WHEN TRUE IN
		|					(SELECT TOP 1
		|						TRUE
		|					FROM
		|						Catalog.AccessGroupProfiles.Purpose AS Purpose
		|					WHERE
		|						Purpose.Ref = AccessGroups.Profile
		|						AND VALUETYPE(Purpose.UsersType) = TYPE(Catalog.Users))
		|				THEN TRUE
		|			WHEN NOT FALSE IN
		|						(SELECT TOP 1
		|							FALSE
		|						FROM
		|							Catalog.AccessGroupProfiles.Purpose AS Purpose
		|						WHERE
		|							Purpose.Ref = AccessGroups.Profile)
		|				THEN TRUE
		|			ELSE FALSE
		|		END
		|
		|ORDER BY
		|	Ref";
	Else
		GroupsQueryText =
		"SELECT
		|	AccessGroups.Ref AS GroupReference
		|FROM
		|	Catalog.AccessGroups AS AccessGroups
		|WHERE
		|	AccessGroups.Profile <> &ProfileAdministrator
		|	AND NOT AccessGroups.DeletionMark
		|	AND NOT AccessGroups.Profile.DeletionMark
		|	AND TRUE IN
		|			(SELECT TOP 1
		|				TRUE
		|			FROM
		|				Catalog.AccessGroups.Users AS AccessGroupsUsers
		|			WHERE
		|				AccessGroupsUsers.Ref = AccessGroups.Ref)
		|	AND TRUE IN
		|			(SELECT TOP 1
		|				TRUE
		|			FROM
		|				Catalog.AccessGroupProfiles.Purpose AS Purpose
		|			WHERE
		|				Purpose.Ref = AccessGroups.Profile
		|				AND Purpose.UsersType <> UNDEFINED
		|				AND VALUETYPE(Purpose.UsersType) <> TYPE(Catalog.Users))
		|
		|ORDER BY
		|	Ref";
	EndIf;
	
	NewGroupsSetsQueryText =
	"SELECT
	|	UserAccessGroups.User AS User,
	|	SUM(GroupsNumbers.NumberPart1) AS NumberPart1
	|INTO NewGroupsSets
	|FROM
	|	(SELECT DISTINCT
	|		UserGroupCompositions.User AS User,
	|		AccessGroupsUsers.Ref AS AccessGroup
	|	FROM
	|		Catalog.AccessGroups.Users AS AccessGroupsUsers
	|			INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|			ON (UserGroupCompositions.UsersGroup = AccessGroupsUsers.User)
	|				AND (VALUETYPE(UserGroupCompositions.User) = TYPE(Catalog.Users))
	|				AND (CAST(UserGroupCompositions.User AS Catalog.Users).IBUserID <> &BlankUUID)
	|				AND (UserGroupCompositions.Used)) AS UserAccessGroups
	|		INNER JOIN GroupsNumbers AS GroupsNumbers
	|		ON UserAccessGroups.AccessGroup = GroupsNumbers.Group
	|
	|GROUP BY
	|	UserAccessGroups.User
	|
	|INDEX BY
	|	UserAccessGroups.User";
	
	DataItems = OneUserSetsToUpdateAssignedGroupsSets(ParametersOfUpdate,
		GroupsQueryText, NewGroupsSetsQueryText, "AccessGroupsSet", "AccessGroups");
	
	CountInQuery = DataItems.Count();
	Return DataItems;
	
EndFunction

// For the AccessGroupsSetsToUpdate function.
Function OneUserSetsToUpdateAssignedUsersGroupsSets(ParametersOfUpdate,
			CountInQuery)
	
	GroupsQueryText =
	"SELECT DISTINCT
	|	UserGroupCompositions.UsersGroup AS GroupReference
	|FROM
	|	InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|WHERE
	|	UserGroupCompositions.Used
	|	AND VALUETYPE(UserGroupCompositions.UsersGroup) = TYPE(Catalog.UserGroups)
	|
	|ORDER BY
	|	UserGroupCompositions.UsersGroup";
	
	If ParametersOfUpdate.ForExternalUsers Then
		GroupsQueryText = StrReplace(GroupsQueryText,
			"Catalog.UserGroups", "Catalog.ExternalUsersGroups");
	EndIf;
	
	NewGroupsSetsQueryText =
	"SELECT
	|	UserGroupCompositions.User AS User,
	|	SUM(GroupsNumbers.NumberPart1) AS NumberPart1
	|INTO NewGroupsSets
	|FROM
	|	InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|		INNER JOIN GroupsNumbers AS GroupsNumbers
	|		ON UserGroupCompositions.UsersGroup = GroupsNumbers.Group
	|			AND (VALUETYPE(UserGroupCompositions.User) = TYPE(Catalog.Users))
	|			AND (CAST(UserGroupCompositions.User AS Catalog.Users).IBUserID <> &BlankUUID)
	|			AND (UserGroupCompositions.Used)
	|
	|GROUP BY
	|	UserGroupCompositions.User
	|
	|INDEX BY
	|	UserGroupCompositions.User";
	
	If ParametersOfUpdate.ForExternalUsers Then
		GroupsCatalogName = "ExternalUsersGroups";
	Else
		GroupsCatalogName = "UserGroups";
	EndIf;
	
	DataItems = OneUserSetsToUpdateAssignedGroupsSets(ParametersOfUpdate,
		GroupsQueryText, NewGroupsSetsQueryText, "UserGroupsSet", GroupsCatalogName);
	
	CountInQuery = DataItems.Count();
	Return DataItems;
	
EndFunction

// For the SetsOfOneUserToUpdateAssignedAccessGroupsSets,
// SetsOfOneUserToUpdateAssignedUsersGroupsSets functions.
//
Function OneUserSetsToUpdateAssignedGroupsSets(ParametersOfUpdate,
			GroupsQueryText, NewGroupsSetsQueryText, SetFieldName, GroupsCatalogName)
	
	Query = New Query;
	Query.SetParameter("ProfileAdministrator", AccessManagement.ProfileAdministrator());
	Query.Text = GroupsQueryText;
	GroupsNumbers = Query.Execute().Unload();
	
	NumberPartsNames = New Array;
	MaxGroupNumberInNumberPart = 9223372036854775808; // 2^63.
	FillGroupsNumbers(GroupsNumbers, NumberPartsNames, MaxGroupNumberInNumberPart);
	
	Query = New Query;
	Query.SetParameter("GroupsNumbers", GroupsNumbers);
	Query.SetParameter("ForExternalUsers", ParametersOfUpdate.ForExternalUsers);
	Query.SetParameter("BlankUUID",
		CommonClientServer.BlankUUID());
	
	Query.Text =
	"SELECT
	|	GroupsNumbers.GroupReference AS Group,
	|	GroupsNumbers.NumberPart1 AS NumberPart1
	|INTO GroupsNumbers
	|FROM
	|	&GroupsNumbers AS GroupsNumbers
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	UNDEFINED AS User,
	|	SUM(GroupsNumbers.NumberPart1) AS NumberPart1
	|INTO NewGroupsSets
	|FROM
	|	GroupsNumbers AS GroupsNumbers
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	GroupsSets.Ref AS SingleUserSet,
	|	GroupsSets.User AS User,
	|	GroupsSets.AllowedAccessGroupsSet AS CurrentGroupsSet,
	|	SUM(ISNULL(GroupsNumbers.NumberPart1, -1234567)) AS NumberPart1
	|INTO OldGroupSets
	|FROM
	|	Catalog.SetsOfAccessGroups AS GroupsSets
	|		LEFT JOIN Catalog.SetsOfAccessGroups.Groups AS SetGroups1
	|		ON (SetGroups1.Ref = GroupsSets.AllowedAccessGroupsSet)
	|		LEFT JOIN GroupsNumbers AS GroupsNumbers
	|		ON (SetGroups1.Group = GroupsNumbers.Group)
	|WHERE
	|	GroupsSets.ForExternalUsers = &ForExternalUsers
	|	AND GroupsSets.SetItemsType = VALUE(Catalog.Users.EmptyRef)
	|	AND GroupsSets.NotUsedSince = DATETIME(1, 1, 1)
	|	AND GroupsSets.NewAccessGroupsSet = VALUE(Catalog.SetsOfAccessGroups.EmptyRef)
	|	AND &QueryPlanClarification
	|
	|GROUP BY
	|	GroupsSets.Ref,
	|	GroupsSets.User,
	|	GroupsSets.AllowedAccessGroupsSet
	|
	|UNION ALL
	|
	|SELECT
	|	GroupsSets.Ref,
	|	GroupsSets.User,
	|	GroupsSets.NewAccessGroupsSet,
	|	SUM(ISNULL(GroupsNumbers.NumberPart1, -1234567))
	|FROM
	|	Catalog.SetsOfAccessGroups AS GroupsSets
	|		LEFT JOIN Catalog.SetsOfAccessGroups.Groups AS SetGroups1
	|		ON (SetGroups1.Ref = GroupsSets.NewAccessGroupsSet)
	|		LEFT JOIN GroupsNumbers AS GroupsNumbers
	|		ON (SetGroups1.Group = GroupsNumbers.Group)
	|WHERE
	|	GroupsSets.ForExternalUsers = &ForExternalUsers
	|	AND GroupsSets.SetItemsType = VALUE(Catalog.Users.EmptyRef)
	|	AND GroupsSets.NotUsedSince = DATETIME(1, 1, 1)
	|	AND GroupsSets.NewAccessGroupsSet <> VALUE(Catalog.SetsOfAccessGroups.EmptyRef)
	|	AND &QueryPlanClarification
	|
	|GROUP BY
	|	GroupsSets.Ref,
	|	GroupsSets.User,
	|	GroupsSets.NewAccessGroupsSet
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	OldSets.SingleUserSet AS SingleUserSet,
	|	NewSets.NumberPart1 AS NumberPart1
	|INTO GroupSetsForUpdate
	|FROM
	|	OldGroupSets AS OldSets
	|		LEFT JOIN NewGroupsSets AS NewSets
	|		ON (NewSets.User = OldSets.User)
	|WHERE
	|	(NewSets.User IS NULL
	|				AND OldSets.CurrentGroupsSet <> VALUE(Catalog.SetsOfAccessGroups.EmptyRef)
	|			OR OldSets.NumberPart1 <> ISNULL(NewSets.NumberPart1, -1234567))
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	GroupsSets.Ref AS GroupsSet,
	|	SUM(ISNULL(GroupsNumbers.NumberPart1, -1234567)) AS NumberPart1
	|INTO ExistingGroupSets
	|FROM
	|	Catalog.SetsOfAccessGroups AS GroupsSets
	|		INNER JOIN Catalog.SetsOfAccessGroups.Groups AS SetGroups1
	|		ON (GroupsSets.ForExternalUsers = &ForExternalUsers)
	|			AND (GroupsSets.SetItemsType = VALUE(Catalog.AccessGroups.EmptyRef))
	|			AND (SetGroups1.Ref = GroupsSets.Ref)
	|		LEFT JOIN GroupsNumbers AS GroupsNumbers
	|		ON (SetGroups1.Group = GroupsNumbers.Group)
	|			AND (&QueryPlanClarification)
	|
	|GROUP BY
	|	GroupsSets.Ref
	|
	|HAVING
	|	SUM(ISNULL(GroupsNumbers.NumberPart1, -1234567)) >= 0
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	NewSets.SingleUserSet AS CurrentRef,
	|	CASE
	|		WHEN NewSets.NumberPart1 IS NULL
	|			THEN VALUE(Catalog.SetsOfAccessGroups.EmptyRef)
	|		ELSE ISNULL(ExistingSets.GroupsSet, UNDEFINED)
	|	END AS GroupsSet,
	|	TRUE IN
	|		(SELECT TOP 1
	|			TRUE
	|		FROM
	|			Catalog.SetsOfAccessGroups AS AllSets
	|		WHERE
	|			AllSets.ForExternalUsers = &ForExternalUsers
	|			AND AllSets.NewAccessGroupsSet = ExistingSets.GroupsSet) AS NewGroupSet,
	|	NewSets.NumberPart1 AS NumberPart1
	|FROM
	|	GroupSetsForUpdate AS NewSets
	|		LEFT JOIN ExistingGroupSets AS ExistingSets
	|		ON (ExistingSets.NumberPart1 = NewSets.NumberPart1)
	|
	|ORDER BY
	|	CurrentRef,
	|	GroupsSet";
	
	Query.Text = StrReplace(Query.Text,
		"SELECT
		|	UNDEFINED AS User,
		|	SUM(GroupsNumbers.NumberPart1) AS NumberPart1
		|INTO NewGroupsSets
		|FROM
		|	GroupsNumbers AS GroupsNumbers",
		NewGroupsSetsQueryText);
	
	If ParametersOfUpdate.ForExternalUsers Then
		Query.Text = StrReplace(Query.Text, "Catalog.Users", "Catalog.ExternalUsers");
	EndIf;
	
	Query.Text = StrReplace(Query.Text, "VALUE(Catalog.AccessGroups.EmptyRef)", // @query-part-1
		"VALUE(Catalog." + GroupsCatalogName + ".EmptyRef)"); // @query-part-1
	
	Query.Text = StrReplace(Query.Text, "NewAccessGroupsSet",       "New"       + SetFieldName);
	Query.Text = StrReplace(Query.Text, "AllowedAccessGroupsSet", "Allowed" + SetFieldName);
	
	Query.Text = StrReplace(Query.Text,
		"	GroupsNumbers.NumberPart1 AS NumberPart1", // @query-part-1
		"	GroupsNumbers." + StrConcat(NumberPartsNames, ",
		|	GroupsNumbers."));
	
	Query.Text = StrReplace(Query.Text,
		"	SUM(ISNULL(GroupsNumbers.NumberPart1, -1234567)) >= 0", // @query-part-1 @query-part-2 @query-part-3
		"	SUM(ISNULL(GroupsNumbers." + StrConcat(NumberPartsNames, ", -1234567)) >= 0
		|	AND SUM(ISNULL(GroupsNumbers.") + ", -1234567)) >= 0");
	
	Query.Text = StrReplace(Query.Text,
		"	SUM(ISNULL(GroupsNumbers.NumberPart1, -1234567))
		|", // @query-part-1 @query-part-2 @query-part-3
		"	SUM(ISNULL(GroupsNumbers." + StrConcat(NumberPartsNames, ", -1234567)),
		|	SUM(ISNULL(GroupsNumbers.") + ", -1234567))
		|");
	
	Query.Text = StrReplace(Query.Text,
		"	NewSets.NumberPart1 AS NumberPart1", // @query-part-1
		"	NewSets." + StrConcat(NumberPartsNames, ",
		|	NewSets."));
	
	FilterCriterion = "";
	ConnectionCondition = "";
	OldOnesSumFields = "";
	NewOnesSumFields = "";
	For Each NumberPartName In NumberPartsNames Do
		FilterCriterion = FilterCriterion + ?(FilterCriterion = "", "","
		|			OR ") + "OldSets." + NumberPartName + " <> ISNULL(NewSets." + NumberPartName + ", -1234567)"; // @query-part-1 @query-part-3
		ConnectionCondition = ConnectionCondition + ?(ConnectionCondition = "", "", "
		|			AND ") + "(ExistingSets." + NumberPartName + " = NewSets." + NumberPartName + ")"; // @query-part-1
		OldOnesSumFields = OldOnesSumFields + ?(OldOnesSumFields = "", "", ",
		|	") + "SUM(ISNULL(GroupsNumbers." + NumberPartName + ", -1234567)) AS " + NumberPartName; // @query-part-2 @query-part-3
		NewOnesSumFields = NewOnesSumFields + ?(NewOnesSumFields = "", "", ",
		|	") + "SUM(GroupsNumbers." + NumberPartName + ") AS " + NumberPartName; // @query-part-2 @query-part-3
	EndDo;
	
	Query.Text = StrReplace(Query.Text,
		"OldSets.NumberPart1 <> ISNULL(NewSets.NumberPart1, -1234567)", FilterCriterion); // @query-part-1
	Query.Text = StrReplace(Query.Text,
		"(ExistingSets.NumberPart1 = NewSets.NumberPart1)", ConnectionCondition); // @query-part-1
	
	Query.Text = StrReplace(Query.Text,
		"SUM(ISNULL(GroupsNumbers.NumberPart1, -1234567)) AS NumberPart1", OldOnesSumFields); // @query-part-1
	Query.Text = StrReplace(Query.Text,
		"SUM(GroupsNumbers.NumberPart1) AS NumberPart1", NewOnesSumFields); // @query-part-1
	
	Query.Text = StrReplace(Query.Text, "-1234567", Format(-MaxGroupNumberInNumberPart*2, "NG="));
	
	SetQueryPlanClarification(Query.Text);
	
	Result = Query.Execute().Unload();
	
	SetPartsNamesList = StrConcat(NumberPartsNames, ", ");
	NewGroupsSets = Result.Copy(New Array, SetPartsNamesList);
	NewGroupsSets.Columns.Add("SetGroups");
	NewGroupsSets.Columns.Add("GroupsID");
	Filter = New Structure(SetPartsNamesList);
	
	DataItems = Result.Copy(New Array, "CurrentRef, GroupsSet, NewGroupSet");
	DataItems.Columns.Add("SetGroups");
	DataItems.Columns.Add("GroupsID");
	
	For Each String In Result Do
		NewRow = DataItems.Add();
		FillPropertyValues(NewRow, String);
		If String.GroupsSet <> Undefined Then
			Continue;
		EndIf;
		FillPropertyValues(Filter, String);
		FoundRows = NewGroupsSets.FindRows(Filter);
		If FoundRows.Count() = 0 Then
			NewSetProperties = NewGroupsSets.Add();
			FillPropertyValues(NewSetProperties, String);
			NewSetProperties.GroupsID = New UUID;
			NewSetProperties.SetGroups =
				SetGroupsByNumbers(GroupsNumbers, NumberPartsNames, NewSetProperties);
		Else
			NewSetProperties = FoundRows[0];
		EndIf;
		NewRow.SetGroups       = NewSetProperties.SetGroups;
		NewRow.GroupsID = NewSetProperties.GroupsID;
	EndDo;
	
	Return DataItems;
	
EndFunction

// For the UpdateItemsBatch procedure.
Procedure UpdateGroupsSetsAssingedToUsersInCatalog(DataItems,
			ParametersOfUpdate, IsAssignedAccessGroupsSetsUpdate)
	
	ForExternalUsers = ParametersOfUpdate.ForExternalUsers;
	
	If IsAssignedAccessGroupsSetsUpdate Then
		SetFieldName = "AccessGroupsSet";
		SetItemsType = Catalogs.AccessGroups.EmptyRef();
		GroupsItemsPresentation = NStr("en = 'Access groups';",
			Common.DefaultLanguageCode());
		
	Else
		SetFieldName = "UserGroupsSet";
		If Not ForExternalUsers Then
			SetItemsType = Catalogs.UserGroups.EmptyRef();
			GroupsItemsPresentation = NStr("en = 'Users groups';",
				Common.DefaultLanguageCode());
		Else
			SetItemsType = Catalogs.ExternalUsersGroups.EmptyRef();
			GroupsItemsPresentation = NStr("en = 'External user groups';",
				Common.DefaultLanguageCode());
		EndIf;
	EndIf;
	
	NewGroupsSets = New Map;
	
	For Each String In DataItems Do
		If String.GroupsSet = Undefined Then
			GroupsSet = NewGroupsSets.Get(String.GroupsID);
			If GroupsSet = Undefined Then
				// @skip-
				String.GroupsSet = NewGroupsSet(String.SetGroups,
					ParametersOfUpdate.ForExternalUsers,
					SetItemsType,
					SetFieldName,
					GroupsItemsPresentation,
					String.NewGroupSet);
				NewGroupsSets.Insert(String.GroupsID, String.GroupsSet);
			Else
				String.GroupsSet = GroupsSet;
				String.NewGroupSet = True;
			EndIf;
		EndIf;
		
		Block = New DataLock;
		LockItem = Block.Add("Catalog.SetsOfAccessGroups");
		LockItem.SetValue("Ref", String.CurrentRef);
		
		BeginTransaction();
		Try
			Block.Lock();
			
			Object = ServiceItem(Undefined, String.CurrentRef);
			If String.NewGroupSet Then
				Object["New" + SetFieldName] = String.GroupsSet;
			Else
				Object["Allowed" + SetFieldName] = String.GroupsSet;
				Object["New" + SetFieldName] = ParametersOfUpdate.BlankAccessGroupsSet;
			EndIf;
			Object.Write();
			
			CommitTransaction();
		Except
			RollbackTransaction();
			Raise;
		EndTry;
		
		If ItemsProcessingAbortRequired(ParametersOfUpdate, 1) Then
			Break;
		EndIf;
	EndDo;
	
EndProcedure

// For the UpdateGroupsSetsInCatalog procedure.
Procedure FillGroupsNumbers(GroupsNumbers, NumberPartsNames, MaxGroupNumberInNumberPart)
	
	GroupCount = GroupsNumbers.Count();
	NumberPartsCount = Int(GroupCount / 64) + 1;
	NumberTypesDetails = New TypeDescription("Number",,,
		New NumberQualifiers(31, 0, AllowedSign.Nonnegative));
	
	For Counter = 1 To NumberPartsCount Do
		NumberPartName = "NumberPart" + Format(Counter, "NGS=");
		NumberPartsNames.Add(NumberPartName);
		GroupsNumbers.Columns.Add(NumberPartName, NumberTypesDetails);
	EndDo;
	
	CurrentNumberPart = 1;
	CurrentNumberPartName = NumberPartsNames[0];
	CurrentGroupNumber = 1;

	For Each String In GroupsNumbers Do
		String[CurrentNumberPartName] = CurrentGroupNumber;
		CurrentGroupNumber = CurrentGroupNumber * 2;
		If CurrentGroupNumber > MaxGroupNumberInNumberPart Then
			CurrentGroupNumber = 1;
			CurrentNumberPartName = NumberPartsNames[CurrentNumberPart];
			CurrentNumberPart = CurrentNumberPart + 1;
		EndIf;
	EndDo;
	
EndProcedure

// For the UpdateGroupsSetsInCatalog procedure.
Function NewGroupsSet(SetGroups, ForExternalUsers, SetItemsType,
			SetFieldName, GroupsItemsPresentation, NewGroupSet)
	
	NewRef = Catalogs.SetsOfAccessGroups.GetRef();
	Object = ServiceItem(Catalogs.SetsOfAccessGroups);
	Object.SetNewObjectRef(NewRef);
	Object.ForExternalUsers = ForExternalUsers;
	Object.SetItemsType = SetItemsType;
	Object.Description = String(NewRef.UUID()) + " (" + GroupsItemsPresentation + ")";
	
	For Each SetGroup In SetGroups Do
		Object.Groups.Add().Group = SetGroup;
	EndDo;
	
	FillGroupsSetHash(Object);
	
	Block = New DataLock;
	LockItem = Block.Add("Catalog.SetsOfAccessGroups");
	LockItem.SetValue("SetItemsType", Object.SetItemsType);
	LockItem.SetValue("Hash", Object.Hash);
	
	BeginTransaction();
	Try
		Block.Lock();
		If GroupsSetExists(Object) Then
			Query = New Query;
			Query.SetParameter("ForExternalUsers", ForExternalUsers);
			Query.SetParameter("ExistingSet", Object.Ref);
			Query.Text =
			"SELECT TOP 1
			|	TRUE AS TrueValue
			|FROM
			|	Catalog.SetsOfAccessGroups AS AllSets
			|WHERE
			|	AllSets.ForExternalUsers = &ForExternalUsers
			|	AND AllSets.NewAccessGroupsSet = &ExistingSet";
			Query.Text = StrReplace(Query.Text, "NewAccessGroupsSet", "New" + SetFieldName);
			
			If Not Query.Execute().IsEmpty() Then
				NewGroupSet = True;
			EndIf;
		Else
			Object["New" + SetFieldName] = NewRef;
			Object.Write();
			NewGroupSet = True;
		EndIf;
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
	Return Object.Ref;
	
EndFunction

// For the NewGroupsSet function and the FillBlankGroupsSetsHashes procedure.
Procedure FillGroupsSetHash(Object)
	
	Object.Groups.Sort("Group", New CompareValues);
	
	DataForHash = Object.Groups.UnloadColumn("Group");
	StringForHash = DataStringForHashing(DataForHash);
	Hashing = New DataHashing(HashFunction.CRC32);
	Hashing.Append(StringForHash);
	Object.Hash = Hashing.HashSum;
	
EndProcedure

// For the NewGroupsSet function.
Function SetGroupsByNumbers(GroupsNumbers, NumberPartsNames, NumberParts)
	
	SetGroups = New Array;
	GroupIndex = 0;
	Divisor = 4294967296; // 2^32.
	
	For Each NumberPartName In NumberPartsNames Do
		NumberPart = NumberParts[NumberPartName];
		For NumberPartBlockNumber = 1 To 2 Do
			Integer = Int(NumberPart / Divisor);
			NumberPartBlock = NumberPart - Integer * Divisor;
			NumberPart = Integer;
			If NumberPartBlock > 0 Then
				For BitNumber = 0 To 31 Do
					If CheckBit(NumberPartBlock, BitNumber) Then
						SetGroups.Add(GroupsNumbers[GroupIndex + BitNumber].GroupReference);
					EndIf;
				EndDo;
			EndIf;
			GroupIndex = GroupIndex + 32;
		EndDo;
	EndDo;
	
	Return SetGroups;
	
EndFunction

// For the NewGroupsSet function.
Function GroupsSetExists(Object)
	
	Query = New Query;
	Query.SetParameter("SetItemsType", Object.SetItemsType);
	Query.SetParameter("Hash", Object.Hash);
	Query.Text =
	"SELECT
	|	ExistingSets.Ref AS SetRef1,
	|	ExistingSets.Groups.(
	|		Groups.Group AS Group
	|	) AS SetGroups
	|FROM
	|	Catalog.SetsOfAccessGroups AS ExistingSets
	|WHERE
	|	ExistingSets.SetItemsType = &SetItemsType
	|	AND ExistingSets.Hash = &Hash
	|
	|ORDER BY
	|	Ref";
	
	ObjectGroups = Object.Groups.Unload(, "Group");
	ObjectGroups.Indexes.Add("Group");
	
	Upload0 = Query.Execute().Unload();
	For Each String In Upload0 Do
		If ObjectGroups.Count() <> String.SetGroups.Count() Then
			Continue;
		EndIf;
		GroupsMap = True;
		For Each Substring In String.SetGroups Do
			If ObjectGroups.Find(Substring.Group, "Group") = Undefined Then
				GroupsMap = False;
				Break;
			EndIf;
		EndDo;
		If GroupsMap Then
			Object = New Structure("Ref", String.SetRef1);
			Return True;
		EndIf;
	EndDo;
	
	Return False;
	
EndFunction

// For the UpdateAccessGroupsSets procedure.
Procedure UpdateGroupsSetsAllowedForUsersInCatalog(DataItems, ParametersOfUpdate)
	
	Block = New DataLock;
	LockItem = Block.Add("Catalog.SetsOfAccessGroups");
	
	For Each String In DataItems Do
		LockItem.SetValue("Ref", String.CurrentRef);
		
		BeginTransaction();
		Try
			Block.Lock();
			
			Object = ServiceItem(Undefined, String.CurrentRef);
			If Object <> Undefined Then
				If ValueIsFilled(Object.NewAccessGroupsSet) Then
					Object.AllowedAccessGroupsSet = Object.NewAccessGroupsSet;
					Object.NewAccessGroupsSet = ParametersOfUpdate.BlankAccessGroupsSet;
				EndIf;
				If ValueIsFilled(Object.NewUserGroupsSet) Then
					Object.AllowedUserGroupsSet = Object.NewUserGroupsSet;
					Object.NewUserGroupsSet = ParametersOfUpdate.BlankAccessGroupsSet;
				EndIf;
				If Object.Modified() Then
					Object.Write();
				EndIf;
			EndIf;
			
			CommitTransaction();
		Except
			RollbackTransaction();
			Raise;
		EndTry;
		
		If ItemsProcessingAbortRequired(ParametersOfUpdate, 1) Then
			Break;
		EndIf;
	EndDo;
	
EndProcedure

// For the RunListAccessUpdate procedure.
Procedure ClearNonExistentAccessGroupsSetsRights(ParametersOfUpdate)
	
	If ParametersOfUpdate.ForExternalUsers Then
		Return;
	EndIf;
	
	Query = New Query;
	Query.Text =
	"SELECT DISTINCT
	|	SetsAccessKeys.AccessGroupsSet AS Set
	|FROM
	|	InformationRegister.AccessGroupSetsAccessKeys AS SetsAccessKeys
	|WHERE
	|	SetsAccessKeys.AccessGroupsSet.Ref IS NULL
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT DISTINCT
	|	SetsAccessKeys.User AS Set
	|FROM
	|	InformationRegister.UsersAccessKeys AS SetsAccessKeys
	|WHERE
	|	SetsAccessKeys.User.Ref IS NULL
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT DISTINCT
	|	SetsAccessKeys.ExternalUser AS Set
	|FROM
	|	InformationRegister.ExternalUsersAccessKeys AS SetsAccessKeys
	|WHERE
	|	SetsAccessKeys.ExternalUser.Ref IS NULL";
	
	QueryResults = Query.ExecuteBatch();
	
	Selection = QueryResults[0].Select();
	While Selection.Next() Do
		// 
		DeleteRegisterRecordsForSet(Selection.Set,
			"AccessGroupSetsAccessKeys", "AccessGroupsSet");
	EndDo;
	
	Selection = QueryResults[1].Select();
	While Selection.Next() Do
		// 
		DeleteRegisterRecordsForSet(Selection.Set,
			"UsersAccessKeys", "User");
	EndDo;
	
	Selection = QueryResults[2].Select();
	While Selection.Next() Do
		// 
		DeleteRegisterRecordsForSet(Selection.Set,
			"ExternalUsersAccessKeys", "ExternalUser");
	EndDo;
	
EndProcedure

// For the AccessGroupsSetsToUpdate function.
Function ObsoleteAccessGroupsSetsInCatalog(ParametersOfUpdate, CountInQuery)
	
	Query = New Query;
	Query.SetParameter("ForExternalUsers", ParametersOfUpdate.ForExternalUsers);
	Query.SetParameter("ExpirationDate", ExpirationDate());
	Query.SetParameter("AllowedBlankSet",
		AccessManagementInternalCached.AllowedBlankAccessGroupsSet());
	
	Query.Text =
	"SELECT
	|	SetsOfAccessGroups.Ref AS CurrentRef,
	|	SetsOfAccessGroups.SetItemsType AS SetItemsType,
	|	FALSE AS Used,
	|	TRUE AS Delete
	|FROM
	|	Catalog.SetsOfAccessGroups AS SetsOfAccessGroups
	|WHERE
	|	SetsOfAccessGroups.SetItemsType = UNDEFINED
	|	AND &QueryPlanClarification
	|
	|UNION ALL
	|
	|SELECT
	|	SetsOfAccessGroups.Ref,
	|	SetsOfAccessGroups.SetItemsType,
	|	FALSE,
	|	TRUE
	|FROM
	|	Catalog.SetsOfAccessGroups AS SetsOfAccessGroups
	|WHERE
	|	SetsOfAccessGroups.ForExternalUsers = &ForExternalUsers
	|	AND SetsOfAccessGroups.SetItemsType = VALUE(Catalog.Users.EmptyRef)
	|	AND (CAST(SetsOfAccessGroups.User AS Catalog.Users).Ref IS NULL
	|			OR SetsOfAccessGroups.NotUsedSince <> DATETIME(1, 1, 1)
	|				AND SetsOfAccessGroups.NotUsedSince < &ExpirationDate)
	|
	|UNION ALL
	|
	|SELECT DISTINCT
	|	SetsOfAccessGroups.Ref,
	|	SetsOfAccessGroups.SetItemsType,
	|	NOT MIN(SetsWithSingleUser.Ref IS NULL),
	|	MIN(SetsOfAccessGroups.NotUsedSince <> DATETIME(1, 1, 1)
	|			AND SetsOfAccessGroups.NotUsedSince < &ExpirationDate)
	|FROM
	|	Catalog.SetsOfAccessGroups AS SetsOfAccessGroups
	|		LEFT JOIN Catalog.SetsOfAccessGroups AS SetsWithSingleUser
	|		ON (SetsWithSingleUser.ForExternalUsers = &ForExternalUsers)
	|			AND (SetsWithSingleUser.AllowedAccessGroupsSet = SetsOfAccessGroups.Ref
	|				OR SetsWithSingleUser.NewAccessGroupsSet = SetsOfAccessGroups.Ref)
	|WHERE
	|	SetsOfAccessGroups.ForExternalUsers = &ForExternalUsers
	|	AND SetsOfAccessGroups.SetItemsType = VALUE(Catalog.AccessGroups.EmptyRef)
	|	AND SetsOfAccessGroups.Ref <> &AllowedBlankSet
	|
	|GROUP BY
	|	SetsOfAccessGroups.Ref,
	|	SetsOfAccessGroups.SetItemsType
	|
	|HAVING
	|	(SetsOfAccessGroups.NotUsedSince = DATETIME(1, 1, 1)
	|			AND MIN(SetsWithSingleUser.Ref IS NULL)
	|		OR SetsOfAccessGroups.NotUsedSince <> DATETIME(1, 1, 1)
	|			AND (NOT MIN(SetsWithSingleUser.Ref IS NULL)
	|				OR SetsOfAccessGroups.NotUsedSince < &ExpirationDate))
	|
	|UNION ALL
	|
	|SELECT DISTINCT
	|	UsersGroupsSets.Ref,
	|	UsersGroupsSets.SetItemsType,
	|	NOT MIN(SetsWithSingleUser.Ref IS NULL),
	|	MIN(UsersGroupsSets.NotUsedSince <> DATETIME(1, 1, 1)
	|			AND UsersGroupsSets.NotUsedSince < &ExpirationDate)
	|FROM
	|	Catalog.SetsOfAccessGroups AS UsersGroupsSets
	|		LEFT JOIN Catalog.SetsOfAccessGroups AS SetsWithSingleUser
	|		ON (SetsWithSingleUser.ForExternalUsers = &ForExternalUsers)
	|			AND (SetsWithSingleUser.AllowedUserGroupsSet = UsersGroupsSets.Ref
	|				OR SetsWithSingleUser.NewUserGroupsSet = UsersGroupsSets.Ref)
	|WHERE
	|	UsersGroupsSets.ForExternalUsers = &ForExternalUsers
	|	AND UsersGroupsSets.SetItemsType = VALUE(Catalog.UserGroups.EmptyRef)
	|
	|GROUP BY
	|	UsersGroupsSets.Ref,
	|	UsersGroupsSets.SetItemsType
	|
	|HAVING
	|	(UsersGroupsSets.NotUsedSince = DATETIME(1, 1, 1)
	|			AND MIN(SetsWithSingleUser.Ref IS NULL)
	|		OR UsersGroupsSets.NotUsedSince <> DATETIME(1, 1, 1)
	|			AND (NOT MIN(SetsWithSingleUser.Ref IS NULL)
	|				OR UsersGroupsSets.NotUsedSince < &ExpirationDate))";
	
	If ParametersOfUpdate.ForExternalUsers Then
		Query.Text = StrReplace(Query.Text, "Catalog.Users", "Catalog.ExternalUsers");
		Query.Text = StrReplace(Query.Text, "Catalog.UserGroups", "Catalog.ExternalUsersGroups");
	EndIf;
	SetQueryPlanClarification(Query.Text);
	
	DataItems = Query.Execute().Unload();
	
	CountInQuery = DataItems.Count();
	Return DataItems;
	
EndFunction

// For the ObsoleteAccessGroupsSetsInCatalog, ItemsToUpdate functions.
Function ExpirationDate()
	
	Return CurrentSessionDate() - HoursOfNotUsedItemsBecomingObsoleteCount() * 60 * 60;
	
EndFunction

// For the UpdateItemsBatch procedure.
Procedure ProcessObsoleteSetsInCatalog(DataItems, ParametersOfUpdate)
	
	Block = New DataLock;
	LockItem = Block.Add("Catalog.SetsOfAccessGroups");
	
	For Each String In DataItems Do
		LockItem.SetValue("Ref", String.CurrentRef);
		
		BeginTransaction();
		Try
			Block.Lock();
			Object = ServiceItem(Undefined, String.CurrentRef);
			If Object <> Undefined Then
				If String.Used Then
					Object.NotUsedSince = '00010101';
				ElsIf Not String.Delete Then
					Object.NotUsedSince = CurrentSessionDate();
				Else
					Object.SetItemsType = Undefined;
					Object.Hash = 0;
					Object.Groups.Clear();
				EndIf;
				Object.Write();
			EndIf;
			CommitTransaction();
		Except
			RollbackTransaction();
			Raise;
		EndTry;
		
		If Not String.Used And String.Delete Then
			// 
			DeleteRegisterRecordsForSet(String.CurrentRef, "AccessGroupSetsAccessKeys",  "AccessGroupsSet");
			// 
			DeleteRegisterRecordsForSet(String.CurrentRef, "UsersAccessKeys",        "User");
			// 
			DeleteRegisterRecordsForSet(String.CurrentRef, "ExternalUsersAccessKeys", "ExternalUser");
			
			BeginTransaction();
			Try
				Block.Lock();
				Object = ServiceItem(Undefined, String.CurrentRef);
				If Object <> Undefined Then
					Object.Delete();
				EndIf;
				CommitTransaction();
			Except
				RollbackTransaction();
				Raise;
			EndTry;
		EndIf;
		
		If ItemsProcessingAbortRequired(ParametersOfUpdate, 1) Then
			Break;
		EndIf;
	EndDo;
	
EndProcedure

// For the DeleteObsoleteSetsInCatalog procedure.
Procedure DeleteRegisterRecordsForSet(Set, InformationRegisterName, SetFieldName)
	
	Query = New Query;
	Query.SetParameter("Set", Set);
	Query.Text =
	"SELECT TOP 1000
	|	SetsAccessKeys.AccessKey AS AccessKey
	|FROM
	|	InformationRegister.AccessGroupSetsAccessKeys AS SetsAccessKeys
	|WHERE
	|	SetsAccessKeys.AccessGroupsSet = &Set";
	
	Query.Text = StrReplace(Query.Text, "AccessGroupSetsAccessKeys", InformationRegisterName);
	Query.Text = StrReplace(Query.Text, "AccessGroupsSet", SetFieldName);
	
	RecordSet = ServiceRecordSet(InformationRegisters[InformationRegisterName]);
	FullInformationRegisterName = "InformationRegister." + InformationRegisterName;
	
	While True Do
		Upload0 = Query.Execute().Unload();
		If Upload0.Count() = 0 Then
			Break;
		EndIf;
		
		Block = New DataLock;
		For Each String In Upload0 Do
			LockItem = Block.Add(FullInformationRegisterName);
			LockItem.SetValue(SetFieldName, Set);
			LockItem.SetValue("AccessKey", String.AccessKey);
		EndDo;
		
		BeginTransaction();
		Try
			Block.Lock();
			For Each String In Upload0 Do
				FilterElement = RecordSet.Filter[SetFieldName]; // FilterItem
				FilterElement.Set(Set);
				RecordSet.Filter.AccessKey.Set(String.AccessKey);
				RecordSet.Write();
			EndDo;
			CommitTransaction();
		Except
			RollbackTransaction();
			Raise;
		EndTry;
	EndDo;
	
EndProcedure

// For the RunListAccessUpdate procedure.
Procedure UpdateRightsToAllowedAccessKey(HasChanges = False)
	
	UpdateAccessGroupsOfAllowedAccessKey( , HasChanges);
	
EndProcedure

// For the UpdateRightsToAllowedAccessKey procedure.
Procedure UpdateAccessGroupsOfAllowedAccessKey(AccessGroups = Undefined, HasChanges = False) Export
	
	SetPrivilegedMode(True);
	AllowedAccessKey = AccessManagementInternalCached.AllowedAccessKey();
	AllowedBlankSet = AccessManagementInternalCached.AllowedBlankAccessGroupsSet();
	
	Block = New DataLock;
	
	// Access group update in the AccessGroupsAccessKeys register.
	GroupsQuery = New Query;
	GroupsQuery.SetParameter("AccessKey", AllowedAccessKey);
	GroupsQuery.SetParameter("ProfileAdministrator", AccessManagement.ProfileAdministrator());
	GroupsQuery.Text = SelectionQueryTextOfAllowedKeyAccessGroupsDifferences();
	SetFilterCriterionInQuery(GroupsQuery, AccessGroups, "AccessGroups",
		"&AccessGroupFilterCriterion1:AccessGroups.Ref
		|&AccessGroupFilterCriterion2:OldData.AccessGroup"); // @query-part-1
	
	GroupsLockItem = Block.Add("InformationRegister.AccessGroupsAccessKeys");
	GroupsLockItem.SetValue("AccessKey", AllowedAccessKey);
	GroupsRecordSet = ServiceRecordSet(InformationRegisters.AccessGroupsAccessKeys);
	GroupsRecordSet.Filter.AccessKey.Set(AllowedAccessKey);
	
	// Updating access group sets in the AccessGroupSetsAccessKeys register.
	RightsRequestForAccessGroups = New Query;
	RightsRequestForAccessGroups.SetParameter("AccessKey", AllowedAccessKey);
	RightsRequestForAccessGroups.SetParameter("AllowedBlankSet", AllowedBlankSet);
	RightsRequestForAccessGroups.Text = DifferencesSelectionOfDerivedRightsQueryTextForAccessGroups();
	
	LockItem = Block.Add("InformationRegister.AccessGroupSetsAccessKeys");
	LockItem.SetValue("AccessKey", AllowedAccessKey);
	RightsForAccessGroups = ServiceRecordSet(InformationRegisters.AccessGroupSetsAccessKeys);
	RightsForAccessGroups.Filter.AccessKey.Set(AllowedAccessKey);
	
	If Common.FileInfobase() Then
		LockItem = Block.Add("Catalog.AccessGroupProfiles");
		LockItem.Mode = DataLockMode.Shared;
		LockItem = Block.Add("Catalog.AccessGroups");
		LockItem.Mode = DataLockMode.Shared;
		LockItem = Block.Add("Catalog.SetsOfAccessGroups");
		LockItem.Mode = DataLockMode.Shared;
	EndIf;
	
	BeginTransaction();
	Try
		Block.Lock();
		
		GroupsRequestResult = GroupsQuery.Execute();
		UpdateDerivedRightsToAccessKey(GroupsRequestResult,
			GroupsRecordSet, "AccessGroup", AllowedAccessKey, HasChanges);
		
		RightsRequestForAccessGroupsResult = RightsRequestForAccessGroups.Execute();
		UpdateDerivedRightsToAccessKey(RightsRequestForAccessGroupsResult,
			RightsForAccessGroups, "AccessGroupsSet", AllowedAccessKey, HasChanges);
		
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

// For the UpdateAllowedAccessKeyGroups procedure.
Function SelectionQueryTextOfAllowedKeyAccessGroupsDifferences()
	
	QueryText =
	"SELECT
	|	AllRows.AccessGroup AS AccessGroup,
	|	AllRows.RightUpdate AS RightUpdate,
	|	AllRows.AddRight AS AddRight,
	|	SUM(AllRows.LineChangeType) AS LineChangeType
	|FROM
	|	(SELECT
	|		AccessGroups.Ref AS AccessGroup,
	|		TRUE AS RightUpdate,
	|		TRUE AS AddRight,
	|		1 AS LineChangeType
	|	FROM
	|		Catalog.AccessGroups AS AccessGroups
	|			INNER JOIN Catalog.AccessGroupProfiles AS AccessGroupProfiles
	|			ON AccessGroups.Profile = AccessGroupProfiles.Ref
	|				AND (AccessGroups.Profile <> &ProfileAdministrator)
	|				AND (NOT AccessGroups.DeletionMark)
	|				AND (NOT AccessGroupProfiles.DeletionMark)
	|				AND (&AccessGroupFilterCriterion1)
	|				AND (TRUE IN
	|					(SELECT TOP 1
	|						TRUE AS TrueValue
	|					FROM
	|						Catalog.AccessGroups.Users AS AccessGroupsMembers
	|					WHERE
	|						AccessGroupsMembers.Ref = AccessGroups.Ref))
	|				AND (&QueryPlanClarification)
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		OldData.AccessGroup,
	|		OldData.RightUpdate,
	|		OldData.AddRight,
	|		-1
	|	FROM
	|		InformationRegister.AccessGroupsAccessKeys AS OldData
	|	WHERE
	|		OldData.AccessKey = &AccessKey
	|		AND &AccessGroupFilterCriterion2) AS AllRows
	|
	|GROUP BY
	|	AllRows.AccessGroup,
	|	AllRows.RightUpdate,
	|	AllRows.AddRight
	|
	|HAVING
	|	SUM(AllRows.LineChangeType) <> 0
	|
	|ORDER BY
	|	LineChangeType";
	
	SetQueryPlanClarification(QueryText);
	
	Return QueryText;
	
EndFunction

// For the UpdateItemsBatch procedure.
Procedure DeleteObsoleteListDataItems(DataItems, ParametersOfUpdate)
	
	PortionSize = 100; // 
	DataItemsBatch = Undefined;
	ItemCount = DataItems.Count();
	
	If ParametersOfUpdate.IsReferenceType Then
		SetOfOneRecord = ServiceRecordSet(InformationRegisters.AccessKeysForObjects);
		IndexOf = 0;
		While IndexOf < ItemCount Do
			If DataItemsBatch = Undefined Then
				DataItemsBatch = DataItems.Copy(New Array);
				Block = New DataLock;
			EndIf;
			DataElement = DataItems[IndexOf];
			FillPropertyValues(DataItemsBatch.Add(), DataElement);
			
			LockItem = Block.Add("InformationRegister.AccessKeysForObjects");
			LockItem.SetValue("Object", DataElement.CurrentRef);
			
			IndexOf = IndexOf + 1;
			If DataItemsBatch.Count() < PortionSize And IndexOf < ItemCount Then
				Continue;
			EndIf;
			
			ProcessedItemsCount = DataItemsBatch.Count();
			LockSet = False;
			BeginTransaction();
			Try
				Block.Lock();
				LockSet = True;
				For Each String In DataItemsBatch Do
					SetOfOneRecord.Filter.Object.Set(String.CurrentRef);
					If Not ParametersOfUpdate.ForExternalUsers
					   And (ParametersOfUpdate.DoNotWriteAccessKeysForUsersAndExternalUsers
					      Or String.Delete) Then
						SetOfOneRecord.Clear();
						SetOfOneRecord.Write();
					Else
						SetOfOneRecord.Read();
						If SetOfOneRecord.Count() > 0 Then
							If ParametersOfUpdate.ForExternalUsers Then
								SetOfOneRecord[0].ExternalUsersAccessKey = Undefined;
							Else
								SetOfOneRecord[0].UsersAccessKey = Undefined;
							EndIf;
							If Not ValueIsFilled(SetOfOneRecord[0].ExternalUsersAccessKey)
							   And Not ValueIsFilled(SetOfOneRecord[0].UsersAccessKey) Then
								SetOfOneRecord.Clear();
							EndIf;
							SetOfOneRecord.Write();
						EndIf;
					EndIf;
				EndDo;
				CommitTransaction();
			Except
				RollbackTransaction();
				If LockSet Then
					Raise;
				EndIf;
			EndTry;
			ProcessedItemsCount = 0;
			
			If ItemsProcessingAbortRequired(ParametersOfUpdate) Then
				Break;
			EndIf;
		EndDo;
		
		Return;
	EndIf;
	
	If ValueIsFilled(ParametersOfUpdate.SeparateKeysRegisterName)
	   And ParametersOfUpdate.LastUpdatedItem.DataKeyKind <> "ObsoleteCommonRegisterItems" Then
		
		RegisterName = ParametersOfUpdate.SeparateKeysRegisterName;
	Else
		RegisterName = "AccessKeysForRegisters";
	EndIf;
	SetOfOneRecord = ServiceRecordSet(InformationRegisters[RegisterName]);
	
	If RegisterName = "AccessKeysForRegisters" Then
		SetOfOneRecord.Filter.Register.Set(ParametersOfUpdate.ListID);
	EndIf;
	
	DimensionsNames = New Array;
	DimensionsNames.Add("AccessOption");
	For Each Column In DataItems.Columns Do
		If StrStartsWith(Column.Name, "Field") Then
			DimensionsNames.Add(Column.Name);
		EndIf;
	EndDo;
	DimensionsFilter = Undefined;
	
	IndexOf = 0;
	While IndexOf < ItemCount Do
		If DataItemsBatch = Undefined Then
			IsVerificationRequired = False;
			DataItemsBatch = DataItems.Copy(New Array);
			Block = New DataLock;
		EndIf;
		DataElement = DataItems[IndexOf];
		FillPropertyValues(DataItemsBatch.Add(), DataElement);
		If Not ParametersOfUpdate.DoNotWriteAccessKeys And Not DataElement.Delete Then
			IsVerificationRequired = True;
		EndIf;
		
		LockItem = Block.Add("InformationRegister." + RegisterName);
		If RegisterName = "AccessKeysForRegisters" Then
			LockItem.SetValue("Register", ParametersOfUpdate.ListID);
		EndIf;
		For Each DimensionName In DimensionsNames Do
			LockItem.SetValue(DimensionName, DataElement[DimensionName]);
		EndDo;
		
		IndexOf = IndexOf + 1;
		If DataItemsBatch.Count() < PortionSize And IndexOf < ItemCount Then
			Continue;
		EndIf;
		
		If IsVerificationRequired Then
			LockItem = Block.Add(ParametersOfUpdate.List);
			LockItem.Mode = DataLockMode.Shared;
			Query = New Query;
			Query.Text = ParametersOfUpdate.ObsoleteDataItemsCheckQueryText;
			Query.SetParameter("AccessKeysForRegisters", DataItemsBatch);
			SetQueryPlanClarification(Query.Text);
		EndIf;
		
		ProcessedItemsCount = DataItemsBatch.Count();
		LockSet = False;
		BeginTransaction();
		Try
			Block.Lock();
			LockSet = True;
			If IsVerificationRequired Then
				// 
				Upload0 = Query.Execute().Unload();
				If DimensionsFilter = Undefined Then
					DimensionsToCheckNames = New Array;
					For Each Column In Upload0.Columns Do
						DimensionsToCheckNames.Add(Column.Name);
					EndDo;
					DimensionsFilter = New Structure(StrConcat(DimensionsToCheckNames, ","));
				EndIf;
			EndIf;
			For Each String In DataItemsBatch Do
				If IsVerificationRequired And Not String.Delete Then
					FillPropertyValues(DimensionsFilter, String);
					If Upload0.FindRows(DimensionsFilter).Count() = 0 Then
						Continue;
					EndIf;
				EndIf;
				For Each DimensionName In DimensionsNames Do
					FilterElement = SetOfOneRecord.Filter[DimensionName]; // FilterItem
					If String[DimensionName] = Undefined Then
						FilterElement.Value = Undefined;
						FilterElement.Use = True;
					Else
						FilterElement.Set(String[DimensionName]);
					EndIf;
				EndDo;
				SetOfOneRecord.Write();
			EndDo;
			CommitTransaction();
		Except
			RollbackTransaction();
			If LockSet Then
				Raise;
			EndIf;
			ProcessedItemsCount = 0;
		EndTry;
		DataItemsBatch = Undefined;
		
		If ItemsProcessingAbortRequired(ParametersOfUpdate, ProcessedItemsCount) Then
			Break;
		EndIf;
	EndDo;
	
EndProcedure

// For the RunListAccessUpdate procedure.
Procedure DeleteObjectsOfInvalidTypesInAccessKeysToObjectsRegister()
	
	Query = New Query;
	Query.Text =
	"SELECT DISTINCT
	|	VALUETYPE(DataAccessKeys.Object) AS RefType
	|FROM
	|	InformationRegister.AccessKeysForObjects AS DataAccessKeys";
	
	RecordSet = ServiceRecordSet(InformationRegisters.AccessKeysForObjects);
	AllowedTypes = AccessManagementInternalCached.AllowedObjectsRefsTypesDetails();
	Selection = Query.Execute().Select();
	
	Query.Text =
	"SELECT
	|	DataAccessKeys.Object AS Object
	|FROM
	|	InformationRegister.AccessKeysForObjects AS DataAccessKeys
	|WHERE
	|	VALUETYPE(DataAccessKeys.Object) = &Type";
	
	While Selection.Next() Do
		If Selection.RefType = Type("Undefined") Then
			RecordSet.Filter.Object.Set(Undefined);
			RecordSet.Write();
			Continue;
		ElsIf AllowedTypes.ContainsType(Selection.RefType) Then
			Continue;
		EndIf;
		Query.SetParameter("Type", Selection.RefType);
		// 
		Objects = Query.Execute().Unload().UnloadColumn("Object");
		For Each Object In Objects Do
			RecordSet.Filter.Object.Set(Object);
			RecordSet.Write();
		EndDo;
	EndDo;
	
	Query = New Query;
	Query.Text =
	"SELECT TOP 1
	|	TRUE AS TrueValue
	|FROM
	|	InformationRegister.AccessKeysForRegisters AS AccessKeysForRegisters
	|WHERE
	|	AccessKeysForRegisters.Register = UNDEFINED";
	
	If Query.Execute().IsEmpty() Then
		Return;
	EndIf;
	
	RecordSet = ServiceRecordSet(InformationRegisters.AccessKeysForRegisters);
	RecordSet.Filter.Register.Set(Undefined);
	RecordSet.Write();
	
EndProcedure

// For the UpdateItemsBatch procedure.
Procedure UpdateListDataItemsWithObsoleteKeys(DataItems, ParametersOfUpdate)
	
	PortionSize = 100; // 
	
	IsExistingCombinationsProcessing = Not ParametersOfUpdate.IsReferenceType
		And ParametersOfUpdate.LastUpdatedItem.DataKeyKind = "ItemsWithObsoleteKeys";
	
	IndexOf = 0;
	While IndexOf < DataItems.Count() Do
		
		DataItemsBatch = DataItems.Copy(New Array);
		If Not ParametersOfUpdate.IsReferenceType Then
			DataItemsBatch.Columns.Add("CurrentRef", New TypeDescription("Number"));
			DeletedDataItemsBatch = New Array;
		EndIf;
		
		While IndexOf < DataItems.Count()
		   And DataItemsBatch.Count() < PortionSize
		   And (ParametersOfUpdate.IsReferenceType
		      Or DeletedDataItemsBatch.Count() < PortionSize) Do
			
			DataElement = DataItems[IndexOf];
			
			If IsExistingCombinationsProcessing
			   And IncorrectCombinationOfBasicFieldsValues(DataElement, ParametersOfUpdate) Then
				
				If DataItemsBatch.Count() > 0 Then
					Break;
				EndIf;
				DeletedDataItemsBatch.Add(DataElement);
				
			ElsIf IsExistingCombinationsProcessing
			        And DeletedDataItemsBatch.Count() > 0 Then
				Break;
			Else
				NewRow = DataItemsBatch.Add();
				FillPropertyValues(NewRow, DataElement);
				If Not ParametersOfUpdate.IsReferenceType Then
					NewRow.CurrentRef = DataItemsBatch.IndexOf(NewRow) + 1;
				EndIf;
			EndIf;
			IndexOf = IndexOf + 1;
		EndDo;
		
		If IsExistingCombinationsProcessing
		   And DeletedDataItemsBatch.Count() > 0 Then
			
			DeleteIncorrectBasicFieldsValuesCombinations(DeletedDataItemsBatch, ParametersOfUpdate);
			If ItemsProcessingAbortRequired(ParametersOfUpdate, DeletedDataItemsBatch.Count()) Then
				Break;
			EndIf;
		EndIf;
		
		If DataItemsBatch.Count() > 0 Then
			// 
			UpdateAccessKeysOfListDataItemsBatch(DataItemsBatch, ParametersOfUpdate);
		EndIf;
		
		If ItemsProcessingAbortRequired(ParametersOfUpdate, 0) Then
			Break;
		EndIf;
	EndDo;
	
EndProcedure

// For the UpdateListDataItemsWithObsoleteKeys function.
Function IncorrectCombinationOfBasicFieldsValues(DataElement, ParametersOfUpdate)
	
	Number = 1;
	For Each FieldTypesStorage In ParametersOfUpdate.BasicFields.UsedItemsTypes Do
		FieldTypes = FieldTypesStorage.Get();
		
		If Not FieldTypes.ContainsType(TypeOf(DataElement["Field" + Number]))
		   And DataElement["Field" + Number] <> Undefined Then
			
			Return True;
		EndIf;
		
		Number = Number + 1;
	EndDo;
	
	Return False;
	
EndFunction

// For the AccessAllowed function.
Function InMemoryObjectsModel(DataDetails, RestrictionParameters)
	
	If TypeOf(DataDetails) = Type("Array") Then
		Objects = DataDetails;
	Else
		Objects = CommonClientServer.ValueInArray(DataDetails);
	EndIf;
	Object = Objects[0]; // CatalogObject
	
	DataItems = New ValueTable;
	DataItems.Columns.Add("CurrentRef", New TypeDescription(
		CommonClientServer.ValueInArray(TypeOf(Object.Ref))));
	
	Model = New Structure;
	Model.Insert("DataItems", DataItems);
	Model.Insert("Tables", New Map);
	Model.Insert("AccessKeysForObjects",
		InformationRegisters.AccessKeysForObjects.CreateRecordSet().Unload());
	
	ObjectTablesFields = RestrictionParameters.ObjectTablesFields;
	
	For Each Object In Objects Do
		Object = Object; // CatalogObject
		CurrentRef = UsersInternal.ObjectRef2(DataDetails);
		DataItems.Add().CurrentRef = CurrentRef;
		For Each TableDetails In ObjectTablesFields Do
			TableDetails = TableDetails; // See NewObjectTableFields
			Table = Model.Tables.Get(TableDetails.FullTableName); // ValueTable
			FieldList = TableDetails.FieldList;
			If Table = Undefined Then
				Table = TableDetails.TableWithFields.Get();
				Model.Tables.Insert(TableDetails.FullTableName, Table);
			EndIf;
			If ValueIsFilled(TableDetails.TabularSection) Then
				Upload0 = Object[TableDetails.TabularSection].Unload(, FieldList); // ValueTable
				Upload0.GroupBy(FieldList);
				For Each String In Upload0 Do
					NewRow = Table.Add();
					FillPropertyValues(NewRow, String, FieldList);
					NewRow.Ref = CurrentRef;
				EndDo;
			Else
				NewRow = Table.Add();
				FillPropertyValues(NewRow, Object, FieldList);
				NewRow.Ref = CurrentRef;
			EndIf;
		EndDo;
	EndDo;
	
	Return Model;
	
EndFunction

// For the UpdateListDataItemsWithObsoleteKeys and UpdateAccessKeysOfDataItemsOnWrite function.
Procedure UpdateAccessKeysOfListDataItemsBatch(DataItemsBatch, ParametersOfUpdate)
	
	IsReferenceType     = ParametersOfUpdate.IsReferenceType;
	ListID = ParametersOfUpdate.ListID;
	
	Context = New Structure;
	Context.Insert("DataItemsBatch", DataItemsBatch);
	
	DataItemsValuesQuery = New Query;
	If IsReferenceType Then
		Context.Insert("ObjectsRefs", DataItemsBatch.UnloadColumn("CurrentRef"));
	EndIf;
	If ValueIsFilled(ParametersOfUpdate.FieldsComposition) Then
		If IsReferenceType Then
			DataItemsValuesQuery.SetParameter("ObjectsRefs", Context.ObjectsRefs);
			TableIndex = 0;
		EndIf;
		If ParametersOfUpdate.Property("InMemoryObjectsModel") Then
			DataItemsValuesQuery.Text = ParametersOfUpdate.TextOfQueryForInMemoryObjectsValuesForAccessKeys;
			For Each Table In ParametersOfUpdate.InMemoryObjectsModel.Tables Do
				DataItemsValuesQuery.SetParameter(Table.Key, Table.Value);
			EndDo;
			TableIndex = ParametersOfUpdate.InMemoryObjectsModel.Tables.Count();
		Else
			DataItemsValuesQuery.Text = ParametersOfUpdate.DataItemValueForAccessKeysQueryText;
			If Not IsReferenceType Then
				DataItemsValuesQuery.SetParameter("RegisterID", ListID);
				DataItemsValuesQuery.SetParameter("BasicFieldsValues",  DataItemsBatch);
				TableIndex = 1;
			EndIf;
		EndIf;
		SetQueryPlanClarification(DataItemsValuesQuery.Text);
		ItemsValuesQueryResults = DataItemsValuesQuery.ExecuteBatch();
	Else
		ItemsValuesQueryResults = New Array;
	EndIf;
	
	StringAccessKeysData = New Map;
	KeyTables = ParametersOfUpdate.KeyTables;
	
	TablesRowsValues = New Map;
	ObjectsRowsValuesKeys = ObjectsRowsValuesKeys(ItemsValuesQueryResults,
		TableIndex, KeyTables, TablesRowsValues);
	
	RequiredAccessKeys         = New Array;
	RequiredAccessKeysHash    = New Array;
	ObjectsAccessKeysDetails = New Array;
	For Each DataElement In DataItemsBatch Do
		ValuesKeysDetails = ObjectsRowsValuesKeys.Get(DataElement.CurrentRef);
		StringForHash = StringForAccessKeyHash(ValuesKeysDetails, KeyTables);
		Properties = StringAccessKeysData.Get(StringForHash);
		If Properties = Undefined Then
			Properties = New Structure("TablesValues, StringForHash, Hash, AccessKey, TablesColumnsValues");
			StringAccessKeysData.Insert(StringForHash, Properties);
			TablesValues = New Array;
			For Each TableName In KeyTables Do
				ValuesKey = ValuesKeysDetails.ValuesKeys[KeyTables.Find(TableName)];
				RowsValues = TablesRowsValues.Get(TableName).Get(ValuesKey);
				If RowsValues = Undefined Then
					RowsValues = New Array;
				EndIf;
				TablesValues.Add(New Structure("TableName, Table", TableName, RowsValues));
			EndDo;
			Properties.TablesValues = TablesValues;
			Properties.StringForHash = StringForHash;
			Properties.TablesColumnsValues = ValuesKeysDetails.TablesColumnsValues;
			Hashing = New DataHashing(HashFunction.CRC32);
			Hashing.Append(StringForHash);
			Properties.Hash = Hashing.HashSum;
			RequiredAccessKeys.Add(Properties);
			RequiredAccessKeysHash.Add(Properties.Hash);
		EndIf;
		ObjectsAccessKeysDetails.Add(
			New Structure("CurrentRef, KeyProperties1", DataElement.CurrentRef, Properties));
	EndDo;
	Context.Insert("ObjectsAccessKeysDetails", ObjectsAccessKeysDetails);
	
	// Receiving data of existing access keys by hash of required access keys.
	KeysValuesQuery = New Query;
	KeysValuesQuery.Text = ParametersOfUpdate.ValueFromAccessKeysInUseForComparisonQueryText;
	KeysValuesQuery.SetParameter("Hashes",   RequiredAccessKeysHash);
	KeysValuesQuery.SetParameter("List", ListID);
	SetQueryPlanClarification(KeysValuesQuery.Text);
	KeysValuesQueryResults = KeysValuesQuery.ExecuteBatch();
	
	KeysRowsValuesKeys = ObjectsRowsValuesKeys(KeysValuesQueryResults,
		?(Not ValueIsFilled(ParametersOfUpdate.FieldsComposition)
			Or StrStartsWith(KeyTables[0], "Header"), 0, 1),
		KeyTables);
	Selection = KeysValuesQueryResults[0].Select();
	
	While Selection.Next() Do
		ValuesKeysDetails = KeysRowsValuesKeys.Get(Selection.CurrentRef);
		StringForHash = StringForAccessKeyHash(ValuesKeysDetails, KeyTables);
		Properties = StringAccessKeysData.Get(StringForHash);
		If Properties <> Undefined And Properties.AccessKey = Undefined Then
			Properties.AccessKey = Selection.CurrentRef;
		EndIf;
	EndDo;
	
	// Creating missing access keys.
	NewKeysDetails = New Array;
	For Each KeyDetails In RequiredAccessKeys Do
		If KeyDetails.AccessKey <> Undefined Then
			Continue;
		EndIf;
		NewKeysDetails.Add(KeyDetails);
	EndDo;
	If NewKeysDetails.Count() > 0 Then
		UpdateAccessKeysRights(NewKeysDetails, ParametersOfUpdate, True, Context);
		For Each KeyDetails In NewKeysDetails Do
			AccessKeyObject = KeyDetails.AccessKeyObject; // CatalogObject.AccessKeys
			If ValueIsFilled(AccessKeyObject.Ref) Then
				KeyDetails.AccessKey = AccessKeyObject.Ref;
			EndIf;
		EndDo;
	EndIf;
	
	// Updating access keys of data items.
	If IsReferenceType Then
		If ParametersOfUpdate.Property("InMemoryObjectsModel") Then
			KeyFieldName1 = ?(ParametersOfUpdate.ForExternalUsers,
				"ExternalUsersAccessKey", "UsersAccessKey");
			AccessKeysForObjects = ParametersOfUpdate.InMemoryObjectsModel.AccessKeysForObjects; // InformationRegisterRecordSet
			For Each ObjectAccessKeyDetails In ObjectsAccessKeysDetails Do
				NewRow = AccessKeysForObjects.Add();
				NewRow.Object = ObjectAccessKeyDetails.CurrentRef;
				NewRow[KeyFieldName1] = ObjectAccessKeyDetails.KeyProperties1.AccessKey;
			EndDo;
		Else
			WriteObjectsAccessKeys(ParametersOfUpdate, Context);
		EndIf;
	Else
		WriteRegistersAccessKeys(ParametersOfUpdate, Context);
	EndIf;
	
	// Forced manual update of rights.
	If ParametersOfUpdate.Property("UpdateRightsToKeys")
	   And ParametersOfUpdate.UpdateRightsToKeys Then
		
		ExistingAccessKeys = New Array;
		For Each KeyDetails In RequiredAccessKeys Do
			If NewKeysDetails.Find(KeyDetails) <> Undefined Then
				Continue;
			EndIf;
			ExistingAccessKeys.Add(KeyDetails.AccessKey);
		EndDo;
		If ExistingAccessKeys.Count() > 0 Then
			UpdateAccessKeysRights(ExistingAccessKeys, ParametersOfUpdate);
		EndIf;
	EndIf;
	
EndProcedure

// For the UpdateAccessKeysOfListDataItemsBatch procedure.
Procedure UpdateAccessKeysRights(KeysDetails, ParametersOfUpdate, IsNewKeys = False, Context = Undefined)
	
	If ParametersOfUpdate.Property("ProcessedItemsCount") Then
		ProcessedItemsCount = ParametersOfUpdate.ProcessedItemsCount;
		ParametersOfUpdate.ProcessedItemsCount = 0;
	EndIf;
	
	If IsNewKeys Then
		AccessKeys = New ValueTable;
		AccessKeys.Columns.Add("Ref", New TypeDescription("CatalogRef.AccessKeys"));
		
		KeysValuesQuery = New Query;
		KeysValuesQuery.Text = ParametersOfUpdate.ValueFromAllAccessKeysForComparisonQueryText;
		KeysValuesQuery.SetParameter("List", ParametersOfUpdate.ListID);
		SetQueryPlanClarification(KeysValuesQuery.Text);
		
		KeysExistenceQuery = New Query;
		KeysExistenceQuery.Text = ParametersOfUpdate.KeysForComparisonExistenceQueryText;
		KeysExistenceQuery.SetParameter("List", ParametersOfUpdate.ListID);
		SetQueryPlanClarification(KeysExistenceQuery.Text);
		
		NewKeysDetails = New Structure;
		NewKeysDetails.Insert("KeysDetails",            KeysDetails);
		NewKeysDetails.Insert("AccessKeys",              AccessKeys);
		NewKeysDetails.Insert("TablesValues",            New Structure);
		NewKeysDetails.Insert("KeysDetailsByRef",    New Map);
		NewKeysDetails.Insert("KeysValuesQuery",      KeysValuesQuery);
		NewKeysDetails.Insert("KeysExistenceQuery", KeysExistenceQuery);
		
		AllowedValuesTypes = AccessManagementInternalCached.AllowedAccessKeysValuesTypes();
		TablesValues = NewKeysDetails.TablesValues;
		
		For Each KeyTable In ParametersOfUpdate.KeyTables Do
			ValueTable = KeyTableValues();
			ValueTable.Columns.Add("Ref", New TypeDescription("CatalogRef.AccessKeys"));
			TableFields = ParametersOfUpdate.KeyTablesAttributes.Get(KeyTable);
			If StrStartsWith(KeyTable, "Header") And KeyTable <> "Header0" Then
				ValueTable.Columns.Add("LineNumber", New TypeDescription("Number"));
			EndIf;
			For Each Field In TableFields Do
				ValueTable.Columns.Add(Field, AllowedValuesTypes);
			EndDo;
			TablesValues.Insert(KeyTable, ValueTable);
		EndDo;
		
		For Each KeyDetails In KeysDetails Do
			CheckAccessKeyValueType(KeyDetails, AllowedValuesTypes, ParametersOfUpdate);
			PrepareNewAccessKey(KeyDetails, NewKeysDetails, ParametersOfUpdate);
		EndDo;
		AccessKeysDetails = NewKeysDetails;
	Else
		AccessKeysDetails = New ValueTable;
		AccessKeysDetails.Columns.Add("Ref", New TypeDescription("CatalogRef.AccessKeys"));
		For Each AccessKeyRef In KeysDetails Do
			AccessKeysDetails.Add().Ref = AccessKeyRef;
		EndDo;
	EndIf;
	
	UpdateRightsOfListAccessKeysBatch(AccessKeysDetails, ParametersOfUpdate, IsNewKeys);
	
	If ParametersOfUpdate.Property("ProcessedItemsCount") Then
		ParametersOfUpdate.ProcessedItemsCount = ProcessedItemsCount;
	EndIf;
	
EndProcedure

// Returns:
//  ValueTable:
//    * Ref      - CatalogRef.AccessKeys
//    * LineNumber - Number - Table row number.
//
Function KeyTableValues()
	
	Return New ValueTable;
	
EndFunction

// For the UpdateAccessKeysOfListDataItemsBatch procedure.
Function StringForAccessKeyHash(ValuesKeysDetails, KeyTables)
	
	If ValuesKeysDetails = Undefined Then
		ValuesKeysDetails = New Structure(
			"ValuesKeys, TablesNames, TablesColumnsValues",
			New Array, New Array, New Array);
	EndIf;
	
	ValuesKeys = ValuesKeysDetails.ValuesKeys;
	TablesNames   = ValuesKeysDetails.TablesNames;
	
	If TablesNames.Count() <> KeyTables.Count() Then
		// The access key uses tabular sections and some blank ones.
		For IndexOf = 0 To KeyTables.Count() - 1 Do
			
			If IndexOf >= TablesNames.Count()
			 Or TablesNames[IndexOf] <> KeyTables[IndexOf] Then
				
				TablesNames.Insert(IndexOf, KeyTables[IndexOf]);
				ValuesKeys.Insert(IndexOf, "6ab8db6a-4878-483a-b9d5-ef905ff1537e");
			EndIf;
		EndDo;
	EndIf;
	
	Return StrConcat(ValuesKeys);
	
EndFunction

// For the UpdateAccessKeysOfDataItemsBatch procedure.
Procedure WriteObjectsAccessKeys(ParametersOfUpdate, Context)
	
	WriteOnlyChangedOnes = WriteOnlyChangedDataItemsAccessKeys();
	
	If ParametersOfUpdate.WriteAccessKeysForUsersAndExternalUsers
	 Or WriteOnlyChangedOnes Then
		
		CurrentKeysQuery = New Query;
		CurrentKeysQuery.Text =
		"SELECT
		|	AccessKeysForObjects.Object AS Object,
		|	AccessKeysForObjects.UsersAccessKey AS UsersAccessKey,
		|	AccessKeysForObjects.ExternalUsersAccessKey AS ExternalUsersAccessKey
		|FROM
		|	InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
		|WHERE
		|	AccessKeysForObjects.Object IN (&ObjectsRefs)";
		CurrentKeysQuery.SetParameter("ObjectsRefs", Context.ObjectsRefs);
	EndIf;
	
	If ParametersOfUpdate.ForExternalUsers Then
		KeyToSaveAttributeName = "UsersAccessKey";
		KeyToUpdateAttributeName = "ExternalUsersAccessKey";
	Else
		KeyToSaveAttributeName = "ExternalUsersAccessKey";
		KeyToUpdateAttributeName = "UsersAccessKey";
	EndIf;
	
	SetOfOneRecord = ServiceRecordSet(InformationRegisters.AccessKeysForObjects);
	Record = SetOfOneRecord.Add();
	ObjectType = Metadata.InformationRegisters.AccessKeysForObjects.Dimensions.Object.Type;
	If Not ObjectType.ContainsType(TypeOf(Context.ObjectsAccessKeysDetails[0].CurrentRef)) Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Cannot update object access key ""%1,"" as its type ""%2""
			           |is not specified in the ""%3"" type collection.';"),
			String(Context.ObjectsAccessKeysDetails[0].CurrentRef),
			String(TypeOf(Context.ObjectsAccessKeysDetails[0].CurrentRef)),
			"AccessKeysValuesOwner");
		Raise ErrorText;
	EndIf;
	
	If WriteOnlyChangedOnes Then
		BeforeCurrentAccessKeysQuery(ParametersOfUpdate);
		CurrentKeysBeforeLock = CurrentKeysQuery.Execute().Unload();
		AfterCurrentAccessKeysQuery(ParametersOfUpdate);
	EndIf;
	
	ProcessedItemsCount = 0;
	ObjectsAccessKeysDetails = New Array;
	
	Block = New DataLock;
	For Each ObjectAccessKeyDetails In Context.ObjectsAccessKeysDetails Do
		AccessKey = ObjectAccessKeyDetails.KeyProperties1.AccessKey;
		If AccessKey = Undefined Then
			Break;
		EndIf;
		If WriteOnlyChangedOnes Then
			String = CurrentKeysBeforeLock.Find(ObjectAccessKeyDetails.CurrentRef, "Object");
			If String <> Undefined And String[KeyToUpdateAttributeName] = AccessKey Then
				ProcessedItemsCount = ProcessedItemsCount + 1;
				Continue;
			EndIf;
		EndIf;
		ObjectsAccessKeysDetails.Add(ObjectAccessKeyDetails);
		LockItem = Block.Add("InformationRegister.AccessKeysForObjects");
		LockItem.SetValue("Object", ObjectAccessKeyDetails.CurrentRef);
	EndDo;
	
	If ObjectsAccessKeysDetails.Count() = 0 Then
		ItemsProcessingAbortRequired(ParametersOfUpdate, ProcessedItemsCount);
		Return;
	EndIf;
	
	ListsToUpdate = New Structure("ListsNames, ForExternalUsers",
		ParametersOfUpdate.DependentListsByAccessKeys,
		ParametersOfUpdate.ForExternalUsers);
	
	If Common.FileInfobase() Then
		ScheduleUpdateOfObsoleteAccessKeys(ListsToUpdate,
			ParametersOfUpdate.TransactionID, "FillAccessRestrictionParametersCache");
	EndIf;
	
	BeginTransaction();
	Try
		BeforeDataLock(ParametersOfUpdate);
		Block.Lock();
		If Common.FileInfobase() Then
			LockRegistersSchedulingUpdateAccessKeysInFileIB();
		EndIf;
		AfterDataLock(ParametersOfUpdate);
		
		If ParametersOfUpdate.WriteAccessKeysForUsersAndExternalUsers Then
			BeforeCurrentAccessKeysQuery(ParametersOfUpdate);
			CurrentKeys = CurrentKeysQuery.Execute().Unload();
			AfterCurrentAccessKeysQuery(ParametersOfUpdate);
		EndIf;
		
		BeforeWriteRows(ParametersOfUpdate);
		ObjectsRefs = New Array;
		For Each ObjectAccessKeyDetails In ObjectsAccessKeysDetails Do
			ObjectsRefs.Add(ObjectAccessKeyDetails.CurrentRef);
			SetOfOneRecord.Filter.Object.Set(ObjectAccessKeyDetails.CurrentRef);
			Record.Object = ObjectAccessKeyDetails.CurrentRef;
			Record[KeyToUpdateAttributeName] = ObjectAccessKeyDetails.KeyProperties1.AccessKey;
			
			If ParametersOfUpdate.WriteAccessKeysForUsersAndExternalUsers Then
				String = CurrentKeys.Find(ObjectAccessKeyDetails.CurrentRef, "Object");
				If String <> Undefined Then
					Record[KeyToSaveAttributeName] = String[KeyToSaveAttributeName];
				EndIf;
			EndIf;
			SetOfOneRecord.Write();
		EndDo;
		AfterWriteRows(ParametersOfUpdate, ObjectsAccessKeysDetails.Count());
		
		BeforePlanUpdate(ParametersOfUpdate);
		ScheduleUpdateOfObsoleteAccessKeys(ListsToUpdate,
			ParametersOfUpdate.TransactionID,
			"WriteObjectsAccessKeys",
			?(ObjectsRefs.Count() > 25, Undefined,
				New Structure("ByAccessKeys", ObjectsRefs)),
			ParametersOfUpdate.Property("IsBackgroundAccessUpdate"));
		AfterPlanUpdate(ParametersOfUpdate);
		
		// 
		// 
		// 
		BeforeCommitTransaction(ParametersOfUpdate);
		CommitTransaction();
		AfterCommitTransaction(ParametersOfUpdate);
		// ACC:330-on
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
	ProcessedItemsCount = ProcessedItemsCount + ObjectsAccessKeysDetails.Count();
	If ItemsProcessingAbortRequired(ParametersOfUpdate, ProcessedItemsCount) Then
		Return;
	EndIf;
	
EndProcedure

// For the UpdateAccessKeysOfDataItemsBatch procedure.
Procedure WriteRegistersAccessKeys(ParametersOfUpdate, Context)
	
	If Not ValueIsFilled(ParametersOfUpdate.SeparateKeysRegisterName) Then
		KeysRegisterName = "AccessKeysForRegisters";
	Else
		KeysRegisterName = ParametersOfUpdate.SeparateKeysRegisterName;
	EndIf;
	SetOfOneRecord = ServiceRecordSet(InformationRegisters[KeysRegisterName]);
	Record = SetOfOneRecord.Add();
	
	DataItemsBatch = Context.DataItemsBatch;
	BlankBasicFieldsValues = AccessManagementInternalCached.BlankBasicFieldsValues(
		ParametersOfUpdate.BasicFields.MaxCount);
	
	WriteOnlyChangedOnes = WriteOnlyChangedDataItemsAccessKeys();
	If WriteOnlyChangedOnes Then
		Query = New Query;
		Query.SetParameter("RegisterID", ParametersOfUpdate.ListID);
		QueryText = ParametersOfUpdate.CurrentRegisterAccessKeysQueryText;
		PackageTexts = New Array;
		LineNumber = 1;
		For Each ObjectAccessKeyDetails In Context.ObjectsAccessKeysDetails Do
			CurrentNumber = "_" + Format(LineNumber, "NG=");
			PackageTexts.Add(StrReplace(QueryText, "_%1", CurrentNumber));
			For FieldNumber = 1 To ParametersOfUpdate.BasicFields.UsedItems.Count() Do
				FieldName = "Field" + FieldNumber;
				DataElement = DataItemsBatch.Find(ObjectAccessKeyDetails.CurrentRef, "CurrentRef");
				Query.SetParameter(FieldName + CurrentNumber, DataElement[FieldName]);
			EndDo;
			LineNumber = LineNumber + 1;
		EndDo;
		Query.Text = StrConcat(PackageTexts, Common.QueryBatchSeparator());
		BeforeCurrentAccessKeysQuery(ParametersOfUpdate);
		If PackageTexts.Count() > 1 Then
			QueryResults = Query.ExecuteBatch();
		Else
			QueryResults = New Array;
			QueryResults.Add(Query.Execute());
		EndIf;
		AfterCurrentAccessKeysQuery(ParametersOfUpdate);
	EndIf;
	
	ProcessedItemsCount = 0;
	ObjectsAccessKeysDetails = New Array;
	
	ResultIndex = -1;
	Block = New DataLock;
	For Each ObjectAccessKeyDetails In Context.ObjectsAccessKeysDetails Do
		ResultIndex = ResultIndex + 1;
		AccessKey = ObjectAccessKeyDetails.KeyProperties1.AccessKey;
		If AccessKey = Undefined Then
			Break;
		EndIf;
		If WriteOnlyChangedOnes Then
			QueryResult = QueryResults[ResultIndex];
			If Not QueryResult.IsEmpty() Then
				Upload0 = QueryResult.Unload();
				If Upload0.Count() = 1 And Upload0[0].AccessKey = AccessKey Then
					ProcessedItemsCount = ProcessedItemsCount + 1;
					Continue;
				EndIf;
			EndIf;
		EndIf;
		ObjectsAccessKeysDetails.Add(ObjectAccessKeyDetails);
		LockItem = Block.Add("InformationRegister." + KeysRegisterName);
		If Not ValueIsFilled(ParametersOfUpdate.SeparateKeysRegisterName) Then
			LockItem.SetValue("Register", ParametersOfUpdate.ListID);
		EndIf;
		LockItem.SetValue("AccessOption", ParametersOfUpdate.AccessOption);
		DataElement = DataItemsBatch.Find(ObjectAccessKeyDetails.CurrentRef, "CurrentRef");
		For FieldNumber = 1 To ParametersOfUpdate.BasicFields.UsedItems.Count() Do
			FieldName = "Field" + FieldNumber;
			LockItem.SetValue(FieldName, DataElement[FieldName]);
		EndDo;
	EndDo;
	
	If ObjectsAccessKeysDetails.Count() = 0 Then
		ItemsProcessingAbortRequired(ParametersOfUpdate, ProcessedItemsCount);
		Return;
	EndIf;
	
	BeginTransaction();
	Try
		BeforeDataLock(ParametersOfUpdate);
		Block.Lock();
		AfterDataLock(ParametersOfUpdate);
		
		BeforeWriteRows(ParametersOfUpdate);
		For Each ObjectAccessKeyDetails In ObjectsAccessKeysDetails Do
			If Not ValueIsFilled(ParametersOfUpdate.SeparateKeysRegisterName) Then
				SetOfOneRecord.Filter.Register.Set(ParametersOfUpdate.ListID);
				Record.Register = ParametersOfUpdate.ListID;
			EndIf;
			SetOfOneRecord.Filter.AccessOption.Set(ParametersOfUpdate.AccessOption);
			Record.AccessOption = ParametersOfUpdate.AccessOption;
			
			DataElement = DataItemsBatch.Find(ObjectAccessKeyDetails.CurrentRef, "CurrentRef");
			FillPropertyValues(Record, BlankBasicFieldsValues);
			For FieldNumber = 1 To ParametersOfUpdate.BasicFields.UsedItems.Count() Do
				FieldName = "Field" + FieldNumber;
				FilterElement = SetOfOneRecord.Filter[FieldName]; // FilterItem
				If DataElement[FieldName] = Undefined Then
					FilterElement.Value = Undefined;
					FilterElement.Use = True;
				Else
					FilterElement.Set(DataElement[FieldName]);
				EndIf;
				Record[FieldName] = DataElement[FieldName];
			EndDo;
			
			Record.AccessKey = ObjectAccessKeyDetails.KeyProperties1.AccessKey;
			SetOfOneRecord.Write();
		EndDo;
		AfterWriteRows(ParametersOfUpdate, ObjectsAccessKeysDetails.Count());
		
		// 
		// 
		// 
		BeforeCommitTransaction(ParametersOfUpdate);
		CommitTransaction();
		AfterCommitTransaction(ParametersOfUpdate);
		// ACC:330-on
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
	ProcessedItemsCount = ProcessedItemsCount + ObjectsAccessKeysDetails.Count();
	If ItemsProcessingAbortRequired(ParametersOfUpdate, ProcessedItemsCount) Then
		Return;
	EndIf;
	
EndProcedure

// For the UpdateListDataItemsWithObsoleteKeys function.
Procedure DeleteIncorrectBasicFieldsValuesCombinations(DataItemsBatch, ParametersOfUpdate)
	
	If Not ValueIsFilled(ParametersOfUpdate.SeparateKeysRegisterName) Then
		KeysRegisterName = "AccessKeysForRegisters";
	Else
		KeysRegisterName = ParametersOfUpdate.SeparateKeysRegisterName;
	EndIf;
	SetOfOneRecord = ServiceRecordSet(InformationRegisters[KeysRegisterName]);
	FieldsToUseCount = ParametersOfUpdate.BasicFields.UsedItems.Count();
	
	Block = New DataLock;
	For Each DataElement In DataItemsBatch Do
		LockItem = Block.Add("InformationRegister." + KeysRegisterName);
		If Not ValueIsFilled(ParametersOfUpdate.SeparateKeysRegisterName) Then
			LockItem.SetValue("Register", ParametersOfUpdate.ListID);
		EndIf;
		LockItem.SetValue("AccessOption", ParametersOfUpdate.AccessOption);
		For FieldNumber = 1 To FieldsToUseCount Do
			FieldName = "Field" + FieldNumber;
			LockItem.SetValue(FieldName, DataElement[FieldName]);
		EndDo;
	EndDo;
	
	BeginTransaction();
	Try
		Block.Lock();
		For Each DataElement In DataItemsBatch Do
			If Not ValueIsFilled(ParametersOfUpdate.SeparateKeysRegisterName) Then
				SetOfOneRecord.Filter.Register.Set(ParametersOfUpdate.ListID);
			EndIf;
			SetOfOneRecord.Filter.AccessOption.Set(ParametersOfUpdate.AccessOption);
			For FieldNumber = 1 To FieldsToUseCount Do
				FieldName = "Field" + FieldNumber;
				FilterElement = SetOfOneRecord.Filter[FieldName]; // FilterItem
				If DataElement[FieldName] = Undefined Then
					FilterElement.Value = Undefined;
					FilterElement.Use = True;
				Else
					FilterElement.Set(DataElement[FieldName]);
				EndIf;
			EndDo;
			SetOfOneRecord.Write();
		EndDo;
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

// For the UpdateAccessKeysOfDataItemsBatch procedure.
Function ObjectsRowsValuesKeys(QueryResults, IndexOf, KeyTables, TablesRowsValues = Undefined)
	
	ObjectsRowsValuesKeys = New Map;
	
	If TablesRowsValues = Undefined Then
		TablesRowsValues = New Map;
	EndIf;
	
	For Each AccessKeyTableName In KeyTables Do
		TableRowsValues = TablesRowsValues.Get(AccessKeyTableName);
		If TableRowsValues = Undefined Then
			TableRowsValues = New Map;
			TablesRowsValues.Insert(AccessKeyTableName, TableRowsValues);
		EndIf;
		Tree = QueryResults[IndexOf].Unload(QueryResultIteration.ByGroups);
		IndexOf = IndexOf + 1;
		For Each String In Tree.Rows Do
			TableColumnsValues = New Array;
			For Each Column In Tree.Columns Do
				If StrStartsWith(Column.Name, "Value") Then
					TableColumnsValues.Add(String.Rows.UnloadColumn(Column.Name));
				EndIf;
			EndDo;
			RowsValuesKey = DataStringForHashing(TableColumnsValues);
			If TableRowsValues.Get(RowsValuesKey) = Undefined Then
				TableRowsValues.Insert(RowsValuesKey, String.Rows);
			EndIf;
			ValuesKeysDetails = ObjectsRowsValuesKeys.Get(String.CurrentRef);
			If ValuesKeysDetails = Undefined Then
				ValuesKeysDetails = New Structure(
					"ValuesKeys, TablesNames, TablesColumnsValues",
					New Array, New Array, New Array);
				ObjectsRowsValuesKeys.Insert(String.CurrentRef, ValuesKeysDetails);
			EndIf;
			ValuesKeysDetails.TablesNames.Add(AccessKeyTableName);
			ValuesKeysDetails.ValuesKeys.Add(RowsValuesKey);
			ValuesKeysDetails.TablesColumnsValues.Add(TableColumnsValues);
		EndDo;
	EndDo;
	
	Return ObjectsRowsValuesKeys;
	
EndFunction

// For the ObjectsRowsValuesKeys function and other.
Function DataStringForHashing(Data)
	
	// 
	// 
	// 
	// 
	// 
	//
	// 
	// 
	
	Return ValueToStringInternal(Data);
	
EndFunction

// For the UpdateAccessKeysOfDataItemsBatch procedure.
Procedure CheckAccessKeyValueType(KeyDetails, AllowedValuesTypes, ParametersOfUpdate)
	
	TablesColumnsValues = KeyDetails.TablesColumnsValues;
	
	For Each TableColumnsValues In TablesColumnsValues Do
		For Each TableColumnValues In TableColumnsValues Do
			For Each Value In TableColumnValues Do
				If Not AllowedValuesTypes.ContainsType(TypeOf(Value)) Then
					ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
						NStr("en = 'Update of access value keys for the ""%3"" list:
						           |cannot save value ""%1,"" as its type ""%2""
						           |is not specified in type collection ""%4"".';"),
						String(Value),
						String(TypeOf(Value)),
						ParametersOfUpdate.List,
						"AccessValue");
					Raise ErrorText;
				EndIf;
			EndDo;
		EndDo;
	EndDo;
	
EndProcedure

// For the UpdateAccessKeysOfDataItemsBatch procedure.
Procedure PrepareNewAccessKey(KeyDetails, NewKeysDetails, ParametersOfUpdate)
	
	NewRef = Catalogs.AccessKeys.GetRef();
	NewKey = ServiceItem(Catalogs.AccessKeys); // CatalogObject.AccessKeys
	
	NewKey.SetNewObjectRef(NewRef);
	NewKey.Description            = String(NewRef.UUID());
	NewKey.List                  = ParametersOfUpdate.ListID;
	NewKey.FieldsComposition             = ParametersOfUpdate.FieldsComposition;
	NewKey.ForExternalUsers = ParametersOfUpdate.ForExternalUsers;
	NewKey.Hash                     = KeyDetails.Hash;
	
	AllTablesValues = NewKeysDetails.TablesValues;
	
	For Each TableValues In KeyDetails.TablesValues Do
		AllTableValues = AllTablesValues[TableValues.TableName]; // See KeyTableValues
		
		If StrStartsWith(TableValues.TableName, "Header") Then
			NewRow = AllTableValues.Add();
			FillPropertyValues(NewRow, TableValues.Table[0]);
			NewRow.Ref = NewRef;
			
			If StrEndsWith(TableValues.TableName, "0") Then
				FillPropertyValues(NewKey, TableValues.Table[0],, "Parent");
			Else
				LineNumber = Number(Right(TableValues.TableName, 1));
				NewKey.Header.Add();
				FillPropertyValues(NewKey.Header[LineNumber - 1], TableValues.Table[0]);
				NewRow.LineNumber = LineNumber;
			EndIf;
		Else
			For Each String In TableValues.Table Do
				KeyTabularSection = NewKey[TableValues.TableName]; // TabularSection
				FillPropertyValues(KeyTabularSection.Add(), String);
				NewRow = AllTableValues.Add();
				FillPropertyValues(NewRow, String);
				NewRow.Ref = NewRef;
			EndDo;
		EndIf;
	EndDo;
	
	KeyDetails.Insert("AccessKeyObject", NewKey);
	NewKeysDetails.AccessKeys.Add().Ref = NewRef;
	NewKeysDetails.KeysDetailsByRef.Insert(NewRef, KeyDetails);
	
EndProcedure

// For the UpdateItemsBatch and UpdateRightsToAccessKeys procedures.
Procedure UpdateRightsOfListAccessKeysBatch(AccessKeysDetails, ParametersOfUpdate, IsNewKeys = False)
	
	If Not ParametersOfUpdate.Property("Cache") Then
		ParametersOfUpdate.Insert("Cache", New Structure);
	EndIf;
	AccessKeys = ?(IsNewKeys, AccessKeysDetails.AccessKeys, AccessKeysDetails);
	
	If ValueIsFilled(ParametersOfUpdate.FieldsComposition) Then
		Query = New Query;
		Query.Text = ParametersOfUpdate.ValueFromAccessKeysForRightsCalculationQueryText;
		TableNumber = 0;
		
		If IsNewKeys Then
			QueryTexts = New Array;
			KeyTablesAttributes = ParametersOfUpdate.KeyTablesAttributes;
			Template =
			"SELECT
			|	&Fields
			|INTO Table
			|FROM
			|	&Table AS Table";
			For Each KeyTable In ParametersOfUpdate.KeyTables Do
				FieldLIneNumber = "";
				If StrStartsWith(KeyTable, "Header") Then
					If StrEndsWith(KeyTable, "0") Then
						TempTableName = "CatalogAccessKeys";
						Query.Text = StrReplace(Query.Text,
							"@Catalog.AccessKeys ", TempTableName + " ");
					Else
						TempTableName = "CatalogAccessKeys" + KeyTable;
						FieldLIneNumber = "LineNumber, "; // @query-part-1
						Query.Text = StrReplace(Query.Text,
							"@Catalog.AccessKeys.Header AS " + KeyTable, // @query-part-1
							TempTableName + " AS " + KeyTable); // @query-part-1
					EndIf;
				Else
					TempTableName = "CatalogAccessKeys" + KeyTable;
					Query.Text = StrReplace(Query.Text,
						"@Catalog.AccessKeys." + KeyTable, TempTableName);
				EndIf;
				QueryText = StrReplace(Template, "Table", TempTableName);
				TableAttributes = KeyTablesAttributes.Get(KeyTable);
				Fields = "Ref, " + FieldLIneNumber + StrConcat(TableAttributes, ", ");
				QueryText = StrReplace(QueryText, "&Fields", Fields);
				QueryTexts.Add(QueryText);
				Query.SetParameter(TempTableName, AccessKeysDetails.TablesValues[KeyTable]);
				TableNumber = TableNumber + 1;
			EndDo;
			QueryTexts.Add(Query.Text);
			Query.Text = StrConcat(QueryTexts, Common.QueryBatchSeparator());
		Else
			Query.Text = StrReplace(Query.Text, "@Catalog.AccessKeys", "Catalog.AccessKeys");
		EndIf;
		Query.SetParameter("AccessKeys", AccessKeys);
		
		Query.SetParameter("RightSettingsTableID",
			ParametersOfUpdate.RightSettingsTableID);
		
		Query.SetParameter("BlankUUID",
			CommonClientServer.BlankUUID());
		
		SetQueryPlanClarification(Query.Text);
		QueryResults = Query.ExecuteBatch();
	Else
		QueryResults = New Array;
	EndIf;
	
	ParametersOfUpdate.Insert("UserType", ?(ParametersOfUpdate.ForExternalUsers,
		Type("CatalogRef.ExternalUsers"), Type("CatalogRef.Users")));
	
	ParametersOfUpdate.Insert("UserGroupType", ?(ParametersOfUpdate.ForExternalUsers,
		Type("CatalogRef.ExternalUsersGroups"), Type("CatalogRef.UserGroups")));
	
	ParametersOfUpdate.Insert("AccessGroupType",    Type("CatalogRef.AccessGroups"));
	ParametersOfUpdate.Insert("BlankAccessGroup", Catalogs.AccessGroups.EmptyRef());
	
	KeysTablesValues = KeysTableNewVals();
	For Each KeyTable In ParametersOfUpdate.KeyTables Do
		TableNumber = TableNumber + 1;
		KeysTablesValues.Insert(KeyTable,
			QueryResults[TableNumber].Unload(QueryResultIteration.ByGroups));
	EndDo;
	FillRightsToLeadingAccessKeysAndLeadingLists(QueryResults, TableNumber, ParametersOfUpdate);
	FillRightsByRightsSettingsOwners(QueryResults, TableNumber, ParametersOfUpdate);
	
	RightsCalculationCache = CacheForCalculatingRightsForTheUserType(ParametersOfUpdate.ForExternalUsers);
	If Not ParametersOfUpdate.Cache.Property("RoleRightsFunctionsAccessRights")
	 Or RightsCalculationCache.RolesOfAccessGroupProfiles = Undefined Then
		ParametersOfUpdate.Cache.Insert("RoleRightsFunctionsAccessRights",        New Map);
		ParametersOfUpdate.Cache.Insert("MetadataObjectsFunctionsAccessRights", New Map);
		ParametersOfUpdate.Cache.Insert("ProfileRightsFunctionsAccessRights",     New Map);
	EndIf;
	
	FillInTheRightsOfTheListAccessGroups(ParametersOfUpdate, RightsCalculationCache);
	FillAccessGroupsValuesToCalculateRights(ParametersOfUpdate, RightsCalculationCache);
	FillUsersGroupsUsers(ParametersOfUpdate, RightsCalculationCache);
	FillInTheListOfAccessGroupMembers(ParametersOfUpdate, RightsCalculationCache);
	FillInUserGroupsAsAccessValues(ParametersOfUpdate, RightsCalculationCache);
	FillInTheRolesAndAccessGroupsOfProfiles(ParametersOfUpdate, RightsCalculationCache);
	
	FirstTableValues = ?(ValueIsFilled(ParametersOfUpdate.FieldsComposition),
		KeysTablesValues.Get(ParametersOfUpdate.KeyTables[0]),
		New Structure("Rows", AccessKeys));
	LastKeyIndex = FirstTableValues.Rows.Count() - 1;
	
	For KeyIndex = 0 To LastKeyIndex Do
		KeyTablesValues = NewValuesOfKeyTables();
		For Each KeyTable In ParametersOfUpdate.KeyTables Do
			TableValues = KeysTablesValues.Get(KeyTable).Rows[KeyIndex].Rows;
			If StrStartsWith(KeyTable, "Header") Then
				TableValues = TableValues[0];
			EndIf;
			KeyTablesValues.Insert(KeyTable, TableValues);
		EndDo;
		ValuesRow = FirstTableValues.Rows[KeyIndex]; // CatalogObject.AccessKeys
		AccessKey = ValuesRow.Ref;
		
		RightsToKey = RightsToListAccessKey(KeyTablesValues, ParametersOfUpdate);
		// 
		UpdateRightsToListAccessKey(AccessKey, RightsToKey,
			?(IsNewKeys, AccessKeysDetails, Undefined), ParametersOfUpdate);
		
		If ItemsProcessingAbortRequired(ParametersOfUpdate) Then
			Break;
		EndIf;
	EndDo;
	
EndProcedure

// Returns:
//  Structure of KeyAndValue:
//   * Key - String -
//   * Value - ValueTree
//
Function KeysTableNewVals()
	Return New Map;
EndFunction

// Returns:
//  Structure of KeyAndValue:
//   * Key - String -
//   * Value - See TableOfKeyNewValues
//
Function NewValuesOfKeyTables()
	Return New Structure;
EndFunction

// Returns:
//   - ValueTreeRowCollection
//   - ValueTable
//   - ValueTreeRow
//
Function TableOfKeyNewValues()
	Return New ValueTable;
EndFunction

// For the UpdateItemsBatch procedure.
Procedure ProcessObsoleteListAccessKeys(DataItems, ParametersOfUpdate)
	
	Query = New Query;
	Query.Text =
	"SELECT TOP 1
	|	TRUE AS Field1
	|FROM
	|	InformationRegister.AccessGroupsAccessKeys AS AccessGroupsAccessKeys
	|WHERE
	|	AccessGroupsAccessKeys.AccessKey = &AccessKey
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT TOP 1
	|	TRUE AS Field1
	|FROM
	|	InformationRegister.AccessGroupSetsAccessKeys AS AccessGroupSetsAccessKeys
	|WHERE
	|	AccessGroupSetsAccessKeys.AccessKey = &AccessKey
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT TOP 1
	|	TRUE AS Field1
	|FROM
	|	InformationRegister.UsersAccessKeys AS UsersAccessKeys
	|WHERE
	|	UsersAccessKeys.AccessKey = &AccessKey
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT TOP 1
	|	TRUE AS Field1
	|FROM
	|	InformationRegister.ExternalUsersAccessKeys AS ExternalUsersAccessKeys
	|WHERE
	|	ExternalUsersAccessKeys.AccessKey = &AccessKey";
	
	ThisIsClearingSelectedKeys = ParametersOfUpdate.DoNotWriteAccessKeys
		Or ParametersOfUpdate.WithAccessKeyEntryForDependentListsWithoutKeys;
	
	If Not ThisIsClearingSelectedKeys Then
		KeyUsageQuery = New Query;
		KeyUsageQuery.Text =
		"SELECT TOP 1
		|	TRUE AS TrueValue
		|FROM
		|	Catalog.AccessKeys AS AccessKeys
		|WHERE
		|	AccessKeys.Ref = &Ref
		|	AND AccessKeys.NotUsedSince = DATETIME(1, 1, 1)";
	EndIf;
	
	KeyAccessGroupsRecordSet         = ServiceRecordSet(InformationRegisters.AccessGroupsAccessKeys);
	KeyAccessGroupsSetsRecordSet  = ServiceRecordSet(InformationRegisters.AccessGroupSetsAccessKeys);
	KeyUsersRecordSet        = ServiceRecordSet(InformationRegisters.UsersAccessKeys);
	KeyExternalUsersRecordSet = ServiceRecordSet(InformationRegisters.ExternalUsersAccessKeys);
	
	For Each String In DataItems Do
		ValuesRow = String; // CatalogObject.AccessKeys
		Ref = ValuesRow.Ref;
		If Not ThisIsClearingSelectedKeys And String.Used Then
			KeyUsageQuery.SetParameter("Ref", Ref);
			// 
			If Not KeyUsageQuery.Execute().IsEmpty() Then
				If ItemsProcessingAbortRequired(ParametersOfUpdate, 1) Then
					Break;
				EndIf;
				Continue;
			EndIf;
		EndIf;
		
		Block = New DataLock;
		If Not ThisIsClearingSelectedKeys Then
			LockItem = Block.Add("Catalog.AccessKeys");
			LockItem.SetValue("List",      String.List);
			LockItem.SetValue("Hash",         String.Hash);
			LockItem.SetValue("FieldsComposition", String.FieldsComposition);
			LockItem.SetValue("ForExternalUsers",
				ParametersOfUpdate.ForExternalUsers);
		EndIf;
		LockItem = Block.Add("Catalog.AccessKeys");
		LockItem.SetValue("Ref", Ref);
		LockItem = Block.Add("InformationRegister.AccessGroupsAccessKeys");
		LockItem.SetValue("AccessKey", Ref);
		LockItem = Block.Add("InformationRegister.AccessGroupSetsAccessKeys");
		LockItem.SetValue("AccessKey", Ref);
		LockItem = Block.Add("InformationRegister.UsersAccessKeys");
		LockItem.SetValue("AccessKey", Ref);
		LockItem = Block.Add("InformationRegister.ExternalUsersAccessKeys");
		LockItem.SetValue("AccessKey", Ref);
		
		BeginTransaction();
		Try
			Block.Lock();
			Object = ServiceItem(Undefined, Ref);
			DeleteKey = False;
			If ThisIsClearingSelectedKeys Or Object = Undefined Then
				DeleteKey = True;
			ElsIf String.Used Then
				Object.NotUsedSince = '00010101';
			ElsIf Not String.Delete Then
				Object.NotUsedSince = CurrentSessionDate();
			ElsIf ValueIsFilled(Object.NotUsedSince) Then
				DeleteKey = True;
			EndIf;
			If DeleteKey Then
				Query.SetParameter("AccessKey", Ref);
				// 
				QueryResults = Query.ExecuteBatch();
				If Not QueryResults[0].IsEmpty() Then
					KeyAccessGroupsRecordSet.Filter.AccessKey.Set(Ref);
					KeyAccessGroupsRecordSet.Write();
				EndIf;
				If Not QueryResults[1].IsEmpty() Then
					KeyAccessGroupsSetsRecordSet.Filter.AccessKey.Set(Ref);
					KeyAccessGroupsSetsRecordSet.Write();
				EndIf;
				If Not QueryResults[2].IsEmpty() Then
					KeyUsersRecordSet.Filter.AccessKey.Set(Ref);
					KeyUsersRecordSet.Write();
				EndIf;
				If Not QueryResults[3].IsEmpty() Then
					KeyExternalUsersRecordSet.Filter.AccessKey.Set(Ref);
					KeyExternalUsersRecordSet.Write();
				EndIf;
			EndIf;
			If Object <> Undefined Then
				If DeleteKey Then
					Object.Delete();
				ElsIf Object.Modified() Then
					Object.Write();
				EndIf;
			EndIf;
			CommitTransaction();
		Except
			RollbackTransaction();
			Raise;
		EndTry;
		
		If ItemsProcessingAbortRequired(ParametersOfUpdate, 1) Then
			Break;
		EndIf;
	EndDo;
	
EndProcedure

// For the UpdateRightsOfListAccessKeysBatch procedure.
//
// Returns:
//  Structure:
//   * ListAccessGroupPermissions - Map of KeyAndValue:
//      ** Key - CatalogRef.MetadataObjectIDs
//              - CatalogRef.ExtensionObjectIDs - 
//      ** Value - 
//   
//   * AccessGroupsValues                  - See AccessGroupsNewValues
//   * AccessGroupsMembers                 - See AccessGroupsNewMembers
//   * UserGroupsUsers        - See NewUsersInUserGroups
//   * AccessGroupsUserGroups       - See AccessGroupsNewUsersGroups
//   * UserGroupsAsAccessValues - See NewUserGroupsAsAccessVals
//   * RolesOfAccessGroupProfiles              - See NewRolesOfAccessGroupProfiles
//   * ProfilesAccessGroups                 - See ProfilesNewAccessGroups
//
Function CacheForCalculatingRightsForTheUserType(ForExternalUsers) Export
	
	CachedDataKey = String(SessionParameters.CachedDataKey);
	Cache = AccessManagementInternalCached.RightsCalculationCache(CachedDataKey);
	
	DataVersion = DataVersionForTheRightsCalculationCache();
	
	If Cache.DataVersion.AccessGroupsTables <> DataVersion.AccessGroupsTables Then
		ResetTheRightsCalculationCache(Cache, "ListAccessGroupPermissions", True);
		Cache.DataVersion.AccessGroupsTables = DataVersion.AccessGroupsTables;
	EndIf;
	
	If Cache.DataVersion.AccessGroupsValues <> DataVersion.AccessGroupsValues Then
		ResetTheRightsCalculationCache(Cache, "AccessGroupsValues");
		ResetTheRightsCalculationCache(Cache, "UserGroupsAsAccessValues");
		Cache.DataVersion.AccessGroupsValues = DataVersion.AccessGroupsValues;
	EndIf;
	
	If Cache.DataVersion.AccessGroupsMembers <> DataVersion.AccessGroupsMembers Then
		ResetTheRightsCalculationCache(Cache, "AccessGroupsMembers");
		ResetTheRightsCalculationCache(Cache, "AccessGroupsUserGroups");
		Cache.DataVersion.AccessGroupsMembers = DataVersion.AccessGroupsMembers;
	EndIf;
	
	If Cache.DataVersion.UserGroupCompositions <> DataVersion.UserGroupCompositions Then
		ResetTheRightsCalculationCache(Cache, "UserGroupsUsers");
		ResetTheRightsCalculationCache(Cache, "AccessGroupsMembers");
		ResetTheRightsCalculationCache(Cache, "AccessGroupsUserGroups");
		ResetTheRightsCalculationCache(Cache, "UserGroupsAsAccessValues");
		Cache.DataVersion.UserGroupCompositions = DataVersion.UserGroupCompositions;
	EndIf;
	
	If Cache.DataVersion.RolesOfAccessGroupProfiles <> DataVersion.RolesOfAccessGroupProfiles Then
		ResetTheRightsCalculationCache(Cache, "RolesOfAccessGroupProfiles");
		ResetTheRightsCalculationCache(Cache, "ProfilesAccessGroups");
		Cache.DataVersion.RolesOfAccessGroupProfiles = DataVersion.RolesOfAccessGroupProfiles;
	EndIf;
	
	If Cache.DataVersion.ProfilesAccessGroups <> DataVersion.ProfilesAccessGroups Then
		ResetTheRightsCalculationCache(Cache, "RolesOfAccessGroupProfiles");
		ResetTheRightsCalculationCache(Cache, "ProfilesAccessGroups");
		Cache.DataVersion.ProfilesAccessGroups = DataVersion.ProfilesAccessGroups;
	EndIf;
	
	If ForExternalUsers Then
		Return Cache.ForExternalUsers;
	Else
		Return Cache.ForUsers;
	EndIf;
	
EndFunction

// For the RightsCalculationCacheForUsersKind function.
Procedure ResetTheRightsCalculationCache(Cache, Property, NewMap = False)
	
	Cache.ForUsers[Property]        = ?(NewMap, New Map, Undefined);
	Cache.ForExternalUsers[Property] = ?(NewMap, New Map, Undefined);
	
EndProcedure

// For the FillListAccessGroupsRights and
// FillListAccessGroupsMembers procedures.
//
Function TheTextOfTheProfileAssignmentRequest()
	
	Return
	"SELECT
	|	Profiles.Ref AS Profile,
	|	MAX(CASE
	|			WHEN ProfilesPurpose.UsersType IS NULL
	|				THEN TRUE
	|			ELSE VALUETYPE(ProfilesPurpose.UsersType) = TYPE(Catalog.Users)
	|		END) AS ForUsers,
	|	MAX(CASE
	|			WHEN ProfilesPurpose.UsersType IS NULL
	|				THEN FALSE
	|			ELSE ProfilesPurpose.UsersType <> UNDEFINED
	|					AND VALUETYPE(ProfilesPurpose.UsersType) <> TYPE(Catalog.Users)
	|		END) AS ForExternalUsers
	|INTO ProfilesPurpose
	|FROM
	|	Catalog.AccessGroupProfiles AS Profiles
	|		LEFT JOIN Catalog.AccessGroupProfiles.Purpose AS ProfilesPurpose
	|		ON (ProfilesPurpose.Ref = Profiles.Ref)
	|
	|GROUP BY
	|	Profiles.Ref";
	
EndFunction

// Parameters:
//  Rights - ValueTable
//
// Returns:
//  ValueTable:
//   * AccessGroup - CatalogRef.AccessGroups
//   * RightUpdate - Boolean
//   * AddRight - Boolean
//   * UnrestrictedReadRight - Boolean
//   * UnrestrictedUpdateRight - Boolean
//   * UnrestrictedAddRight - Boolean
//
Function ListAccessGroupNewRights(Rights)
	Return Rights;
EndFunction

// For the UpdateRightsOfListAccessKeysBatch procedure.
Procedure FillInTheRightsOfTheListAccessGroups(ParametersOfUpdate, Cache)
	
	ListID = ParametersOfUpdate.ListID;
	ListAccessGroupsRights = Cache.ListAccessGroupPermissions.Get(ListID);
	If ListAccessGroupsRights <> Undefined Then
		ParametersOfUpdate.Insert("ListAccessGroupsRights", ListAccessGroupsRights);
		Return;
	EndIf;
	
	Query = New Query;
	Query.SetParameter("Table", ListID);
	Query.Text =
	"SELECT
	|	AccessGroupsTables.AccessGroup AS AccessGroup,
	|	AccessGroupsTables.RightUpdate AS RightUpdate,
	|	AccessGroupsTables.AddRight AS AddRight,
	|	AccessGroupsTables.UnrestrictedReadRight AS UnrestrictedReadRight,
	|	AccessGroupsTables.UnrestrictedUpdateRight AS UnrestrictedUpdateRight,
	|	AccessGroupsTables.UnrestrictedAddRight AS UnrestrictedAddRight
	|FROM
	|	InformationRegister.AccessGroupsTables AS AccessGroupsTables
	|		INNER JOIN Catalog.AccessGroups AS AccessGroups
	|		ON (AccessGroupsTables.Table = &Table)
	|			AND (AccessGroups.Ref = AccessGroupsTables.AccessGroup)
	|		INNER JOIN ProfilesPurpose AS ProfilesPurpose
	|		ON (ProfilesPurpose.Profile = AccessGroups.Profile)
	|			AND (ProfilesPurpose.ForUsers)";
	
	If ParametersOfUpdate.ForExternalUsers Then
		Query.Text = StrReplace(Query.Text,
			"ProfilesPurpose.ForUsers", "ProfilesPurpose.ForExternalUsers");
	EndIf;
	
	Query.Text = TheTextOfTheProfileAssignmentRequest()
		+ Common.QueryBatchSeparator() + Query.Text;
	
	ListAccessGroupsRights = ListAccessGroupNewRights(Query.Execute().Unload());
	Cache.ListAccessGroupPermissions.Insert(ListID, ListAccessGroupsRights);
	ParametersOfUpdate.Insert("ListAccessGroupsRights", ListAccessGroupsRights);
	
EndProcedure

// Returns:
//  Map of KeyAndValue:
//   * Key - CatalogRef.UserGroups
//          - CatalogRef.ExternalUsersGroups
//          - CatalogRef.Users
//         - CatalogRef.ExternalUsers
//   * Value - Map of KeyAndValue:
//      ** Key - CatalogRef.Users
//             - CatalogRef.ExternalUsers
//      ** Value - Boolean - True
//
Function NewUsersInUserGroups()
	Return New Map;
EndFunction

// For the UpdateRightsOfListAccessKeysBatch procedure.
Procedure FillUsersGroupsUsers(ParametersOfUpdate, Cache)
	
	ParametersOfUpdate.Insert("UserGroupsUsers", NewUsersInUserGroups());
	
	If Not ParametersOfUpdate.CalculateUserRights Then
		Return;
	EndIf;
	
	If Cache.UserGroupsUsers <> Undefined Then
		ParametersOfUpdate.UserGroupsUsers = Cache.UserGroupsUsers;
		Return;
	EndIf;
	
	Query = New Query;
	Query.Text =
	"SELECT
	|	UserGroupCompositions.UsersGroup AS UsersGroup,
	|	UserGroupCompositions.User AS User
	|FROM
	|	InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|		INNER JOIN Catalog.Users AS Users
	|		ON (Users.Ref = UserGroupCompositions.User)
	|			AND (Users.IBUserID <> &BlankUUID)
	|			AND (VALUETYPE(UserGroupCompositions.UsersGroup) = TYPE(Catalog.UserGroups))
	|			AND (UserGroupCompositions.Used)
	|TOTALS BY
	|	UsersGroup";
	
	If ParametersOfUpdate.ForExternalUsers Then
		Query.Text = StrReplace(Query.Text,
			"Catalog.Users", "Catalog.ExternalUsers");
		Query.Text = StrReplace(Query.Text,
			"Catalog.UserGroups", "Catalog.ExternalUsersGroups");
	EndIf;
	
	Query.SetParameter("BlankUUID",
		CommonClientServer.BlankUUID());
	
	UserGroupsUsers = ParametersOfUpdate.UserGroupsUsers;
	
	QueryResult = Query.Execute();
	FillInTheUsersOfTheGroups(UserGroupsUsers, QueryResult);
	
	Cache.UserGroupsUsers = UserGroupsUsers;
	
EndProcedure

// Returns:
//  Map of KeyAndValue:
//   * Key - CatalogRef.UserGroups
//          - CatalogRef.ExternalUsersGroups
//   * Value - Map of KeyAndValue:
//      ** Key - CatalogRef.Users
//              - CatalogRef.ExternalUsers
//      ** Value - Boolean - True
//
Function NewUserGroupsAsAccessVals()
	Return New Map;
EndFunction

// For the UpdateRightsOfListAccessKeysBatch procedure.
Procedure FillInUserGroupsAsAccessValues(ParametersOfUpdate, Cache)
	
	ParametersOfUpdate.Insert("UserGroupsAsAccessValues",
		NewUserGroupsAsAccessVals());
	
	If Not ParametersOfUpdate.CalculateUserRights Then
		Return;
	EndIf;
	
	If Cache.UserGroupsAsAccessValues <> Undefined Then
		ParametersOfUpdate.UserGroupsAsAccessValues = Cache.UserGroupsAsAccessValues;
		Return;
	EndIf;
	
	Query = New Query;
	Query.Text =
	"SELECT
	|	UserGroupCompositions.UsersGroup AS UsersGroup,
	|	UserGroupCompositions.User AS User
	|FROM
	|	InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|		INNER JOIN InformationRegister.AccessGroupsValues AS AccessGroupsValues
	|		ON UserGroupCompositions.UsersGroup = AccessGroupsValues.AccessValue
	|			AND (VALUETYPE(UserGroupCompositions.UsersGroup) = TYPE(Catalog.UserGroups))
	|			AND (VALUETYPE(AccessGroupsValues.AccessValue) = TYPE(Catalog.UserGroups))
	|TOTALS BY
	|	UsersGroup";
	
	If ParametersOfUpdate.ForExternalUsers Then
		Query.Text = StrReplace(Query.Text,
			"Catalog.UserGroups", "Catalog.ExternalUsersGroups");
	EndIf;
	
	UserGroupsAsAccessValues = ParametersOfUpdate.UserGroupsAsAccessValues;
	
	QueryResult = Query.Execute();
	FillInTheUsersOfTheGroups(UserGroupsAsAccessValues, QueryResult);
	
	Cache.UserGroupsAsAccessValues = UserGroupsAsAccessValues;
	
EndProcedure

// Returns:
//  Map of KeyAndValue:
//   * Key - CatalogRef.AccessGroups
//   * Value - Map of KeyAndValue:
//      ** Key - CatalogRef.Users
//              - CatalogRef.UserGroups
//              - CatalogRef.ExternalUsers
//              - CatalogRef.ExternalUsersGroups
//      ** Value - Boolean - True
//
Function AccessGroupsNewMembers()
	Return New Map;
EndFunction

// Returns:
//  Map of KeyAndValue:
//   * Key - CatalogRef.AccessGroups
//   * Value - Map of KeyAndValue:
//      ** Key - CatalogRef.UserGroups
//              - CatalogRef.ExternalUsersGroups
//      ** Value - Map of KeyAndValue:
//          *** Key - CatalogRef.Users
//                   - CatalogRef.ExternalUsers
//          *** Value - Boolean - True
//
Function AccessGroupsNewUsersGroups()
	Return New Map;
EndFunction

// For the UpdateRightsOfListAccessKeysBatch procedure.
Procedure FillInTheListOfAccessGroupMembers(ParametersOfUpdate, Cache)
	
	ParametersOfUpdate.Insert("AccessGroupsMembers",           AccessGroupsNewMembers());
	ParametersOfUpdate.Insert("AccessGroupsUserGroups", AccessGroupsNewUsersGroups());
	
	If Not ParametersOfUpdate.CalculateUserRights Then
		Return;
	EndIf;
	
	If Cache.AccessGroupsMembers <> Undefined Then
		ParametersOfUpdate.AccessGroupsMembers           = Cache.AccessGroupsMembers;
		ParametersOfUpdate.AccessGroupsUserGroups = Cache.AccessGroupsUserGroups;
		Return;
	EndIf;
	
	Query = New Query;
	Query.Text =
	"SELECT DISTINCT
	|	AccessGroupUsers.Ref AS AccessGroup,
	|	AccessGroupUsers.User AS Member
	|FROM
	|	Catalog.AccessGroups AS AccessGroups
	|		INNER JOIN ProfilesPurpose AS ProfilesPurpose
	|		ON (ProfilesPurpose.Profile = AccessGroups.Profile)
	|			AND (ProfilesPurpose.ForUsers)
	|			AND (NOT AccessGroups.DeletionMark)
	|		INNER JOIN Catalog.AccessGroups.Users AS AccessGroupUsers
	|		ON (AccessGroupUsers.Ref = AccessGroups.Ref)
	|			AND (TRUE IN
	|				(SELECT TOP 1
	|					TRUE
	|				FROM
	|					InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|						INNER JOIN Catalog.Users AS Users
	|						ON
	|							UserGroupCompositions.UsersGroup = AccessGroupUsers.User
	|								AND UserGroupCompositions.Used
	|								AND Users.Ref = UserGroupCompositions.User
	|								AND Users.IBUserID <> &BlankUUID))
	|TOTALS BY
	|	AccessGroup";
	
	If ParametersOfUpdate.ForExternalUsers Then
		Query.Text = StrReplace(Query.Text,
			"ProfilesPurpose.ForUsers", "ProfilesPurpose.ForExternalUsers");
		Query.Text = StrReplace(Query.Text,
			"Catalog.Users", "Catalog.ExternalUsers");
		Query.Text = StrReplace(Query.Text,
			"Catalog.UserGroups", "Catalog.ExternalUsersGroups");
	EndIf;
	
	Query.Text = TheTextOfTheProfileAssignmentRequest()
		+ Common.QueryBatchSeparator() + Query.Text;
	
	Query.SetParameter("BlankUUID",
		CommonClientServer.BlankUUID());
	
	AccessGroupsMembers           = ParametersOfUpdate.AccessGroupsMembers;
	AccessGroupsUserGroups = ParametersOfUpdate.AccessGroupsUserGroups;
	UserGroupType          = ParametersOfUpdate.UserGroupType;
	UserGroupsUsers  = ParametersOfUpdate.UserGroupsUsers;
	
	Tree = Query.Execute().Unload(QueryResultIteration.ByGroups);
	
	For Each String In Tree.Rows Do
		AccessGroupMembers = New Map;
		AccessGroupUserGroups = New Map;
		For Each Substring In String.Rows Do
			AccessGroupMembers.Insert(Substring.Member, True);
			If TypeOf(Substring.Member) = UserGroupType Then
				GroupUsers = UserGroupsUsers.Get(Substring.Member);
				If GroupUsers <> Undefined Then
					AccessGroupUserGroups.Insert(Substring.Member, GroupUsers);
				EndIf;
			EndIf;
		EndDo;
		If AccessGroupMembers.Count() > 0 Then
			AccessGroupsMembers.Insert(String.AccessGroup, AccessGroupMembers);
		EndIf;
		If AccessGroupUserGroups.Count() > 0 Then
			AccessGroupsUserGroups.Insert(String.AccessGroup, AccessGroupUserGroups);
		EndIf;
	EndDo;
	
	Cache.AccessGroupsMembers           = AccessGroupsMembers;
	Cache.AccessGroupsUserGroups = AccessGroupsUserGroups;
	
EndProcedure

// For the FillUsersGroupsUsers and
//  FillUsersGroupAsAccessValues procedures.
//
Procedure FillInTheUsersOfTheGroups(UserGroupsUsers, QueryResult)
	
	Tree = QueryResult.Unload(QueryResultIteration.ByGroups);
	For Each String In Tree.Rows Do
		UsersGroupUsers = New Map;
		For Each Substring In String.Rows Do
			UsersGroupUsers.Insert(Substring.User, True);
		EndDo;
		UserGroupsUsers.Insert(String.UsersGroup, UsersGroupUsers);
	EndDo;
	
EndProcedure

// Returns:
//  Map of KeyAndValue:
//   * Key - Type -
//   * Value - Structure:
//      ** AllAllowed - Boolean
//      ** Values - Map of KeyAndValue:
//          *** Key - DefinedType.AccessValue
//          *** Value - Boolean - True
//
Function AccessGroupNewValues()
	Return New Map;
EndFunction

// Returns:
//  Map of KeyAndValue:
//   * Key - CatalogRef.AccessGroups
//   * Value - See AccessGroupNewValues
//
Function AccessGroupsNewValues()
	Return New Map;
EndFunction

// For the UpdateRightsOfListAccessKeysBatch procedure.
Procedure FillAccessGroupsValuesToCalculateRights(ParametersOfUpdate, Cache)
	
	If Cache.AccessGroupsValues <> Undefined Then
		ParametersOfUpdate.Insert("AccessGroupsValues", Cache.AccessGroupsValues);
		Return;
	EndIf;
	
	Query = New Query;
	Query.Text =
	"SELECT
	|	DefaultAccessGroupsValues.AccessGroup AS AccessGroup,
	|	VALUETYPE(DefaultAccessGroupsValues.AccessValuesType) AS AccessValuesType,
	|	DefaultAccessGroupsValues.AllAllowed AS AllAllowed
	|FROM
	|	InformationRegister.DefaultAccessGroupsValues AS DefaultAccessGroupsValues
	|WHERE
	|	NOT DefaultAccessGroupsValues.NoSettings
	|TOTALS BY
	|	AccessGroup
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	AccessGroupsValues.AccessGroup AS AccessGroup,
	|	VALUETYPE(AccessGroupsValues.AccessValue) AS AccessValuesType,
	|	AccessGroupsValues.AccessValue AS AccessValue
	|FROM
	|	InformationRegister.AccessGroupsValues AS AccessGroupsValues
	|TOTALS BY
	|	AccessGroup,
	|	AccessValuesType";
	QueryResults = Query.ExecuteBatch();
	
	AccessGroupsValues = AccessGroupsNewValues();
	
	Tree = QueryResults[0].Unload(QueryResultIteration.ByGroups);
	For Each String In Tree.Rows Do
		AccessGroupValues = AccessGroupNewValues();
		For Each Substring In String.Rows Do
			ValuesOfOneType = New Structure;
			ValuesOfOneType.Insert("AllAllowed", Substring.AllAllowed);
			ValuesOfOneType.Insert("Values",     New Map);
			AccessGroupValues.Insert(Substring.AccessValuesType, ValuesOfOneType);
		EndDo;
		AccessGroupsValues.Insert(String.AccessGroup, AccessGroupValues);
	EndDo;
	
	Tree = QueryResults[1].Unload(QueryResultIteration.ByGroups);
	For Each String In Tree.Rows Do
		AccessGroupValues = AccessGroupsValues.Get(String.AccessGroup);
		If AccessGroupValues = Undefined Then
			Continue;
		EndIf;
		For Each Substring In String.Rows Do
			ValuesOfOneType = AccessGroupValues.Get(Substring.AccessValuesType);
			If ValuesOfOneType = Undefined Then
				Continue;
			EndIf;
			Values = ValuesOfOneType.Values;
			For Each ValueDescription In Substring.Rows Do
				Values.Insert(ValueDescription.AccessValue, True);
			EndDo;
		EndDo;
	EndDo;
	
	ParametersOfUpdate.Insert("AccessGroupsValues", AccessGroupsValues);
	Cache.AccessGroupsValues = AccessGroupsValues;
	
EndProcedure

// Returns:
//  ValueTable:
//   * Profile - CatalogRef.AccessGroupProfiles
//   * Role    - CatalogRef.MetadataObjectIDs
//            - CatalogRef.ExtensionObjectIDs
//   * NameOfRole - String
//   * RoleNameUppercase - String
//
Function NewRolesOfAccessGroupProfiles()
	Return New ValueTable;
EndFunction

// Returns:
//  ValueTable:
//   * Profile       - CatalogRef.AccessGroupProfiles
//   * AccessGroup - CatalogRef.AccessGroups
//
Function ProfilesNewAccessGroups()
	Return New ValueTable;
EndFunction

// For the UpdateRightsOfListAccessKeysBatch procedure.
Procedure FillInTheRolesAndAccessGroupsOfProfiles(ParametersOfUpdate, Cache)
	
	ParametersOfUpdate.Insert("RolesOfAccessGroupProfiles", NewRolesOfAccessGroupProfiles());
	ParametersOfUpdate.Insert("ProfilesAccessGroups",    ProfilesNewAccessGroups());
	
	If Not ParametersOfUpdate.ThereIsAFunctionAccessRightOrRoleAvailable Then
		Return;
	EndIf;
	
	If Cache.RolesOfAccessGroupProfiles <> Undefined Then
		ParametersOfUpdate.RolesOfAccessGroupProfiles = Cache.RolesOfAccessGroupProfiles;
		ParametersOfUpdate.ProfilesAccessGroups    = Cache.ProfilesAccessGroups;
		Return;
	EndIf;
	
	Query = New Query;
	Query.Text =
	"SELECT DISTINCT
	|	ProfilesRoles.Role AS Role
	|FROM
	|	ProfilesPurpose AS ProfilesPurpose
	|		INNER JOIN Catalog.AccessGroupProfiles.Roles AS ProfilesRoles
	|		ON (ProfilesRoles.Ref = ProfilesPurpose.Profile)
	|			AND (ProfilesPurpose.ForUsers)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT DISTINCT
	|	ProfilesRoles.Ref AS Profile,
	|	ProfilesRoles.Role AS Role
	|FROM
	|	ProfilesPurpose AS ProfilesPurpose
	|		INNER JOIN Catalog.AccessGroupProfiles.Roles AS ProfilesRoles
	|		ON (ProfilesRoles.Ref = ProfilesPurpose.Profile)
	|			AND (ProfilesPurpose.ForUsers)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	ProfilesPurpose.Profile AS Profile,
	|	AccessGroups.Ref AS AccessGroup
	|FROM
	|	ProfilesPurpose AS ProfilesPurpose
	|		INNER JOIN Catalog.AccessGroups AS AccessGroups
	|		ON ProfilesPurpose.Profile = AccessGroups.Profile
	|			AND (ProfilesPurpose.ForUsers)";
	
	If ParametersOfUpdate.ForExternalUsers Then
		Query.Text = StrReplace(Query.Text,
			"ProfilesPurpose.ForUsers", "ProfilesPurpose.ForExternalUsers");
	EndIf;
	
	Query.Text = TheTextOfTheProfileAssignmentRequest()
		+ Common.QueryBatchSeparator() + Query.Text;
	
	QueryResults = Query.ExecuteBatch();
	
	Roles = QueryResults[1].Unload().UnloadColumn("Role");
	RoleMetadataObjects = Common.MetadataObjectsByIDs(Roles, False);
	
	RolesOfAccessGroupProfiles = QueryResults[2].Unload();
	TypeOfRoleName = Metadata.Catalogs.MetadataObjectIDs.Attributes.Name.Type;
	RolesOfAccessGroupProfiles.Columns.Add("NameOfRole", TypeOfRoleName);
	RolesOfAccessGroupProfiles.Columns.Add("RoleNameUppercase", TypeOfRoleName);
	RolesOfAccessGroupProfiles.Indexes.Add("Role");
	Filter = New Structure("Role");
	YouNeedToCheckRelevanceOfMetadata = False;
	
	For Each RoleDetails In RoleMetadataObjects Do
		If TypeOf(RoleDetails.Value) <> Type("MetadataObject") Then
			YouNeedToCheckRelevanceOfMetadata = True;
			Continue;
		EndIf;
		NameOfRole = RoleDetails.Value.Name;
		RoleNameUppercase = Upper(NameOfRole);
		Filter.Role = RoleDetails.Key;
		Rows = RolesOfAccessGroupProfiles.FindRows(Filter);
		For Each String In Rows Do
			String.NameOfRole = NameOfRole;
			String.RoleNameUppercase = RoleNameUppercase;
		EndDo;
	EndDo;
	If YouNeedToCheckRelevanceOfMetadata Then
		CheckWhetherTheMetadataIsUpToDate();
	EndIf;
	RolesOfAccessGroupProfiles.Indexes.Add("Profile,RoleNameUppercase");
	
	ProfilesAccessGroups = QueryResults[3].Unload();
	ProfilesAccessGroups.Indexes.Add("AccessGroup");
	
	ParametersOfUpdate.RolesOfAccessGroupProfiles = RolesOfAccessGroupProfiles;
	ParametersOfUpdate.ProfilesAccessGroups    = ProfilesAccessGroups;
	Cache.RolesOfAccessGroupProfiles = RolesOfAccessGroupProfiles;
	Cache.ProfilesAccessGroups    = ProfilesAccessGroups;
	
EndProcedure

// Returns:
//  FixedMap of KeyAndValue:
//   * Key - CatalogRef.AccessKeys
//   * Value - FixedStructure:
//      ** RightToWriteRestrictionDisabled - Boolean
//      ** RestrictionDisabled - Boolean
//      ** ByAccessGroups - FixedMap of KeyAndValue:
//          *** Key - CatalogRef.AccessGroups
//          *** Value - Boolean -
//
Function NewRightsForListsOfMasterAccessKeys()
	Return New Map;
EndFunction

// Returns:
//  FixedMap of KeyAndValue:
//   * Key - CatalogRef.AccessKeys
//   * Value - FixedMap of KeyAndValue:
//      ** Key - CatalogRef.AccessGroups
//              - CatalogRef.UserGroups
//              - CatalogRef.ExternalUsersGroups
//      ** Value - Boolean -
//
Function NewRightsToMasterAccessKeys()
	Return New Map;
EndFunction

// Returns:
//  FixedMap of KeyAndValue:
//   * Key - CatalogRef.MetadataObjectIDs
//          - CatalogRef.ExtensionObjectIDs - 
//          - Type - 
//   * Value - FixedMap of KeyAndValue:
//      ** Key - CatalogRef.AccessGroups
//              - CatalogRef.UserGroups
//              - CatalogRef.ExternalUsersGroups
//      ** Value - Boolean -
//
Function NewRightsToMasterLists()
	Return New Map;
EndFunction

// For the UpdateRightsOfListAccessKeysBatch procedure.
Procedure FillRightsToLeadingAccessKeysAndLeadingLists(QueryResults, TableNumber, ParametersOfUpdate)
	
	RightsToLeadingAccessKeysLists = NewRightsForListsOfMasterAccessKeys();
	RightsToLeadingAccessKeys = NewRightsToMasterAccessKeys();
	If ParametersOfUpdate.HasMasterAccessKeys Then
		ActiveParameters = ActiveAccessRestrictionParameters(ParametersOfUpdate.TransactionID, Undefined, False);
		If ParametersOfUpdate.ForExternalUsers Then
			AdditionalContext = ActiveParameters.AdditionalContext.ForExternalUsers;
		Else
			AdditionalContext = ActiveParameters.AdditionalContext.ForUsers;
		EndIf;
		TableNumber = TableNumber + 1;
		RightsToLists = New Map;
		Tree = QueryResults[TableNumber].Unload(QueryResultIteration.ByGroups);
		ListsIDs = Tree.Rows.UnloadColumn("List");
		If ParametersOfUpdate.Cache.Property("MetadataObjectsByIDs") Then
			MetadataObjectsByIDs = ParametersOfUpdate.Cache.MetadataObjectsByIDs;
			NotFoundListsIDs = New Array;
			For Each ListID In ListsIDs Do
				If MetadataObjectsByIDs.Get(ListID) = Undefined Then
					NotFoundListsIDs.Add(ListID);
				EndIf;
			EndDo;
			Result = Common.MetadataObjectsByIDs(
				NotFoundListsIDs, False);
			For Each KeyAndValue In Result Do
				MetadataObjectsByIDs.Insert(KeyAndValue.Key, KeyAndValue.Value);
			EndDo;
		Else
			MetadataObjectsByIDs = Common.MetadataObjectsByIDs(
				ListsIDs, False);
		EndIf;
		For Each String In Tree.Rows Do
			MetadataObject = MetadataObjectsByIDs.Get(String.List);
			If TypeOf(MetadataObject) <> Type("MetadataObject") Then
				Continue;
			EndIf;
			FullName = MetadataObject.FullName();
			ByAccessGroups = New Map;
			For Each Substring In String.Rows Do
				ByAccessGroups.Insert(Substring.AccessGroup, Substring.RightUpdate);
			EndDo;
			RightsToList = New Structure;
			RightsToList.Insert("RightToWriteRestrictionDisabled",
				AdditionalContext.ListsWithReadRestrictionDisabled.Get(FullName) <> Undefined);
			RightsToList.Insert("RestrictionDisabled",
				AdditionalContext.ListsWithDisabledRestriction.Get(FullName) <> Undefined);
			RightsToList.Insert("ByAccessGroups", New FixedMap(ByAccessGroups));
			RightsToLists.Insert(String.List, New FixedStructure(RightsToList));
		EndDo;
		TableNumber = TableNumber + 1;
		Table = QueryResults[TableNumber].Unload();
		For Each String In Table Do
			RightsToLeadingAccessKeysLists.Insert(String.AccessKey,
				RightsToLists.Get(String.List));
		EndDo;
		TableNumber = TableNumber + 1;
		Tree = QueryResults[TableNumber].Unload(QueryResultIteration.ByGroups);
		For Each String In Tree.Rows Do
			RightsToLeadingKey = New Map;
			For Each Substring In String.Rows Do
				RightsToLeadingKey.Insert(Substring.RightsOwner, Substring.RightUpdate);
			EndDo;
			RightsToLeadingAccessKeys.Insert(String.AccessKey,
				New FixedMap(RightsToLeadingKey));
		EndDo;
	EndIf;
	ParametersOfUpdate.Insert("RightsToLeadingAccessKeysLists",
		New FixedMap(RightsToLeadingAccessKeysLists));
	ParametersOfUpdate.Insert("RightsToLeadingAccessKeys",
		New FixedMap(RightsToLeadingAccessKeys));
	
	RightsToLeadingLists = NewRightsToMasterLists();
	If ParametersOfUpdate.HasHeadRightsLists Then
		TableNumber = TableNumber + 1;
		Tree = QueryResults[TableNumber].Unload(QueryResultIteration.ByGroups);
		AddRightsByTypes = Tree.Columns.Find("ValueType") <> Undefined;
		For Each String In Tree.Rows Do
			RightsToLeadingList = New Map;
			For Each Substring In String.Rows Do
				RightsToLeadingList.Insert(Substring.RightsOwner, Substring.RightUpdate);
				If AddRightsByTypes Then
					ListValueType = Substring.ValueType;
				EndIf;
			EndDo;
			RightsToLeadingLists.Insert(String.List,
				New FixedMap(RightsToLeadingList));
			If AddRightsByTypes Then
				RightsToLeadingLists.Insert(ListValueType,
					New FixedMap(RightsToLeadingList));
			EndIf;
		EndDo;
	EndIf;
	ParametersOfUpdate.Insert("RightsToLeadingLists",
		New FixedMap(RightsToLeadingLists));
	
EndProcedure

// Returns:
//  FixedMap of KeyAndValue:
//   * Key    - DefinedType.RightsSettingsOwner
//   * Value - FixedMap of KeyAndValue:
//      ** Key - CatalogRef.Users
//              - CatalogRef.UserGroups
//              - CatalogRef.ExternalUsers
//              - CatalogRef.ExternalUsersGroups
//      ** Value - Boolean -
//
Function NewRightsByRightSetupOwners()
	Return New Map;
EndFunction

// For the UpdateRightsOfListAccessKeysBatch procedure.
Procedure FillRightsByRightsSettingsOwners(QueryResults, TableNumber, ParametersOfUpdate)
	
	RightsByRightsSettingsOwners = NewRightsByRightSetupOwners();
	If ParametersOfUpdate.HasRightsSettingsOwners Then
		TableNumber = TableNumber + 5;
		Tree = QueryResults[TableNumber].Unload(QueryResultIteration.ByGroups);
		For Each String In Tree.Rows Do
			RightsByRightsSettingsOwner = New Map;
			For Each Substring In String.Rows Do
				RightsByRightsSettingsOwner.Insert(Substring.RightsOwner, Substring.RightUpdate);
			EndDo;
			RightsByRightsSettingsOwners.Insert(String.RightsSettingsOwner,
				New FixedMap(RightsByRightsSettingsOwner));
		EndDo;
	EndIf;
	ParametersOfUpdate.Insert("RightsByRightsSettingsOwners",
		New FixedMap(RightsByRightsSettingsOwners));
	
EndProcedure

// Returns:
//  Structure:
//   * KeyTablesValues - See NewValuesOfKeyTables
//   * WithoutWriteReadRight - Boolean
//   * KeyTablesAttributes                  - See KeyTableNewAttributes
//   * AccessGroupsMembers                 - See AccessGroupsNewMembers
//   * AccessGroupsUserGroups       - See AccessGroupsNewUsersGroups
//   * UserGroupsAsAccessValues - See NewUserGroupsAsAccessVals
//   * UserGroupsUsers        - See NewUsersInUserGroups
//   * RightsToLeadingAccessKeysLists     - See NewRightsForListsOfMasterAccessKeys
//   * RightsToLeadingAccessKeys            - See NewRightsToMasterAccessKeys
//   * RightsToLeadingLists                  - See NewRightsToMasterLists
//   * RightsByRightsSettingsOwners         - See NewRightsByRightSetupOwners
//   * AccessGroupType - Type
//   * BlankAccessGroup - CatalogRef.AccessGroups
//   * UserType - Type
//   * UserGroupType - Type
//   * RightsSettingsOwnersTypes - FixedMap
//   * RoleRightsFunctionsAccessRights - Map
//   * MetadataObjectsFunctionsAccessRights - Map
//   * ProfileRightsFunctionsAccessRights - Map
//   * RolesOfAccessGroupProfiles - 
//   * ProfilesAccessGroups - 
//   * AccessGroup - CatalogRef.AccessGroups -
//   * AccessGroupValues - See AccessGroupNewValues
//   * RequiredKeyTablesDetails - Array of Structure:
//      ** TablesAttributes    - Map of KeyAndValue:
//          *** Key     - String -
//          *** Value - Array of String -
//      ** TablesValues     - See CurrentKeyTablesValues
//      ** TablesRowsIndexes - Map
//   * CurrentKeyTableRows - See NewValuesOfKeyTables
//
Function RightsCalculationNewContext()
	Return New Structure;
EndFunction

// For the UpdateRightsToListAccessKeys procedure.
Function RightsToListAccessKey(KeyTablesValues, ParametersOfUpdate)
	
	RightsToKey = New Structure("ForGroups, ForUsers", New Map, New Map);
	
	If ParametersOfUpdate.RestrictionDisabled Then
		If Not ParametersOfUpdate.HasDependantListsWithoutAccessKeysRecords Then
			Return RightsToKey;
		ElsIf ParametersOfUpdate.EditionAllowedForAllUsers Then
			RightsToKey.ForGroups.Insert(ParametersOfUpdate.BlankAccessGroup,
				New Structure("RightUpdate, AddRight", True, True));
			Return RightsToKey;
		EndIf;
	EndIf;
	
	WithoutWriteReadRight = ParametersOfUpdate.RightToWriteRestrictionDisabled
		And Not ParametersOfUpdate.HasDependantListsWithoutAccessKeysRecords;
	
	Context = RightsCalculationNewContext();
	Context.Insert("KeyTablesValues",                   KeyTablesValues);
	Context.Insert("WithoutWriteReadRight",                  WithoutWriteReadRight);
	Context.Insert("KeyTablesAttributes",                  ParametersOfUpdate.KeyTablesAttributes);
	Context.Insert("AccessGroupsMembers",                 ParametersOfUpdate.AccessGroupsMembers);
	Context.Insert("AccessGroupsUserGroups",       ParametersOfUpdate.AccessGroupsUserGroups);
	Context.Insert("UserGroupsAsAccessValues", ParametersOfUpdate.UserGroupsAsAccessValues);
	Context.Insert("UserGroupsUsers",        ParametersOfUpdate.UserGroupsUsers);
	Context.Insert("RightsToLeadingAccessKeysLists",     ParametersOfUpdate.RightsToLeadingAccessKeysLists);
	Context.Insert("RightsToLeadingAccessKeys",            ParametersOfUpdate.RightsToLeadingAccessKeys);
	Context.Insert("RightsToLeadingLists",                  ParametersOfUpdate.RightsToLeadingLists);
	Context.Insert("RightsByRightsSettingsOwners",         ParametersOfUpdate.RightsByRightsSettingsOwners);
	Context.Insert("CalculateUserRights",        ParametersOfUpdate.CalculateUserRights);
	Context.Insert("AccessGroupType",                      ParametersOfUpdate.AccessGroupType);
	Context.Insert("BlankAccessGroup",                   ParametersOfUpdate.BlankAccessGroup);
	Context.Insert("UserType",                       ParametersOfUpdate.UserType);
	Context.Insert("UserGroupType",                ParametersOfUpdate.UserGroupType);
	Context.Insert("RightsSettingsOwnersTypes",            ParametersOfUpdate.RightsSettingsOwnersTypes);
	Context.Insert("RoleRightsFunctionsAccessRights",         ParametersOfUpdate.Cache.RoleRightsFunctionsAccessRights);
	Context.Insert("MetadataObjectsFunctionsAccessRights",  ParametersOfUpdate.Cache.MetadataObjectsFunctionsAccessRights);
	Context.Insert("ProfileRightsFunctionsAccessRights",      ParametersOfUpdate.Cache.ProfileRightsFunctionsAccessRights);
	Context.Insert("RolesOfAccessGroupProfiles",              ParametersOfUpdate.RolesOfAccessGroupProfiles);
	Context.Insert("ProfilesAccessGroups",                 ParametersOfUpdate.ProfilesAccessGroups);
	
	ReadAllowedForAllAccessGroups = True;
	ChangeAllowedForAllAccessGroups = True;
	AddAllowedForAllAccessGroups = True;
	
	For Each RightsDetails In ParametersOfUpdate.ListAccessGroupsRights Do
		AccessGroup      = RightsDetails.AccessGroup;
		AccessGroupRights1 = RightsDetails; // ValueTableRow
		
		Context.Insert("AccessGroup", AccessGroup);
		Context.Insert("AccessGroupValues",
			ParametersOfUpdate.AccessGroupsValues.Get(AccessGroup));
		
		If WithoutWriteReadRight
		 Or AccessGroupRights1.UnrestrictedReadRight Then
			
			ReadRight = "True";
		Else
			ReadRight = CalculatedConditionForRows(Context,
				ParametersOfUpdate.ReadRightCalculationStructure);
		EndIf;
		
		If ReadRight <> "True" Then
			ReadAllowedForAllAccessGroups = False;
			ChangeAllowedForAllAccessGroups = False;
			AddAllowedForAllAccessGroups = False;
		EndIf;
		
		If ReadRight = "False"
		 Or TypeOf(ReadRight) = Type("Map")
		   And ReadRight.Count() = 0 Then
			
			Continue;
		EndIf;
		
		If AccessGroupRights1.UnrestrictedUpdateRight
		   And AccessGroupRights1.UnrestrictedAddRight Then
			
			RightUpdate = "True";
			
		ElsIf Not AccessGroupRights1.RightUpdate Then
			RightUpdate = "False";
			
		ElsIf ParametersOfUpdate.HasLimitChanges Then
			RightUpdate = CalculatedConditionForRows(Context,
				ParametersOfUpdate.RightCalculationStructureUpdate);
			
		ElsIf WithoutWriteReadRight
		      Or AccessGroupRights1.UnrestrictedReadRight Then
			
			RightUpdate = CalculatedConditionForRows(Context,
				ParametersOfUpdate.ReadRightCalculationStructure);
		Else
			RightUpdate = "True";
		EndIf;
		
		AddRight = ?(AccessGroupRights1.AddRight, RightUpdate, "False");
		
		If AccessGroupRights1.UnrestrictedUpdateRight Then
			RightUpdate = "True";
		EndIf;
		
		If RightUpdate <> "True" Then
			ChangeAllowedForAllAccessGroups = False;
		EndIf;
		If AddRight <> "True" Then
			AddAllowedForAllAccessGroups = False;
		EndIf;
		
		If Context.CalculateUserRights Then
			AddUsersRightsToAccessKey(RightsToKey,
				ReadRight, RightUpdate, AddRight, Context);
		
		ElsIf Not WithoutWriteReadRight Or RightUpdate = "True" Or AddRight = "True" Then
			RightsToKey.ForGroups.Insert(AccessGroup, New Structure("RightUpdate, AddRight",
				RightUpdate = "True", AddRight = "True"));
		EndIf;
	EndDo;
	
	If Not ReadAllowedForAllAccessGroups
	 Or ParametersOfUpdate.HasDependantListsWithoutAccessKeysRecords
	   And Not ParametersOfUpdate.ReadingAllowedForAllUsers Then
		
		Return RightsToKey;
	EndIf;
	
	If AddAllowedForAllAccessGroups
	   And ( Not ParametersOfUpdate.HasDependantListsWithoutAccessKeysRecords
	      Or ParametersOfUpdate.EditionAllowedForAllUsers) Then
		
		RightsToKey = New Structure("ForGroups, ForUsers", New Map, New Map);
		RightsToKey.ForGroups.Insert(ParametersOfUpdate.BlankAccessGroup,
			New Structure("RightUpdate, AddRight", True, True));
		
	Else // ReadAllowedForAllAccessGroups.
		CurrentRightsToKey = RightsToKey;
		RightsToKey = New Structure("ForGroups, ForUsers", New Map, New Map);
		If Not WithoutWriteReadRight Or ChangeAllowedForAllAccessGroups Then
			RightsToKey.ForGroups.Insert(ParametersOfUpdate.BlankAccessGroup,
				New Structure("RightUpdate, AddRight", ChangeAllowedForAllAccessGroups, False));
		EndIf;
		NameOfRight = ?(ChangeAllowedForAllAccessGroups, "AddRight", "RightUpdate");
		For Each KeyAndValue In CurrentRightsToKey.ForGroups Do
			If KeyAndValue.Value[NameOfRight] Then
				RightsToKey.ForGroups.Insert(KeyAndValue.Key, KeyAndValue.Value);
			EndIf;
		EndDo;
		For Each KeyAndValue In CurrentRightsToKey.ForUsers Do
			If KeyAndValue.Value[NameOfRight] Then
				RightsToKey.ForUsers.Insert(KeyAndValue.Key, KeyAndValue.Value);
			EndIf;
		EndDo;
	EndIf;
	
	Return RightsToKey;
	
EndFunction

// For the RightsToListAccessKey procedure.
Procedure AddUsersRightsToAccessKey(RightsToKey, ReadRight, RightUpdate, AddRight, Context)
	
	If TypeOf(RightUpdate) = Type("Map") And RightUpdate.Count() = 0 Then
		RightUpdate  = "False";
		AddRight = "False";
		
	ElsIf TypeOf(AddRight) = Type("Map") And AddRight.Count() = 0 Then
		AddRight = "False";
	EndIf;
	
	Rights = NewRights(RightUpdate = "True", AddRight = "True");
	
	If TypeOf(ReadRight) <> Type("Map") Then
		If Not Context.WithoutWriteReadRight Or Rights.RightUpdate Or Rights.AddRight Then
			RightsToKey.ForGroups.Insert(Context.AccessGroup,
				New Structure("RightUpdate, AddRight",
					Rights.RightUpdate, Rights.AddRight));
		EndIf;
	Else
		AddRightsToAccessKeyToUsers(RightsToKey.ForUsers,
			ReadRight, Rights.RightUpdate, Rights.AddRight, Context.WithoutWriteReadRight);
	EndIf;
	
	If TypeOf(RightUpdate)  <> Type("Map")
	   And TypeOf(AddRight) <> Type("Map") Then
		Return;
	EndIf;
	
	Right = ?(TypeOf(RightUpdate) = Type("Map"), RightUpdate, AddRight);
	AddRightsToAccessKeyToUsers(RightsToKey.ForUsers,
		Right, True, AddRight <> "False", Context.WithoutWriteReadRight);
	
EndProcedure

// Returns:
//   Structure:
//     * RightUpdate  - Boolean
//     * AddRight - Boolean
//
Function NewRights(RightUpdate, AddRight)
	
	Return New Structure("RightUpdate, AddRight", RightUpdate, AddRight);
	
EndFunction

// For the AddUsersRightsToAccessKey procedure.
Procedure AddRightsToAccessKeyToUsers(RightsToAccessKeyForUsers,
				UsersContent, RightUpdate, AddRight, WithoutWriteReadRight)
	
	If RightUpdate And AddRight Then
		For Each KeyAndValue In UsersContent Do
			RightsToAccessKeyForUsers.Insert(KeyAndValue.Key,
				New Structure("RightUpdate, AddRight", True, True));
		EndDo;
		
	ElsIf Not RightUpdate And Not AddRight Then
		If Not WithoutWriteReadRight Then
			For Each KeyAndValue In UsersContent Do
				Rights = RightsToAccessKeyForUsers.Get(KeyAndValue.Key);
				If Rights = Undefined Then
					Rights = New Structure("RightUpdate, AddRight", False, False);
					RightsToAccessKeyForUsers.Insert(KeyAndValue.Key, Rights);
				EndIf;
			EndDo;
		EndIf;
	Else
		For Each KeyAndValue In UsersContent Do
			Rights = RightsToAccessKeyForUsers.Get(KeyAndValue.Key); // See NewRights
			If Rights = Undefined Then
				Rights = New Structure("RightUpdate, AddRight",
					RightUpdate, AddRight);
			Else
				Rights.RightUpdate  = Rights.RightUpdate  Or RightUpdate;
				Rights.AddRight = Rights.AddRight Or AddRight;
			EndIf;
			RightsToAccessKeyForUsers.Insert(KeyAndValue.Key, Rights);
		EndDo;
	EndIf;
	
EndProcedure

// For the RightsToListAccessKey and CalculatedCondition functions.
Function CalculatedConditionForRows(Context, Condition, AttributesNode = Undefined, ForAnyRow = True, RootNode = True)
	
	If AttributesNode = Undefined Then
		Context.Insert("RequiredKeyTablesDetails", New Array);
		If Condition.Node = "ForAllRows" Or Condition.Node = "ForAtLeastOneRow" Then
			Return CalculatedCondition(Context, Condition, RootNode);
		EndIf;
		AttributesNode = Condition;
	EndIf;
	
	If Not ValueIsFilled(AttributesNode.RequiredKeyTabularSectionsAttributes) Then
		Context.Insert("CurrentKeyTableRows", Context.KeyTablesValues);
		Return CalculatedCondition(Context, Condition, RootNode);
	EndIf;
	TablesAttributes    = AttributesNode.RequiredKeyTabularSectionsAttributes;
	TablesValues     = CurrentKeyTablesValues(Context, TablesAttributes);
	TablesRowsIndexes = New Map;
	
	Context.RequiredKeyTablesDetails.Add(
		New Structure("TablesAttributes, TablesValues, TablesRowsIndexes",
			TablesAttributes, TablesValues, TablesRowsIndexes));
	
	CurrentKeyTableRows = ?(Context.Property("CurrentKeyTableRows"),
		Context.CurrentKeyTableRows, Undefined);
	
	Context.Insert("CurrentKeyTableRows", New Structure);
	For Each ValuesDetails In Context.KeyTablesValues Do
		If StrStartsWith(ValuesDetails.Key, "Header") Then
			Context.CurrentKeyTableRows.Insert(ValuesDetails.Key, ValuesDetails.Value);
		EndIf;
	EndDo;
	
	Result = "Undefined";
	
	While True Do
		IndexChanged = False;
		For Each TableDetails In TablesAttributes Do
			KeyTableName = TableDetails.Key;
			RowIndex = TablesRowsIndexes.Get(KeyTableName);
			TableValues = TablesValues[KeyTableName];
			If RowIndex = Undefined Then
				RowIndex = 0;
			Else
				If RowIndex >= TableValues.Count() - 1 Then
					Continue;
				EndIf;
				RowIndex = RowIndex + 1;
			EndIf;
			IndexChanged = True;
			TablesRowsIndexes.Insert(KeyTableName, RowIndex);
			Context.CurrentKeyTableRows.Insert(KeyTableName, TableValues[RowIndex]);
		EndDo;
		If Not IndexChanged Then
			Break;
		EndIf; 
		CurrentResult = CalculatedCondition(Context, Condition);
		If TypeOf(CurrentResult) <> Type("Map") Then
			If ForAnyRow Then
				If CurrentResult = "True" Then
					Result = "True";
					Break;
				ElsIf CurrentResult = "False" Then
					If Result = "Undefined" Or Result = "Empty" Then
						Result = "False";
					EndIf;
				ElsIf CurrentResult = "Empty" Then
					If Result = "Undefined" Then
						Result = "Empty";
					EndIf;
				EndIf;
			Else
				If CurrentResult = "False" Then
					Result = "False";
					Break;
				ElsIf CurrentResult = "True" Then
					If Result = "Undefined" Or Result = "Empty" Then
						Result = "True";
					EndIf;
				ElsIf CurrentResult = "Empty" Then
					If Result = "Undefined" Then
						Result = "Empty";
					EndIf;
				EndIf;
			EndIf;
		Else
			If Not ForAnyRow And CurrentResult.Count() = 0 Then
				Result = "False";
				Break;
			EndIf;
			If TypeOf(Result) = Type("String") Then
				Result = CurrentResult;
			Else
				AddCurrentResult(Result, CurrentResult, ForAnyRow, Context);
			EndIf;
		EndIf;
	EndDo;
	
	If Result = "Undefined" Then
		Result = "False";
	ElsIf RootNode And Result = "Empty" Then
		Result = "True";
	EndIf;
	
	Context.RequiredKeyTablesDetails.Delete(
		Context.RequiredKeyTablesDetails.Count() - 1);
	
	Context.Insert("CurrentKeyTableRows", CurrentKeyTableRows);
	
	Return Result;
	
EndFunction

// For the CalculatedConditionForRows function.
Procedure AddCurrentResult(Result, CurrentResult, ForAnyRow, Context)
	
	If ForAnyRow Then
		For Each KeyAndValue In CurrentResult Do
			Result.Insert(KeyAndValue.Key, KeyAndValue.Value);
		EndDo;
	Else
		If Result.Count() > CurrentResult.Count() Then
			SmallerResult = CurrentResult;
			BiggerResult = Result;
		Else
			SmallerResult = Result;
			BiggerResult = CurrentResult;
		EndIf;
		Result = New Map;
		UserGroupType = Undefined;
		
		For Each KeyAndValue In SmallerResult Do
			Member = KeyAndValue.Key;
			If BiggerResult.Get(Member) <> Undefined Then
				Result.Insert(Member, True);
			Else
				If UserGroupType = Undefined Then
					UserGroupType = Context.UserGroupType;
					UserGroupsUsers = Context.UserGroupsUsers;
					BiggerResultGroupsUsers = GroupsUsers(BiggerResult, Context);
				EndIf;
				If TypeOf(Member) = UserGroupType Then
					GroupUsers = UserGroupsUsers.Get(Member);
					If GroupUsers = Undefined Then
						Continue;
					EndIf;
					For Each UserDetails In GroupUsers Do
						If BiggerResultGroupsUsers.Get(UserDetails.Key) <> Undefined Then
							Result.Insert(UserDetails.Key, True);
						EndIf;
					EndDo;
				ElsIf BiggerResultGroupsUsers.Get(Member) <> Undefined Then
					Result.Insert(Member, True);
				EndIf;
			EndIf;
		EndDo;
	EndIf;
	
EndProcedure

// For the AddCurrentResult and SetReverseResult procedures.
Function GroupsUsers(UsersAndGroups, Context)
	
	GroupsUsers = New Map;
	
	UserGroupType = Context.UserGroupType;
	UserGroupsUsers = Context.UserGroupsUsers;
	
	For Each KeyAndValue In UsersAndGroups Do
		If TypeOf(KeyAndValue.Key) = UserGroupType Then
			GroupUsers = UserGroupsUsers.Get(KeyAndValue.Key);
			If GroupUsers <> Undefined Then
				For Each UserDetails In GroupUsers Do
					GroupsUsers.Insert(UserDetails.Key, True);
				EndDo;
			EndIf;
		EndIf;
	EndDo;
	
	Return GroupsUsers;
	
EndFunction

// For the CalculatedCondition function.
Procedure SetReverseResult(Result, Context)
	
	ExceptionsList = Result;
	Result = New Map;
	
	CurrentAccessGroupMembers = Context.AccessGroupsMembers.Get(Context.AccessGroup);
	If CurrentAccessGroupMembers = Undefined Then
		Return;
	EndIf;
	
	UserGroupsUsers = Context.UserGroupsUsers;
	UserGroupType         = Context.UserGroupType;
	UserType                = Context.UserType;
	
	UsersOfGroupsToExclude = GroupsUsers(ExceptionsList, Context);
	
	For Each KeyAndValue In CurrentAccessGroupMembers Do
		Member = KeyAndValue.Key;
		If ExceptionsList.Get(Member) <> Undefined Then
			Continue;
		EndIf;
		If TypeOf(Member) = UserType Then
			If ExceptionsList.Get(Member) = Undefined
			   And UsersOfGroupsToExclude.Get(Member) = Undefined Then
				
				Result.Insert(Member, True);
			EndIf;
		ElsIf TypeOf(Member) = UserGroupType Then
			GroupUsers = UserGroupsUsers.Get(Member);
			If GroupUsers = Undefined Then
				Continue;
			EndIf;
			AllGroupWithoutExceptions = True;
			For Each UserDetails In GroupUsers Do
				If ExceptionsList.Get(UserDetails.Key) <> Undefined
				 Or UsersOfGroupsToExclude.Get(UserDetails.Key) <> Undefined Then
					
					AllGroupWithoutExceptions = False;
					Break;
				EndIf;
			EndDo;
			If AllGroupWithoutExceptions Then
				Result.Insert(Member, True);
			Else
				For Each UserDetails In GroupUsers Do
					If ExceptionsList.Get(UserDetails.Key) = Undefined
					   And UsersOfGroupsToExclude.Get(UserDetails.Key) = Undefined Then
						
						Result.Insert(UserDetails.Key, True);
					EndIf;
				EndDo;
			EndIf;
		EndIf;
	EndDo;
	
EndProcedure

// For the CalculatedConditionForRows function.
//
// Returns:
//  Structure of KeyAndValue:
//   * Key - String -
//   * Value - See KeyTableValues
//
Function CurrentKeyTablesValues(Context, RequiredKeyTabularSectionsAttributes)
	
	CurrentKeyTablesValues = New Structure;
	For Each TableDetails In RequiredKeyTabularSectionsAttributes Do
		KeyTableName = TableDetails.Key;
		Attributes       = TableDetails.Value;
		KeyTableValues = Context.KeyTablesValues[KeyTableName];
		Filter = New Structure;
		For Each CurrentDetails In Context.RequiredKeyTablesDetails Do
			TableAttributes    = CurrentDetails.TablesAttributes.Get(KeyTableName);
			TableValues     = CurrentDetails.TablesValues[KeyTableName];
			TableRowIndex = CurrentDetails.TablesRowsIndexes.Get(KeyTableName);
			TableRow = TableValues[TableRowIndex];
			For Each AttributeName In TableAttributes Do
				Filter.Insert(AttributeName, TableRow[AttributeName]);
			EndDo;
		EndDo;
		TableAttributesTotal = Context.KeyTablesAttributes.Get(KeyTableName).Count();
		If TableAttributesTotal = Attributes.Count() And Not ValueIsFilled(Filter) Then
			CurrentKeyTablesValues.Insert(KeyTableName, KeyTableValues);
			Continue;
		EndIf;
		Rows = KeyTableValues;
		If ValueIsFilled(Filter) Then
			Rows = Rows.FindRows(Filter);
		EndIf;
		TableValues = TableOfKeyNewValues();
		For Each AttributeName In Attributes Do
			TableValues.Columns.Add(AttributeName);
		EndDo;
		For Each String In Rows Do
			FillPropertyValues(TableValues.Add(), String);
		EndDo;
		If Attributes.Count() < TableAttributesTotal Then
			AttributesAsString = StrConcat(Attributes, ", ");
			TableValues.GroupBy(AttributesAsString);
		EndIf;
		CurrentKeyTablesValues.Insert(KeyTableName, TableValues);
	EndDo;
	
	Return CurrentKeyTablesValues;
	
EndFunction

// For the CalculatedConditionForRows function.
Function CalculatedCondition(Context, Condition, RootNode = False)
	
	// Checked types are already considered.
	
	If Condition.Node = "Field" Then
		Value = Context.CurrentKeyTableRows[Condition.Table][Condition.Attribute];
		Result = ?(Value = Enums.AdditionalAccessValues.True
			Or Value = Null And Condition.Property("CheckHasNull"), "True", "False");
		
	ElsIf Condition.Node = "Constant" Then
		Result = ?(Condition.Value = True, "True",
			?(Condition.Value = "Empty", "Empty", "False"));
		
	ElsIf Condition.Node = "And" Then
		
		Result = "Undefined";
		For Each Argument In Condition.Arguments Do
			CurrentResult = CalculatedCondition(Context, Argument);
			If CurrentResult = "False" Then
				Result = "False";
				Break;
			EndIf;
			If CurrentResult = "True" Then
				If Result = "Undefined" Or Result = "Empty" Then
					Result = "True";
				EndIf;
			ElsIf CurrentResult = "Empty" Then
				If Result = "Undefined" Then
					Result = "Empty";
				EndIf;
			ElsIf TypeOf(CurrentResult) = Type("Map") Then
				If CurrentResult.Count() = 0 Then
					Result = "False";
					Break;
				EndIf;
				If TypeOf(Result) = Type("String") Then
					Result = CurrentResult;
				Else
					AddCurrentResult(Result, CurrentResult, False, Context);
				EndIf;
			EndIf;
		EndDo;
		If Result = "Undefined" Then
			Result = "False";
		EndIf;
		
	ElsIf Condition.Node = "Or" Then
		
		Result = "Undefined";
		For Each Argument In Condition.Arguments Do
			CurrentResult = CalculatedCondition(Context, Argument);
			If CurrentResult = "True" Then
				Result = "True";
				Break;
			EndIf;
			If CurrentResult = "False" Then
				If Result = "Undefined" Or Result = "Empty" Then
					Result = "False";
				EndIf;
			ElsIf CurrentResult = "Empty" Then
				If Result = "Undefined" Then
					Result = "Empty";
				EndIf;
			ElsIf TypeOf(CurrentResult) = Type("Map") Then
				If CurrentResult.Count() = 0 Then
					If Result = "Undefined" Then
						Result = "False";
					EndIf;
				ElsIf TypeOf(Result) = Type("String") Then
					Result = CurrentResult;
				Else
					AddCurrentResult(Result, CurrentResult, True, Context);
				EndIf;
			EndIf;
		EndDo;
		If Result = "Undefined" Then
			Result = "False";
		EndIf;
		
	ElsIf Condition.Node = "Not" Then
		Result = CalculatedCondition(Context, Condition.Argument);
		If Result = "True" Then
			Result = "False";
		ElsIf Result = "False" Then
			Result = "True";
		ElsIf TypeOf(Result) = Type("Map") Then
			If Result.Count() = 0 Then
				Result = "True";
			Else
				SetReverseResult(Result, Context);
			EndIf;
		EndIf;
		
	ElsIf Condition.Node = "ForAllRows"
	      Or Condition.Node = "ForAtLeastOneRow" Then
		
		Result = CalculatedConditionForRows(Context,
			Condition.Argument, Condition, Condition.Node = "ForAtLeastOneRow", False);
		
	ElsIf Condition.Node = "Case" Then
		Result = Undefined;
		For Each When In Condition.When Do
			If CalculatedCondition(Context, When.Condition) = "True" Then
				Result = CalculatedCondition(Context, When.Value);
				Break;
			EndIf;
		EndDo;
		If Result = Undefined Then
			Result = CalculatedCondition(Context, Condition.Else);
		EndIf;
		
	ElsIf Condition.Node = "ValueAllowed"
	      Or Condition.Node = "IsAuthorizedUser"
	      Or Condition.Node = "ObjectReadingAllowed"
	      Or Condition.Node = "ObjectUpdateAllowed"
	      Or Condition.Node = "ListReadingAllowed"
	      Or Condition.Node = "ListUpdateAllowed" Then
		
		Value = Context.CurrentKeyTableRows[Condition.Field.Table][Condition.Field.Attribute];
		If Value = Null Then
			Value = Enums.AdditionalAccessValues.Null;
		EndIf;
		DisabledAsFalse = Condition.ComparisonClarifications.Get("Disabled") = "False";
		
		If Value = Enums.AdditionalAccessValues.ValidType Then
			If DisabledAsFalse Then
				CurrentResult = "Empty";
			Else
				CurrentResult = "True";
			EndIf;
			
		ElsIf Value = Enums.AdditionalAccessValues.ProhibitedType Then
			If DisabledAsFalse Then
				CurrentResult = "Empty";
			Else
				CurrentResult = "False";
			EndIf;
		Else
			CurrentResult = Undefined;
			For Each ComparisonClarification In Condition.ComparisonClarifications Do
				If ComparisonClarification.Key = "Null"
				 Or ComparisonClarification.Key = "Undefined" Then
					If Value = Enums.AdditionalAccessValues[ComparisonClarification.Key] Then
						CurrentResult = ComparisonClarification.Value;
						Break;
					EndIf;
				ElsIf ComparisonClarification.Key = "EmptyRef" Then
					If Value = Enums.AdditionalAccessValues.EmptyRefAnyType
					 Or Value.IsEmpty() Then
						CurrentResult = ComparisonClarification.Value;
						Break;
					EndIf;
				ElsIf ComparisonClarification.Key = TypeOf(Value) Then
					CurrentResult = ComparisonClarification.Value;
					Break;
				EndIf;
			EndDo;
		EndIf;
		
		If CurrentResult <> Undefined Then
			Result = CurrentResult;
			
		ElsIf Condition.Node = "ValueAllowed" Then
			If Value = Enums.AdditionalAccessValues.Null
			 Or Value = Enums.AdditionalAccessValues.Undefined Then
				If DisabledAsFalse Then
					Result = "Empty";
				Else
					Result = "False";
				EndIf;
			Else
				If Context.AccessGroupValues = Undefined Then
					ValuesOfOneType = Undefined;
				Else
					ValueType = TypeOf(Value);
					ValuesOfOneType = Context.AccessGroupValues.Get(ValueType);
				EndIf;
				If ValuesOfOneType = Undefined Then
					If DisabledAsFalse Then
						Result = "Empty";
					Else
						Result = "True";
					EndIf;
				Else
					ValueSpecified = ValuesOfOneType.Values.Get(Value) <> Undefined;
					If Not ValueSpecified And ValueType = Context.UserType Then
						ValueSpecified = ValueSpecifiedInUsersGroup(Value, Context);
					EndIf;
					Result = "False";
					If    ValueSpecified And Not ValuesOfOneType.AllAllowed
					 Or Not ValueSpecified And    ValuesOfOneType.AllAllowed Then
						Result = "True";
						
					ElsIf ValueType = Context.UserType Then
						FillResultForUser(Result, Value, Context);
						
					ElsIf ValueType = Context.UserGroupType Then
						FillResultForUserGroup(Result, Value, Context);
					EndIf;
				EndIf;
			EndIf;
			
		ElsIf Condition.Node = "IsAuthorizedUser" Then
			If TypeOf(Value) = Context.UserType Then
				FillResultForUser(Result, Value, Context);
			Else
				Result = "False";
			EndIf;
			
		ElsIf TypeOf(Value) = Type("CatalogRef.AccessKeys") Then
			RightsToList = Context.RightsToLeadingAccessKeysLists.Get(Value);
			If RightsToList = Undefined Then
				Result = "False";
			Else
				RightUpdate = RightsToList.ByAccessGroups.Get(Context.AccessGroup);
				If Condition.Node =    "ObjectReadingAllowed" And RightUpdate = Undefined
				 Or Condition.Node = "ObjectUpdateAllowed" And RightUpdate <> True Then
					Result = "False";
				
				ElsIf Condition.Node =    "ObjectReadingAllowed" And RightsToList.RightToWriteRestrictionDisabled
					  Or Condition.Node = "ObjectUpdateAllowed" And RightsToList.RestrictionDisabled Then
					
					Result = "True";
				Else
					RightsToLeadingAccessKey = Context.RightsToLeadingAccessKeys.Get(Value);
					If RightsToLeadingAccessKey = Undefined Then
						Result = "False";
						
					ElsIf Context.CalculateUserRights Then
						If Condition.Node = "ObjectReadingAllowed"
						 Or Condition.Node = "ObjectUpdateAllowed" Then
							
							Result = New Map;
							CheckTheRightToChange = Condition.Node <> "ObjectReadingAllowed";
							For Each KeyAndValue In RightsToLeadingAccessKey Do
								If CheckTheRightToChange And Not KeyAndValue.Value Then
									Continue;
								EndIf;
								If TypeOf(KeyAndValue.Key) <> Context.AccessGroupType Then
									Result.Insert(KeyAndValue.Key, True);
									
								ElsIf KeyAndValue.Key = Context.AccessGroup Then
									AccessGroupMembers = Context.AccessGroupsMembers.Get(
										Context.AccessGroup);
									If AccessGroupMembers <> Undefined Then
										If Result.Count() = 0 Then
											Result = New Map(
												New FixedMap(AccessGroupMembers));
										Else
											For Each DescriptionOfTheParticipant In AccessGroupMembers Do
												Result.Insert(DescriptionOfTheParticipant.Key, True);
											EndDo;
										EndIf;
									EndIf;
								ElsIf KeyAndValue.Key = Context.BlankAccessGroup Then
									Result = "True";
									Break;
								EndIf;
							EndDo;
						Else
							Result = "False";
						EndIf;
					Else
						RightUpdate = RightsToLeadingAccessKey.Get(Context.AccessGroup);
						If Condition.Node =    "ObjectReadingAllowed" And RightUpdate <> Undefined
						 Or Condition.Node = "ObjectUpdateAllowed" And RightUpdate = True Then
							Result = "True";
						Else
							Result = "False";
						EndIf;
					EndIf;
				EndIf;
			EndIf;
			
		ElsIf Context.RightsSettingsOwnersTypes.Get(TypeOf(Value)) <> Undefined Then
			RightsByRightsSettingsOwner = Context.RightsByRightsSettingsOwners.Get(Value);
			If RightsByRightsSettingsOwner = Undefined Then
				Result = "False";
				
			ElsIf Condition.Node = "ObjectReadingAllowed" Then
				Result = New Map(RightsByRightsSettingsOwner);
				
			ElsIf Condition.Node = "ObjectUpdateAllowed" Then
				Result = New Map;
				For Each KeyAndValue In RightsByRightsSettingsOwner Do
					If KeyAndValue.Value Then
						Result.Insert(KeyAndValue.Key, True);
					EndIf;
				EndDo;
			Else
				Result = "False";
			EndIf;
			
		Else // Checking rights to the list.
			RightsToLeadingList = Context.RightsToLeadingLists.Get(Value);
			If RightsToLeadingList = Undefined Then
				RightsToLeadingList = Context.RightsToLeadingLists.Get(TypeOf(Value));
			EndIf;
			If RightsToLeadingList = Undefined Then
				Result = "False";
			Else
				RightUpdate = RightsToLeadingList.Get(Context.AccessGroup);
				If Condition.Node = "ListReadingAllowed"     And RightUpdate <> Undefined
				 Or Condition.Node = "ObjectReadingAllowed"    And RightUpdate <> Undefined
				 Or Condition.Node = "ListUpdateAllowed"  And RightUpdate = True
				 Or Condition.Node = "ObjectUpdateAllowed" And RightUpdate = True Then
					
					If Context.CalculateUserRights Then
						AccessGroupMembers = Context.AccessGroupsMembers.Get(Context.AccessGroup);
						If AccessGroupMembers <> Undefined Then
							Result = New Map(New FixedMap(AccessGroupMembers));
						Else
							Result = "False";
						EndIf;
					Else
						Result = "True";
					EndIf;
				Else
					Result = "False";
				EndIf;
			EndIf;
		EndIf;
		
	ElsIf Condition.Node = "AccessRight" Then
		Result = ?(ThereIsAnAccessRightInTheRolesOfTheAccessGroupProfile(Condition, Context), "True", "False");
		
	ElsIf Condition.Node = "IsInRole" Then
		Result = ?(ThereIsARoleInTheAccessGroupProfile(Condition, Context), "True", "False");
		
	Else
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Cannot calculate the access key rights as node ""%1"" is not supported.';"),
			Condition.Node);
		Raise ErrorText;
	EndIf;
	
	If RootNode And Result = "Empty" Then
		Result = "True";
	EndIf;
	
	Return Result;
	
EndFunction

// For the CalculatedCondition function.
Function ValueSpecifiedInUsersGroup(User, Context)
	
	SpecifiedUsersGroups = Context.AccessGroupValues.Get(Context.UserGroupType);
	If SpecifiedUsersGroups = Undefined Then
		Return False;
	EndIf;
	
	For Each SpecifiedUsersGroup In SpecifiedUsersGroups.Values Do
		GroupUsers = Context.UserGroupsAsAccessValues.Get(SpecifiedUsersGroup.Key);
		If GroupUsers = Undefined Then
			Continue;
		EndIf;
		If GroupUsers.Get(User) <> Undefined Then
			Return True;
		EndIf;
	EndDo;
	
	Return False;
	
EndFunction

// For the CalculatedCondition function.
Procedure FillResultForUser(Result, User, Context)
	
	Result = "False";
	
	AccessGroupMembers = Context.AccessGroupsMembers.Get(Context.AccessGroup);
	If AccessGroupMembers = Undefined Then
		Return;
	EndIf;
	If AccessGroupMembers.Get(User) <> Undefined Then
		Result = New Map;
		Result.Insert(User, True);
		Return;
	EndIf;
	
	AccessGroupUserGroups = Context.AccessGroupsUserGroups.Get(Context.AccessGroup);
	If AccessGroupUserGroups = Undefined Then
		Return;
	EndIf;
	
	For Each GroupUsersDetails In AccessGroupUserGroups Do
		If GroupUsersDetails.Value.Get(User) <> Undefined Then
			Result = New Map;
			Result.Insert(User, True);
			Return;
		EndIf;
	EndDo;
	
EndProcedure

// For the CalculatedCondition function.
Procedure FillResultForUserGroup(Result, UsersGroup, Context)
	
	Result = "False";
	
	AccessGroupMembers = Context.AccessGroupsMembers.Get(Context.AccessGroup);
	If AccessGroupMembers = Undefined Then
		Return;
	EndIf;
	
	If AccessGroupMembers.Get(UsersGroup) <> Undefined Then
		Result = New Map;
		Result.Insert(UsersGroup, True);
		Return;
	EndIf;
	
	AccessGroupUserGroups = Context.AccessGroupsUserGroups.Get(Context.AccessGroup);
	If AccessGroupUserGroups = Undefined Then
		AccessGroupUserGroups = New Map;
	EndIf;
	
	GroupUsers = Context.UserGroupsUsers.Get(UsersGroup);
	If GroupUsers = Undefined Then
		Return;
	EndIf;
	
	Result = New Map;
	For Each UserDetails In GroupUsers Do
		If AccessGroupMembers.Get(UserDetails.Key) <> Undefined Then
			Result.Insert(UserDetails.Key, True);
			Continue;
		EndIf;
		For Each GroupUsersDetails In AccessGroupUserGroups Do
			If GroupUsersDetails.Value.Get(UserDetails.Key) <> Undefined Then
				Result.Insert(UserDetails.Key, True);
				Break;
			EndIf;
		EndDo;
	EndDo;
	
	If Result.Count() = 0 Then
		Result = "False";
	EndIf;
	
EndProcedure

// For the CalculatedCondition function.
Function ThereIsAnAccessRightInTheRolesOfTheAccessGroupProfile(Condition, Context)
	
	FullName = Condition.FullMetadataObjectName;
	LongDesc = Context.MetadataObjectsFunctionsAccessRights.Get(FullName);
	If LongDesc = Undefined Then
		LongDesc = New Structure("MetadataObject, TheNameOfTheStandardProps");
		LongDesc.MetadataObject = MetadataObjectByFullNameForCheckingTheRight(
			FullName, LongDesc.TheNameOfTheStandardProps);
		Context.MetadataObjectsFunctionsAccessRights.Insert(FullName, LongDesc);
	EndIf;
	
	TableRow = Context.ProfilesAccessGroups.Find(Context.AccessGroup, "AccessGroup");
	If TableRow = Undefined Then
		Return False;
	EndIf;
	
	ProfileRights = Context.ProfileRightsFunctionsAccessRights.Get(TableRow.Profile);
	If ProfileRights = Undefined Then
		ProfileRights = New Map;
		Context.ProfileRightsFunctionsAccessRights.Insert(TableRow.Profile, ProfileRights);
	EndIf;
	
	TheKeyOfTheRightInTheProfileRoles = FullName + "/" + Condition.NameOfRight;
	ThereIsARightInTheProfileRoles = ProfileRights.Get(TheKeyOfTheRightInTheProfileRoles);
	If TypeOf(ThereIsARightInTheProfileRoles) = Type("Boolean") Then
		Return ThereIsARightInTheProfileRoles;
	EndIf;
	
	Filter = New Structure("Profile", TableRow.Profile);
	ProfileRoles = Context.RolesOfAccessGroupProfiles.FindRows(Filter);
	
	ThereIsARightInTheRole = False;
	For Each RoleDetails In ProfileRoles Do
		RoleRightKey = RoleDetails.NameOfRole + "/" + FullName + "/" + Condition.NameOfRight;
		ThereIsARightInTheRole = Context.RoleRightsFunctionsAccessRights.Get(RoleRightKey);
		If ThereIsARightInTheRole = Undefined Then
			If ValueIsFilled(RoleDetails.NameOfRole) Then
				FullNameOfTheRole = "Role." + RoleDetails.NameOfRole;
				Role = Context.MetadataObjectsFunctionsAccessRights.Get(FullNameOfTheRole);
				If Role = Undefined Then
					Role = Metadata.Roles[RoleDetails.NameOfRole];
					Context.MetadataObjectsFunctionsAccessRights.Insert(FullNameOfTheRole, Role);
				EndIf;
				ThereIsARightInTheRole = AccessRight(Condition.NameOfRight, LongDesc.MetadataObject, Role,
					LongDesc.TheNameOfTheStandardProps);
			Else
				ThereIsARightInTheRole = False;
			EndIf;
			Context.RoleRightsFunctionsAccessRights.Insert(RoleRightKey, ThereIsARightInTheRole);
		EndIf;
		If ThereIsARightInTheRole Then
			Break;
		EndIf;
	EndDo;
	
	ProfileRights.Insert(TheKeyOfTheRightInTheProfileRoles, ThereIsARightInTheRole);
	
	Return ThereIsARightInTheRole;
	
EndFunction

// For the CalculatedCondition function.
Function ThereIsARoleInTheAccessGroupProfile(Condition, Context)
	
	TableRow = Context.ProfilesAccessGroups.Find(Context.AccessGroup, "AccessGroup");
	If TableRow = Undefined Then
		Return False;
	EndIf;
	
	Filter = New Structure("Profile,RoleNameUppercase", TableRow.Profile, Upper(Condition.NameOfRole));
	
	Return Context.RolesOfAccessGroupProfiles.FindRows(Filter).Count() > 0;
	
EndFunction

// For the UpdateRightsOfListAccessKeysBatch procedure.
Procedure UpdateRightsToListAccessKey(AccessKey, RightsToKey, NewKeysDetails, ParametersOfUpdate)
	
	If ParametersOfUpdate.CalculateUserRights Then
		RightsToAccessKeyForUsers = New Map;
		UserType = ParametersOfUpdate.UserType;
		For Each KeyAndValue In RightsToKey.ForUsers Do
			If TypeOf(KeyAndValue.Key) = UserType Then
				Set = Catalogs.SetsOfAccessGroups.GetRef(KeyAndValue.Key.UUID());
				RightsToAccessKeyForUsers.Insert(Set, KeyAndValue.Value);
			Else
				RightsToKey.ForGroups.Insert(KeyAndValue.Key, KeyAndValue.Value);
			EndIf;
		EndDo;
	EndIf;
	
	Block = New DataLock;
	
	GroupsQuery = New Query;
	GroupsQuery.SetParameter("AccessKey", AccessKey);
	GroupsQuery.Text =
	"SELECT
	|	AccessGroupsAccessKeys.AccessGroup AS AccessGroup,
	|	AccessGroupsAccessKeys.RightUpdate AS RightUpdate,
	|	AccessGroupsAccessKeys.AddRight AS AddRight
	|FROM
	|	InformationRegister.AccessGroupsAccessKeys AS AccessGroupsAccessKeys
	|WHERE
	|	AccessGroupsAccessKeys.AccessKey = &AccessKey
	|	AND &QueryPlanClarification";
	SetQueryPlanClarification(GroupsQuery.Text);
	
	GroupsLockItem = Block.Add("InformationRegister.AccessGroupsAccessKeys");
	GroupsLockItem.SetValue("AccessKey", AccessKey);
	GroupsRecordSet = ServiceRecordSet(InformationRegisters.AccessGroupsAccessKeys);
	GroupsRecordSet.Filter.AccessKey.Set(AccessKey);
	
	AccessGroupsSetsQuery = New Query;
	AccessGroupsSetsQuery.SetParameter("AccessKey", AccessKey);
	AccessGroupsSetsQuery.SetParameter("AllowedBlankSet",
		AccessManagementInternalCached.AllowedBlankAccessGroupsSet());
	
	AccessGroupsSetsQuery.Text = DifferencesSelectionOfDerivedRightsQueryTextForAccessGroups();
	LockItem = Block.Add("InformationRegister.AccessGroupSetsAccessKeys");
	LockItem.SetValue("AccessKey", AccessKey);
	AccessGroupsSetsRecordSet = ServiceRecordSet(InformationRegisters.AccessGroupSetsAccessKeys);
	AccessGroupsSetsRecordSet.Filter.AccessKey.Set(AccessKey);
	
	If ParametersOfUpdate.CalculateUserRights Then
		Query = New Query;
		Query.SetParameter("AccessKey", AccessKey);
		
		If Not ParametersOfUpdate.ForExternalUsers Then
			Query.Text = DifferencesSelectionOfDerivedRightsQueryTextForUsers();
			RightsOwnerFieldName = "User";
			LockItem = Block.Add("InformationRegister.UsersAccessKeys");
			RecordSet = ServiceRecordSet(InformationRegisters.UsersAccessKeys);
		Else
			Query.Text = DifferencesSelectionOfDerivedRightsQueryTextForExternalUsers();
			RightsOwnerFieldName = "ExternalUser";
			LockItem = Block.Add("InformationRegister.ExternalUsersAccessKeys");
			RecordSet = ServiceRecordSet(InformationRegisters.ExternalUsersAccessKeys);
		EndIf;
		LockItem.SetValue("AccessKey", AccessKey);
		RecordSet.Filter.AccessKey.Set(AccessKey);
	EndIf;
	
	If NewKeysDetails <> Undefined Then
		NewKeyDetails = NewKeysDetails.KeysDetailsByRef.Get(AccessKey);
		AccessKeyObject = NewKeyDetails.AccessKeyObject; // CatalogObject.AccessKeys
		KeyLockItem = Block.Add("Catalog.AccessKeys");
		KeyLockItem.SetValue("Hash",                     AccessKeyObject.Hash);
		KeyLockItem.SetValue("List",                  AccessKeyObject.List);
		KeyLockItem.SetValue("ForExternalUsers", AccessKeyObject.ForExternalUsers);
		KeyLockItem.SetValue("FieldsComposition",             AccessKeyObject.FieldsComposition);
	EndIf;
	
	UpdateManually = ParametersOfUpdate.Property("UpdateRightsToKeys")
		And ParametersOfUpdate.UpdateRightsToKeys;
	
	If Common.FileInfobase() Then
		If NewKeysDetails <> Undefined Then
			LockItem = Block.Add("Catalog.AccessKeys");
		EndIf;
		LockItem = Block.Add("Catalog.SetsOfAccessGroups");
		LockItem.Mode = DataLockMode.Shared;
	EndIf;
	
	BeginTransaction();
	Try
		BeforeDataLock(ParametersOfUpdate);
		Block.Lock();
		If Common.FileInfobase() Then
			LockRegistersSchedulingUpdateAccessKeysInFileIB();
		EndIf;
		AfterDataLock(ParametersOfUpdate);
		
		HasRightsChanges = False;
		
		If NewKeysDetails = Undefined
		 Or Not NewAccessKeyAlreadyExists(NewKeysDetails, NewKeyDetails, ParametersOfUpdate) Then
			
			If NewKeysDetails <> Undefined Then
				BeforeWriteNewKey(ParametersOfUpdate);
				AccessKeyObject.Write();
				AfterWriteNewKey(ParametersOfUpdate);
			EndIf;
			
			BeforeAccessGroupsRightsQuery(ParametersOfUpdate);
			GroupsRequestResult = GroupsQuery.Execute();
			AfterAccessGroupsRightsQuery(ParametersOfUpdate);
			
			HasChanges = New Structure("AccessGroupRights, UserGroupRights", False, False);
			UpdateInitialGroupsRightsToAccessKey(GroupsRequestResult, GroupsRecordSet, "AccessGroup",
				AccessKey, RightsToKey.ForGroups, ParametersOfUpdate, HasChanges);
			
			HasRightsChanges = HasChanges.AccessGroupRights Or HasChanges.UserGroupRights;
			
			If HasChanges.AccessGroupRights Or UpdateManually Then
				BeforeDerivedRightsChangesQuery(ParametersOfUpdate);
				AccessGroupsSetsQueryResult = AccessGroupsSetsQuery.Execute();
				AfterDerivedRightsChangesQuery(ParametersOfUpdate);
				UpdateDerivedRightsToAccessKey(AccessGroupsSetsQueryResult,
					AccessGroupsSetsRecordSet, "AccessGroupsSet", AccessKey, , ParametersOfUpdate);
			EndIf;
			
			If ParametersOfUpdate.CalculateUserRights Then
				PackageQueries = StrSplit(Query.Text, ";", False);
				If HasChanges.UserGroupRights Or UpdateManually Then
					Query.Text = PackageQueries[1];
					BeforeDerivedRightsChangesQuery(ParametersOfUpdate);
					QueryResult = Query.Execute();
					AfterDerivedRightsChangesQuery(ParametersOfUpdate);
					UpdateDerivedRightsToAccessKey(QueryResult,
						RecordSet, RightsOwnerFieldName, AccessKey, , ParametersOfUpdate);
					RecordSet.Clear();
				EndIf;
				Query.Text = PackageQueries[0];
				BeforeUsersRightsQuery(ParametersOfUpdate);
				UsersQueryResult = Query.Execute();
				AfterUsersRightsQuery(ParametersOfUpdate);
				UpdateInitialUsersRightsToAccessKey(UsersQueryResult, RecordSet,
					RightsOwnerFieldName, AccessKey, RightsToAccessKeyForUsers, HasRightsChanges, ParametersOfUpdate);
			EndIf;
			
			If NewKeysDetails = Undefined
			   And HasRightsChanges
			   And ParametersOfUpdate.DependentListsByAccessKeys.Count() > 0 Then
				
				BeforePlanUpdate(ParametersOfUpdate);
				ScheduleAccessKeysUsersUpdate(ParametersOfUpdate.DependentListsByAccessKeys,
					"UpdateRightsToListAccessKey",
					Not ParametersOfUpdate.ForExternalUsers,
					ParametersOfUpdate.ForExternalUsers, ,
					New Structure("ByAccessKeys", AccessKey));
				AfterPlanUpdate(ParametersOfUpdate);
			EndIf;
		EndIf;
		
		// 
		// 
		// 
		BeforeCommitTransaction(ParametersOfUpdate);
		CommitTransaction();
		AfterCommitTransaction(ParametersOfUpdate);
		// ACC:330-on
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
	If HasRightsChanges And ParametersOfUpdate.Property("HasRightsChanges") Then
		ParametersOfUpdate.HasRightsChanges = True;
	EndIf;
	
EndProcedure

// For the UpdateRightsToListAccessKey and UpdateAccessGroupsOfAllowedAccessKey procedures.
Function DifferencesSelectionOfDerivedRightsQueryTextForAccessGroups()
	
	QueryText =
	"SELECT
	|	AllRows.AccessGroupsSet AS AccessGroupsSet,
	|	AllRows.RightUpdate AS RightUpdate,
	|	AllRows.AddRight AS AddRight,
	|	SUM(AllRows.LineChangeType) AS LineChangeType
	|FROM
	|	(SELECT
	|		GroupsInSets.Ref AS AccessGroupsSet,
	|		MAX(AccessGroupsAccessKeys.RightUpdate) AS RightUpdate,
	|		MAX(AccessGroupsAccessKeys.AddRight) AS AddRight,
	|		1 AS LineChangeType
	|	FROM
	|		InformationRegister.AccessGroupsAccessKeys AS AccessGroupsAccessKeys
	|			INNER JOIN Catalog.SetsOfAccessGroups.Groups AS GroupsInSets
	|			ON (GroupsInSets.Group = AccessGroupsAccessKeys.AccessGroup)
	|				AND (VALUETYPE(GroupsInSets.Group) = TYPE(Catalog.AccessGroups))
	|				AND (VALUETYPE(AccessGroupsAccessKeys.AccessGroup) = TYPE(Catalog.AccessGroups))
	|				AND (AccessGroupsAccessKeys.AccessKey = &AccessKey)
	|				AND (&QueryPlanClarification)
	|	
	|	GROUP BY
	|		GroupsInSets.Ref
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		&AllowedBlankSet,
	|		AccessGroupsAccessKeys.RightUpdate,
	|		AccessGroupsAccessKeys.AddRight,
	|		1
	|	FROM
	|		InformationRegister.AccessGroupsAccessKeys AS AccessGroupsAccessKeys
	|	WHERE
	|		AccessGroupsAccessKeys.AccessGroup = VALUE(Catalog.AccessGroups.EmptyRef)
	|		AND AccessGroupsAccessKeys.AccessKey = &AccessKey
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		OldData.AccessGroupsSet,
	|		OldData.RightUpdate,
	|		OldData.AddRight,
	|		-1
	|	FROM
	|		InformationRegister.AccessGroupSetsAccessKeys AS OldData
	|	WHERE
	|		OldData.AccessKey = &AccessKey) AS AllRows
	|
	|GROUP BY
	|	AllRows.AccessGroupsSet,
	|	AllRows.RightUpdate,
	|	AllRows.AddRight
	|
	|HAVING
	|	SUM(AllRows.LineChangeType) <> 0
	|
	|ORDER BY
	|	LineChangeType";
	
	SetQueryPlanClarification(QueryText);
	
	Return QueryText;
	
EndFunction

// For the UpdateRightsToListAccessKey procedures.
Function DifferencesSelectionOfDerivedRightsQueryTextForUsers()
	
	QueryText =
	"SELECT
	|	UsersAccessKeys.User AS User,
	|	UsersAccessKeys.RightUpdate AS RightUpdate,
	|	UsersAccessKeys.AddRight AS AddRight,
	|	UsersAccessKeys.AreGroupSetRights AS AreGroupSetRights
	|FROM
	|	InformationRegister.UsersAccessKeys AS UsersAccessKeys
	|WHERE
	|	UsersAccessKeys.AccessKey = &AccessKey
	|	AND NOT UsersAccessKeys.AreGroupSetRights
	|	AND &QueryPlanClarification
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	AllRows.User AS User,
	|	AllRows.RightUpdate AS RightUpdate,
	|	AllRows.AddRight AS AddRight,
	|	TRUE AS AreGroupSetRights,
	|	SUM(AllRows.LineChangeType) AS LineChangeType
	|FROM
	|	(SELECT
	|		GroupsInSets.Ref AS User,
	|		MAX(AccessGroupsAccessKeys.RightUpdate) AS RightUpdate,
	|		MAX(AccessGroupsAccessKeys.AddRight) AS AddRight,
	|		1 AS LineChangeType
	|	FROM
	|		InformationRegister.AccessGroupsAccessKeys AS AccessGroupsAccessKeys
	|			INNER JOIN Catalog.SetsOfAccessGroups.Groups AS GroupsInSets
	|			ON (GroupsInSets.Group = AccessGroupsAccessKeys.AccessGroup)
	|				AND (VALUETYPE(GroupsInSets.Group) = TYPE(Catalog.UserGroups))
	|				AND (VALUETYPE(AccessGroupsAccessKeys.AccessGroup) = TYPE(Catalog.UserGroups))
	|				AND (AccessGroupsAccessKeys.AccessKey = &AccessKey)
	|				AND (&QueryPlanClarification)
	|	
	|	GROUP BY
	|		GroupsInSets.Ref
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		OldData.User,
	|		OldData.RightUpdate,
	|		OldData.AddRight,
	|		-1
	|	FROM
	|		InformationRegister.UsersAccessKeys AS OldData
	|	WHERE
	|		OldData.AreGroupSetRights
	|		AND OldData.AccessKey = &AccessKey) AS AllRows
	|
	|GROUP BY
	|	AllRows.User,
	|	AllRows.RightUpdate,
	|	AllRows.AddRight
	|
	|HAVING
	|	SUM(AllRows.LineChangeType) <> 0
	|
	|ORDER BY
	|	LineChangeType";
	
	SetQueryPlanClarification(QueryText);
	
	Return QueryText;
	
EndFunction

// For the UpdateRightsToListAccessKey procedures.
Function DifferencesSelectionOfDerivedRightsQueryTextForExternalUsers()
	
	QueryText =
	"SELECT
	|	ExternalUsersAccessKeys.ExternalUser AS ExternalUser,
	|	ExternalUsersAccessKeys.RightUpdate AS RightUpdate,
	|	ExternalUsersAccessKeys.AddRight AS AddRight,
	|	ExternalUsersAccessKeys.AreGroupSetRights AS AreGroupSetRights
	|FROM
	|	InformationRegister.ExternalUsersAccessKeys AS ExternalUsersAccessKeys
	|WHERE
	|	ExternalUsersAccessKeys.AccessKey = &AccessKey
	|	AND NOT ExternalUsersAccessKeys.AreGroupSetRights
	|	AND &QueryPlanClarification
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	AllRows.ExternalUser AS ExternalUser,
	|	AllRows.RightUpdate AS RightUpdate,
	|	AllRows.AddRight AS AddRight,
	|	TRUE AS AreGroupSetRights,
	|	SUM(AllRows.LineChangeType) AS LineChangeType
	|FROM
	|	(SELECT
	|		GroupsInSets.Ref AS ExternalUser,
	|		MAX(AccessGroupsAccessKeys.RightUpdate) AS RightUpdate,
	|		MAX(AccessGroupsAccessKeys.AddRight) AS AddRight,
	|		1 AS LineChangeType
	|	FROM
	|		InformationRegister.AccessGroupsAccessKeys AS AccessGroupsAccessKeys
	|			INNER JOIN Catalog.SetsOfAccessGroups.Groups AS GroupsInSets
	|			ON (GroupsInSets.Group = AccessGroupsAccessKeys.AccessGroup)
	|				AND (VALUETYPE(GroupsInSets.Group) = TYPE(Catalog.ExternalUsersGroups))
	|				AND (VALUETYPE(AccessGroupsAccessKeys.AccessGroup) = TYPE(Catalog.ExternalUsersGroups))
	|				AND (AccessGroupsAccessKeys.AccessKey = &AccessKey)
	|				AND (&QueryPlanClarification)
	|	
	|	GROUP BY
	|		GroupsInSets.Ref
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		OldData.ExternalUser,
	|		OldData.RightUpdate,
	|		OldData.AddRight,
	|		-1
	|	FROM
	|		InformationRegister.ExternalUsersAccessKeys AS OldData
	|	WHERE
	|		OldData.AreGroupSetRights
	|		AND OldData.AccessKey = &AccessKey) AS AllRows
	|
	|GROUP BY
	|	AllRows.ExternalUser,
	|	AllRows.RightUpdate,
	|	AllRows.AddRight
	|
	|HAVING
	|	SUM(AllRows.LineChangeType) <> 0
	|
	|ORDER BY
	|	LineChangeType";
	
	SetQueryPlanClarification(QueryText);
	
	Return QueryText;
	
EndFunction

// For the UpdateRightsToListAccessKey procedure.
Function NewAccessKeyAlreadyExists(NewKeysDetails, NewKeyDetails, ParametersOfUpdate)
	
	KeysExistenceQuery = NewKeysDetails.KeysExistenceQuery;
	KeysExistenceQuery.SetParameter("Hash", NewKeyDetails.AccessKeyObject.Hash);
	
	If KeysExistenceQuery.Execute().IsEmpty() Then
		Return False;
	EndIf;
	
	KeysValuesQuery = NewKeysDetails.KeysValuesQuery;
	KeysValuesQuery.SetParameter("Hashes", NewKeyDetails.AccessKeyObject.Hash);
	
	KeysValuesQueryResults = KeysValuesQuery.ExecuteBatch();
	
	KeyTables = ParametersOfUpdate.KeyTables;
	KeysRowsValuesKeys = ObjectsRowsValuesKeys(KeysValuesQueryResults,
		?(Not ValueIsFilled(ParametersOfUpdate.FieldsComposition)
			Or StrStartsWith(KeyTables[0], "Header"), 0, 1),
		KeyTables);
	
	Selection = KeysValuesQueryResults[0].Select();
	
	While Selection.Next() Do
		Ref = Selection.CurrentRef; // CatalogRef.AccessKeys
		ValuesKeysDetails = KeysRowsValuesKeys.Get(Ref);
		StringForHash = StringForAccessKeyHash(ValuesKeysDetails, KeyTables);
		If NewKeyDetails.StringForHash = StringForHash Then
			NewKeyDetails.AccessKeyObject = New Structure("Ref", Ref);
			NotUsedSince = Common.ObjectAttributeValue(Ref, "NotUsedSince");
			If ValueIsFilled(NotUsedSince) Then
				Object = ServiceItem(Undefined, Ref);
				Object.NotUsedSince = '00010101';
				Object.Write();
			EndIf;
			Return True;
		EndIf;
	EndDo;
	
	Return False;
	
EndFunction

// For the UpdateRightsToListAccessKey procedure.
Procedure UpdateInitialGroupsRightsToAccessKey(QueryResult, RecordSet, RightsOwnerFieldName,
			 AccessKey, RightsToKey, ParametersOfUpdate, HasChanges)
	
	Selection = QueryResult.Select();
	AccessGroupType = ParametersOfUpdate.AccessGroupType;
	HasAccessGroupsRightsChanges = False;
	HasUsersGroupsRightsChanges = False;
	
	WrittenItemsCount = 0;
	BeforeWriteRows(ParametersOfUpdate);
	While Selection.Next() Do
		RightsOwner = Selection[RightsOwnerFieldName];
		Rights = RightsToKey.Get(RightsOwner); // See NewRights
		If Rights = Undefined Then
			FilterElement = RecordSet.Filter[RightsOwnerFieldName]; // FilterItem
			FilterElement.Set(RightsOwner);
			RecordSet.Write();
			If TypeOf(RightsOwner) = AccessGroupType Then
				HasAccessGroupsRightsChanges = True;
			Else
				HasUsersGroupsRightsChanges = True;
			EndIf;
		ElsIf Selection.RightUpdate  = Rights.RightUpdate
		        And Selection.AddRight = Rights.AddRight Then
			RightsToKey.Insert(RightsOwner, Null);
		EndIf;
	EndDo;
	
	OneRecord = RecordSet.Add();
	OneRecord.AccessKey = AccessKey;
	For Each RightsDetails In RightsToKey Do
		Rights = RightsDetails.Value; // See NewRights
		If Rights = Null Then
			Continue;
		EndIf;
		RightsOwner = RightsDetails.Key;
		FilterElement = RecordSet.Filter[RightsOwnerFieldName]; // FilterItem
		FilterElement.Set(RightsOwner);
		OneRecord[RightsOwnerFieldName] = RightsOwner;
		OneRecord.RightUpdate  = Rights.RightUpdate;
		OneRecord.AddRight = Rights.AddRight;
		RecordSet.Write();
		If TypeOf(RightsOwner) = AccessGroupType Then
			HasAccessGroupsRightsChanges = True;
		Else
			HasUsersGroupsRightsChanges = True;
		EndIf;
		WrittenItemsCount = WrittenItemsCount + 1;
	EndDo;
	AfterWriteRows(ParametersOfUpdate, WrittenItemsCount);
	
	HasChanges.AccessGroupRights       = HasAccessGroupsRightsChanges;
	HasChanges.UserGroupRights = HasUsersGroupsRightsChanges;
	
EndProcedure

// For the UpdateRightsToListAccessKey procedure.
Procedure UpdateInitialUsersRightsToAccessKey(QueryResult, RecordSet,
			RightsOwnerFieldName, AccessKey, RightsToKey, HasRightsChanges, ParametersOfUpdate)
	
	Selection = QueryResult.Select();
	
	WrittenItemsCount = 0;
	BeforeWriteRows(ParametersOfUpdate);
	While Selection.Next() Do
		RightsOwner = Selection[RightsOwnerFieldName];
		Rights = RightsToKey.Get(RightsOwner); // See NewRights
		If Rights = Undefined Then
			FilterElement = RecordSet.Filter[RightsOwnerFieldName]; // FilterItem
			FilterElement.Set(RightsOwner);
			RecordSet.Write();
			HasRightsChanges = True;
		ElsIf Selection.RightUpdate  = Rights.RightUpdate
		        And Selection.AddRight = Rights.AddRight
		        And Selection.AreGroupSetRights = False Then
			RightsToKey.Insert(RightsOwner, Null);
		EndIf;
	EndDo;
	
	OneRecord = RecordSet.Add();
	OneRecord.AccessKey = AccessKey;
	For Each RightsDetails In RightsToKey Do
		Rights = RightsDetails.Value; // See NewRights
		If Rights = Null Then
			Continue;
		EndIf;
		RightsOwner = RightsDetails.Key;
		FilterElement = RecordSet.Filter[RightsOwnerFieldName]; // FilterItem
		FilterElement.Set(RightsOwner);
		OneRecord[RightsOwnerFieldName] = RightsOwner;
		OneRecord.RightUpdate  = Rights.RightUpdate;
		OneRecord.AddRight = Rights.AddRight;
		OneRecord.AreGroupSetRights = False;
		RecordSet.Write();
		HasRightsChanges = True;
		WrittenItemsCount = WrittenItemsCount + 1;
	EndDo;
	AfterWriteRows(ParametersOfUpdate, WrittenItemsCount);
	
EndProcedure

// For the UpdateRightsToListAccessKey procedure.
Procedure UpdateDerivedRightsToAccessKey(QueryResult, RecordSet, RightsOwnerFieldName,
			AccessKey, HasChanges = False, ParametersOfUpdate = Undefined)
	
	Selection = QueryResult.Select();
	DeletionCompleted = False;
	
	WrittenItemsCount = 0;
	BeforeWriteRows(ParametersOfUpdate);
	While Selection.Next() Do
		FilterElement = RecordSet.Filter[RightsOwnerFieldName]; // FilterItem
		FilterElement.Set(Selection[RightsOwnerFieldName]);
		If Not DeletionCompleted And Selection.LineChangeType = 1 Then
			DeletionCompleted = True;
			OneRecord = RecordSet.Add();
			OneRecord.AccessKey = AccessKey;
		EndIf;
		If DeletionCompleted Then
			FillPropertyValues(OneRecord, Selection);
		EndIf;
		RecordSet.Write();
		HasChanges = True;
		WrittenItemsCount = WrittenItemsCount + 1;
	EndDo;
	AfterWriteRows(ParametersOfUpdate, WrittenItemsCount);
	
EndProcedure

// Creates a catalog service item that does not subscribe to events.
Function ServiceItem(CatalogManager, Ref = Undefined)
	
	If Ref = Undefined Then
		CatalogItem = CatalogManager.CreateItem();
	Else
		CatalogItem = Ref.GetObject();
		If CatalogItem = Undefined Then
			Return Undefined;
		EndIf;
	EndIf;
	
	CatalogItem.AdditionalProperties.Insert("DontControlObjectsToDelete");
	CatalogItem.AdditionalProperties.Insert("DisableObjectChangeRecordMechanism");
	CatalogItem.DataExchange.Recipients.AutoFill = False;
	CatalogItem.DataExchange.Load = True;
	
	Return CatalogItem;
	
EndFunction

// Creates a record set of a service register that does subscribe to events.
Function ServiceRecordSet(RegisterManager)
	
	RecordSet = RegisterManager.CreateRecordSet();
	RecordSet.AdditionalProperties.Insert("DontControlObjectsToDelete");
	RecordSet.AdditionalProperties.Insert("DisableObjectChangeRecordMechanism");
	RecordSet.DataExchange.Recipients.AutoFill = False;
	RecordSet.DataExchange.Load = True;
	
	Return RecordSet;
	
EndFunction

// Creates an internal constant value manager that does not subscribe to events.
Function ServiceValueManager(ManagerOfConstant)
	
	ValueManager = ManagerOfConstant.CreateValueManager();
	ValueManager.AdditionalProperties.Insert("DontControlObjectsToDelete");
	ValueManager.AdditionalProperties.Insert("DisableObjectChangeRecordMechanism");
	ValueManager.DataExchange.Recipients.AutoFill = False;
	ValueManager.DataExchange.Load = True;
	
	Return ValueManager;
	
EndFunction

// For the RegisterAccessUpdatePlanning procedure.
Procedure RegisterAccessUpdatePlanningInLog(Lists, PlanningParameters)
	
	CommentForLog = NStr("en = 'Source';", Common.DefaultLanguageCode())
		+ ": " + PlanningParameters.LongDesc + Chars.LF;
	
	If Lists.Count() > 1 Then
		CommentForLog = CommentForLog
			+ NStr("en = 'Lists';", Common.DefaultLanguageCode()) + ":"
			+ Chars.LF + Chars.Tab + StrConcat(Lists, Chars.LF + Chars.Tab);
	Else
		CommentForLog = CommentForLog
			+ NStr("en = 'List';", Common.DefaultLanguageCode());
		
		CommentForLog = CommentForLog + " = " + Lists[0];
	EndIf;
	
	CommentForLog = CommentForLog + Chars.LF + "IsSpotJob"
		+ " = " + ?(PlanningParameters.Property("IsSpotJob"), "Yes", "None");
	
	CommentForLog = CommentForLog + Chars.LF + "DataAccessKeys"
		+ " = " + ?(PlanningParameters.DataAccessKeys, "Yes", "None");
	
	CommentForLog = CommentForLog + Chars.LF + "AllowedAccessKeys"
		+ " = " + ?(PlanningParameters.AllowedAccessKeys, "Yes", "None");
	
	CommentForLog = CommentForLog + Chars.LF + "ForUsers"
		+ " = " + ?(PlanningParameters.ForUsers, "Yes", "None");
	
	CommentForLog = CommentForLog + Chars.LF + "ForExternalUsers"
		+ " = " + ?(PlanningParameters.ForExternalUsers, "Yes", "None");
	
	CommentForLog = CommentForLog + Chars.LF + "IsUpdateContinuation"
		+ " = " + ?(PlanningParameters.IsUpdateContinuation, "Yes", "None");
	
	CommentForLog = CommentForLog + Chars.LF + "IsObsoleteItemsDataProcessor"
	 + " = " + ?(PlanningParameters.IsObsoleteItemsDataProcessor, "Yes", "None");
	
	LeadingObject = Undefined;
	LeadingObjectDetails = PlanningParameters.LeadingObject; // See LeadingObjectDetails
	
	If TypeOf(LeadingObjectDetails) = Type("Structure") Then
		If LeadingObjectDetails.Property("ByFieldsValues") Then
			Pointers = LeadingObjectDetails.ByFieldsValues.LongDesc;
			LeadingObject = "ByFieldsValues";
		ElsIf LeadingObjectDetails.Property("ByAccessKeys") Then
			Pointers = LeadingObjectDetails.ByAccessKeys;
			LeadingObject = "ByAccessKeys";
		ElsIf LeadingObjectDetails.Property("ByValuesWithGroups") Then
			Pointers = LeadingObjectDetails.ByValuesWithGroups;
			LeadingObject = "ByValuesWithGroups";
		EndIf;
		If LeadingObject <> Undefined Then
			If TypeOf(Pointers) = Type("Array") And Pointers.Count() > 1 Then
				LeadingObject = LeadingObject + ":";
				For Each Pointer In Pointers Do
					LeadingObject = LeadingObject + Chars.LF + """" + String(Pointer) + """ "
						+ LeadingObjectPointerDetails(Pointer, PlanningParameters);
				EndDo;
			Else
				Pointer = ?(TypeOf(Pointers) = Type("Array"), Pointers[0], Pointers);
				LeadingObject = LeadingObject + ": """ + String(Pointer) + """ "
					+ LeadingObjectPointerDetails(Pointer, PlanningParameters);
			EndIf;
		EndIf;
		If LeadingObjectDetails.Property("AccordingToTheRightsCalculationCache") Then
			LeadingObject = "AccordingToTheRightsCalculationCache" + ": """
				+ LeadingObjectDetails.AccordingToTheRightsCalculationCache;
		EndIf;
	EndIf;
	
	Try
		Raise NStr("en = 'Call stack';");
	Except
		CallStack = ErrorProcessing.DetailErrorDescription(ErrorInfo());
	EndTry;
	
	CommentForLog = CommentForLog + Chars.LF + Chars.LF + CallStack;
	
	WriteLogEvent(
		NStr("en = 'Access management.Indicators.Schedule access update';",
		     Common.DefaultLanguageCode()),
		EventLogLevel.Information, ,
		LeadingObject,
		CommentForLog,
		?(TransactionActive(), EventLogEntryTransactionMode.Transactional, Undefined));
	
EndProcedure

// For the RegisterAccessUpdatePlanningInLog procedure.
Function LeadingObjectPointerDetails(Pointer, PlanningParameters)
	
	If PlanningParameters.Property("LeadingObjectsRefTypes") Then
		RefsTypes = PlanningParameters.LeadingObjectsRefTypes;
	Else
		RefsTypes = AccessManagementInternalCached.LeadingObjectsRefTypes();
		PlanningParameters.Insert("LeadingObjectsRefTypes", RefsTypes);
	EndIf;
	
	If RefsTypes.Get(TypeOf(Pointer)) <> Undefined Then
		Return GetURL(Pointer);
	EndIf;
	
	LongDesc = "";
	For Each FilterElement In Pointer Do
		If Not FilterElement.Use Then
			Continue;
		EndIf;
		If RefsTypes.Get(TypeOf(FilterElement.Value)) <> Undefined Then
			ValueDescription = GetURL(FilterElement.Value);
		ElsIf TypeOf(FilterElement.Value) = Type("Undefined") Then
			ValueDescription = NStr("en = 'Undefined';");
		Else
			ValueDescription = Format(FilterElement.Value, "NZ=0; DE='01.01.0001 00:00:00'");
		EndIf;
		LongDesc = LongDesc + ?(LongDesc = "", "", ", ")
			+ FilterElement.Name + " = " + ValueDescription;
	EndDo;
	
	Return LongDesc;
	
EndFunction

// To call from access update planning locations.
Procedure RegisterAccessUpdatePlanning(ListsByIDs, PlanningParameters, AllLists = False)
	
	If Not RegisterAccessUpdatePlanningIndicators() Then
		Return;
	EndIf;
	
	If PlanningParameters = Undefined Then
		PlanningParameters = AccessUpdatePlanningParameters();
	EndIf;
	
	Lists = New Array;
	
	If Not AllLists Then
		For Each ListDetails In ListsByIDs Do
			If ValueIsFilled(ListDetails.Value) Then
				Lists.Add(ListDetails.Value);
			Else
				Lists.Add(FullListName(ListDetails.Key));
			EndIf;
		EndDo;
	Else
		Lists.Add("All");
	EndIf;
	
	RegisterAccessUpdatePlanningInLog(Lists, PlanningParameters);
	
EndProcedure

// For the RegisterAccessUpdatePlanning procedure.
Function FullListName(ListDetails)
	
	If TypeOf(ListDetails) = Type("CatalogRef.MetadataObjectIDs")
	 Or TypeOf(ListDetails) = Type("CatalogRef.ExtensionObjectIDs") Then
		
		MetadataObject = Common.MetadataObjectByID(ListDetails, False);
		
		If TypeOf(MetadataObject) = Type("MetadataObject") Then
			Return MetadataObject.FullName();
		Else
			Return Common.ObjectAttributeValue(ListDetails, "FullName");
		EndIf;
	Else
		Return String(ListDetails);
	EndIf;
	
EndFunction

// For the AccessManagement.DisableAccessKeysUpdate procedure.
//
// Parameters:
//   Lists - Array
//   AddedLists - Map
//   UnavailableLists - Array - a return value.
//
Procedure AddDependentLists(Lists, AddedLists, UnavailableLists) Export
	
	InitialLists = New FixedArray(Lists);
	ActiveParameters = ActiveAccessRestrictionParameters(Undefined, Undefined, False);
	
	NotFoundLists = New Array;
	
	For Each InitialList In InitialLists Do
		Properties = ActiveParameters.LeadingLists.Get(InitialList);
		If Properties = Undefined Then
			Continue;
		EndIf;
		For Each KeyAndValue In Properties.DependentLists Do
			If AddedLists.Get(KeyAndValue.Key) = Undefined Then
				MetadataObject = Common.MetadataObjectByFullName(KeyAndValue.Key);
				If MetadataObject = Undefined Then
					NotFoundLists.Add(KeyAndValue.Key);
				Else
					FullName = MetadataObject.FullName();
					Lists.Add(FullName);
					AddedLists.Insert(FullName, True);
				EndIf;
				AddedLists.Insert(KeyAndValue.Key, True);
			EndIf;
		EndDo;
	EndDo;
	
	If NotFoundLists.Count() = 0 Then
		Return;
	EndIf;
	
	UnavailableLists = AllIDsWithSimilarFullNames(NotFoundLists);
	
EndProcedure

Function DataRestrictionsDetails() Export
	
	CommonContext = New Structure;
	CommonContext.Insert("ListsWithRestriction", AccessManagementInternalCached.ListsWithRestriction());
	
	Result = New Map;
	
	For Each ListDetails In CommonContext.ListsWithRestriction Do
		FullName = ListDetails.Key;
		RestrictionDetails = DataRestrictionDetails(CommonContext, FullName);
		Result.Insert(FullName, RestrictionDetails);
	EndDo;
	
	Return Result;
	
EndFunction

#Region ParametersToOverrideThroughConfigurationUpdate

Function HoursOfNotUsedItemsBecomingObsoleteCount()
	
	Return 47;
	
EndFunction

Function HoursCountBetweenPlanningToProcessObsoleteItems()
	
	Return 48;
	
EndFunction

Function MaxCountOfMinutesToPerformBackgroundAccessUpdateJob()
	
	If Common.FileInfobase() Then
		Return 2;
	Else
		Return 15;
	EndIf;
	
EndFunction

Function MaxWaitSecondsCountOfWaitingForOneJobInThreadToBeProcessed()
	
	Return 900; // 15 minutes (for example, excessively long SQL request).
	
EndFunction

Function MinSecondsCountOfBatchProcessingInSingleThread()
	
	Return 1;
	
EndFunction

Function SpotJobExecutionMinSecondsCount()
	
	Return 15;
	
EndFunction

Function LoadFreeThreadsWithNextJobsAtLongQueries()
	
	Return True;
	
EndFunction

Function MaxGettingBatchesByQueryPeriod()
	
	Return "Year"; // Year, Quarter, Month, Week.
	
EndFunction

Function StartGotBatchesUpdateOnGetNewBatches()
	
	Return False;
	
EndFunction

Function MaxSecondsCountOfQuickDataItemsBatchReceipt()
	
	Return 6; // 0 - Disable storage load balancing.
	
EndFunction

Function DataItemsInQueryCount()
	
	Return 1000;
	
EndFunction

Function DataItemsInBatchCount()
	
	Return 1000;
	
EndFunction

Function AccessKeysInQueryCount()
	
	Return 1000;
	
EndFunction

Function AccessKeysInBatchCount()
	
	Return 200;
	
EndFunction

Function WriteOnlyChangedDataItemsAccessKeys()
	
	Return False;
	
EndFunction

Function MaxCombinationsCountOfLeadingFieldsValuesOnCalculateContentOfChangedOnes()
	
	Return 100;
	
EndFunction

Function SecondsCountBeforeDisableScheduledJobAfterUpdateCompletion()
	
	Return 15;
	
EndFunction

Function RegisterAccessUpdateIndicators()
	
	Return True;
	
EndFunction

Function RegisterAccessUpdatePlanningIndicators()
	
	Return False;
	
EndFunction

Function NeedRegisterAccessRestrictionParametersVersionString()
	
	Return False;
	
EndFunction

#EndRegion

#Region AttachmentPointsToAnalyzeProductivityUsingConfigurationExtension

Procedure BeforeDataLock(ParametersOfUpdate)
	Return;
EndProcedure

Procedure AfterDataLock(ParametersOfUpdate)
	Return;
EndProcedure

Procedure BeforeCurrentAccessKeysQuery(ParametersOfUpdate)
	Return;
EndProcedure

Procedure AfterCurrentAccessKeysQuery(ParametersOfUpdate)
	Return;
EndProcedure

Procedure BeforeWriteRows(ParametersOfUpdate)
	Return;
EndProcedure

Procedure AfterWriteRows(ParametersOfUpdate, WrittenItemsCount)
	Return;
EndProcedure

Procedure BeforeCommitTransaction(ParametersOfUpdate)
	Return;
EndProcedure

Procedure AfterCommitTransaction(ParametersOfUpdate)
	Return;
EndProcedure

Procedure BeforePlanUpdate(ParametersOfUpdate)
	Return;
EndProcedure

Procedure AfterPlanUpdate(ParametersOfUpdate)
	Return;
EndProcedure

Procedure BeforeWriteNewKey(ParametersOfUpdate)
	Return;
EndProcedure

Procedure AfterWriteNewKey(ParametersOfUpdate)
	Return;
EndProcedure

Procedure BeforeAccessGroupsRightsQuery(ParametersOfUpdate)
	Return;
EndProcedure

Procedure AfterAccessGroupsRightsQuery(ParametersOfUpdate)
	Return;
EndProcedure

Procedure BeforeDerivedRightsChangesQuery(ParametersOfUpdate)
	Return;
EndProcedure

Procedure AfterDerivedRightsChangesQuery(ParametersOfUpdate)
	Return;
EndProcedure

Procedure BeforeUsersRightsQuery(ParametersOfUpdate)
	Return;
EndProcedure

Procedure AfterUsersRightsQuery(ParametersOfUpdate)
	Return;
EndProcedure

Procedure BeforeChangeSessionParametersForTemplates(NewValues, IsInstallation)
	Return;
EndProcedure

Procedure InCaseOfAnErrorCheckingTheRelevanceOfMetadata(ErrorText)
	Return;
EndProcedure

#EndRegion

#EndRegion

#Region AccessRestrictionParameters

#Region AccessRestrictionParametersMainPart

// The main function that returns the parameters required for registering
// necessity to update access keys to data items.
//
// Parameters:
//  FullName               - String - a full list name
//  TransactionID - UUID
//  RepeatedCall          - Boolean - when calling from the function itself only
//
// Returns:
//  Structure:
//   * DependentLists      - Map of KeyAndValue:
//      ** Key     - String -
//      ** Value - Boolean - Truth.
//   * ByFieldsValues     - See LeadingListByFieldsValues
//   * ByAccessKeys      - See LeadingListByAccessKeysOrValuesWithGroups
//   * ByValuesWithGroups - See LeadingListByAccessKeysOrValuesWithGroups
//
Function ListPropertiesAsLeadingOne(FullName, TransactionID = Undefined, RepeatedCall = False) Export
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	ActiveParameters = ActiveAccessRestrictionParameters(TransactionID, Undefined, RepeatedCall);
	StoredListPropertiesAsLeadingOne = ActiveParameters.LeadingLists.Get(FullName);
	
	If StoredListPropertiesAsLeadingOne = Undefined Then
		Return Undefined;
	EndIf;
	
	Cache = RestrictionParametersCache();
	
	ListPropertiesAsLeadingOne = Cache.LeadingListsChecked.Get(FullName);
	If ListPropertiesAsLeadingOne <> Undefined Then
		Return ListPropertiesAsLeadingOne;
	EndIf;
	
	ListPropertiesAsLeadingOne = New Structure(StoredListPropertiesAsLeadingOne);
	Cancel = False;
	FillPreviousValuesQueryTextToCheckLeadingListFieldsChanges(FullName,
		ListPropertiesAsLeadingOne, Cancel);
	
	If Not Cancel Then
		Cache.LeadingListsChecked.Insert(FullName,
			New FixedStructure(ListPropertiesAsLeadingOne));
		
		Return ListPropertiesAsLeadingOne;
	EndIf;
	
	If RepeatedCall Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Cannot prepare properties of the leading ""%1"" list
			           |due to the invalid state of access restriction parameters.';"),
			FullName);
		Raise ErrorText;
	EndIf;
	
	Return ListPropertiesAsLeadingOne(FullName, TransactionID, True);
	
EndFunction

// Returns:
//  Structure:
//   * LeadingListsChecked - Map of KeyAndValue:
//       ** Key     - String - full name of the list
//       ** Value - See AccessManagementInternal.ListPropertiesAsLeadingOne
//   * ListsRestrictions - Map of KeyAndValue:
//       ** Key     - String - full name of the list
//       ** Value - See AccessManagementInternal.CalculatedRestrictionParameters
//   * TransactionIDs - Map of KeyAndValue:
//       ** Key     - UUID - an arbitrary UID.
//       ** Value - Boolean - the value is True.
//   * TypesRestrictionsPermissionsForUsers        - Undefined
//                                                - String
//   * TypesRestrictionsPermissionsForExternalUsers - Undefined
//                                                - String
//
Function RestrictionParametersNewCache() Export
	
	Store = New Structure;
	Store.Insert("LeadingListsChecked", New Map);
	Store.Insert("ListsRestrictions",       New Map);
	Store.Insert("TransactionIDs", New Map);
	Store.Insert("TypesRestrictionsPermissionsForUsers",        Undefined);
	Store.Insert("TypesRestrictionsPermissionsForExternalUsers", Undefined);
	
	Return Store;
	
EndFunction

// For the ListPropertiesAsLeadingOne function, the FillRestrictionParameters,
// UpdateTransactionIDs, and SetParameterVersion procedures.
//
Function RestrictionParametersCache()
	
	CachedDataKey = String(SessionParameters.CachedDataKey);
	
	Return AccessManagementInternalCached.RestrictionParametersCache(CachedDataKey);
	
EndFunction

Procedure ResetRestrictionParametersCache()
	
	Cache = RestrictionParametersCache();
	NewCache = RestrictionParametersNewCache();
	
	For Each KeyAndValue In NewCache Do
		Cache.Insert(KeyAndValue.Key, KeyAndValue.Value);
	EndDo;
	
EndProcedure

// For the ListPropertiesAsLeadingOne function.
Procedure FillPreviousValuesQueryTextToCheckLeadingListFieldsChanges(FullName, Properties, Cancel)
	
	Properties.Delete("DependentLists");
	If Properties.ByFieldsValues = Undefined Then
		Return;
	EndIf;
	
	ByFieldsValues = New Structure(Properties.ByFieldsValues); // See LeadingListByFieldsValues
	MetadataObject = Common.MetadataObjectByFullName(FullName);
	
	If ByFieldsValues.IsReferenceType Then
		If ValueIsFilled(ByFieldsValues.HeaderFields.AllFields) Then
			QueryText =
			"SELECT
			|	CurrentTable.Field1 AS Field1
			|FROM
			|	(SELECT
			|		TRUE AS TrueValue) AS TrueValue
			|		LEFT JOIN CurrentDataItemTable AS CurrentTable
			|		ON (CurrentTable.Ref = &ObjectReference)";
			FillCurrentTableSelectionFields(QueryText,
				FullName, ByFieldsValues.HeaderFields.AllFields, MetadataObject, Cancel);
		Else
			QueryText = "";
		EndIf;
		
		For Each TabularSection In ByFieldsValues.TabularSections Do
			Collections = New Structure("StandardTabularSections, TabularSections");
			TabularSectionName2 = TabularSection.Name;
			FillPropertyValues(Collections, MetadataObject);
			MetadataTables = Undefined;
			If TypeOf(Collections.TabularSections) = Type("MetadataObjectCollection") Then
				MetadataTables = MetadataObject.TabularSections.Find(TabularSectionName2);
			EndIf;
			If MetadataTables = Undefined
			   And TypeOf(Collections.StandardTabularSections) = Type("StandardTabularSectionDescriptions") Then
				For Each StandardTabularSection In Collections.StandardTabularSections Do
					StandardTabularSection = StandardTabularSection; // StandardTabularSectionDescription
					If StandardTabularSection.Name = TabularSectionName2 Then
						MetadataTables = StandardTabularSection;
						Break;
					EndIf;
				EndDo;
			EndIf;
			If MetadataTables = Undefined Then
				Cancel = True;
				Break;
			EndIf;
			
			TabularSectionQueryText =
			"SELECT DISTINCT TOP 100
			|	CurrentTable.Field1 AS Field1
			|FROM
			|	CurrentDataItemTable AS CurrentTable
			|WHERE
			|	CurrentTable.Ref = &ObjectReference";
			FillCurrentTableSelectionFields(TabularSectionQueryText,
				FullName + "." + TabularSectionName2, TabularSection.AllFields, MetadataTables, Cancel, True);
			
			QueryText = QueryText + ?(QueryText = "", "",
				Common.QueryBatchSeparator()) + TabularSectionQueryText;
		EndDo;
		
	ElsIf ValueIsFilled(ByFieldsValues.HeaderFields.AllFields) Then
		QueryText =
		"SELECT DISTINCT TOP 100
		|	CurrentTable.Field1 AS Field1
		|FROM
		|	CurrentDataItemTable AS CurrentTable
		|WHERE
		|	&FilterByDimensions";
		FillCurrentTableSelectionFields(QueryText,
			FullName, ByFieldsValues.HeaderFields.AllFields, MetadataObject, Cancel);
	Else
		QueryText = "";
	EndIf;
	
	ByFieldsValues.Insert("QueryText", QueryText);
	Properties.ByFieldsValues = New FixedStructure(ByFieldsValues);
	
EndProcedure

// For the FillPreviousValuesQueryTextToCheckLeadingListFieldsChanges procedure.
Procedure FillCurrentTableSelectionFields(QueryText, FullName, FieldsDetails,
			MetadataTables, Cancel, IsTabularSection = False)
	
	FieldsCollections = New Structure("Attributes, Dimensions, Resources, StandardAttributes");
	FillPropertyValues(FieldsCollections, MetadataTables);
	
	SelectionFields = "";
	For Each FieldDetails In FieldsDetails Do
		FieldName = ?(TypeOf(FieldsDetails) = Type("FixedArray"), FieldDetails, FieldDetails.Key);
		
		If Not FieldExists(FieldsCollections.Attributes, FieldName)
		   And Not FieldExists(FieldsCollections.Dimensions, FieldName)
		   And Not FieldExists(FieldsCollections.Resources, FieldName)
		   And Not FieldExists(FieldsCollections.StandardAttributes, FieldName)
		   And Not (IsTabularSection
		         And (Upper(FieldName) = Upper("Ссылка") // @Non-NLS
		            Or Upper(FieldName) = Upper("Ref"))) Then
			
			Cancel = True;
			Break;
		EndIf;
		
		SelectionFields = SelectionFields + ?(SelectionFields = "", "", "," + Chars.LF)
			+ "CurrentTable." + FieldName + " AS " + FieldName; // @query-part-2
	EndDo;
	QueryText = StrReplace(QueryText,
		"CurrentTable.Field1 AS Field1", TextWithIndent(TrimL(SelectionFields), "	")); // @query-part-1
	
	QueryText = StrReplace(QueryText, "CurrentDataItemTable", FullName);
	
	QueryText = StrReplace(QueryText, "TOP 100", "TOP " + Format( // @query-part-1 @query-part-2
		MaxCombinationsCountOfLeadingFieldsValuesOnCalculateContentOfChangedOnes() * 10, "NG="));
	
EndProcedure

// For the FillCurrentTableSelectionFields procedure.
Function FieldExists(Collection, FieldName)
	
	If TypeOf(Collection) = Type("MetadataObjectCollection") Then
		Return Collection.Find(FieldName) <> Undefined;
		
	ElsIf TypeOf(Collection) = Type("StandardAttributeDescriptions") Then
		For Each StandardAttribute In Collection Do
			If StandardAttribute.Name = FieldName Then
				Return True;
			EndIf;
		EndDo;
	EndIf;
	
	Return False;
	
EndFunction

// The main function that returns the parameters required for checking rights upon recording data items.
//
// Returns:
//   See RestrictionParametersByRestrictionStructure
//
Function RestrictionParameters(FullName, TransactionID = Undefined, ForExternalUsers = Undefined) Export
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	ActiveAccessRestrictionParameters(TransactionID, Undefined, False);
	Parameters = RestrictionParametersCache().ListsRestrictions.Get(FullName);
	
	If Parameters = Undefined Then
		FillRestrictionParameters(FullName, TransactionID, Parameters);
	EndIf;
	
	If ForExternalUsers = Null Then
		Return Parameters;
	EndIf;
	
	If ForExternalUsers = Undefined Then
		ForExternalUsers = Users.IsExternalUserSession();
	EndIf;
	
	If ForExternalUsers Then
		Return Parameters.ForExternalUsers;
	EndIf;
	
	Return Parameters.ForUsers;
	
EndFunction

// For the ListPropertiesAsLeadingOne and RestrictionParameters functions.
Procedure FillRestrictionParameters(FullName, TransactionID, Parameters,
			CommonContext = Undefined, RepeatedCall = False)
	
	If CommonContext = Undefined Then
		CommonContext = CommonContextOfRestrictionParametersCalculation(FullName);
		CommonContext.Insert("RestrictionsDetails1", New Map);
	EndIf;
	
	ActiveParameters = ActiveAccessRestrictionParameters(TransactionID, CommonContext, False);
	
	RestrictionsVersion = ActiveParameters.ListsRestrictionsVersions.Get(FullName);
	CalculatedParameters = CalculatedRestrictionParameters(FullName, CommonContext, ActiveParameters);
	
	If RestrictionsVersion <> CalculatedParameters.Version Then
		If RepeatedCall Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'Cannot update access restriction parameters of the ""%1"" list.
				           |The string of properties of the parameters version that is the source for calculating the hash is unstable.';"),
				FullName);
			Raise ErrorText;
		EndIf;
		ActiveParameters = ActiveAccessRestrictionParameters(TransactionID, CommonContext, True);
		FillRestrictionParameters(FullName, TransactionID, Parameters, CommonContext, True);
		Return;
	EndIf;
	
	Parameters = Common.FixedData(CalculatedParameters);
	
	RestrictionParametersCache().ListsRestrictions.Insert(FullName, Parameters);
	
EndProcedure

// For the FillRestrictionParameters procedure,
// the StoredAccessRestrictionParameters, and AccessRestrictionsErrors functions.
//
// Returns:
//  Structure:
//    * AccessKindsProperties         - See AccessKindsProperties
//    * UserTypes             - Array of Type
//    * RightsSettingsOwnersTypes   - FixedMap
//    * SeparateRightsSettingsTables - FixedMap
//    * ExternalUsersEnabled  - Boolean
//    * UsedValuesTypes     - See UsedValuesTypes
//    * ListsWithRestriction          - See AccessManagementInternalCached.ListsWithRestriction
//
Function CommonContextOfRestrictionParametersCalculation(FullName = Undefined,
			AllAccessKindsUsed = Undefined, FillListsWithRestriction = True)
	
	UserTypes = New Array;
	UserTypes.Add(Type("CatalogRef.Users"));
	UserTypes.Add(Type("CatalogRef.UserGroups"));
	UserTypes.Add(Type("CatalogRef.ExternalUsers"));
	UserTypes.Add(Type("CatalogRef.ExternalUsersGroups"));
	
	AccessRestrictionEnabled = Constants.LimitAccessAtRecordLevel.Get();
	If AccessManagement.LimitAccessAtRecordLevel() <> AccessRestrictionEnabled Then
		RefreshReusableValues();
	EndIf;
	AccessKindsProperties = AccessKindsProperties();
	
	UsedValuesTypes = UsedValuesTypes(AccessKindsProperties, FullName, AllAccessKindsUsed);
	If TypeOf(AllAccessKindsUsed) = Type("Boolean") Then
		AccessRestrictionEnabled  = AllAccessKindsUsed;
		ExternalUsersEnabled = AllAccessKindsUsed;
	Else
		ExternalUsersEnabled = Constants.UseExternalUsers.Get();
	EndIf;
	
	AvailableRights = RightsForObjectsRightsSettingsAvailable();
	
	CommonContext = New Structure;
	CommonContext.Insert("AccessKindsProperties",         AccessKindsProperties);
	CommonContext.Insert("UserTypes",             UserTypes);
	CommonContext.Insert("RightsSettingsOwnersTypes",   AvailableRights.ByRefsTypes);
	CommonContext.Insert("SeparateRightsSettingsTables", AvailableRights.SeparateTables);
	CommonContext.Insert("ExternalUsersEnabled",  ExternalUsersEnabled);
	CommonContext.Insert("AccessRestrictionEnabled",   AccessRestrictionEnabled);
	CommonContext.Insert("UsedValuesTypes",     UsedValuesTypes);
	
	If FillListsWithRestriction Then
		CommonContext.Insert("ListsWithRestriction", AccessManagementInternalCached.ListsWithRestriction());
	EndIf;
	
	Return CommonContext;
	
EndFunction

// For the RestrictionParametersCalculationCommonContext and AccessKindsUsageChanged functions.
//
// Parameters:
//  AccessKindsProperties - See AccessKindsProperties
//  FullName - String
//  AllAccessKindsUsed - Undefined
//                             - Boolean
//  HashAmountOnly             - Boolean
// 
// Returns:
//   Structure:
//     * ForIB - Map of KeyAndValue:
//         ** Key - Type
//         ** Value - Boolean - True.
//     * ByTables - Map of KeyAndValue:
//         ** Key - String - a full name of a metadata object
//         ** Value - Map of KeyAndValue:
//              *** Key - Type
//              *** Value - Boolean - True.
//     * HashSum - String - the checksum of the ForIB and ByTables usage settings.
//     * FullTableName - String - Full name of the table.
//                                   Applicable when only one table has a value in the ByTables property.
//
Function UsedValuesTypes(AccessKindsProperties, FullName = Undefined, AllAccessKindsUsed = Undefined, HashAmountOnly = False)
	
	UsedValuesTypes = New Structure;
	UsedValuesTypes.Insert("ForIB", New Map);
	UsedValuesTypes.Insert("ByTables", New Map);
	UsedValuesTypes.Insert("HashSum", "");
	UsedValuesTypes.Insert("FullTableName", "");
	
	If AllAccessKindsUsed = False Then
		Return UsedValuesTypes;
	EndIf;
	
	If AllAccessKindsUsed <> True Then
		Query = New Query;
		Query.Text =
		"SELECT
		|	UsedAccessKinds.AccessValuesType AS AccessValuesType
		|FROM
		|	InformationRegister.UsedAccessKinds AS UsedAccessKinds
		|WHERE
		|	&LimitAccessAtRecordLevel
		|
		|ORDER BY
		|	AccessValuesType
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|SELECT
		|	UsedAccessKindsByTables.Table AS Table,
		|	UsedAccessKindsByTables.AccessValuesType AS AccessValuesType
		|FROM
		|	InformationRegister.UsedAccessKindsByTables AS UsedAccessKindsByTables
		|WHERE
		|	UsedAccessKindsByTables.Table = &Table
		|
		|ORDER BY
		|	Table,
		|	AccessValuesType";
		
		If FullName <> Undefined Then
			Id = Common.MetadataObjectID(FullName, False);
			If Id <> Null Then
				Query.SetParameter("Table", Id);
			EndIf;
		EndIf;
		If FullName = Undefined Or Id = Null Then
			Query.Text = StrReplace(Query.Text,
				"UsedAccessKindsByTables.Table = &Table", "TRUE");
		Else
			UsedValuesTypes.FullTableName = FullName;
		EndIf;
		LineAccessRestrictionEnabled =
			?(Constants.LimitAccessAtRecordLevel.Get(), "TRUE", "FALSE");
		Query.Text = StrReplace(Query.Text, "&LimitAccessAtRecordLevel",
			LineAccessRestrictionEnabled);
		
		QueryResults = Query.ExecuteBatch();
		UsedItems = QueryResults[0].Unload();
		UsedByTables = QueryResults[1].Unload();
		If FullName = Undefined Then
			Hashing = New DataHashing(HashFunction.SHA256);
			Hashing.Append(LineAccessRestrictionEnabled);
			Hashing.Append(DataStringForHashing(UsedItems));
			Hashing.Append(DataStringForHashing(UsedByTables));
			UsedValuesTypes.HashSum = Base64String(Hashing.HashSum);
			If HashAmountOnly Then
				Return UsedValuesTypes;
			EndIf;
		EndIf;
		Tables = UsedByTables.Copy(, "Table");
		Tables.GroupBy("Table");
		IDs = Tables.UnloadColumn("Table");
		MetadataObjects = Common.MetadataObjectsByIDs(IDs, False);
		CurrentTable = Undefined;
		For Each String In UsedByTables Do
			If CurrentTable <> String.Table Then
				MetadataObject = MetadataObjects.Get(String.Table);
				If TypeOf(MetadataObject) <> Type("MetadataObject") Then
					Continue;
				EndIf;
				CurrentFullName = MetadataObject.FullName();
				CurrentTable = String.Table;
				CurrentTypesUsed = New Map;
				UsedValuesTypes.ByTables.Insert(CurrentFullName, CurrentTypesUsed);
			EndIf;
			CurrentTypesUsed.Insert(TypeOf(String.AccessValuesType), True);
		EndDo;
	EndIf;
	
	PropertiesOfAccessTypesArray = AccessKindsProperties.Array; // Array of See AccessKindProperties
	For Each AccessKindProperties In PropertiesOfAccessTypesArray Do
		If AllAccessKindsUsed <> True
		   And UsedItems.Find(AccessKindProperties.Ref) = Undefined Then
			Continue;
		EndIf;
		UsedValuesTypes.ForIB.Insert(AccessKindProperties.ValuesType, True);
		For Each AdditionalTypeDetails In AccessKindProperties.AdditionalTypes Do
			UsedValuesTypes.ForIB.Insert(AdditionalTypeDetails.ValuesType, True);
		EndDo;
	EndDo;
	
	Return UsedValuesTypes;
	
EndFunction

// For the AddListRestrictionParameters procedure.
//
// Returns:
//  Structure:
//   * Version - String
//   * LeadingLists - Map of KeyAndValue:
//       ** Key     - String - a full list name
//       ** Value - See ListPropertiesAsLeadingOne
//   * ForUsers - See RestrictionParametersByRestrictionStructure
//   * ResultForExternalUsers - See RestrictionParametersByRestrictionStructure
//
Function CalculatedRestrictionParameters(FullName, CommonContext, ActiveParameters) Export
	
	RestrictionDetails = DataRestrictionDetails(CommonContext, FullName);
	
	// For users.
	RestrictionStructureForUsers = CalculatedRestrictionStructure(FullName,
		RestrictionDetails.Text, RestrictionDetails.TextInManagerModule, False);
	
	AdditionalContext = NewAdditionalContext();
	FillPropertyValues(AdditionalContext, ActiveParameters.AdditionalContext.ForUsers);
	AddAdditionalContext(FullName, AdditionalContext, RestrictionDetails, False);
	
	ResultForUsers = RestrictionParametersByRestrictionStructure(FullName,
		RestrictionStructureForUsers, False, CommonContext, AdditionalContext);
	
	// For external users.
	RestrictionStructureForExternalUsers = CalculatedRestrictionStructure(FullName,
		RestrictionDetails.TextForExternalUsers1, RestrictionDetails.TextInManagerModule, True);
	
	AdditionalContext = NewAdditionalContext();
	FillPropertyValues(AdditionalContext, ActiveParameters.AdditionalContext.ForExternalUsers);
	AddAdditionalContext(FullName, AdditionalContext, RestrictionDetails, True);
	
	ResultForExternalUsers = RestrictionParametersByRestrictionStructure(FullName,
		RestrictionStructureForExternalUsers, True, CommonContext, AdditionalContext);
	
	// Filling in parameters based on parameters of both user types.
	Version = CommonVersion(CommonContext, FullName, ResultForUsers.Version, ResultForExternalUsers.Version);
	SetAccessKeysRecordProperties(ResultForUsers);
	SetAccessKeysRecordProperties(ResultForExternalUsers);
	WithTwoKeysRecord = Not ResultForUsers.DoNotWriteAccessKeys And Not ResultForExternalUsers.DoNotWriteAccessKeys;
	WithoutKeysRecord    =    ResultForUsers.DoNotWriteAccessKeys And    ResultForExternalUsers.DoNotWriteAccessKeys;
	ResultForUsers.Insert(       "WriteAccessKeysForUsersAndExternalUsers", WithTwoKeysRecord);
	ResultForExternalUsers.Insert("WriteAccessKeysForUsersAndExternalUsers", WithTwoKeysRecord);
	ResultForUsers.Insert(       "DoNotWriteAccessKeysForUsersAndExternalUsers", WithoutKeysRecord);
	ResultForExternalUsers.Insert("DoNotWriteAccessKeysForUsersAndExternalUsers", WithoutKeysRecord);
	
	// Generate query texts.
	AddQueryTextsToRestrictionParameters(ResultForUsers);
	AddQueryTextsToRestrictionParameters(ResultForExternalUsers);
	
	LeadingLists = New Structure;
	LeadingLists.Insert("ForUsers",        ResultForUsers.LeadingLists);
	LeadingLists.Insert("ForExternalUsers", ResultForExternalUsers.LeadingLists);
	
	Parameters = New Structure;
	Parameters.Insert("Version",                  Version);
	Parameters.Insert("LeadingLists",           LeadingLists);
	Parameters.Insert("ForUsers",        ResultForUsers);
	Parameters.Insert("ForExternalUsers", ResultForExternalUsers);
	
	Return Parameters;
	
EndFunction

// For the AccessRestrictionErrors function.
Function AccessRestrictionError(CommonContext, FullName)
	
	ErrorTextForUsers = "";
	ErrorTextForExternalUsers = "";
	
	Try
		RestrictionDetails = DataRestrictionDetails(CommonContext, FullName, True);
	Except
		ErrorInfo = ErrorInfo();
		Return ErrorProcessing.DetailErrorDescription(ErrorInfo);
	EndTry;
	If TypeOf(RestrictionDetails) = Type("String") Then
		Return RestrictionDetails;
	EndIf;
	
	// For users.
	RestrictionStructureForUsers = CalculatedRestrictionStructure(FullName,
		RestrictionDetails.Text, RestrictionDetails.TextInManagerModule, False, True);
	
	If RestrictionStructureForUsers <> Undefined
	   And RestrictionStructureForUsers.ErrorsDescription.HasErrors Then
		
		ErrorTextForUsers = ErrorsTextToCallException(FullName,
			RestrictionStructureForUsers.ErrorsDescription, False, RestrictionDetails.TextInManagerModule);
	Else
		AdditionalContext = NewAdditionalContext();
		AddAdditionalContext(FullName, AdditionalContext, RestrictionDetails, False);
		
		ErrorOnCallException = New Structure("Text", Undefined);
		AdditionalContext.Insert("ErrorOnCallException", ErrorOnCallException);
		Try
			ResultForUsers = RestrictionParametersByRestrictionStructure(FullName,
				RestrictionStructureForUsers, False, CommonContext, AdditionalContext);
		Except
			ErrorInfo = ErrorInfo();
			If ValueIsFilled(ErrorOnCallException.Text) Then
				ErrorTextForUsers = ErrorOnCallException.Text;
			Else
				ErrorTextForUsers = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("en = 'Cannot generate access restriction parameters for users. Reason:
					           |%1';"), ErrorProcessing.DetailErrorDescription(ErrorInfo));
			EndIf;
		EndTry;
		
		If Not ValueIsFilled(ErrorTextForUsers) Then
			ResultForUsers.Context.ListsWithKeysRecordForDependentListsWithoutKeys = New Map;
			SetAccessKeysRecordProperties(ResultForUsers);
			ResultForUsers.Insert("DoNotWriteAccessKeysForUsersAndExternalUsers", False);
			ResultForUsers.Context.Insert("SkipTypesToDefineCheck");
			Try
				AddQueryTextsToRestrictionParameters(ResultForUsers);
			Except
				ErrorInfo = ErrorInfo();
				If ValueIsFilled(ErrorOnCallException.Text) Then
					ErrorTextForUsers = ErrorOnCallException.Text;
				Else
					ErrorTextForUsers = StringFunctionsClientServer.SubstituteParametersToString(
						NStr("en = 'Cannot generate query texts based on users'' access restriction parameters.
						           |Reason:
						           |%1';"), ErrorProcessing.DetailErrorDescription(ErrorInfo));
				EndIf;
			EndTry;
		EndIf;
	EndIf;
	
	// For external users.
	RestrictionStructureForExternalUsers = CalculatedRestrictionStructure(FullName,
		RestrictionDetails.TextForExternalUsers1, RestrictionDetails.TextInManagerModule, True, True);
	
	If RestrictionStructureForExternalUsers <> Undefined
	   And RestrictionStructureForExternalUsers.ErrorsDescription.HasErrors Then
		
		ErrorTextForExternalUsers = ErrorsTextToCallException(FullName,
			RestrictionStructureForExternalUsers.ErrorsDescription, True, RestrictionDetails.TextInManagerModule);
	Else
		AdditionalContext = NewAdditionalContext();
		AddAdditionalContext(FullName, AdditionalContext, RestrictionDetails, True);
		
		ErrorOnCallException = New Structure("Text", Undefined);
		AdditionalContext.Insert("ErrorOnCallException", ErrorOnCallException);
		Try
			ResultForExternalUsers = RestrictionParametersByRestrictionStructure(FullName,
				RestrictionStructureForExternalUsers, True, CommonContext, AdditionalContext);
		Except
			ErrorInfo = ErrorInfo();
			If ValueIsFilled(ErrorOnCallException.Text) Then
				ErrorTextForExternalUsers = ErrorOnCallException.Text;
			Else
				ErrorTextForExternalUsers = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("en = 'Cannot generate access restriction parameters for external users. Reason:
					           |%1';"), ErrorProcessing.DetailErrorDescription(ErrorInfo));
			EndIf;
		EndTry;
		
		If Not ValueIsFilled(ErrorTextForExternalUsers) Then
			ResultForExternalUsers.Context.ListsWithKeysRecordForDependentListsWithoutKeys = New Map;
			SetAccessKeysRecordProperties(ResultForExternalUsers);
			ResultForExternalUsers.Insert("DoNotWriteAccessKeysForUsersAndExternalUsers", False);
			ResultForExternalUsers.Context.Insert("SkipTypesToDefineCheck");
			Try
				AddQueryTextsToRestrictionParameters(ResultForExternalUsers);
			Except
				ErrorInfo = ErrorInfo();
				If ValueIsFilled(ErrorOnCallException.Text) Then
					ErrorTextForExternalUsers = ErrorOnCallException.Text;
				Else
					ErrorTextForExternalUsers = StringFunctionsClientServer.SubstituteParametersToString(
						NStr("en = 'Cannot generate query texts based on access restriction parameters of external users.
						           |Reason:
						           |%1';"), ErrorProcessing.DetailErrorDescription(ErrorInfo));
				EndIf;
			EndTry;
		EndIf;
	EndIf;
	
	Return TrimAll(ErrorTextForUsers
		+ Chars.LF + Chars.LF + ErrorTextForExternalUsers);
	
EndFunction

// For the AccessRestrictionCheckResult function.
Function ObjectAccessRestrictionCheckResult(FullName, AdditionalParameters)
	
	Parameters = New Structure;
	Parameters.Insert("Text", Undefined);
	Parameters.Insert("TextForExternalUsers1", Undefined);
	Parameters.Insert("ConsiderDependencies", False);
	Parameters.Insert("AllAccessKindsUsed", True);
	
	If TypeOf(AdditionalParameters) = Type("Structure") Then
		FillPropertyValues(Parameters, AdditionalParameters);
	EndIf;
	
	ForUsers        = RestrictionCheckResultStructureForUsersKind();
	ForExternalUsers = RestrictionCheckResultStructureForUsersKind();
	
	Result = New Structure;
	Result.Insert("RestrictionDetailsError", "");
	Result.Insert("TextInManagerModule",     Undefined);
	Result.Insert("ForUsers",          ForUsers);
	Result.Insert("ForExternalUsers",   ForExternalUsers);
	Result.Insert("ImplementationSettings",        New Structure);
	
	CommonContext = Undefined;
	Try
		CommonContext = CommonContextOfRestrictionParametersCalculation(, Parameters.AllAccessKindsUsed, False);
	Except
		ErrorInfo = ErrorInfo();
		Result.RestrictionDetailsError = ErrorProcessing.DetailErrorDescription(ErrorInfo);
	EndTry;
	
	If CommonContext = Undefined Then
		Return Result;
	EndIf;
	
	DependenciesAccountingAvailable = True;
	ListsWithRestriction = Undefined;
	Try
		ListsWithRestriction = AccessManagementInternalCached.ListsWithRestriction();
	Except
		ErrorInfo = ErrorInfo();
		Result.RestrictionDetailsError = ErrorProcessing.DetailErrorDescription(ErrorInfo);
		DependenciesAccountingAvailable = False;
	EndTry;
	
	If ListsWithRestriction <> Undefined Then
		ListsWithRestriction = New Map(ListsWithRestriction);
	Else
		ListsWithRestriction = New Map;
		DependenciesAccountingAvailable = False;
	EndIf;
	CommonContext.Insert("ListsWithRestriction", ListsWithRestriction);
	
	RestrictionDetails = Undefined;
	Try
		RestrictionDetails = DataRestrictionDetails(CommonContext, FullName, True);
	Except
		Result.RestrictionDetailsError = ErrorProcessing.DetailErrorDescription(ErrorInfo);
		DependenciesAccountingAvailable = False;
	EndTry;
	If TypeOf(RestrictionDetails) = Type("String") Then
		Result.RestrictionDetailsError = RestrictionDetails;
		RestrictionDetails = Undefined;
	EndIf;
	
	If RestrictionDetails <> Undefined Then
		Result.TextInManagerModule                    = RestrictionDetails.TextInManagerModule;
		ForUsers.RestrictionInModule                = RestrictionDetails.Text;
		ForUsers.ByOwnerWithoutSavingAccessKeys = RestrictionDetails.ByOwnerWithoutSavingAccessKeys;
		ForExternalUsers.RestrictionInModule         = RestrictionDetails.TextForExternalUsers1;
		ForExternalUsers.ByOwnerWithoutSavingAccessKeys =
			RestrictionDetails.ByOwnerWithoutSavingAccessKeysForExternalUsers;
		
		If Parameters.Text = Undefined Then
			ForUsers.RestrictionToCheck = ForUsers.RestrictionInModule;
		Else
			ForUsers.RestrictionToCheck = Parameters.Text;
			RestrictionDetails.Text               = Parameters.Text;
		EndIf;
		
		If Parameters.TextForExternalUsers1 = Undefined Then
			ForExternalUsers.RestrictionToCheck = ForExternalUsers.RestrictionInModule;
		Else
			ForExternalUsers.RestrictionToCheck   = Parameters.TextForExternalUsers1;
			RestrictionDetails.TextForExternalUsers1 = Parameters.TextForExternalUsers1;
		EndIf;
	EndIf;
	
	If ListsWithRestriction.Get(FullName) = Undefined Then
		ListsWithRestriction.Insert(FullName, True);
		Result.TextInManagerModule = Undefined;
	EndIf;
	
	Context = New Structure;
	Context.Insert("FullName",                FullName);
	Context.Insert("CommonResult",           Result);
	Context.Insert("CommonContext",            CommonContext);
	Context.Insert("RestrictionDetails",      RestrictionDetails);
	Context.Insert("ConsiderDependencies",     Parameters.ConsiderDependencies);
	Context.Insert("DependenciesAccountingAvailable", DependenciesAccountingAvailable);
	Context.Insert("ListsRestrictionsVersions", New Map);
	Context.Insert("LeadingLists",            New Map);
	Context.Insert("AdditionalContext",   New Structure("ForUsers, ForExternalUsers"));
	
	CheckRestrictionForUsersKind(Context, ForUsers, False,
		Context.AdditionalContext.ForUsers);
	
	CheckRestrictionForUsersKind(Context, ForExternalUsers, True,
		Context.AdditionalContext.ForExternalUsers);
	
	If Not Context.DependenciesAccountingAvailable Then
		Return Result;
	EndIf;
	
	If Parameters.ConsiderDependencies Then
		CommonContext.Insert("SpecialFullName", FullName);
		CommonContext.Insert("SpecialRestrictionDetails", RestrictionDetails);
		CommonContext.Insert("ListsWithRestriction", New FixedMap(ListsWithRestriction));
		NewStoredParameters = StoredAccessRestrictionParameters(CommonContext);
		ActiveParameters = New Structure(NewStoredParameters.ForWritingObjectsAndCheckingRights.Get()); // See NewStoredWriteParametersStructure
		If ActiveParameters.ListsRestrictionsVersions.Get(FullName) = Undefined Then
			Context.ListsRestrictionsVersions.Insert(FullName, True);
		Else
			Context.ListsRestrictionsVersions.Insert(FullName,
				ActiveParameters.ListsRestrictionsVersions.Get(FullName));
		EndIf;
		SetALimitOnTheOwnerUsed(ForUsers,
			FullName, ActiveParameters.AdditionalContext.ForUsers);
		SetALimitOnTheOwnerUsed(ForExternalUsers,
			FullName, ActiveParameters.AdditionalContext.ForExternalUsers);
	Else
		Context.ListsRestrictionsVersions.Insert(FullName, True);
		ActiveParameters = New Structure;
		ActiveParameters.Insert("AdditionalContext", Context.AdditionalContext);
	EndIf;
	ActiveParameters.Insert("ListsRestrictionsVersions", Context.ListsRestrictionsVersions);
	ActiveParameters.Insert("LeadingLists",            Context.LeadingLists);
	
	Settings = ImplementationSettings(ActiveParameters);
	
	TablesTypesByNames = AccessManagementInternalCached.LanguageSyntax().TablesTypes.ByNames;
	SetImplementationSettings(Result.ImplementationSettings, Settings, TablesTypesByNames);
	
	Result.ForUsers.RestrictionInRoles = Settings.RestrictionsInRoles.ForUsers.Get(
		XMLFullName(FullName, TablesTypesByNames));
	
	Result.ForExternalUsers.RestrictionInRoles = Settings.RestrictionsInRoles.ForExternalUsers.Get(
		XMLFullName(FullName, TablesTypesByNames));
	
	Return Result;
	
EndFunction

// For the ObjectAccessRestrictionCheckResult function
Procedure SetALimitOnTheOwnerUsed(Result, FullName, AdditionalContext)
	
	Properties = AdditionalContext.ListRestrictionsProperties.Get(FullName);
	If Properties = Undefined Then
		Return;
	EndIf;
	
	Result.TheOwnerRestrictionIsUsed =
		Properties.OwnerField <> Undefined And Not Properties.OwnerField.Disabled;
	
EndProcedure

// For the ObjectAccessRestrictionCheckResult function.
Procedure SetImplementationSettings(ImplementationSettings, Data, TablesTypesByNames)
	
	AddTypesReguiredInDefinedType(ImplementationSettings, TablesTypesByNames, True,
		Data.AccessValues, "AccessValue");
	
	AddTypesReguiredInDefinedType(ImplementationSettings, TablesTypesByNames, True,
		Data.AccessKeysValuesOwners.References, "AccessKeysValuesOwner");
	
	AddTypesReguiredInDefinedType(ImplementationSettings, TablesTypesByNames, False,
		Data.AccessKeysValuesOwners.Objects, "AccessKeysValuesOwnerObject");
	
	AddTypesReguiredInDefinedType(ImplementationSettings, TablesTypesByNames, False,
		Data.AccessKeysValuesOwners.Documents, "AccessKeysValuesOwnerDocument");
	
	AddTypesReguiredInDefinedType(ImplementationSettings, TablesTypesByNames, False,
		Data.AccessKeysValuesOwners.RecordSets, "AccessKeysValuesOwnerRecordSet");
	
	AddTypesReguiredInDefinedType(ImplementationSettings, TablesTypesByNames, False,
		Data.AccessKeysValuesOwners.CalculationRegisterRecordSets,
			"AccessKeysValuesOwnerCalculationRegisterRecordSet");
	
	AddTypesReguiredInDefinedType(ImplementationSettings, TablesTypesByNames, False,
		Data.AccessKeysValuesOwners.CalculationRegisterRecordSets,
			"AccessKeysValuesOwnerCalculationRegisterRecordSet");
	
	ImplementationSettings.Insert("RegisterAccessKeysRegisterField", "");
	ImplementationSettings.Insert("DimensionTypesForSeparateKeyRegister", Undefined);
	For Each KeyAndValue In Data.KeysRegistersDimensionsTypes Do
		If StrFind(KeyAndValue.Key, ".") > 0 Then
			Continue;
		EndIf;
		KeysRegisterName = KeyAndValue.Key;
		
		If KeysRegisterName = "AccessKeysForRegisters" Then
			AddTypesReguiredInDefinedType(ImplementationSettings, TablesTypesByNames, True,
				KeyAndValue.Value.TypesNames, "RegisterAccessKeysRegisterField");
		Else
			RegisterDimensions = Metadata.InformationRegisters[KeysRegisterName].Dimensions;
			TypesList = "";
			FieldNumber = 1;
			For Each RegisterFieldsDetails In KeyAndValue.Value.RegistersFields Do
				Break;
			EndDo;
			For Each FieldDetails In RegisterFieldsDetails.Value Do
				RegisterField = RegisterDimensions.Find("Field" + FieldNumber);
				TypeDescription = ?(RegisterField = Undefined, New TypeDescription, RegisterField.Type);
				TypesList = TypesList + ?(TypesList = "", "", Chars.LF)
					+ NStr("en = '- for dimension';") + " " + "Field" + FieldNumber + ":" + Chars.LF
					+ "	" + TextWithIndent(TypesListFromArray(FieldDetails.Type.Types(),
						True, TablesTypesByNames, TypeDescription), "	");
				FieldNumber = FieldNumber + 1;
			EndDo;
			ImplementationSettings.Insert("DimensionTypesForSeparateKeyRegister",
				New Structure("InformationRegisterName, DimensionsTypes", KeysRegisterName, TypesList));
		EndIf;
	EndDo;
	
	ImplementationSettings.Insert("PredefinedID", Undefined);
	For Each KeyAndValue In Data.PredefinedIDs Do
		NameParts = StrSplit(KeyAndValue.Key, ".", False);
		AlreadyAdded = Metadata.Catalogs[NameParts[0]].GetPredefinedNames().Find(NameParts[1]) <> Undefined;
		ImplementationSettings.Insert("PredefinedID",
			New Structure("CatalogName, PredefinedItemName", NameParts[0],
				 "- " + NameParts[1] + ?(AlreadyAdded, " (" + NStr("en = 'already added';") + ")", "")));
		Break;
	EndDo;
	
EndProcedure

// For the SetImplementationSettings procedure.
Procedure AddTypesReguiredInDefinedType(ImplementationSettings, TablesTypesByNames, RefsTypes, TypesNames, TypeToDefineName)
	
	ImplementationSettings.Insert(TypeToDefineName, "");
	If TypesNames.Count() = 0 Then
		Return;
	EndIf;
	
	ImplementationSettings[TypeToDefineName] = TypesListFromArray(TypesNames,
		RefsTypes, TablesTypesByNames, Metadata.DefinedTypes[TypeToDefineName].Type);
	
EndProcedure

// For the SetImplementationSettings and AddTypesRequiredInDefinedType procedures.
Function TypesListFromArray(TypesNames, RefsTypes, TablesTypesByNames, TypeDescription)
	
	TypesList = "";
	For Each TypeName In TypesNames Do
		If TypeOf(TypeName) = Type("Type") Then
			Type = TypeName;
		Else
			Type = Type(TypeName);
		EndIf;
		MetadataObject = Metadata.FindByType(Type);
		FullName = MetadataObject.FullName();
		
		TypesList = TypesList + ?(TypesList = "", "", Chars.LF)
			+ "- " + ?(RefsTypes, RefTypeName1(FullName, TablesTypesByNames),
				ObjectTypeOrRecordSetName(FullName, TablesTypesByNames));
		
		If TypeDescription.ContainsType(Type) Then
			TypesList = TypesList + " (" + NStr("en = 'already added';") + ")";
		EndIf;
	EndDo;
	
	Return TypesList;
	
EndFunction

// For the ObjectAccessRestrictionCheckResult function.
Function RestrictionCheckResultStructureForUsersKind()
	
	Properties = New Structure;
	Properties.Insert("RestrictionToCheck");
	Properties.Insert("ErrorsDescription");
	Properties.Insert("RestrictionParametersGenerationError");
	Properties.Insert("QueriesTextsGenerationError");
	Properties.Insert("RestrictionByOwnerPossible");
	Properties.Insert("TheOwnerRestrictionIsUsed");
	Properties.Insert("RestrictionInRoles");
	Properties.Insert("RestrictionInModule");
	Properties.Insert("ByOwnerWithoutSavingAccessKeys");
	
	Return Properties;
	
EndFunction

// For the ObjectAccessRestrictionCheckResult function.
Procedure CheckRestrictionForUsersKind(Context, Result, ForExternalUsers, AdditionalContext)
	
	RestrictionText = ?(ForExternalUsers, Context.CommonResult.ForExternalUsers,
		Context.CommonResult.ForUsers).RestrictionToCheck;
	
	RestrictionStructure = CalculatedRestrictionStructure(Context.FullName,
		RestrictionText, Context.CommonResult.TextInManagerModule, ForExternalUsers, True);
	
	If RestrictionStructure <> Undefined
	   And RestrictionStructure.ErrorsDescription.HasErrors Then
		
		Result.ErrorsDescription = RestrictionStructure.ErrorsDescription;
		Context.DependenciesAccountingAvailable = False;
		Return;
	EndIf;
	
	AdditionalContext = NewAdditionalContext();
	AddAdditionalContext(Context.FullName,
		AdditionalContext, Context.RestrictionDetails, ForExternalUsers);
	
	ErrorOnCallException = New Structure("Text", Undefined);
	AdditionalContext.Insert("ErrorOnCallException", ErrorOnCallException);
	
	Try
		RestrictionParameters = RestrictionParametersByRestrictionStructure(Context.FullName,
			RestrictionStructure, ForExternalUsers, Context.CommonContext, AdditionalContext);
	Except
		ErrorInfo = ErrorInfo();
		RestrictionParameters = Undefined;
		If ValueIsFilled(ErrorOnCallException.Text) Then
			Result.RestrictionParametersGenerationError = ErrorOnCallException.Text;
		Else
			Result.RestrictionParametersGenerationError =
				StringFunctionsClientServer.SubstituteParametersToString(
					NStr("en = 'Cannot generate access restriction parameters. Reason:
					           |%1';"), ErrorProcessing.DetailErrorDescription(ErrorInfo));
		EndIf;
		Context.DependenciesAccountingAvailable = False;
	EndTry;
	
	If RestrictionParameters <> Undefined Then
		Result.RestrictionByOwnerPossible = RestrictionParameters.OwnerField <> Undefined;
		RestrictionParameters.Context.ListsWithKeysRecordForDependentListsWithoutKeys = New Map;
		SetAccessKeysRecordProperties(RestrictionParameters);
		RestrictionParameters.Insert("DoNotWriteAccessKeysForUsersAndExternalUsers", False);
		For Each KeyAndValue In RestrictionParameters.LeadingLists.ByFieldsValues Do
			Context.LeadingLists.Insert(KeyAndValue.Key, Undefined);
		EndDo;
		For Each KeyAndValue In RestrictionParameters.LeadingLists.ByAccessKeys Do
			Context.ListsRestrictionsVersions.Insert(KeyAndValue.Key, Undefined);
		EndDo;
		RestrictionParameters.Context.Insert("SkipTypesToDefineCheck");
		Try
			AddQueryTextsToRestrictionParameters(RestrictionParameters);
		Except
			ErrorInfo = ErrorInfo();
			If ValueIsFilled(ErrorOnCallException.Text) Then
				Result.QueriesTextsGenerationError = ErrorOnCallException.Text;
			Else
				Result.QueriesTextsGenerationError =
					StringFunctionsClientServer.SubstituteParametersToString(
						NStr("en = 'Cannot generate query texts based on access restriction parameters. Reason:
						           |%1';"), ErrorProcessing.DetailErrorDescription(ErrorInfo));
			EndIf;
			Context.DependenciesAccountingAvailable = False;
		EndTry;
	EndIf;
	
	If Context.ConsiderDependencies Then
		Return;
	EndIf;
	
	ShortenedProperties = New Structure;
	ShortenedProperties.Insert("AccessDenied", False);
	ShortenedProperties.Insert("OwnerField", Undefined);
	ShortenedProperties.Insert("BasicFields", Undefined);
	ShortenedProperties.Insert("SeparateKeysRegisterName", Undefined);
	AdditionalContext.ListRestrictionsProperties.Insert(Context.FullName, ShortenedProperties);
	
	If Not Context.DependenciesAccountingAvailable Then
		Return;
	EndIf;
	
	FillPropertyValues(ShortenedProperties, RestrictionParameters);
	
EndProcedure

// For the StoredAccessRestrictionParameters and CalculatedRestrictionParameters functions.
Function CommonVersion(CommonContext, FullName, VersionForUsers, VersionForExternalUsers)
	
	If CommonContext.ListsWithRestriction.Get(FullName) = Undefined Then
		Return Undefined;
	EndIf;
	
	Return String(VersionForUsers) + Chars.LF + String(VersionForExternalUsers);
	
EndFunction

// For the CalculatedRestrictionParameters function.
Procedure SetAccessKeysRecordProperties(Result)
	
	WithoutKeysRecord = False;
	WithKeyEntryForDependentListsWithoutKeys = False;
	
	If Result.RestrictionDisabled
	 Or Result.AccessDenied
	 Or Result.UsesRestrictionByOwner Then
		
		If Result.UsesRestrictionByOwner
		 Or Result.Context.WithoutMetadataObject
		 Or Result.Context.ListsWithKeysRecordForDependentListsWithoutKeys.Get(
		 		Result.List) = Undefined Then
			
			WithoutKeysRecord = True;
		Else
			WithKeyEntryForDependentListsWithoutKeys = True;
		EndIf;
	EndIf;
	
	Result.Insert("DoNotWriteAccessKeys", WithoutKeysRecord);
	Result.Insert("WithAccessKeyEntryForDependentListsWithoutKeys",
		WithKeyEntryForDependentListsWithoutKeys);
	
EndProcedure

// For the CalculatedRestrictionParameters and StoredAccessRestrictionParameters functions.
//
// Returns:
//   Structure:
//     * Text - String
//     * TextForExternalUsers1 - String
//     * ByOwnerWithoutSavingAccessKeys - Boolean
//                                         - Undefined
//     * ByOwnerWithoutSavingAccessKeysForExternalUsers - Boolean
//                                                                - Undefined
//     * TextInManagerModule - Boolean
//
Function DataRestrictionDetails(CommonContext, FullName, WithoutCallingException = False)
	
	Restriction = New Structure;
	Restriction.Insert("Text", "");
	Restriction.Insert("TextForExternalUsers1", "");
	Restriction.Insert("ByOwnerWithoutSavingAccessKeys", Undefined);
	Restriction.Insert("ByOwnerWithoutSavingAccessKeysForExternalUsers", Undefined);
	Restriction.Insert("TextInManagerModule", False);
	
	TextInManagerModule = CommonContext.ListsWithRestriction.Get(FullName);
	If TextInManagerModule = Undefined Then
		Return Restriction;
	EndIf;
	
	Restriction.TextInManagerModule = TextInManagerModule;
	
	If Common.SubsystemExists("StandardSubsystems.FilesOperations") Then
		ModuleFilesOperationsInternal = Common.CommonModule("FilesOperationsInternal");
		IsFilesCatalog = ModuleFilesOperationsInternal.IsFilesOrFilesVersionsCatalog(FullName);
	Else
		IsFilesCatalog = False;
	EndIf;
	
	If IsDocumentJournal(FullName) Or IsFilesCatalog Then
		// 
		// 
		// 
		Restriction.ByOwnerWithoutSavingAccessKeys = True;
		Restriction.ByOwnerWithoutSavingAccessKeysForExternalUsers = True;
	EndIf;
	
	If TextInManagerModule Then
		Manager = Common.ObjectManagerByFullName(FullName);
		
		Try
			Manager.OnFillAccessRestriction(Restriction);
		Except
			ErrorInfo = ErrorInfo();
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = '""%1"" is specified as a access restriction list in procedure
				           |""%2"" of common module ""%3"".
				           |
				           |Access restriction of this list is misspecified
				           |in manager module of procedure ""%4"". Reason:
				           |
				           |%5';"),
				FullName,
				"OnFillListsWithAccessRestriction",
				"AccessManagementOverridable",
				"OnFillAccessRestriction",
				ErrorProcessing.DetailErrorDescription(ErrorInfo));
			
			If WithoutCallingException Then
				Return ErrorText;
			EndIf;
			Raise ErrorText;
		EndTry;
	Else
		MetadataObject = Common.MetadataObjectByFullName(FullName);
		Try
			AccessManagementOverridable.OnFillAccessRestriction(MetadataObject, Restriction);
		Except
			ErrorInfo = ErrorInfo();
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = '""%1"" is specified as a access restriction list in procedure
				           |""%2"" of common module ""%3"".
				           |
				           |Access restriction of this list is misspecified
				           |in procedure ""%5"" of common module ""%4"". Reason:
				           |
				           |%6';"),
				FullName,
				"OnFillListsWithAccessRestriction",
				"AccessManagementOverridable",
				"AccessManagementOverridable",
				"OnFillAccessRestriction",
				ErrorProcessing.DetailErrorDescription(ErrorInfo));
			
			If WithoutCallingException Then
				Return ErrorText;
			EndIf;
			Raise ErrorText;
		EndTry;
	EndIf;
	
	If IsDocumentJournal(FullName)
	   And (    Restriction.ByOwnerWithoutSavingAccessKeys <> True
		  Or Restriction.ByOwnerWithoutSavingAccessKeysForExternalUsers <> True) Then
		
		If ScriptVariantRussian() Then
			RestrictionTemplate =
				"РазрешитьЧтениеИзменение
				|ГДЕ
				|	ЧтениеОбъектаРазрешено(Ссылка)"; // @Non-NLS
		Else
			RestrictionTemplate =
				"AllowReadWrite
				|WHERE
				|	ObjectReadingAllowed(Ref)";
		EndIf;
		
		If TextInManagerModule Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = '""%1"" is specified as a access restriction list in procedure
				           |""%2"" of common module ""%3"".
				           |
				           |Access restriction of this list is misspecified
				           |in procedure ""%4"" of the manager module. Reason:
				           |
				           |Unlike registers, document journals only support
				           |restrictions by owner without writing access keys:
				           |
				           |%5';"),
				FullName,
				"OnFillListsWithAccessRestriction",
				"AccessManagementOverridable",
				"OnFillAccessRestriction",
				RestrictionTemplate);
		Else
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = '""%1"" is specified as a access restriction list in procedure
				           |""%2"" of common module ""%3"".
				           |
				           |Access restriction of this list is misspecified
				           |in procedure ""%5"" of common module ""%4"". Reason:
				           |
				           |Unlike registers, document journals only support
				           |restrictions by owner without writing access keys:
				           |
				           |%6';"),
				FullName,
				"OnFillListsWithAccessRestriction",
				"AccessManagementOverridable",
				"AccessManagementOverridable",
				"OnFillAccessRestriction",
				RestrictionTemplate);
		EndIf;
		If WithoutCallingException Then
			Return ErrorText;
		EndIf;
		Raise ErrorText;
	EndIf;
	
	Return Restriction;
	
EndFunction

// For the DataRestrictionDetails function.
Function IsDocumentJournal(FullName)
	
	Return StrStartsWith(Upper(FullName), Upper("ЖурналДокументов.")) // @Non-NLS
	    Or StrStartsWith(Upper(FullName), Upper("DocumentJournal."));
	
EndFunction

// For the CalculatedRestrictionParameters and RestrictionParametersForUsersKind functions.
//
// Returns:
//   See RestrictionStructure
//
Function CalculatedRestrictionStructure(FullName, RestrictionText, TextInManagerModule, ForExternalUsers, WithoutException = False)
	
	If Not ValueIsFilled(RestrictionText) Then
		Return Undefined;
	EndIf;
	
	ParsedRestriction = ParsedRestriction(FullName, RestrictionText);
	
	CheckFieldTablesAndFieldsTypes(ParsedRestriction);
	
	RestrictionStructure = RestrictionStructure(ParsedRestriction);
	
	If WithoutException Or Not RestrictionStructure.ErrorsDescription.HasErrors Then
		Return RestrictionStructure;
	EndIf;
	
	ErrorsText = ErrorsTextToCallException(FullName,
		RestrictionStructure.ErrorsDescription, ForExternalUsers, TextInManagerModule);
	
	Raise ErrorsText;
	
EndFunction

// For the ListPropertiesAsLeadingOne and RestrictionParameters functions, and the SessionParametersSetting,
// FillRestrictionParameters, and AddListRestrictionParameters procedures.
//
// Returns:
//   See NewStoredWriteParametersStructure
//
Function ActiveAccessRestrictionParameters(TransactionID, CommonContext,
			Refresh, SetSessionParametersForTemplates = False,
			SettingParametersForAccesRightsReport = False, HasChanges = False) Export
	
	If Refresh Then
		ParametersVersion = NewAccessRestrictionParametersVersion(CommonContext, HasChanges);
		SetParametersVersion(ParametersVersion, TransactionID, CommonContext);
		AccessRestrictionParameters = SessionParameters.AccessRestrictionParameters; // See SessionAccessRestrictionParameters
		Return AccessRestrictionParameters.Parameters;
	EndIf;
	
	CurrentParameters = SessionParameters.AccessRestrictionParameters; // See SessionAccessRestrictionParameters
	
	If Not CurrentParameters.Property("Parameters") Or CurrentParameters.Parameters = Undefined Then
		CurrentParameters = New Structure("Version, HashSum", "", ""); // See SessionAccessRestrictionParameters
		TransactionIDs = New Map;
	Else
		TransactionIDs = RestrictionParametersCache().TransactionIDs;
	EndIf;
	
	If TransactionActive()
	   And TransactionIDs.Get(TransactionID) <> Undefined Then
		
		Return CurrentParameters.Parameters;
	EndIf;
	
	While True Do
		VersionDetails = LastVersionDetails();
		If CurrentParameters.Version   = VersionDetails.Version
		   And CurrentParameters.HashSum = VersionDetails.HashSum Then
			Break;
		EndIf;
		If Common.FileInfobase() Then
			Break;
		EndIf;
		If TheTasksForRecordingTheNewVersionOfTheAccessRestrictionParametersHaveBeenCompleted() Then
			Break;
		EndIf;
	EndDo;
	
	If Not SetSessionParametersForTemplates
	   And Not SettingParametersForAccesRightsReport
	   And CurrentParameters.Version   = VersionDetails.Version
	   And CurrentParameters.HashSum = VersionDetails.HashSum Then
		
		UpdateTransactionIDs(TransactionID);
		Return CurrentParameters.Parameters;
	EndIf;
	
	// Parameters in the database differ from the parameters in memory.
	If ValueIsFilled(VersionDetails.Version) Then
		ParametersVersion = ParametersVersion(VersionDetails.Version,
			SetSessionParametersForTemplates, SettingParametersForAccesRightsReport);
	Else
		ParametersVersion = NewAccessRestrictionParametersVersion(CommonContext);
	EndIf;
	
	SetParametersVersion(ParametersVersion, TransactionID, CommonContext,
		SetSessionParametersForTemplates);
	
	AccessRestrictionParameters = SessionParameters.AccessRestrictionParameters; // See SessionAccessRestrictionParameters
	Return AccessRestrictionParameters.Parameters;
	
EndFunction

// For the AccessRights report.
//
// Returns:
//  Structure:
//   * ForUsers - String
//   * ForExternalUsers - String
//
Function AllRightsRestrictionsKindsForAccessRightsReport()
	
	Cache = RestrictionParametersCache();
	
	If Cache.TypesRestrictionsPermissionsForUsers <> Undefined
	   And Cache.TypesRestrictionsPermissionsForExternalUsers <> Undefined Then
		Return New Structure("ForUsers, ForExternalUsers",
			Cache.TypesRestrictionsPermissionsForUsers,
			Cache.TypesRestrictionsPermissionsForExternalUsers);
	EndIf;
	
	ActiveAccessRestrictionParameters(Undefined, Undefined, False, False, True);
	
	Return AllRightsRestrictionsKindsForAccessRightsReport();
	
EndFunction

// This method is required by the NewVersionOfAccessRestrictionParameters function.
Function RecordingAccessRestrictionParametersInTheCurrentSession()
	
	SetPrivilegedMode(True);
	CurrentParameters = SessionParameters.AccessRestrictionParameters;
	SetPrivilegedMode(False);
	
	Return CurrentParameters.Property("RecordingAccessRestrictionParametersInTheCurrentSession");
	
EndFunction

// For the ActiveAccessRestrictionParameters and NewAccessRestrictionParametersVersion functions.
//
// Returns:
//  Structure:
//   * Version                   - Number
//                              - Undefined
//   * HashSum                 - String
//                              - Undefined
//   * CreationDate             - Date
//                              - Undefined
//   * TemplatesParametersVersions - ValueStorage
//                              - Undefined
//
Function LastVersionDetails(ReadVersionsOfTemplateParameters = False)
	
	Query = New Query;
	Query.Text =
	"SELECT TOP 1
	|	AccessRestrictionParameters.Version AS Version,
	|	AccessRestrictionParameters.HashSum AS HashSum,
	|	AccessRestrictionParameters.CreationDate AS CreationDate,
	|	AccessRestrictionParameters.TemplatesParametersVersions AS TemplatesParametersVersions
	|FROM
	|	InformationRegister.AccessRestrictionParameters AS AccessRestrictionParameters
	|
	|ORDER BY
	|	AccessRestrictionParameters.Version DESC";
	
	If Not ReadVersionsOfTemplateParameters Then
		Query.Text = StrReplace(Query.Text,
			"AccessRestrictionParameters.TemplatesParametersVersions", "Undefined");
	EndIf;
	
	Selection = Query.Execute().Select();
	Selection.Next();
	
	Result = New Structure("Version, HashSum, CreationDate, TemplatesParametersVersions");
	FillPropertyValues(Result, Selection);
	
	Return Result;
	
EndFunction

// For the ActiveAccessRestrictionParameters function.
Function ParametersVersion(Version, SetSessionParametersForTemplates, SettingParametersForAccesRightsReport)
	
	Query = New Query;
	Query.Text =
	"SELECT TOP 1
	|	AccessRestrictionParameters.Version AS Version,
	|	AccessRestrictionParameters.HashSum AS HashSum,
	|	AccessRestrictionParameters.CreationDate AS CreationDate,
	|	AccessRestrictionParameters.ForTemplatesInUsersSessions AS ForTemplatesInUsersSessions,
	|	AccessRestrictionParameters.ForTemplatesInExternalUsersSessions AS ForTemplatesInExternalUsersSessions,
	|	AccessRestrictionParameters.ForWritingObjectsAndCheckingRights AS ForWritingObjectsAndCheckingRights,
	|	AccessRestrictionParameters.TemplatesParametersVersions AS TemplatesParametersVersions,
	|	AccessRestrictionParameters.ForAccessRightsReport AS ForAccessRightsReport
	|FROM
	|	InformationRegister.AccessRestrictionParameters AS AccessRestrictionParameters
	|WHERE
	|	AccessRestrictionParameters.Version = &Version";
	
	If SetSessionParametersForTemplates Or SettingParametersForAccesRightsReport Then
		Query.Text = StrReplace(Query.Text,
			"AccessRestrictionParameters.ForWritingObjectsAndCheckingRights", "Undefined");
		Query.Text = StrReplace(Query.Text,
			"AccessRestrictionParameters.TemplatesParametersVersions", "Undefined");
	EndIf;
	If Not SettingParametersForAccesRightsReport Then
		Query.Text = StrReplace(Query.Text,
			"AccessRestrictionParameters.ForAccessRightsReport", "Undefined");
	EndIf;
		
	If SetSessionParametersForTemplates
	 Or SessionParameters.AccessRestrictionParameters.Property("SessionParametersForRemplatesAreSet") Then
		
		Query.Text = StrReplace(Query.Text, ?(Users.IsExternalUserSession(),
			"AccessRestrictionParameters.ForTemplatesInUsersSessions",
			"AccessRestrictionParameters.ForTemplatesInExternalUsersSessions"), "Undefined");
	Else
		Query.Text = StrReplace(Query.Text,
			"AccessRestrictionParameters.ForTemplatesInUsersSessions", "Undefined");
		Query.Text = StrReplace(Query.Text,
			"AccessRestrictionParameters.ForTemplatesInExternalUsersSessions", "Undefined");
	EndIf;
	
	Query.SetParameter("Version", Version);
	
	Selection = Query.Execute().Select();
	Selection.Next();
	
	Return Selection;
	
EndFunction

// For the ActiveAccessRestrictionParameters function.
//
// Returns:
//   See StoredAccessRestrictionParameters
//
Function NewAccessRestrictionParametersVersion(CommonContext, HasChanges = False)
	
	Try
		CheckWhetherTheMetadataIsUpToDate();
	Except
		If StandardSubsystemsServer.ThisErrorRequirementRestartSession(ErrorInfo()) Then
			ScheduleAccessRestrictionParametersUpdate(
				"NewAccessRestrictionParametersVersion", True);
		EndIf;
		Raise;
	EndTry;
	
	DeleteStoredParametersVersionStrings = False;
	
	If TypeOf(CommonContext) <> Type("Structure")
	 Or ValueIsFilled(CommonContext.UsedValuesTypes.FullTableName) Then
		RefreshReusableValues();
		CommonContext = CommonContextOfRestrictionParametersCalculation();
	EndIf;
	
	If NeedRegisterAccessRestrictionParametersVersionString() Then
		If Not CommonContext.Property("StoredParametersVersionStrings") Then
			CommonContext.Insert("StoredParametersVersionStrings");
			DeleteStoredParametersVersionStrings = True;
		EndIf;
	EndIf;
	
	ListsRestrictionsVersions = New Map;
	StoredParameters = StoredAccessRestrictionParameters(CommonContext, ListsRestrictionsVersions);
	ListsRestrictionsVersions.Insert("Catalog.SetsOfAccessGroups", "1");
	
	WriteParameters = New Structure;
	WriteParameters.Insert("ListsRestrictionsVersions", ListsRestrictionsVersions);
	WriteParameters.Insert("StoredParameters",        StoredParameters);
	WriteParameters.Insert("AccessID",     AccessID());
	
	If CommonContext.Property("ListsWithOutdatedAccessOptions") Then
		WriteParameters.Insert("ListsWithOutdatedAccessOptions",
			CommonContext.ListsWithOutdatedAccessOptions);
	Else
		WriteParameters.Insert("ListsWithOutdatedAccessOptions");
	EndIf;
	
	If CommonContext.Property("StoredParametersVersionStrings") Then
		WriteParameters.Insert("VersionStrings", CommonContext.StoredParametersVersionStrings);
	EndIf;
	
	If Not TransactionActive()
	 Or ExclusiveMode()
	 Or CommonContext.Property("WriteInTheCurrentTransaction")
	 Or Common.FileInfobase()
	 Or StandardSubsystemsServer.ThisIsSplitSessionModeWithNoDelimiters()
	 Or RecordingAccessRestrictionParametersInTheCurrentSession() Then
		
		NumberOfTheBlockingAttempt = 0;
		While True Do
			NumberOfTheBlockingAttempt = NumberOfTheBlockingAttempt + 1;
			IsLockError = False;
			Try
				VersionDetails = DescriptionOfTheNewVersionOfAccessRestrictionParameters(WriteParameters,, IsLockError);
			Except
				If IsLockError
				   And NumberOfTheBlockingAttempt < 3
				   And Not TransactionActive() Then
					Continue;
				EndIf;
				If StandardSubsystemsServer.ThisErrorRequirementRestartSession(ErrorInfo()) Then
					ScheduleAccessRestrictionParametersUpdate(
						"NewAccessRestrictionParametersVersion", True);
				EndIf;
				Raise;
			EndTry;
			Break;
		EndDo;
	Else
		RecordingOptionsInTheStore = New ValueStorage(WriteParameters);
		VersionDetails = Undefined;
		While True Do
			VersionDetails = DescriptionOfTheNewVersionOfAccessRestrictionParameters(
				RecordingOptionsInTheStore.Get(), True);
			If VersionDetails <> Undefined Then
				Break;
			EndIf;
			If TheTasksForRecordingTheNewVersionOfTheAccessRestrictionParametersHaveBeenCompleted() Then
				Break;
			EndIf;
		EndDo;
		If VersionDetails = Undefined Then
			ProcedureName = NameOfTheProcedureForSettingTheRecordOfTheNewVersionOfTheAccessRestrictionParameters();
			ResultAddress = PutToTempStorage(Undefined);
			ProcedureParameters = New Array;
			ProcedureParameters.Add(ResultAddress);
			ProcedureParameters.Add(RecordingOptionsInTheStore);
			CurrentSession = GetCurrentInfoBaseSession();
			JobDescription = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'Access management: Save a new version of access restriction parameters (from the %1 session started on %2)';",
					Common.DefaultLanguageCode()),
				Format(CurrentSession.SessionNumber, "NG="),
				Format(CurrentSession.SessionStarted, "DLF=DT"));
			BackgroundJob = BackgroundJobs.Execute(ProcedureName, ProcedureParameters,, JobDescription);
			BackgroundJob = BackgroundJob.WaitForExecutionCompletion(60);
			Result = GetFromTempStorage(ResultAddress);
			ErrorTitle = NStr("en = 'Couldn''t save a new version of access restriction parameters due to:';");
			If BackgroundJob.State = BackgroundJobState.Active Then
				BackgroundJob.Cancel();
				ErrorText = ErrorTitle + Chars.LF
					+ NStr("en = 'Background job was in progress for more than 60 seconds. Therefore, it is canceled.';");
				Raise ErrorText;
			EndIf;
			If BackgroundJob.State = BackgroundJobState.Canceled Then
				ErrorText = ErrorTitle + Chars.LF
					+ NStr("en = 'Background job is canceled by administrator.';");
				Raise ErrorText;
			EndIf;
			If BackgroundJob.State <> BackgroundJobState.Completed Then
				If TypeOf(BackgroundJob.ErrorInfo) = Type("ErrorInfo") Then
					ErrorText = ErrorTitle + Chars.LF
						+ ErrorProcessing.DetailErrorDescription(BackgroundJob.ErrorInfo);
				Else
					ErrorText = ErrorTitle + Chars.LF
						+ NStr("en = 'Background job crashed.';");
				EndIf;
				Raise ErrorText;
			EndIf;
			If TypeOf(Result) <> Type("Structure") Then
				ErrorText = ErrorTitle + Chars.LF
					+ NStr("en = 'Background job did not return the result.';");
				Raise ErrorText;
			EndIf;
			If Result.SessionRestartRequired Then
				ScheduleAccessRestrictionParametersUpdate(
					"NewAccessRestrictionParametersVersion", True);
				CheckWhetherTheMetadataIsUpToDate();
				StandardSubsystemsServer.InstallRequiresSessionRestart(Result.ErrorText);
				Raise Result.ErrorText;
			EndIf;
			If ValueIsFilled(Result.ErrorText) Then
				ErrorText = ErrorTitle + Chars.LF + Result.ErrorText;
				Raise ErrorText;
			EndIf;
			VersionDetails = Result.VersionDetails;
		EndIf;
	EndIf;
	
	If CommonContext.Property("ListsWithOutdatedAccessOptions") Then
		CommonContext.ListsWithOutdatedAccessOptions =
			VersionDetails.ListsWithOutdatedAccessOptions;
	EndIf;
	
	If DeleteStoredParametersVersionStrings Then
		CommonContext.Delete("StoredParametersVersionStrings");
		
	ElsIf CommonContext.Property("StoredParametersVersionStrings") Then
		CommonContext.StoredParametersVersionStrings = VersionDetails.VersionStrings;
	EndIf;
	
	If VersionDetails.HasChanges Then
		HasChanges = True;
	EndIf;
	
	For Each KeyAndValue In VersionDetails.FillableVersionProperties Do
		StoredParameters.Insert(KeyAndValue.Key, KeyAndValue.Value);
	EndDo;
	
	Return StoredParameters;
	
EndFunction

// For the ActiveAccessRestrictionParameters and
// NewAccessRestrictionParametersVersion functions.
//
Function TheTasksForRecordingTheNewVersionOfTheAccessRestrictionParametersHaveBeenCompleted()
	
	JobsFilter = New Structure("MethodName, State",
		NameOfTheProcedureForSettingTheRecordOfTheNewVersionOfTheAccessRestrictionParameters(),
		BackgroundJobState.Active);
	
	FoundJobs = BackgroundJobs.GetBackgroundJobs(JobsFilter);
	
	If FoundJobs.Count() = 0 Then
		Return True;
	EndIf;
	
	BackgroundJobs.WaitForExecutionCompletion(FoundJobs, 1);
	
	Return False;
	
EndFunction

// For the NewAccessRestrictionParametersVersion and
//  NewAccessRestrictionParametersVersionWriteJobsCompleted functions.
//
Function NameOfTheProcedureForSettingTheRecordOfTheNewVersionOfTheAccessRestrictionParameters()
	
	Return "AccessManagementInternal.WriteANewVersionOfTheAccessRestrictionParametersInTheBackground";
	
EndFunction

// This method is required by the NewVersionOfAccessRestrictionParameters function.
Procedure WriteANewVersionOfTheAccessRestrictionParametersInTheBackground(ResultAddress, StorageParametersSet) Export
	
	Result = New Structure;
	Result.Insert("VersionDetails", New Structure);
	Result.Insert("ErrorText", "");
	Result.Insert("SessionRestartRequired", False);
	
	SetPrivilegedMode(True);
	Try
		Parameters = StorageParametersSet.Get();
		If Parameters.AccessID = AccessID() Then
			Result.VersionDetails = DescriptionOfTheNewVersionOfAccessRestrictionParameters(Parameters);
		Else
			Result.ErrorText = NStr("en = 'Error verifying access.';");
		EndIf;
	Except
		ErrorInfo = ErrorInfo();
		If StandardSubsystemsServer.SessionRestartRequired(Result.ErrorText) Then
			Result.SessionRestartRequired = True;
		EndIf;
		If Not Result.SessionRestartRequired
		 Or Not StandardSubsystemsServer.ThisErrorRequirementRestartSession(ErrorInfo) Then
			Result.ErrorText = ErrorProcessing.DetailErrorDescription(ErrorInfo);
		EndIf;
	EndTry;
	SetPrivilegedMode(False);
	
	PutToTempStorage(Result, ResultAddress);
	
EndProcedure

// For the NewAccessRestrictionParametersVersion function and
// the WriteNewAccessRestrictionParametersVersionInBackground procedure.
//
Function AccessID()
	
	Return LastAccessUpdate().AccessID;
	
EndFunction

// For the NewAccessRestrictionParametersVersion function and
// the WriteNewAccessRestrictionParametersVersionInBackground procedure.
// 
Function DescriptionOfTheNewVersionOfAccessRestrictionParameters(Parameters, WithoutRecording = False, IsLockError = False)
	
	Record = NewInformationRegisterTableAccessRestrictionParameters().Add();
	FillPropertyValues(Record, Parameters.StoredParameters);
	
	FillableVersionProperties = New Structure("Version, CreationDate, HashSum,
	|TemplatesParametersVersions, PersistentParametersHashSum, TemplatesParametersHashSum,
	|ForTemplatesInUsersSessions, ForTemplatesInExternalUsersSessions");
	
	Result = New Structure;
	Result.Insert("HasChanges", False);
	Result.Insert("FillableVersionProperties", FillableVersionProperties);
	Result.Insert("ListsWithOutdatedAccessOptions",
		Parameters.ListsWithOutdatedAccessOptions);
	Parameters.Insert("ListsWithTheNewPrimaryAccessOption", New Array);
	If Parameters.Property("VersionStrings") Then
		Result.Insert("VersionStrings", Parameters.VersionStrings);
	EndIf;
	
	If WithoutRecording Then
		VersionDetails = LastVersionDetails(True);
		FillInTheParametersForTemplates(Record, Parameters, VersionDetails);
		If VersionDetails.HashSum <> Record.HashSum Then
			Return Undefined;
		EndIf;
	Else
		BeginTransaction();
		Try
			If Common.FileInfobase() Then
				DataLock = New DataLock;
				DataLock.Add("InformationRegister.AccessRestrictionParameters");
				Try
					DataLock.Lock();
				Except
					IsLockError = True;
					Raise;
				EndTry;
				DataLock = New DataLock;
				DataLock.Add("InformationRegister.DataAccessKeysUpdate");
				DataLock.Add("InformationRegister.UsersAccessKeysUpdate");
				Try
					DataLock.Lock();
				Except
					IsLockError = True;
					Raise;
				EndTry;
			EndIf;
			VersionDetails = LastVersionDetails(True);
			While True Do
				FillInTheParametersForTemplates(Record, Parameters, VersionDetails);
				If VersionDetails.HashSum = Record.HashSum Then
					Break;
				EndIf;
				
				CheckWhetherTheMetadataIsUpToDate();
				
				If ValueIsFilled(VersionDetails.Version) Then
					NewVersion = VersionDetails.Version + 1;
				Else
					NewVersion = 1;
				EndIf;
				
				DataLock = New DataLock;
				LockItem = DataLock.Add("InformationRegister.AccessRestrictionParameters");
				LockItem.SetValue("Version", NewVersion);
				DataLock.Lock();
				NewVersionDetails = LastVersionDetails(True);
				
				If VersionDetails.Version <> NewVersionDetails.Version
				 Or NewVersionDetails.Version = NewVersion Then
					
					VersionDetails = NewVersionDetails;
					Continue;
				EndIf;
				
				CheckWhetherTheMetadataIsUpToDate();
				
				Record.Version = NewVersion;
				
				RecordSet = ServiceRecordSet(InformationRegisters.AccessRestrictionParameters);
				FillPropertyValues(RecordSet.Add(), Record);
				Record = RecordSet[0];
				RecordSet.Filter.Version.Set(NewVersion);
				FillPropertyValues(FillableVersionProperties, Record);
				
				ScheduleAccessUpdatesWhenSettingsChange(VersionDetails.Version, Parameters);
				RecordSet.Write();
				Result.HasChanges = True;
				
				If NeedRegisterAccessRestrictionParametersVersionString() Then
					RegisterAccessRestrictionParametersVersionString(RecordSet[0],
						Parameters.VersionStrings);
				EndIf;
				
				Break;
			EndDo;
			CommitTransaction();
		Except
			RollbackTransaction();
			Raise;
		EndTry;
	EndIf;
	
	If Not Result.HasChanges Then
		FillPropertyValues(FillableVersionProperties, VersionDetails,
			"Version, CreationDate, HashSum, TemplatesParametersVersions");
		FillPropertyValues(FillableVersionProperties, Record,
			"PersistentParametersHashSum, TemplatesParametersHashSum,
			|ForTemplatesInUsersSessions, ForTemplatesInExternalUsersSessions");
	ElsIf Not TransactionActive() Then
		ParameterName = "StandardSubsystems.AccessManagement.AccessRestrictionParametersCheckDate";
		StandardSubsystemsServer.SetExtensionParameter(ParameterName, CurrentSessionDate(), True);
		SetAccessUpdate(True);
	EndIf;
	
	Return Result;
	
EndFunction

// Returns:
//  ValueTable:
//   * Version                                  - Number
//   * HashSum                                - String
//   * PersistentParametersHashSum            - String
//   * ForWritingObjectsAndCheckingRights          - ValueStorage
//   * ForAccessRightsReport                - ValueStorage
//   * TemplatesParametersHashSum              - String
//   * ForTemplatesInUsersSessions        - ValueStorage
//   * ForTemplatesInExternalUsersSessions - ValueStorage
//   * TemplatesParametersVersions                - ValueStorage
//   * CreationDate                            - Date
//
Function NewInformationRegisterTableAccessRestrictionParameters()
	
	VersionType   = New TypeDescription("Number",,, New NumberQualifiers(15, 0, AllowedSign.Nonnegative));
	HashAmountType = New TypeDescription("String",,,, New StringQualifiers(48, AllowedLength.Variable));
	
	Table = New ValueTable;
	Table.Columns.Add("Version",                                  VersionType);
	Table.Columns.Add("HashSum",                                HashAmountType);
	Table.Columns.Add("PersistentParametersHashSum",            HashAmountType);
	Table.Columns.Add("ForWritingObjectsAndCheckingRights",          New TypeDescription("ValueStorage"));
	Table.Columns.Add("ForAccessRightsReport",                New TypeDescription("ValueStorage"));
	Table.Columns.Add("TemplatesParametersHashSum",              HashAmountType);
	Table.Columns.Add("ForTemplatesInUsersSessions",        New TypeDescription("ValueStorage"));
	Table.Columns.Add("ForTemplatesInExternalUsersSessions", New TypeDescription("ValueStorage"));
	Table.Columns.Add("TemplatesParametersVersions",                New TypeDescription("ValueStorage"));
	Table.Columns.Add("CreationDate",                            New TypeDescription("Date"));
	
	Return Table;
	
EndFunction

// This method is required by the AccessRestrictionParametersNewVersionDetails function.
Procedure ScheduleAccessUpdatesWhenSettingsChange(OldVersion, Parameters)
	
	UnavailableLists = New Array;
	Lists = ListsWithVersionsChange(OldVersion,
		Parameters.ListsRestrictionsVersions, UnavailableLists);
	
	PlanningParameters = AccessUpdatePlanningParameters();
	PlanningParameters.ListsRestrictionsVersions = Parameters.ListsRestrictionsVersions;
	PlanningParameters.IsUpdateContinuation = True;
	PlanningParameters.LongDesc = "NewAccessRestrictionParametersVersion";
	
	ScheduleAccessUpdate(Lists, PlanningParameters);
	PlanningParameters.IsObsoleteItemsDataProcessor = True;
	ScheduleAccessUpdate(Lists, PlanningParameters);
	
	If ValueIsFilled(UnavailableLists) Then
		PlanningParameters.IsObsoleteItemsDataProcessor = False;
		ScheduleAccessUpdate(UnavailableLists, PlanningParameters);
		PlanningParameters.IsObsoleteItemsDataProcessor = True;
		ScheduleAccessUpdate(UnavailableLists, PlanningParameters);
	EndIf;
	
	If ValueIsFilled(Parameters.ListsWithTheNewPrimaryAccessOption) Then
		PlanningParameters.IsObsoleteItemsDataProcessor = False;
		ScheduleAccessUpdate(Parameters.ListsWithTheNewPrimaryAccessOption,
			PlanningParameters);
		PlanningParameters.IsObsoleteItemsDataProcessor = True;
		ScheduleAccessUpdate(Parameters.ListsWithTheNewPrimaryAccessOption,
			PlanningParameters);
	EndIf;
	If ValueIsFilled(Parameters.ListsWithOutdatedAccessOptions) Then
		PlanningParameters.IsObsoleteItemsDataProcessor = True;
		ScheduleAccessUpdate(Parameters.ListsWithOutdatedAccessOptions,
			PlanningParameters);
	EndIf;
	
EndProcedure

// For the UpdateAccessGroupsTablesForEnabledExtensions procedure and
// the NewAccessRestrictionParametersVersion function.
//
Procedure CheckWhetherTheMetadataIsUpToDate() Export
	
	ConfigurationChanged = DataBaseConfigurationChangedDynamically();
	ExtensionsChanged = Catalogs.ExtensionsVersions.ExtensionsChangedDynamically();
	
	If Not ConfigurationChanged And Not ExtensionsChanged Then
		Return;
	EndIf;
	
	Try
		Try
			If ConfigurationChanged Then
				StandardSubsystemsServer.RequireRestartDueToApplicationVersionDynamicUpdate();
			ElsIf ExtensionsChanged Then
				StandardSubsystemsServer.RequireSessionRestartDueToDynamicUpdateOfProgramExtensions();
			EndIf;
		Except
			If ThisBackgroundJobSession()
			 Or StandardSubsystemsServer.ThisIsSplitSessionModeWithNoDelimiters() Then
				Raise;
			EndIf;
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'Cannot check or update access rights due to:
				           |%1
				           |
				           |Retry the operation in a minute. If the issue persists, restart the session.';"),
						   ErrorProcessing.BriefErrorDescription(ErrorInfo()));
			Raise ErrorText;
		EndTry;
	Except
		ErrorText = ErrorProcessing.BriefErrorDescription(ErrorInfo());
		StandardSubsystemsServer.InstallRequiresSessionRestart(ErrorText);
		InCaseOfAnErrorCheckingTheRelevanceOfMetadata(ErrorText);
		Raise;
	EndTry;
	
EndProcedure

// For procedure CheckMetadataRelevance.
Function ThisBackgroundJobSession()
	
	If CurrentRunMode() <> Undefined Then
		Return False;
	EndIf;
	
	CurrentSession = GetCurrentInfoBaseSession();
	CurrentBackgroundJob = CurrentSession.GetBackgroundJob();
	If CurrentBackgroundJob = Undefined Then
		Return False;
	EndIf;
	
	Return True;
	
EndFunction

// For the SetAccessUpdate procedure
Function ThisIsABackgroundAccessUpdateSession()
	
	If CurrentRunMode() <> Undefined Then
		Return False;
	EndIf;
	
	CurrentSession = GetCurrentInfoBaseSession();
	CurrentBackgroundJob = CurrentSession.GetBackgroundJob();
	If CurrentBackgroundJob = Undefined Then
		Return False;
	EndIf;
	
	Return CurrentBackgroundJob.MethodName = AccessUpdateThreadMethodName()
	    Or CurrentBackgroundJob.MethodName = NameOfTheAccessUpdateTaskMethod();
	
EndFunction

// This method is required by the NewVersionOfAccessRestrictionParameters function.
Procedure RegisterAccessRestrictionParametersVersionString(Record, VersionStrings)
	
	Content = New Array;
	Content.Add(StringFunctionsClientServer.SubstituteParametersToString(
		"Version = %1
		|CreationDate = %2
		|HashSum = %3
		|PersistentParametersHashSum = %4
		|TemplatesParametersHashSum = %5",
		Record.Version,
		Format(Record.CreationDate, "DLF=DT"),
		Record.HashSum,
		Record.PersistentParametersHashSum,
		Record.TemplatesParametersHashSum));
		
	For Each String In VersionStrings.ListsVersionsStrings Do
		Content.Add(StringFunctionsClientServer.SubstituteParametersToString(
			"[List = %1, ForExternalUsers = %2, Version = %3]
			|%4",
			String.List,
			?(String.ForExternalUsers, "Yes", "None"),
			String.Version,
			String.VersionString));
	EndDo;
	
	Content.Add("[AllVersionsAsString]
	|" + VersionStrings.AllVersionsAsString);
	
	Content.Add("[TypesRestrictionsPermissionsForUsersString]
	|" + VersionStrings.TypesRestrictionsPermissionsForUsersString);
	
	Content.Add("[TypesRestrictionsPermissionsForExternalUsersString]
	|" + VersionStrings.TypesRestrictionsPermissionsForExternalUsersString);
	
	Content.Add("[ListsWithRestrictedFieldsInUserSessions]
	|" + VersionStrings.ListsWithRestrictedFieldsInUserSessions);
	
	Content.Add("[ListsWithFieldRestrictionsInExternalUserSessions]
	|" + VersionStrings.ListsWithFieldRestrictionsInExternalUserSessions);
	
	Comment = StrConcat(Content, Chars.LF);
	
	WriteLogEvent(
		NStr("en = 'Access management.Access restriction parameters version string';",
		     Common.DefaultLanguageCode()),
		EventLogLevel.Information,
		Metadata.InformationRegisters.AccessRestrictionParameters,,
		Comment,
		EventLogEntryTransactionMode.Transactional);
	
EndProcedure

// This method is required by the NewVersionOfAccessRestrictionParameters function.
Function ListsWithVersionsChange(Version, NewListsRestrictionsVersions, UnavailableLists)
	
	If Not ValueIsFilled(Version) Then
		Return Undefined;
	EndIf;
	
	ParametersVersion = ParametersVersion(Version, False, False);
	WriteParametersStorage = ParametersVersion.ForWritingObjectsAndCheckingRights;
	
	If TypeOf(WriteParametersStorage) <> Type("ValueStorage") Then
		Return Undefined;
	EndIf;
	WriteParameters = ValueFromStorage(WriteParametersStorage);
	
	If TypeOf(WriteParameters) <> Type("FixedStructure")
	 Or Not WriteParameters.Property("ListsRestrictionsVersions")
	 Or TypeOf(WriteParameters.ListsRestrictionsVersions) <> Type("FixedMap") Then
		Return Undefined;
	EndIf;
	
	Table = New ValueTable;
	Table.Columns.Add("List",       New TypeDescription("String"));
	Table.Columns.Add("Version",       New TypeDescription("String"));
	Table.Columns.Add("ChangeType", New TypeDescription("Number"));
	
	For Each KeyAndValue In WriteParameters.ListsRestrictionsVersions Do
		String = Table.Add();
		String.List = KeyAndValue.Key;
		String.Version = StrGetLine(KeyAndValue.Value, 1)
			+ Chars.LF + StrGetLine(KeyAndValue.Value, 2);
		String.ChangeType = -1;
	EndDo;
	
	For Each KeyAndValue In NewListsRestrictionsVersions Do
		String = Table.Add();
		String.List = KeyAndValue.Key;
		String.Version = StrGetLine(KeyAndValue.Value, 1)
			+ Chars.LF + StrGetLine(KeyAndValue.Value, 2);
		String.ChangeType = 1;
	EndDo;
	
	Table.GroupBy("List, Version", "ChangeType");
	Lists = New Array;
	NotFoundLists = New Array;
	
	For Each String In Table Do
		If String.ChangeType = 0 Then
			Continue;
		EndIf;
		MetadataObject = Common.MetadataObjectByFullName(String.List);
		If MetadataObject = Undefined Then
			NotFoundLists.Add(String.List);
			Continue;
		EndIf;
		FullName = MetadataObject.FullName();
		If Lists.Find(FullName) <> Undefined Then
			Continue;
		EndIf;
		Lists.Add(FullName);
	EndDo;
	
	If NotFoundLists.Count() > 0 Then
		UnavailableLists = AllIDsWithSimilarFullNames(NotFoundLists);
	EndIf;
	
	Return Lists;
	
EndFunction

// For the ListsWithVersionsChange function and for the AddDependentLists procedure.
Function AllIDsWithSimilarFullNames(FullNames)
	
	Query = New Query;
	Query.Text =
	"SELECT
	|	IDs.Ref AS Ref
	|FROM
	|	Catalog.MetadataObjectIDs AS IDs
	|WHERE
	|	&MOIDFilterConditions
	|
	|UNION ALL
	|
	|SELECT DISTINCT
	|	IDs.Id
	|FROM
	|	InformationRegister.ExtensionVersionObjectIDs AS IDs
	|WHERE
	|	&EOIDFilterConditions";
	
	MOIDFilterConditions = New Array;
	EOIDFilterConditions = New Array;
	
	ParameterNumber = 1;
	For Each FullName In FullNames Do
		ParameterName = "FullName" + Format(ParameterNumber, "NG=");
		Query.SetParameter(ParameterName, FullName);
		MOIDFilterConditions.Add(StrReplace("IDs.FullName LIKE &ParameterName ESCAPE ""~""", 
			"ParameterName", ParameterName)); // @query-part-1
		EOIDFilterConditions.Add(StrReplace("IDs.FullObjectName LIKE &ParameterName ESCAPE ""~""",
			"ParameterName", ParameterName)); // @query-part-1
		ParameterNumber = ParameterNumber + 1;
	EndDo;
	
	Query.Text = StrReplace(Query.Text, "&MOIDFilterConditions",
		StrConcat(MOIDFilterConditions, Chars.LF + " OR ")); // @query-part-1
	
	Query.Text = StrReplace(Query.Text, "&EOIDFilterConditions",
		StrConcat(EOIDFilterConditions, Chars.LF + " OR ")); // @query-part-1
	
	Return Query.Execute().Unload().UnloadColumn("Ref");
	
EndFunction

// For the StoredAccessRestrictionParameters procedure.
//
// Returns:
//   String
//
Function CacheStructureVersion()
	
	// 
	// 
	Return "25" + TranslationVersion();
	
EndFunction

Function TranslationVersion()
	
	If ScriptVariantRussian() Then
		Return "";
	Else
		Return "/" + Metadata.Version;
	EndIf;
	
EndFunction

// For the SessionParametersSetting and ClarifyAccessRestrictionTemplatesVersions procedures, and
//  the StoredTemplatesParametersStructure function.
//
// Returns:
//   String
//
Function AccessRestrictionTemplatesVersions()
	
	Return
	",ForObject9,
	|,ForRegister9,
	|,ByValues18,
	|,ByValuesExtended18,
	|,ByValuesAndSetsAdvanced18,
	|,BySetsOfValues18,";
	
EndFunction

// For the SetParametersVersion and FillParametersForTemplates procedures
// and the NewStoredTemplatesParametersVersionsStructure function.
// 
//
// Returns:
//   String
//
Function VersionOfTheTemplateParameterVersionStructure()
	
	// 
	// 
	Return "1";
	
EndFunction

// For the ActiveAccessRestrictionParameters function.
Procedure UpdateTransactionIDs(TransactionID)
	
	Cache = RestrictionParametersCache();
	
	If Not TransactionActive() And Cache.TransactionIDs.Count() = 0
	 Or    TransactionActive() And TransactionID = Undefined Then
		Return;
	EndIf;
	
	If TransactionID <> Undefined And TransactionActive() Then
		Cache.TransactionIDs.Insert(TransactionID, True);
	Else
		Cache.TransactionIDs.Clear();
	EndIf;
	
EndProcedure

// For the ActiveAccessRestrictionParameters function.
Procedure SetParametersVersion(ParametersVersion, TransactionID, CommonContext,
			SetSessionParametersForTemplates = False, RepeatedCall = False)
	
	If Not RepeatedCall Then
		If SetSessionParametersForTemplates Then
			ResetRestrictionParametersCache();
		Else
			RefreshReusableValues();
		EndIf;
	EndIf;
	
	If TransactionID <> Undefined And TransactionActive() Then
		Cache = RestrictionParametersCache();
		Cache.TransactionIDs.Insert(TransactionID, True);
	EndIf;
	
	If TypeOf(ParametersVersion.ForWritingObjectsAndCheckingRights) = Type("ValueStorage") Then
		ForWritingObjectsAndCheckingRights = StoredWriteParametersStructure(
			ValueFromStorage(ParametersVersion.ForWritingObjectsAndCheckingRights));
		
		If ForWritingObjectsAndCheckingRights.CacheStructureVersion <> CacheStructureVersion() Then
			ParametersVersion = NewAccessRestrictionParametersVersion(CommonContext);
			SetParametersVersion(ParametersVersion, TransactionID, CommonContext,
				SetSessionParametersForTemplates, True);
			Return;
		EndIf;
	Else
		ForWritingObjectsAndCheckingRights = Undefined;
	EndIf;
	
	If TypeOf(ParametersVersion.TemplatesParametersVersions) = Type("ValueStorage") Then
		TemplatesParametersVersions = StructureOfStoredVersionsOfTemplateParameters(
			ValueFromStorage(ParametersVersion.TemplatesParametersVersions));
		
		If TemplatesParametersVersions.VersionOfTheVersionStructure <> VersionOfTheTemplateParameterVersionStructure() Then
			ParametersVersion = NewAccessRestrictionParametersVersion(CommonContext);
			SetParametersVersion(ParametersVersion, TransactionID, CommonContext,
				SetSessionParametersForTemplates, True);
			Return;
		EndIf;
	Else
		TemplatesParametersVersions = Undefined;
	EndIf;
	
	If TypeOf(ParametersVersion.ForAccessRightsReport) = Type("ValueStorage") Then
		ForAccessRightsReport = StoredReportParametersStructure(
			ValueFromStorage(ParametersVersion.ForAccessRightsReport));
		
		If ForAccessRightsReport.CacheStructureVersion <> CacheStructureVersion() Then
			ParametersVersion = NewAccessRestrictionParametersVersion(CommonContext);
			SetParametersVersion(ParametersVersion, TransactionID, CommonContext,
				SetSessionParametersForTemplates, True);
			Return;
		EndIf;
		Cache = RestrictionParametersCache();
		Cache.TypesRestrictionsPermissionsForUsers
			= ForAccessRightsReport.TypesRestrictionsPermissionsForUsers;
		Cache.TypesRestrictionsPermissionsForExternalUsers
			= ForAccessRightsReport.TypesRestrictionsPermissionsForExternalUsers;
	EndIf;
	
	If SetSessionParametersForTemplates
	 Or SessionParameters.AccessRestrictionParameters.Property("SessionParametersForRemplatesAreSet") Then
		
		StorageForTemplatesInSessions = ?(Users.IsExternalUserSession(),
			ParametersVersion.ForTemplatesInExternalUsersSessions,
			ParametersVersion.ForTemplatesInUsersSessions);
		
		If TypeOf(StorageForTemplatesInSessions) = Type("ValueStorage") Then
			ForAccessRestrictionTemplates = StoredTemplatesParametersStructure(
				ValueFromStorage(StorageForTemplatesInSessions));
			
			If ForAccessRestrictionTemplates.CacheStructureVersion <> CacheStructureVersion() Then
				ParametersVersion = NewAccessRestrictionParametersVersion(CommonContext);
				SetParametersVersion(ParametersVersion, TransactionID, CommonContext,
					SetSessionParametersForTemplates, True);
				Return;
			EndIf;
		Else
			ForAccessRestrictionTemplates = NewStoredTemplatesParametersStructure();
		EndIf;
		
		TemplatesVersions = StrConcat(StrSplit(
			ForAccessRestrictionTemplates.TemplatesVersions, Chars.LF + Chars.CR, False), Chars.LF);
		ClarifyAccessRestrictionTemplatesVersions(TemplatesVersions);
		
		TemplatesParameters = New Structure(TemplatesParametersStructure(
			ForAccessRestrictionTemplates.TemplatesParameters));
		TemplatesParameters.Insert("AccessRestrictionTemplatesVersions", TemplatesVersions);
		
		UpdateSessionParametersForTemplates = SetSessionParametersForTemplates;
		If Not SetSessionParametersForTemplates
		   And SessionParameters.AccessRestrictionParameters.Property("SessionParametersForRemplatesAreSet") Then
			
			For Each KeyAndValue In TemplatesParameters Do
				If SessionParameters[KeyAndValue.Key] <> KeyAndValue.Value Then
					UpdateSessionParametersForTemplates = True;
					Break;
				EndIf;
			EndDo;
		EndIf;
		If UpdateSessionParametersForTemplates Then
			BeforeChangeSessionParametersForTemplates(TemplatesParameters, SetSessionParametersForTemplates);
			FillPropertyValues(SessionParameters, TemplatesParameters);
		EndIf;
	EndIf;
	
	UpdateAllowedSetsInSessionParameters(SetSessionParametersForTemplates, True);
	
	Parameters = SessionAccessRestrictionParameters(ParametersVersion,
		ForWritingObjectsAndCheckingRights, TemplatesParametersVersions, SetSessionParametersForTemplates);
	SessionParameters.AccessRestrictionParameters = Parameters;
	
EndProcedure

// For the SetParametersVersion procedure.
//
// Returns:
//   FixedStructure:
//     * Version       - String
//     * HashSum     - String
//     * CreationDate - Date
//     * Parameters    - See StoredWriteParametersStructure
//
Function SessionAccessRestrictionParameters(ParametersVersion, ForWritingObjectsAndCheckingRights,
			TemplatesParametersVersions, SetSessionParametersForTemplates)
	
	RestrictionParameters = New Structure;
	RestrictionParameters.Insert("Version",       ParametersVersion.Version);
	RestrictionParameters.Insert("HashSum",     ParametersVersion.HashSum);
	RestrictionParameters.Insert("CreationDate", ParametersVersion.CreationDate);
	
	If ForWritingObjectsAndCheckingRights = Undefined Then
		Parameters = Undefined;
	Else
		ReadParameters = New Structure(ForWritingObjectsAndCheckingRights);
		AdditionalContext = New Structure(ReadParameters.AdditionalContext);
		ForUsers = New Structure(AdditionalContext.ForUsers);
		ForUsers.BasicAccessOptions = New FixedMap(
			TemplatesParametersVersions.ForUsers.BasicAccessOptions);
		AdditionalContext.ForUsers = New FixedStructure(ForUsers);
		ForExternalUsers = New Structure(AdditionalContext.ForExternalUsers);
		ForExternalUsers.BasicAccessOptions = New FixedMap(
			TemplatesParametersVersions.ForExternalUsers.BasicAccessOptions);
		AdditionalContext.ForExternalUsers = New FixedStructure(ForExternalUsers);
		ReadParameters.AdditionalContext = New FixedStructure(AdditionalContext);
		Parameters = New FixedStructure(ReadParameters);
	EndIf;
	
	RestrictionParameters.Insert("Parameters", Parameters);
	
	If SetSessionParametersForTemplates
	 Or SessionParameters.AccessRestrictionParameters.Property("SessionParametersForRemplatesAreSet") Then
		RestrictionParameters.Insert("SessionParametersForRemplatesAreSet");
	EndIf;
	
	If SessionParameters.AccessRestrictionParameters.Property("RecordingAccessRestrictionParametersInTheCurrentSession") Then
		RestrictionParameters.Insert("RecordingAccessRestrictionParametersInTheCurrentSession",
			SessionParameters.AccessRestrictionParameters.RecordingAccessRestrictionParametersInTheCurrentSession);
	EndIf;
	
	Return New FixedStructure(RestrictionParameters);
	
EndFunction

// For the SetParametersVersion procedure.
Procedure ClarifyAccessRestrictionTemplatesVersions(TemplatesVersions)
	
	If TemplatesVersions = AccessRestrictionTemplatesVersions() Then
		Return;
	EndIf;
	
	TemplatesVersions = AccessRestrictionTemplatesVersions() + "
	|,SessionRestartRequired1,";
	
EndProcedure

// For the SetParametersVersion, CheckAccessToObject,
// CheckAccessToRecordSet procedures, and the AccessAllowed function.
//
Procedure UpdateAllowedSetsInSessionParameters(SetSessionParametersForTemplates = False,
			SettingAccessRestrictionParameters = False)
	
	If Not SetSessionParametersForTemplates
	   And Not SessionParameters.AccessRestrictionParameters.Property("SessionParametersForRemplatesAreSet") Then
		Return;
	EndIf;
	
	LastCheck = AccessManagementInternalCached.LastCheckOfAllowedSetsVersion();
	
	If Not SetSessionParametersForTemplates
	   And Not SettingAccessRestrictionParameters
	   And LastCheck.Date + 5 >= CurrentSessionDate() Then
		Return;
	EndIf;
	
	LastCheck.Date = CurrentSessionDate();
	
	Content = AllowedRequestParameterSets();
	
	If Not SetSessionParametersForTemplates
	   And SessionParameters.AllowedUser            = Content.AllowedUser
	   And SessionParameters.AllowedAccessGroupsSet       = Content.AllowedAccessGroupsSet
	   And SessionParameters.AllowedUserGroupsSet = Content.AllowedUserGroupsSet
	   And SessionParameters.AllowedBlankAccessGroupsSet = Content.AllowedBlankAccessGroupsSet Then
		
		Return;
	EndIf;
	
	Content.Insert("CommonAccessRestrictionTemplateParameters", "");
	ConsiderRightsSettingsOnBuildQueryExecutionPlan(Content);
	
	BeforeChangeSessionParametersForTemplates(Content, SetSessionParametersForTemplates);
	FillPropertyValues(SessionParameters, Content);
	
EndProcedure

// For the UpdateAllowedSetsInSessionParameters and
//  SetAllowedSetsInQueryParameters procedures.
//
// Parameters:
//  User   - CatalogRef.Users
//                 - CatalogRef.ExternalUsers
//                 - Undefined - 
//
// Returns:
//  Structure:
//   * AllowedUser            - CatalogRef.SetsOfAccessGroups
//   * AllowedAccessGroupsSet       - CatalogRef.SetsOfAccessGroups
//   * AllowedUserGroupsSet - CatalogRef.SetsOfAccessGroups
//   * AllowedBlankAccessGroupsSet - CatalogRef.SetsOfAccessGroups
//
Function AllowedRequestParameterSets(Val User = Undefined)
	
	BlankAccessGroupsSet = Catalogs.SetsOfAccessGroups.EmptyRef();
	
	Content = New Structure;
	Content.Insert("AllowedUser",            BlankAccessGroupsSet);
	Content.Insert("AllowedAccessGroupsSet",       BlankAccessGroupsSet);
	Content.Insert("AllowedUserGroupsSet", BlankAccessGroupsSet);
	Content.Insert("AllowedBlankAccessGroupsSet",
		AccessManagementInternalCached.AllowedBlankAccessGroupsSet());
	
	If Users.IsFullUser(User,, False) Then
		Return Content;
	EndIf;
	
	If User = Undefined Then
		User = Users.AuthorizedUser();
	EndIf;
	
	Content.AllowedUser = Catalogs.SetsOfAccessGroups.GetRef(
		User.UUID());
	
	Query = New Query;
	Query.SetParameter("AllowedUser", Content.AllowedUser);
	Query.Text =
	"SELECT
	|	SetsOfAccessGroups.AllowedAccessGroupsSet AS AllowedAccessGroupsSet,
	|	SetsOfAccessGroups.AllowedUserGroupsSet AS AllowedUserGroupsSet
	|FROM
	|	Catalog.SetsOfAccessGroups AS SetsOfAccessGroups
	|WHERE
	|	SetsOfAccessGroups.Ref = &AllowedUser";
	
	Selection = Query.Execute().Select();
	If Selection.Next() Then
		Content.AllowedAccessGroupsSet       = Selection.AllowedAccessGroupsSet;
		Content.AllowedUserGroupsSet = Selection.AllowedUserGroupsSet;
	EndIf;
	
	Return Content;
	
EndFunction

// For the UpdateAllowedSetsInSessionParameters procedure.
Procedure ConsiderRightsSettingsOnBuildQueryExecutionPlan(Content)
	
	If Not AccessManagementInternalCached.QueryPlanClarificationRequired() Then
		Return;
	EndIf;
	
	Content.CommonAccessRestrictionTemplateParameters = ";ClarifyForAll;"
		+ RightsSettingsHashsumDetails(Content.AllowedAccessGroupsSet)
		+ RightsSettingsHashsumDetails(Content.AllowedUser, "^");
	
EndProcedure

// For the ConsiderRightsSettingsOnBuildQueryExecutionPlan procedure.
Function RightsSettingsHashsumDetails(AccessGroupsSet, Char = "")
	
	DataHashing = New DataHashing(HashFunction.CRC32);
	DataHashing.Append(GetBinaryDataFromHexString(StrReplace(
		AccessGroupsSet.UUID(), "-", "")));
	Balance = DataHashing.HashSum;
	
	Result = "";
	For Counter = 1 To 32 Do
		Integer = Int(Balance / 2);
		Result = ?(Balance - Integer * 2 = 0, "", XMLString(Counter) + Char + ";") + Result;
		Balance = Integer;
	EndDo;
	
	Return Chars.LF + ";" + Result;
	
EndFunction

// For the AccessAllowed, and the CheckAccessToObject and CheckAccessToRecordSet procedures.
Procedure SetAllowedSetsInQueryParameters(Query, Val User = Undefined)
	
	If User = Undefined Then
		Parameters = SessionParameters;
		User = Users.AuthorizedUser();
	Else
		Parameters = AllowedRequestParameterSets(User);
	EndIf;
	
	Query.SetParameter("AllowedAccessGroupsSet",       Parameters.AllowedAccessGroupsSet);
	Query.SetParameter("AllowedBlankAccessGroupsSet", Parameters.AllowedBlankAccessGroupsSet);
	Query.SetParameter("AllowedUserGroupsSet", Parameters.AllowedUserGroupsSet);
	Query.SetParameter("AllowedUser",            Parameters.AllowedUser);
	Query.SetParameter("AuthorizedUser",         User);
	
EndProcedure

// This method is required by the NewVersionOfAccessRestrictionParameters function.
//
// Parameters:
//  CommonContext            - See CommonContextOfRestrictionParametersCalculation
//  ListsRestrictionsVersions - Map
//
// Returns:
//  Structure:
//    * CreationDate                            - Date
//    * ForWritingObjectsAndCheckingRights          - ValueStorage -
//    * ForAccessRightsReport                - ValueStorage -
//    * PersistentParametersHashSum            - String
//    * ForTemplatesInUsersSessions        - ValueStorage -
//    * ForTemplatesInExternalUsersSessions - ValueStorage -
//    * TemplatesParametersVersions                - ValueStorage -
//    * TemplatesParametersHashSum              - String - filled in while writing after update of
//         the TemplatesParametersVersions parameter and filling the ListsWithRestrictionByFields property of
//         the ForTemplatesInUsersSessions, ForTemplatesInExternalUsersSessions parameters.
//    * HashSum                                - String - filled in while writing,
//         calculated from the PersistentParametersHashSum and TemplatesParametersHashSum hash sums.
//
Function StoredAccessRestrictionParameters(CommonContext, ListsRestrictionsVersions = Undefined)
	
	CreationDate = CurrentSessionDate();
	
	If CommonContext = Undefined Then
		RefreshReusableValues();
		CommonContext = CommonContextOfRestrictionParametersCalculation();
		
	ElsIf CommonContext.Property("SpecialFullName") Then
		SpecialFullName           = CommonContext.SpecialFullName;
		SpecialRestrictionDetails = CommonContext.SpecialRestrictionDetails;
	EndIf;
	
	AdditionalContextForUsers        = NewAdditionalContext();
	AdditionalContextForExternalUsers = NewAdditionalContext();
	
	FullListsNames = New Array;
	For Each ListDetails In CommonContext.ListsWithRestriction Do
		FullName = ListDetails.Key;
		FullListsNames.Add(FullName);
		If FullName = SpecialFullName Then
			RestrictionDetails = SpecialRestrictionDetails;
		Else
			RestrictionDetails = DataRestrictionDetails(CommonContext, FullName);
		EndIf;
		
		AddAdditionalContext(FullName,
			AdditionalContextForUsers, RestrictionDetails, False);
		
		AddAdditionalContext(FullName,
			AdditionalContextForExternalUsers, RestrictionDetails, True);
	EndDo;
	
	ListsWithDate = New Map;
	ListsIDs = Common.MetadataObjectIDs(FullListsNames);
	
	TypesRestrictionsPermissionsForUsers        = New Map;
	TypesRestrictionsPermissionsForExternalUsers = New Map;
	
	If CommonContext.Property("StoredParametersVersionStrings") Then
		ListsVersionsStrings = NewListsVersionsStrings();
		StoredParametersVersionStrings = New Structure;
		StoredParametersVersionStrings.Insert("AllVersionsAsString", "");
		StoredParametersVersionStrings.Insert("TypesRestrictionsPermissionsForUsersString", "");
		StoredParametersVersionStrings.Insert("TypesRestrictionsPermissionsForExternalUsersString", "");
		StoredParametersVersionStrings.Insert("ListsVersionsStrings", ListsVersionsStrings);
		CommonContext.StoredParametersVersionStrings = StoredParametersVersionStrings;
	EndIf;
	
	// Populate for users.
	ContextForUsers = New Structure;
	ContextForUsers.Insert("ForExternalUsers",  False);
	ContextForUsers.Insert("CreationDate",             CreationDate);
	ContextForUsers.Insert("CommonContext",            CommonContext);
	ContextForUsers.Insert("AdditionalContext",   AdditionalContextForUsers);
	ContextForUsers.Insert("LeadingLists",            New Map);
	ContextForUsers.Insert("ListsRestrictionsVersions", New Map);
	ContextForUsers.Insert("TemplatesParameters",        NewTemplatesParametersStructure());
	ContextForUsers.Insert("TemplatesParametersVersions", TheNewVersionOfTheTemplateParameters());
	ContextForUsers.Insert("ListsWithDate",             ListsWithDate);
	ContextForUsers.Insert("ListsIDs",    ListsIDs);
	ContextForUsers.Insert("AllRightsRestrictionsKinds",   TypesRestrictionsPermissionsForUsers);
	ContextForUsers.Insert("LeadingRoles",              New Map);
	
	AddStoredRestrictionParametersForUsersKind(ContextForUsers);
	
	// Filling for external users.
	ContextForExternalUsers = New Structure;
	ContextForExternalUsers.Insert("ForExternalUsers",  True);
	ContextForExternalUsers.Insert("CreationDate",             CreationDate);
	ContextForExternalUsers.Insert("CommonContext",            CommonContext);
	ContextForExternalUsers.Insert("AdditionalContext",   AdditionalContextForExternalUsers);
	ContextForExternalUsers.Insert("LeadingLists",            New Map);
	ContextForExternalUsers.Insert("ListsRestrictionsVersions", New Map);
	ContextForExternalUsers.Insert("TemplatesParameters",        NewTemplatesParametersStructure());
	ContextForExternalUsers.Insert("TemplatesParametersVersions", TheNewVersionOfTheTemplateParameters());
	ContextForExternalUsers.Insert("ListsWithDate",             ListsWithDate);
	ContextForExternalUsers.Insert("ListsIDs",    ListsIDs);
	ContextForExternalUsers.Insert("AllRightsRestrictionsKinds",   TypesRestrictionsPermissionsForExternalUsers);
	ContextForExternalUsers.Insert("LeadingRoles",              New Map);
	
	AddStoredRestrictionParametersForUsersKind(ContextForExternalUsers);
	
	// Filling in general and separate parts of leading lists for users and external users.
	LeadingLists = New Map;
	For Each LeadingListsDetails In ContextForUsers.LeadingLists Do
		AddLeadingLists(LeadingLists,
			"ForUsers", LeadingListsDetails.Key, LeadingListsDetails.Value);
	EndDo;
	For Each LeadingListsDetails In ContextForExternalUsers.LeadingLists Do
		AddLeadingLists(LeadingLists,
			"ForExternalUsers", LeadingListsDetails.Key, LeadingListsDetails.Value);
	EndDo;
	Properties = LeadingListByFieldsValues();
	For Each LeadingList In LeadingLists Do
		Properties = LeadingList.Value;
		If Properties.ByFieldsValues <> Undefined Then
			ByFieldsValues = Properties.ByFieldsValues;
			If ByFieldsValues.IsReferenceType Then
				TabularSections = New Array;
				For Each TabularSectionDetails In ByFieldsValues.TabularSections Do
					TabularSections.Add(TabularSectionDetails.Value);
				EndDo;
				ByFieldsValues.TabularSections = TabularSections;
			EndIf;
		EndIf;
	EndDo;
	
	// Populate main roles for internal users and external users.
	LeadingRoles = New Map;
	AddLeadingRoles(LeadingRoles, "ForUsers", ContextForUsers);
	AddLeadingRoles(LeadingRoles, "ForExternalUsers", ContextForExternalUsers);
	
	// 
	ListsRestrictionsVersions = New Map;
	Versions = New ValueList;
	Versions.Add(CacheStructureVersion());
	For Each VersionDetails In ContextForUsers.ListsRestrictionsVersions Do
		CommonVersion = CommonVersion(CommonContext, VersionDetails.Key, VersionDetails.Value,
			ContextForExternalUsers.ListsRestrictionsVersions.Get(VersionDetails.Key));
		ListsRestrictionsVersions.Insert(VersionDetails.Key, CommonVersion);
		Versions.Add(CommonVersion, GetHexStringFromBinaryData(
			GetBinaryDataFromString(String(CommonVersion))));
	EndDo;
	Versions.SortByPresentation();
	VersionsAsString = StrConcat(Versions.UnloadValues(), Chars.LF);
	DataHashing = New DataHashing(HashFunction.SHA256);
	DataHashing.Append(VersionsAsString);
	If CommonContext.Property("StoredParametersVersionStrings") Then
		CommonContext.StoredParametersVersionStrings.AllVersionsAsString = VersionsAsString;
	EndIf;
	
	// Preparing additional context to calculate restriction parameters of a separate list.
	ForUsers = NewStoredAdditionalContext();
	FillPropertyValues(ForUsers, ContextForUsers.AdditionalContext);
	ForExternalUsers = NewStoredAdditionalContext();
	FillPropertyValues(ForExternalUsers, ContextForExternalUsers.AdditionalContext);
	AdditionalContext = New Structure;
	AdditionalContext.Insert("ForUsers", ForUsers);
	AdditionalContext.Insert("ForExternalUsers", ForExternalUsers);
	
	WriteParameters = NewStoredWriteParametersStructure();
	WriteParameters.ListsRestrictionsVersions = ListsRestrictionsVersions;
	WriteParameters.LeadingLists            = LeadingLists;
	WriteParameters.AdditionalContext   = AdditionalContext;
	WriteParameters.ListsWithDate             = ListsWithDate;
	WriteParameters.LeadingRoles              = LeadingRoles;
	WriteParameters.UsedValuesTypes = New ValueStorage(
		New Structure("HashSum", CommonContext.UsedValuesTypes.HashSum));
	WriteParameters.ExternalUsersEnabled = CommonContext.ExternalUsersEnabled;
	WriteParameters.AccessRestrictionEnabled  = CommonContext.AccessRestrictionEnabled;
	
	StoredParameters = New Structure;
	
	StoredTemplatesParametersForUsers = NewStoredTemplatesParametersStructure();
	StoredTemplatesParametersForUsers.TemplatesParameters = ContextForUsers.TemplatesParameters;
	StoredParameters.Insert("ForTemplatesInUsersSessions",
		New ValueStorage(Common.FixedData(StoredTemplatesParametersForUsers)));
	
	StoredTemplatesParametersForExternalUsers = NewStoredTemplatesParametersStructure();
	StoredTemplatesParametersForExternalUsers.TemplatesParameters = ContextForExternalUsers.TemplatesParameters;
	StoredParameters.Insert("ForTemplatesInExternalUsersSessions",
		New ValueStorage(Common.FixedData(StoredTemplatesParametersForExternalUsers)));
	
	StoredVersionsOfTemplateSettings = NewStructureOfStoredVersionsOfTemplateParameters();
	StoredVersionsOfTemplateSettings.ForUsers.TemplatesParametersVersions =
		ContextForUsers.TemplatesParametersVersions;
	StoredVersionsOfTemplateSettings.ForExternalUsers.TemplatesParametersVersions =
		ContextForExternalUsers.TemplatesParametersVersions;
	StoredParameters.Insert("TemplatesParametersVersions",
		New ValueStorage(StoredVersionsOfTemplateSettings));
	
	StoredParameters.Insert("ForWritingObjectsAndCheckingRights",
		New ValueStorage(Common.FixedData(WriteParameters)));
	
	ReportParametersToStore = NewStoredReportParametersStructure();
	ReportParametersToStore.TypesRestrictionsPermissionsForUsers =
		KindsRestrictionsPermissionsString(TypesRestrictionsPermissionsForUsers);
	DataHashing.Append(ReportParametersToStore.TypesRestrictionsPermissionsForUsers);
	ReportParametersToStore.TypesRestrictionsPermissionsForExternalUsers =
		KindsRestrictionsPermissionsString(TypesRestrictionsPermissionsForExternalUsers);
	DataHashing.Append(ReportParametersToStore.TypesRestrictionsPermissionsForExternalUsers);
	If CommonContext.Property("StoredParametersVersionStrings") Then
		CommonContext.StoredParametersVersionStrings.TypesRestrictionsPermissionsForUsersString
			= ReportParametersToStore.TypesRestrictionsPermissionsForUsers;
		CommonContext.StoredParametersVersionStrings.TypesRestrictionsPermissionsForExternalUsersString
			= ReportParametersToStore.TypesRestrictionsPermissionsForExternalUsers;
	EndIf;
	
	StoredParameters.Insert("ForAccessRightsReport",
		New ValueStorage(Common.FixedData(ReportParametersToStore)));
	
	StoredParameters.Insert("PersistentParametersHashSum", Base64String(DataHashing.HashSum));
	StoredParameters.Insert("CreationDate", CreationDate);
	
	If CommonContext.Property("StoredParametersVersionStrings") Then
		ListsVersionsStrings.Sort("List, ForExternalUsers");
	EndIf;
	
	Return StoredParameters;
	
EndFunction

// Returns:
//   ValueTable:
//     * List                  - String
//     * ForExternalUsers - Boolean
//     * Version                  - String
//     * VersionString            - String
//
Function NewListsVersionsStrings()
	
	ListsVersionsStrings = New ValueTable;
	ListsVersionsStrings.Columns.Add("List",                  New TypeDescription("String"));
	ListsVersionsStrings.Columns.Add("ForExternalUsers", New TypeDescription("Boolean"));
	ListsVersionsStrings.Columns.Add("Version",                  New TypeDescription("String"));
	ListsVersionsStrings.Columns.Add("VersionString",            New TypeDescription("String"));
	
	Return ListsVersionsStrings;
	
EndFunction

// For the CalculatedRestrictionParameters and StoredAccessRestrictionParameters functions.
//
// Returns:
//   Structure:
//     * RestrictionsDetails1 - Map of KeyAndValue:
//         ** Key     - String - a full list name
//         ** Value - See BriefRestrictionDetails
//     * ListRestrictionsProperties - Map of KeyAndValue:
//         ** Key     - String - a full list name
//         ** Value - See NewListRestrictionProperties
//     * ListsWithRestrictionByOwner - Map of KeyAndValue:
//         ** Key     - String - a full file name
//         ** Value - Boolean - the ByOwner value, except for Undefined.
//     * ListsWithDisabledRestriction - Map of KeyAndValue:
//         ** Key     - String - a full list name
//         ** Value - Boolean - True.
//     * ListsWithReadRestrictionDisabled - Map of KeyAndValue:
//         ** Key     - String - a full list name
//         ** Value - Boolean - True.
//     * ListsWithKeysRecordForDependentListsWithoutKeys - Map of KeyAndValue:
//         ** Key     - String - a full file name
//         ** Value - Boolean - True.
//     * BasicAccessOptions - See NewBasicAccessOptions
//
Function NewAdditionalContext()
	
	AdditionalContext = New Structure;
	AdditionalContext.Insert("RestrictionsDetails1",                  New Map);
	AdditionalContext.Insert("ListRestrictionsProperties",           New Map);
	AdditionalContext.Insert("ListsWithRestrictionByOwner",       New Map);
	AdditionalContext.Insert("ListsWithDisabledRestriction",       New Map);
	AdditionalContext.Insert("ListsWithReadRestrictionDisabled", New Map);
	AdditionalContext.Insert("ListsWithKeysRecordForDependentListsWithoutKeys", Undefined);
	AdditionalContext.Insert("BasicAccessOptions",              New Map);
	
	Return AdditionalContext;
	
EndFunction

// For the CalculatedRestrictionParameters and StoredAccessRestrictionParameters functions.
//
// Returns:
//   Structure:
//     * ListRestrictionsProperties - Map of KeyAndValue:
//         ** Key     - String - a full list name
//         ** Value - See NewListRestrictionProperties
//     * ListsWithDisabledRestriction - Map of KeyAndValue:
//         ** Key     - String - a full list name
//         ** Value - Boolean - True.
//     * ListsWithReadRestrictionDisabled - Map of KeyAndValue:
//         ** Key     - String - a full list name
//         ** Value - Boolean - True.
//     * ListsWithKeysRecordForDependentListsWithoutKeys - Map of KeyAndValue:
//         ** Key     - String - a full list name
//         ** Value - Boolean - True.
//     * BasicAccessOptions - See NewBasicAccessOptions
//
Function NewStoredAdditionalContext()
	
	AdditionalContext = New Structure;
	AdditionalContext.Insert("ListRestrictionsProperties",           New Map);
	AdditionalContext.Insert("ListsWithDisabledRestriction",       New Map);
	AdditionalContext.Insert("ListsWithReadRestrictionDisabled", New Map);
	AdditionalContext.Insert("ListsWithKeysRecordForDependentListsWithoutKeys", Undefined);
	AdditionalContext.Insert("BasicAccessOptions",              New Map);
	
	Return AdditionalContext;
	
EndFunction

// For the CalculatedRestrictionParameters and StoredAccessRestrictionParameters functions.
Procedure AddAdditionalContext(FullName, AdditionalContext,
				RestrictionDetails, ForExternalUsers)
	
	If ForExternalUsers Then
		Text               = RestrictionDetails.TextForExternalUsers1;
		ByOwner         = RestrictionDetails.ByOwnerWithoutSavingAccessKeysForExternalUsers;
	Else
		Text               = RestrictionDetails.Text;
		ByOwner         = RestrictionDetails.ByOwnerWithoutSavingAccessKeys;
	EndIf;
	InManagerModule = RestrictionDetails.TextInManagerModule;
	
	BriefRestrictionDetails = BriefRestrictionDetails();
	BriefRestrictionDetails.Insert("Text",               Text);
	BriefRestrictionDetails.Insert("InManagerModule",    InManagerModule);
	
	AdditionalContext.RestrictionsDetails1.Insert(FullName, BriefRestrictionDetails);
	
	If ByOwner <> Undefined Then
		AdditionalContext.ListsWithRestrictionByOwner.Insert(FullName, ByOwner);
	EndIf;
	
EndProcedure

// Returns:
//   Structure:
//     * Text            - String
//     * InManagerModule - Boolean
//
Function BriefRestrictionDetails()
	
	Return New Structure;
	
EndFunction

// For the StoredAccessRestrictionParameters function.
Procedure AddStoredRestrictionParametersForUsersKind(Context)
	
	// Prepare parameters considering dependencies by access keys only.
	PropertiesTable = ListsPropertiesToCalculateStoredParameters();
	PropertiesTable = New ValueTable;
	PropertiesTable.Columns.Add("FullName", New TypeDescription("String"));
	PropertiesTable.Columns.Add("DependentItem", New TypeDescription("Boolean"));
	PropertiesTable.Columns.Add("LeadingItems",   New TypeDescription("Array"));
	PropertiesTable.Columns.Add("Level",   New TypeDescription("Number"));
	PropertiesTable.Columns.Add("Master",   New TypeDescription("Boolean"));
	PropertiesTable.Columns.Add("DependentItems", New TypeDescription("Array"));
	PropertiesTable.Columns.Add("Parameters", New TypeDescription("Structure"));
	PropertiesTable.Columns.Add("Processed", New TypeDescription("Boolean"));
	PropertiesTable.Columns.Add("RestrictionByOwnerPossible",  New TypeDescription("Boolean"));
	PropertiesTable.Columns.Add("RestrictionByOwnerEnabled",  New TypeDescription("Boolean"));
	PropertiesTable.Columns.Add("RestrictionByOwnerDisabled", New TypeDescription("Boolean"));
	PropertiesTable.Columns.Add("UsersAccessKeys",       New TypeDescription("Boolean"));
	PropertiesTable.Columns.Add("HasDependantListsWithoutAccessKeysRecords", New TypeDescription("Boolean"));
	PropertiesTable.Columns.Add("UsersAndAccessGroupsAccessKeys",    New TypeDescription("Boolean"));
	
	ListsWithRestriction = New Map(Context.CommonContext.ListsWithRestriction);
	ListsWithDisabledRestriction       = New Map;
	ListsWithReadRestrictionDisabled = New Map;
	
	For Each ListDetails In ListsWithRestriction Do
		FullName = ListDetails.Key;
		
		If TypeOf(ListDetails.Value) = Type("Boolean") Then
			Properties = PropertiesTable.Add();
			Properties.FullName = FullName;
			ListsWithRestriction.Insert(FullName, Properties);
			Parameters = RestrictionParametersForUsersKind(FullName, Context);
			Properties.Parameters = Parameters;
		Else
			Properties = ListDetails.Value; // See ListsPropertiesToCalculateStoredParameters
			Parameters = Properties.Parameters;
		EndIf;
		
		If Parameters.RightToWriteRestrictionDisabled Then
			ListsWithReadRestrictionDisabled.Insert(FullName, True);
		EndIf;
		If Parameters.RestrictionDisabled Then
			ListsWithDisabledRestriction.Insert(FullName, True);
		EndIf;
		If Parameters.HasUsersRestriction Then
			Properties.UsersAccessKeys = True;
			SetRestrictionProperty(FullName, "CalculateUserRights", True, Context);
		EndIf;
		If Parameters.OwnerField <> Undefined Then
			SetRestrictionProperty(FullName, "OwnerField", Parameters.OwnerField, Context);
		EndIf;
		
		LeadingLists = Parameters.LeadingLists;
		If LeadingLists.ByAccessKeys.Count() > 0 Then
			Properties.DependentItem = True;
			For Each KeyAndValue In LeadingLists.ByAccessKeys Do
				LeadingList = KeyAndValue.Key;
				Properties.LeadingItems.Add(LeadingList);
				LeadingListProperties = ListsWithRestriction.Get(LeadingList);
				If LeadingListProperties = Undefined Or TypeOf(LeadingListProperties) = Type("Boolean") Then
					LeadingListProperties = PropertiesTable.Add();
					LeadingListProperties.FullName = LeadingList;
					ListsWithRestriction.Insert(LeadingList, LeadingListProperties);
					LeadingListParameters = RestrictionParametersForUsersKind(LeadingList, Context);
					LeadingListProperties.Parameters = LeadingListParameters;
					If LeadingListParameters.RightToWriteRestrictionDisabled Then
						ListsWithReadRestrictionDisabled.Insert(LeadingList, True);
					EndIf;
					If LeadingListParameters.RestrictionDisabled Then
						ListsWithDisabledRestriction.Insert(LeadingList, True);
					EndIf;
					If LeadingListParameters.HasUsersRestriction Then
						LeadingListProperties.UsersAccessKeys = True;
						SetRestrictionProperty(LeadingList,
							"CalculateUserRights", True, Context);
					EndIf;
					If LeadingListParameters.OwnerField <> Undefined Then
						SetRestrictionProperty(LeadingList,
							"OwnerField", LeadingListParameters.OwnerField, Context);
					EndIf;
				EndIf;
				LeadingListProperties.Master = True;
				LeadingListProperties.DependentItems.Add(FullName);
			EndDo;
		EndIf;
	EndDo;
	
	MaxLevel = 0;
	Rows = PropertiesTable.FindRows(New Structure("DependentItem, Master", False, True));
	For Each String In Rows Do
		SetDependentListsLevel(String, ListsWithRestriction, New Array, MaxLevel);
	EndDo;
	// 
	Rows = PropertiesTable.FindRows(New Structure("Processed", False));
	For Each String In Rows Do
		SetDependentListsLevel(String, ListsWithRestriction, New Array, MaxLevel);
	EndDo;
	
	Rows = PropertiesTable.FindRows(New Structure("DependentItem, Master", True, False));
	For Each String In Rows Do
		SetOptimizationByOwnerField(String, ListsWithRestriction, Context);
	EndDo;
	
	// Shortening dependencies by access keys of dependent objects.
	ListsWithKeysRecordForDependentListsWithoutKeys = New Map;
	Filter = New Structure("HasDependantListsWithoutAccessKeysRecords", True);
	Rows = PropertiesTable.FindRows(Filter);
	For Each String In Rows Do
		ListsWithKeysRecordForDependentListsWithoutKeys.Insert(String.FullName, True);
	EndDo;
	AdditionalContext = Context.AdditionalContext;
	AdditionalContext.ListsWithReadRestrictionDisabled = ListsWithReadRestrictionDisabled;
	AdditionalContext.ListsWithDisabledRestriction       = ListsWithDisabledRestriction;
	AdditionalContext.ListsWithKeysRecordForDependentListsWithoutKeys
		= ListsWithKeysRecordForDependentListsWithoutKeys;
	
	Filter = New Structure("Level, HasDependantListsWithoutAccessKeysRecords", 0, True);
	Rows = PropertiesTable.FindRows(Filter);
	For Each String In Rows Do
		String.Parameters = RestrictionParametersForUsersKind(String.FullName, Context);
	EndDo;
	
	ListsPropertiesByLevels = New Array;
	For Level = 1 To MaxLevel Do
		ListsProperties = PropertiesTable.FindRows(New Structure("Level", Level));
		ListsPropertiesByLevels.Add(ListsProperties);
	EndDo;
	
	CommonContextListsWithRestriction = Context.CommonContext.ListsWithRestriction;
	
	For Each ListsProperties In ListsPropertiesByLevels Do
		For Each ListProperties In ListsProperties Do
			ListProperties = ListProperties; // See ListsPropertiesToCalculateStoredParameters
			
			AllLeadingListsWithRestriction = True;
			CalculateUsersRightsPropertyChanged = False;
			UsersAccessKeys = False;
			AccessGroupsAccessKeys = False;
			
			For Each Master In ListProperties.LeadingItems Do
				LeadingListProperties = ListsWithRestriction.Get(Master);
				If LeadingListProperties.UsersAccessKeys Then
					UsersAccessKeys = True;
				Else
					AccessGroupsAccessKeys = True;
				EndIf;
				If CommonContextListsWithRestriction.Get(Master) = Undefined
				 Or ListsWithDisabledRestriction.Get(Master) <> Undefined Then
					AllLeadingListsWithRestriction = False;
				EndIf;
			EndDo;
			
			If UsersAccessKeys Then
				If Not ListProperties.RestrictionByOwnerEnabled
				   And Not ListProperties.UsersAccessKeys Then
					
					CalculateUsersRightsPropertyChanged = True;
					SetRestrictionProperty(ListProperties.FullName,
						"CalculateUserRights", True, Context);
				EndIf;
				ListProperties.UsersAccessKeys = True;
				If AccessGroupsAccessKeys Then
					ListProperties.UsersAndAccessGroupsAccessKeys = True;
				EndIf;
			EndIf;
			
			If ListProperties.RestrictionByOwnerEnabled
			   And AllLeadingListsWithRestriction
			   And Not CalculateUsersRightsPropertyChanged
			   And ListsWithKeysRecordForDependentListsWithoutKeys.Get(ListProperties.FullName) = Undefined
			    Then
				Continue;
			EndIf;
			
			ListProperties.Parameters =
				RestrictionParametersForUsersKind(ListProperties.FullName, Context);
		EndDo;
	EndDo;
	
	// Filling in stored list properties.
	For Each ListProperties In PropertiesTable Do
		FullName = ListProperties.FullName;
		
		If ListProperties.Parameters.AccessDenied Then
			SetRestrictionProperty(FullName, "AccessDenied", True, Context);
		EndIf;
		If ValueIsFilled(ListProperties.Parameters.SeparateKeysRegisterName) Then
			SetRestrictionProperty(FullName,
				"SeparateKeysRegisterName", ListProperties.Parameters.SeparateKeysRegisterName, Context);
		EndIf;
		If ValueIsFilled(ListProperties.Parameters.BasicFields) Then
			BasicFields = New Structure("All, AllItemsTypes, UsedItems");
			FillPropertyValues(BasicFields, ListProperties.Parameters.BasicFields);
			SetRestrictionProperty(FullName, "BasicFields", BasicFields, Context);
		EndIf;
		If ListProperties.UsersAndAccessGroupsAccessKeys Then
			SetRestrictionProperty(FullName,
				"TemplateRestrictionsWithUserAccessKeysAndAccessGroups", True, Context);
		ElsIf ListProperties.UsersAccessKeys Then
			SetRestrictionProperty(FullName,
				"TemplateRestrictionsWithUserAccessKeys", True, Context);
		EndIf;
		If ListProperties.Parameters.RightToWriteRestrictionDisabled Then
			ListsWithReadRestrictionDisabled.Insert(FullName, True);
		EndIf;
		If ListProperties.Parameters.RestrictionDisabled Then
			ListsWithDisabledRestriction.Insert(FullName, True);
		EndIf;
		SetRestrictionProperty(FullName, "UsedAccessValuesTypes",
			New ValueStorage(ListProperties.Parameters.UsedAccessValuesTypes), Context);
		
		Context.ListsRestrictionsVersions.Insert(FullName, ListProperties.Parameters.Version);
		If Context.CommonContext.Property("StoredParametersVersionStrings") Then
			ListsVersionsStrings = Context.CommonContext.StoredParametersVersionStrings.ListsVersionsStrings; // See NewListsVersionsStrings
			NewRow = ListsVersionsStrings.Add();
			NewRow.List                  = ListProperties.FullName;
			NewRow.ForExternalUsers = Context.ForExternalUsers;
			NewRow.Version                  = ListProperties.Parameters.Version;
			NewRow.VersionString            = ListProperties.Parameters.Context.VersionPropertiesString;
		EndIf;
		
		LeadingLists = ListProperties.Parameters.LeadingLists;
		
		If LeadingLists.ByFieldsValues.Count() > 0
		 Or LeadingLists.ByAccessKeys.Count() > 0
		 Or LeadingLists.ByValuesWithGroups.Count() > 0 Then
			
			Context.LeadingLists.Insert(FullName, LeadingLists);
		EndIf;
		
		SetTemplatesParameters(ListProperties, Context);
		
		If ListProperties.Parameters.ListWithDate Then
			Context.ListsWithDate.Insert(ListProperties.FullName, True);
		EndIf;
		
		For Each KeyAndValue In ListProperties.Parameters.AllRightsRestrictionsKinds Do
			Context.AllRightsRestrictionsKinds.Insert(ListProperties.FullName + "." + KeyAndValue.Key, True);
		EndDo;
		
		If ValueIsFilled(ListProperties.Parameters.Context.LeadingRoles) Then
			For Each KeyAndValue In ListProperties.Parameters.Context.LeadingRoles Do
				DependentLists = Context.LeadingRoles.Get(KeyAndValue.Key);
				If DependentLists = Undefined Then
					DependentLists = New Map;
					Context.LeadingRoles.Insert(KeyAndValue.Key, DependentLists);
				EndIf;
				DependentLists.Insert(ListProperties.FullName, True);
			EndDo;
		EndIf;
	EndDo;
	
EndProcedure

// Returns:
//   Structure:
//     * FullName - String
//     * DependentItem - Boolean
//     * LeadingItems   - Array
//     * Level   - Number
//     * Master   - Boolean
//     * Parameters - Structure
//     * Processed - Boolean
//     * RestrictionByOwnerPossible  - Boolean
//     * RestrictionByOwnerEnabled  - Boolean
//     * RestrictionByOwnerDisabled - Boolean
//     * UsersAccessKeys       - Boolean
//     * HasDependantListsWithoutAccessKeysRecords - Boolean
//     * UsersAndAccessGroupsAccessKeys    - Boolean
//
Function ListsPropertiesToCalculateStoredParameters()
	
	Return Undefined;
	
EndFunction

// For the StoredRestrictionParametersForUsersKind procedure.
//
// Returns:
//   See RestrictionParametersByRestrictionStructure
//
Function RestrictionParametersForUsersKind(FullName, Context)
	
	RestrictionDetails = Context.AdditionalContext.RestrictionsDetails1.Get(FullName);
	
	If RestrictionDetails = Undefined Then
		RestrictionStructure = Undefined;
	Else
		RestrictionStructure = CalculatedRestrictionStructure(FullName,
			RestrictionDetails.Text, RestrictionDetails.InManagerModule, Context.ForExternalUsers);
	EndIf;
	
	Return RestrictionParametersByRestrictionStructure(FullName,
		RestrictionStructure,
		Context.ForExternalUsers,
		Context.CommonContext,
		Context.AdditionalContext);
	
EndFunction

// For the AddStoredRestrictionParametersForUsersKind procedure.
Procedure SetDependentListsLevel(LeadingListProperties1, ListsProperties, PreviousLeadingLists,
			MaxLevel)
	
	PreviousLeadingLists.Add(LeadingListProperties1.FullName);
	
	For Each DependentList In LeadingListProperties1.DependentItems Do
		If PreviousLeadingLists.Find(DependentList) <> Undefined Then
			LoopMembers = "";
			IndexOf = PreviousLeadingLists.Count() - 1;
			While True Do
				LoopMembers = "- " + PreviousLeadingLists[IndexOf] + Chars.LF + LoopMembers;
				If PreviousLeadingLists[IndexOf] = DependentList Then
					Break;
				EndIf;
				IndexOf = IndexOf - 1;
			EndDo;
			LoopMembers = LoopMembers + "(!) " + DependentList;
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'The access restrictions specified in procedures ""%1""
				           |of manager modules or common module ""%2""
				           |contain a circular dependency if function
				           |""%3"" or ""%4"" is present in one or several lists
				           |included in the cycle:
				           |%5';"),
				"OnFillAccessRestriction",
				"AccessManagementOverridable",
				"ObjectReadingAllowed",
				"ObjectUpdateAllowed",
				LoopMembers);
			Raise ErrorText;
		EndIf;
		DependentListProperties = ListsProperties.Get(DependentList);
		If DependentListProperties.Level < LeadingListProperties1.Level + 1 Then
			DependentListProperties.Level = LeadingListProperties1.Level + 1;
			If MaxLevel < DependentListProperties.Level Then
				MaxLevel = DependentListProperties.Level;
			EndIf;
		EndIf;
		If Not DependentListProperties.Master Then
			DependentListProperties.Processed = True;
			Continue;
		EndIf;
		SetDependentListsLevel(DependentListProperties, ListsProperties, PreviousLeadingLists, MaxLevel);
	EndDo;
	
	PreviousLeadingLists.Delete(PreviousLeadingLists.Count() - 1);
	LeadingListProperties1.Processed = True;
	
EndProcedure

// For the AddStoredRestrictionParametersForUsersKind procedure.
Procedure SetOptimizationByOwnerField(DependentListProperties, ListsProperties, Context)
	
	DependentListProperties.RestrictionByOwnerPossible =
		DependentListProperties.Parameters.OwnerField <> Undefined;
	
	DependentListProperties.RestrictionByOwnerEnabled =
		     DependentListProperties.RestrictionByOwnerPossible
		And Not DependentListProperties.RestrictionByOwnerDisabled;
	
	DependentListWithOptimization = DependentListProperties.RestrictionByOwnerEnabled;
	
	For Each LeadingList In DependentListProperties.LeadingItems Do
		LeadingListProperties1 = ListsProperties.Get(LeadingList); // See ListsPropertiesToCalculateStoredParameters
		If LeadingListProperties1.Parameters.AccessDenied Then
			Continue;
		EndIf;
		If Not LeadingListProperties1.DependentItem Then
			If DependentListWithOptimization Then
				LeadingListProperties1.HasDependantListsWithoutAccessKeysRecords = True;
			EndIf;
			Continue;
		EndIf;
		If DependentListWithOptimization Then
			If LeadingListProperties1.Parameters.OwnerField <> Undefined
			   And Not LeadingListProperties1.Parameters.OwnerField.Disabled Then
				If LeadingListProperties1.Parameters.RestrictionByOwnerRequired Then
					OptimizationFlagName = ?(Context.ForExternalUsers,
						"ByOwnerWithoutSavingAccessKeysForExternalUsers", "ByOwnerWithoutSavingAccessKeys");
					ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
						NStr("en = 'Cannot apply the optimization option ""%1"" as it is required
						           |for the dependent list ""%2"".';"),
						OptimizationFlagName,
						DependentListProperties.FullName);
					ErrorContext = New Structure("ListsWithRestriction, RestrictionsDetails1");
					ErrorContext.Insert("List",                  LeadingListProperties1.FullName);
					ErrorContext.Insert("RestrictionsDetails1",     Context.AdditionalContext.RestrictionsDetails1);
					ErrorContext.Insert("ForExternalUsers", Context.ForExternalUsers);
					ErrorText = ErrorTextWithTitle(ErrorText, ErrorContext);
					Raise ErrorText;
				Else
					LeadingListProperties1.RestrictionByOwnerDisabled = True;
					LeadingListProperties1.Parameters.OwnerField.Disabled = True;
					SetRestrictionProperty(LeadingListProperties1.FullName,
						"OwnerField", LeadingListProperties1.Parameters.OwnerField, Context);
				EndIf;
			EndIf;
			LeadingListProperties1.HasDependantListsWithoutAccessKeysRecords = True;
		EndIf;
		SetOptimizationByOwnerField(LeadingListProperties1, ListsProperties, Context);
	EndDo;
	
EndProcedure

// For the AddStoredRestrictionParametersForUsersKind procedure.
Procedure SetRestrictionProperty(FullName, PropertyName, PropertyValue, Context)
	
	Properties = ListRestrictionProperties(FullName, Context.AdditionalContext, True);
	
	Properties[PropertyName] = PropertyValue;
	
EndProcedure

// For the SetRestrictionProperty and FillReadUpdateRightCheckQueries procedures.
Function ListRestrictionProperties(FullName, Context, AddToCollection = False)
	
	Properties = Context.ListRestrictionsProperties.Get(FullName);
	
	If Properties = Undefined Then
		Properties = NewListRestrictionProperties();
		If AddToCollection Then
			Context.ListRestrictionsProperties.Insert(FullName, Properties);
		EndIf;
	EndIf;
	
	Return Properties;
	
EndFunction

// Returns:
//   Structure:
//     * AccessDenied                  - Boolean
//     * OwnerField                   - See NewOwnerField 
//     * BasicFields                     - See NewBasicFieldsDetails
//     * SeparateKeysRegisterName     - String
//     * CalculateUserRights  - Boolean
//     * UsedAccessValuesTypes - ValueStorage -
//     * TemplateRestrictionsWithUserAccessKeys              - Boolean
//     * TemplateRestrictionsWithUserAccessKeysAndAccessGroups - Boolean
//
Function NewListRestrictionProperties()
	
	Properties = New Structure;
	Properties.Insert("AccessDenied", False);
	Properties.Insert("OwnerField",  Undefined);
	Properties.Insert("BasicFields",    Undefined);
	Properties.Insert("SeparateKeysRegisterName", "");
	Properties.Insert("CalculateUserRights", False);
	Properties.Insert("TemplateRestrictionsWithUserAccessKeys", False);
	Properties.Insert("TemplateRestrictionsWithUserAccessKeysAndAccessGroups", False);
	Properties.Insert("UsedAccessValuesTypes", Undefined);
	
	Return Properties;
	
EndFunction

// For the StoredAccessRestrictionParameters function.
Procedure AddLeadingRoles(LeadingRoles, UsersKindPropertyName, UserViewContext)
	
	For Each DescriptionOfTheLeadingRole In UserViewContext.LeadingRoles Do
		NameOfRole = DescriptionOfTheLeadingRole.Key;
		DependentLists = LeadingRoles.Get(NameOfRole);
		If DependentLists = Undefined Then
			DependentLists = New Structure("ForUsers, ForExternalUsers");
			LeadingRoles.Insert(NameOfRole, DependentLists);
		EndIf;
		DependentLists[UsersKindPropertyName] =
			New FixedMap(DescriptionOfTheLeadingRole.Value);
	EndDo;
	
EndProcedure

// For the StoredAccessRestrictionParameters function.
Procedure AddLeadingLists(LeadingLists, UsersKindPropertyName, DependentList,
			LeadingListsOfDependentList)
	
	For Each LeadingListDetails In LeadingListsOfDependentList.ByFieldsValues Do
		LeadingList = CurrentLeadingListProperties(LeadingLists, LeadingListDetails.Key);
		LeadingList.DependentLists.Insert(DependentList, True);
		FieldsToAdd = LeadingListDetails.Value;
		
		If LeadingList.ByFieldsValues = Undefined Then
			ByFieldsValues = New Structure;
			ByFieldsValues.Insert("IsReferenceType", FieldsToAdd.IsReferenceType);
			ByFieldsValues.Insert("HeaderFields", LeadingListFieldsDetails());
			If ByFieldsValues.IsReferenceType Then
				ByFieldsValues.Insert("TabularSections", New Map);
			EndIf;
			LeadingList.ByFieldsValues = ByFieldsValues;
		Else
			ByFieldsValues = LeadingList.ByFieldsValues;
		EndIf;
		
		AddLeadingListFields(ByFieldsValues.HeaderFields, FieldsToAdd.ForTracking.HeaderFields,
			FieldsToAdd.ForFilter.HeaderFields, DependentList, UsersKindPropertyName);
		
		For Each TabularSection In FieldsToAdd.ForTracking.TabularSections Do
			TabularSectionDetails = ByFieldsValues.TabularSections.Get(TabularSection.Key);
			If TabularSectionDetails = Undefined Then
				TabularSectionDetails = LeadingListFieldsDetails();
				TabularSectionDetails.Insert("Name", TabularSection.Key);
				ByFieldsValues.TabularSections.Insert(TabularSection.Key, TabularSectionDetails);
			EndIf;
			FilterFieldTabularSection = FieldsToAdd.ForFilter.TabularSections.Get(TabularSection.Key);
			AddLeadingListFields(TabularSectionDetails, TabularSection.Value,
				FilterFieldTabularSection, DependentList, UsersKindPropertyName);
		EndDo;
	EndDo;
	
	AddLeadingListsByDependencyKind(LeadingLists,
		UsersKindPropertyName, DependentList, LeadingListsOfDependentList, "ByAccessKeys");
	
	AddLeadingListsByDependencyKind(LeadingLists,
		UsersKindPropertyName, DependentList, LeadingListsOfDependentList, "ByValuesWithGroups");
	
EndProcedure

// Returns:
//   Structure:
//     * IsReferenceType - Boolean
//     * HeaderFields       - See LeadingListFieldsDetails
//     * TabularSections  - Array of See LeadingListFieldsDetails
//
Function LeadingListByFieldsValues()
	
	Return New Structure;
	
EndFunction

// Returns:
//   Structure:
//     * ForUsers        - Array of String - full list names
//     * ForExternalUsers - Array of String - full list names
//
Function LeadingListByAccessKeysOrValuesWithGroups()
	
	Return New Structure;
	
EndFunction

// For the AddLeadingLists procedure.
//
// Returns:
//   Structure:
//     * AllFields       - Array
//     * AllFieldsTypes - Map of KeyAndValue:
//        ** Key - String - field name.
//        ** Value - ValueStorage -
//     * FieldsSets   - Structure:
//         ** ForUsers - Boolean
//         ** ForExternalUsers - Boolean
//     * Name - String - a tabular section name (only tabular section fields have it)
//
Function LeadingListFieldsDetails()
	
	LongDesc = New Structure;
	LongDesc.Insert("AllFields",       New Array);
	LongDesc.Insert("AllFieldsTypes", New Map);
	LongDesc.Insert("FieldsSets",   New Structure("ForUsers, ForExternalUsers"));
	
	Return LongDesc;
	
EndFunction

// For the AddLeadingLists procedure.
Procedure AddLeadingListsByDependencyKind(LeadingLists, UsersKindPropertyName,
			DependentList, LeadingListsOfDependentList, DependencyKind)
	
	For Each LeadingListDetails In LeadingListsOfDependentList[DependencyKind] Do
		LeadingList = CurrentLeadingListProperties(LeadingLists, LeadingListDetails.Key);
		LeadingList.DependentLists.Insert(DependentList, True);
		
		If LeadingList[DependencyKind] = Undefined Then
			Properties = LeadingListByAccessKeysOrValuesWithGroups();
			Properties.Insert("ForUsers",        Undefined);
			Properties.Insert("ForExternalUsers", Undefined);
			LeadingList[DependencyKind] = Properties;
		Else
			Properties = LeadingList[DependencyKind];
		EndIf;
		
		If Properties[UsersKindPropertyName] = Undefined Then
			Properties[UsersKindPropertyName] = New Array;
		EndIf;
		DependentLists = Properties[UsersKindPropertyName]; // Array 
		DependentLists.Add(DependentList);
	EndDo;
	
EndProcedure

// For the AddLeadingLists procedure.
//
// Returns:
//   Structure:
//     * DependentLists      - Map of KeyAndValue:
//         ** Key     - String - full name of the list
//         ** Value - Boolean - True
//     * ByFieldsValues     - Structure - similar to LeadingListByFieldsValues 
//     * ByAccessKeys      - See LeadingListByAccessKeysOrValuesWithGroups
//     * ByValuesWithGroups - See LeadingListByAccessKeysOrValuesWithGroups
//
Function CurrentLeadingListProperties(LeadingLists, FullName)
	
	LeadingList = LeadingLists.Get(FullName);
	If LeadingList = Undefined Then
		LeadingList = New Structure;
		LeadingList.Insert("DependentLists",      New Map);
		LeadingList.Insert("ByFieldsValues",     Undefined);
		LeadingList.Insert("ByAccessKeys",      Undefined);
		LeadingList.Insert("ByValuesWithGroups", Undefined);
		LeadingLists.Insert(FullName, LeadingList)
	EndIf;
	
	Return LeadingList;
	
EndFunction

// For the AddLeadingLists procedure.
Procedure AddLeadingListFields(CurrentFields, FieldsDetails, FilterFieldsDetails, DependentList,
			UsersKindPropertyName)
	
	FieldList = New ValueList;
	For Each FieldDetails In FieldsDetails Do
		If CurrentFields.AllFields.Find(FieldDetails.Key) = Undefined Then
			CurrentFields.AllFields.Add(FieldDetails.Key);
			CurrentFields.AllFieldsTypes.Insert(FieldDetails.Key, FieldDetails.Value);
		EndIf;
		FieldList.Add(FieldDetails.Key);
	EndDo;
	FieldList.SortByValue();
	FieldsSet = StrConcat(FieldList.UnloadValues(), ", ");
	
	FieldsSets = CurrentFields.FieldsSets[UsersKindPropertyName];
	If FieldsSets = Undefined Then
		FieldsSets = New Map;
		CurrentFields.FieldsSets[UsersKindPropertyName] = FieldsSets;
	EndIf;
	DependentListsByFilterFields = FieldsSets.Get(FieldsSet);
	If DependentListsByFilterFields = Undefined Then
		DependentListsByFilterFields = New Map;
		FieldsSets.Insert(FieldsSet, DependentListsByFilterFields);
	EndIf;
	
	FieldList = New ValueList;
	For Each FieldDetails In FilterFieldsDetails Do
		FieldList.Add(FieldDetails.Key);
	EndDo;
	FieldList.SortByValue();
	FilterFieldsSet = StrConcat(FieldList.UnloadValues(), ", ");
	
	DependentLists = DependentListsByFilterFields.Get(FilterFieldsSet);
	If DependentLists = Undefined Then
		DependentLists = New Array;
		DependentListsByFilterFields.Insert(FilterFieldsSet, DependentLists);
	EndIf;
	DependentLists.Add(DependentList);
	
EndProcedure

// For the AddStoredRestrictionParametersForUsersKind procedure.
Procedure SetTemplatesParameters(ListProperties, Context)
	
	Parameters = ListProperties.Parameters;
	TemplatesParameters = Context.TemplatesParameters;
	
	If Parameters.AccessDenied Then
		Refinement = ?(Context.ForExternalUsers
			And Not Context.CommonContext.ExternalUsersEnabled, "1", "0");
		TemplatesParameters.ListsWithAccessGroupsAccessKeysRestriction =
			TemplatesParameters.ListsWithAccessGroupsAccessKeysRestriction
				+ ListProperties.FullName + ";" + Refinement + Chars.LF;
		Return;
	EndIf;
	
	If Not Parameters.UsesRestrictionByOwner
	   And Not Parameters.IsReferenceType
	   And Not Parameters.RestrictionDisabled Then
		
		BasicFields = Parameters.BasicFields;
		Version = NewVersionOfTemplateParameters();
		Version.CreationDate   = Context.CreationDate;
		Version.List         = ListProperties.FullName;
		Version.ConnectionFields = StrConcat(BasicFields.UsedItems, ",");
		Version.TemplateFields    = StrConcat(BasicFields.All, ",");
		Version.AccessOption = BasicFields.UsedItems.Count() * 2
			+ ?(Context.ForExternalUsers, 1, 0);
		Versions = New Array;
		Versions.Add(Version);
		TheKeyOfTheTable = TheKeyOfTheTable(ListProperties.FullName, Parameters.Context.TypeCollectionName);
		Context.TemplatesParametersVersions.Insert(TheKeyOfTheTable, Versions);
	EndIf;
	
	If Parameters.RightToWriteRestrictionDisabled Then
		TemplatesParameters.ListsWithReadRestrictionDisabled =
			TemplatesParameters.ListsWithReadRestrictionDisabled
				+ ListProperties.FullName + ";" + Chars.LF;
		Return;
	EndIf;
	
	OwnerFieldDisabled = "";
	
	If Parameters.UsesRestrictionByOwner
	 Or Parameters.IsReferenceType Then
		
		OwnerField = Parameters.OwnerField; // See NewOwnerField
		If OwnerField <> Undefined Then
			Fields = ":" + OwnerField.Name;
			If Not Parameters.UsesRestrictionByOwner Then
				OwnerFieldDisabled = ";-";
			EndIf;
		Else
			Fields = ":";
		EndIf;
	Else
		BasicFields = Parameters.BasicFields;
		If ValueIsFilled(Parameters.SeparateKeysRegisterName) Then
			Fields = "AccessKeysToRegister" + StrSplit(ListProperties.FullName, ".")[1];
		Else
			Fields = AccessManagementInternalCached.PredefinedMetadataObjectIDDetails(
				ListProperties.FullName);
		EndIf;
		Fields = ":[" + Fields + "]";
		Number = 1;
		For Each FieldName In BasicFields.All Do
			Fields = Fields + ":" + FieldName;
			Number = Number + 1;
		EndDo;
		BlankFieldNumber = BasicFields.All.Count() + 1;
		For Number = BlankFieldNumber To BasicFields.MaxQuantity Do
			Fields = Fields + ":";
		EndDo;
	EndIf;
	
	TemplatesParameters.ListsWithAccessGroupsAccessKeysRestriction =
		TemplatesParameters.ListsWithAccessGroupsAccessKeysRestriction
			+ ListProperties.FullName + Fields + ";*" + OwnerFieldDisabled + Chars.LF;
	
	If ListProperties.UsersAndAccessGroupsAccessKeys
	 Or ListProperties.UsersAccessKeys Then
		
		TemplatesParameters.ListsWithUsersAccessKeysRestriction =
			TemplatesParameters.ListsWithUsersAccessKeysRestriction
				+ ListProperties.FullName + Fields + ";+" + OwnerFieldDisabled + Chars.LF;
	EndIf;
	
EndProcedure

// For the SetTemplatesParameters procedure.
//
// Parameters:
//  FullName - String
//  TypeCollectionName - String
//  TablesTypesByNames - Map
//
// Returns:
//  String
//
Function TheKeyOfTheTable(FullName, TypeCollectionName = Undefined, TablesTypesByNames = Undefined)
	
	If TypeCollectionName = Undefined Then
		TypeProperties = TablesTypesByNames.Get(Upper(StrSplit(FullName, ".", False)[0]));
		TypeCollectionName = TypeProperties.CollectionName;
	EndIf;
	
	If TypeCollectionName = "InformationRegisters"
	 Or TypeCollectionName = "AccumulationRegisters"
	 Or TypeCollectionName = "AccountingRegisters"
	 Or TypeCollectionName = "CalculationRegisters" Then
		
		TableKeyType = RecordKeyTypeByFullMetadataName(FullName);
		
	ElsIf TypeCollectionName = "Sequences" Then
		TableKeyType = RecordsetTypeByFullMetadataName(FullName);
		
	ElsIf TypeCollectionName = "DocumentJournals" Then
		TableKeyType = ObjectManagerTypeByFullMetadataName(FullName);
	Else
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Unknown non-reference metadata object
			           |""%1""
			           |with record-level restriction support.';"), FullName);
		Raise ErrorText;
	EndIf;
	
	DataHashing = New DataHashing(HashFunction.SHA256);
	HashString = DataStringForHashing(TableKeyType);
	DataHashing.Append(HashString);
	
	Return Base64String(DataHashing.HashSum);
	
EndFunction

// For the AccessRestrictionParametersNewVersionDetails procedure.
Procedure FillInTheParametersForTemplates(Record, WriteParameters, VersionDetails)
	
	If TypeOf(VersionDetails.CreationDate) = Type("Date") Then
		OldCreationDate = VersionDetails.CreationDate;
	Else
		OldCreationDate = '00010101';
	EndIf;
	
	StoredCurrentVersions = NewStructureOfStoredVersionsOfTemplateParameters();
	CurrentListRestrictionPropertiesForUsers        = New Map;
	CurrentListRestrictionPropertiesForExternalUsers = New Map;
	VersionsOfTemplateParametersAreReceived = False;
	
	If TypeOf(VersionDetails.TemplatesParametersVersions) = Type("ValueStorage") Then
		StorageContents = ValueFromStorage(VersionDetails.TemplatesParametersVersions);
		If ValueIsFilled(StorageContents) Then
			StoredCurrentVersions = StructureOfStoredVersionsOfTemplateParameters(StorageContents);
			If StoredCurrentVersions.VersionOfTheVersionStructure = VersionOfTheTemplateParameterVersionStructure() Then
				VersionsOfTemplateParametersAreReceived = True;
				CurrentListRestrictionPropertiesForUsers        = Undefined;
				CurrentListRestrictionPropertiesForExternalUsers = Undefined;
			Else
				StoredCurrentVersions = NewStructureOfStoredVersionsOfTemplateParameters();
			EndIf;
		ElsIf TypeOf(VersionDetails.Version) = Type("Number") Then
			CurrentStoredParameters = ParametersVersion(VersionDetails.Version, False, False);
			If TypeOf(CurrentStoredParameters.ForWritingObjectsAndCheckingRights) = Type("ValueStorage") Then
				CurrentWriteParameters = StoredWriteParametersStructure(
					ValueFromStorage(CurrentStoredParameters.ForWritingObjectsAndCheckingRights));
				If CurrentWriteParameters.CacheStructureVersion = CacheStructureVersion()
				 Or CurrentWriteParameters.CacheStructureVersion = "20" Then
					CurrentListRestrictionPropertiesForUsers =
						CurrentWriteParameters.AdditionalContext.ForUsers.ListRestrictionsProperties;
					CurrentListRestrictionPropertiesForExternalUsers =
						CurrentWriteParameters.AdditionalContext.ForExternalUsers.ListRestrictionsProperties;
				EndIf;
			EndIf;
		EndIf;
	EndIf;
	If Not VersionsOfTemplateParametersAreReceived Then
		VersionDetails.HashSum = "#" + VersionDetails.HashSum;
	EndIf;
	
	If WriteParameters.Property("VersionStrings") Then
		VersionStrings = WriteParameters.VersionStrings;
	Else
		VersionStrings = New Structure;
	EndIf;
	VersionStrings.Insert("ListsWithRestrictedFieldsInUserSessions");
	VersionStrings.Insert("ListsWithFieldRestrictionsInExternalUserSessions");
	
	If CurrentListRestrictionPropertiesForUsers <> Undefined Then
		NewRecordingParameters = WriteParameters.StoredParameters.ForWritingObjectsAndCheckingRights.Get();
		NewListRestrictionPropertiesForUsers =
			NewRecordingParameters.AdditionalContext.ForUsers.ListRestrictionsProperties;
		NewListRestrictionPropertiesForExternalUsers =
			NewRecordingParameters.AdditionalContext.ForExternalUsers.ListRestrictionsProperties;
	EndIf;
	
	StoredNewVersions = WriteParameters.StoredParameters.TemplatesParametersVersions.Get();
	DataHashing = New DataHashing(HashFunction.SHA256);
	
	Parameters = NewStructureForFillingInTemplateParameters();
	If TypeOf(WriteParameters.ListsWithOutdatedAccessOptions) = Type("Array") Then
		Parameters.Insert("DisableAdditionalAccessOptions");
	Else
		WriteParameters.ListsWithOutdatedAccessOptions = New Array;
	EndIf;
	Parameters.Insert("OldCreationDate", OldCreationDate);
	Parameters.Insert("DataHashing",  DataHashing);
	Parameters.Insert("ListsWithTheNewPrimaryAccessOption", WriteParameters.ListsWithTheNewPrimaryAccessOption);
	Parameters.Insert("ListsWithOutdatedAccessOptions",  WriteParameters.ListsWithOutdatedAccessOptions);
	
	Parameters.Insert("StoredCurrentVersions",   StoredCurrentVersions.ForUsers);
	Parameters.Insert("NewVersionsOfListFields", StoredNewVersions.ForUsers.TemplatesParametersVersions);
	Parameters.Insert("CurrentListConstraintProperties", CurrentListRestrictionPropertiesForUsers);
	Parameters.Insert("NewListConstraintProperties",   NewListRestrictionPropertiesForUsers);
	
	FillInTheParametersForTemplatesForTheUserView(Parameters,
		Record.ForTemplatesInUsersSessions,
		VersionStrings.ListsWithRestrictedFieldsInUserSessions);
	
	Parameters.StoredCurrentVersions   = StoredCurrentVersions.ForExternalUsers;
	Parameters.NewVersionsOfListFields = StoredNewVersions.ForExternalUsers.TemplatesParametersVersions;
	Parameters.CurrentListConstraintProperties = CurrentListRestrictionPropertiesForExternalUsers;
	Parameters.NewListConstraintProperties   = NewListRestrictionPropertiesForExternalUsers;
	
	FillInTheParametersForTemplatesForTheUserView(Parameters,
		Record.ForTemplatesInExternalUsersSessions,
		VersionStrings.ListsWithFieldRestrictionsInExternalUserSessions);
	
	Record.TemplatesParametersHashSum = Base64String(DataHashing.HashSum);
	Record.TemplatesParametersVersions = New ValueStorage(StoredCurrentVersions);
	
	DataHashing = New DataHashing(HashFunction.SHA256);
	DataHashing.Append(Record.PersistentParametersHashSum);
	DataHashing.Append(Record.TemplatesParametersHashSum);
	Record.HashSum = Base64String(DataHashing.HashSum);
	
EndProcedure

// For the FillParametersForTemplates procedure.
//
// Returns:
//  Structure:
//   * OldCreationDate - Date
//   * DataHashing  - DataHashing
//   * ListsWithTheNewPrimaryAccessOption - Array of String
//   * ListsWithOutdatedAccessOptions  - Array of String
//   * StoredCurrentVersions - Structure:
//      ** TemplatesParametersVersions - See TheNewVersionOfTheTemplateParameters
//      ** BasicAccessOptions  - See NewBasicAccessOptions
//   * NewVersionsOfListFields - See TheNewVersionOfTheTemplateParameters
//   * CurrentListConstraintProperties - Map of KeyAndValue:
//      ** Key     - String - a full list name
//      ** Value - See NewListRestrictionProperties
//   * NewListConstraintProperties - Map of KeyAndValue:
//      ** Key     - String - a full list name
//      ** Value - See NewListRestrictionProperties
//
Function NewStructureForFillingInTemplateParameters()
	
	Return New Structure;
	
EndFunction

// For the FillParametersForTemplates procedure.
// 
// Parameters:
//  Parameters - See NewStructureForFillingInTemplateParameters
//  StorageForTemplatesInSessions - ValueStorage - a value being updated
//  ListsWithRestrictionByFields - String - a return value
//
Procedure FillInTheParametersForTemplatesForTheUserView(Parameters,
			StorageForTemplatesInSessions, ListsWithRestrictionByFields)
	
	MaximumNumberOfVersions = MaximumNumberOfVersionsInTheAccessOption();
	ListRestrictionsSettings = New ValueList;
	CurrentVersionsOfListFields = Parameters.StoredCurrentVersions.TemplatesParametersVersions;
	
	If Parameters.CurrentListConstraintProperties <> Undefined Then
		DatabaseAccessOptions = DatabaseAccessOptions(Parameters);
		For Each KeyAndValue In Parameters.NewVersionsOfListFields Do
			CurrentVersionsOfTheListFields = New Array;
			AddExistingVersionsOfListFields(CurrentVersionsOfTheListFields,
				KeyAndValue.Value[0], DatabaseAccessOptions, Parameters);
			If ValueIsFilled(CurrentVersionsOfTheListFields) Then
				CurrentVersionsOfListFields.Insert(KeyAndValue.Key, CurrentVersionsOfTheListFields);
			EndIf;
		EndDo;
	EndIf;
	
	PossiblyUnusedVersionsOfListFields = New Array;
	
	For Each KeyAndValue In CurrentVersionsOfListFields Do
		CurrentVersionsOfTheListFields = KeyAndValue.Value;
		NewVersionsOfTheListFields = Parameters.NewVersionsOfListFields.Get(KeyAndValue.Key);
		
		If NewVersionsOfTheListFields = Undefined Then
			UsageWasDisabled = False;
			For Each Version In CurrentVersionsOfTheListFields Do
				If Version.Used Then
					Version.Used = False;
					UsageWasDisabled = True;
				EndIf;
			EndDo;
			If UsageWasDisabled And CurrentVersionsOfTheListFields.Count() > 0 Then
				FullName = CurrentVersionsOfTheListFields[0].List;
				If Common.MetadataObjectByFullName(FullName) <> Undefined Then
					Parameters.ListsWithOutdatedAccessOptions.Add(
						CurrentVersionsOfTheListFields[0].List);
				EndIf;
			EndIf;
			Continue;
		EndIf;
		
		NewVersion = NewVersionsOfTheListFields[0];
		ANewVersionExists = False;
		For Each Version In CurrentVersionsOfTheListFields Do
			If Upper(Version.ConnectionFields) = Upper(NewVersion.ConnectionFields)
			   And Version.AccessOption > 1 Then
				ANewVersionExists = True;
				Break;
			EndIf;
		EndDo;
		
		MainVersionChanged = True;
		If ANewVersionExists Then
			IndexOf = CurrentVersionsOfTheListFields.Find(Version);
			If IndexOf > 0 Then
				CurrentVersionsOfTheListFields.Delete(IndexOf);
				CurrentVersionsOfTheListFields.Insert(0, Version);
			Else
				MainVersionChanged = False;
			EndIf;
			FillPropertyValues(Version, NewVersion,, "AccessOption");
		Else
			VersionNumbersUsed = New Array(MaximumNumberOfVersions);
			TheOldestVersion = Undefined;
			DeletedVersions = New Array;
			For Each Version In CurrentVersionsOfTheListFields Do
				VersionNumber = Int(Version.AccessOption / 64);
				If NewVersion.AccessOption <> (Version.AccessOption - VersionNumber * 64) Then
					Continue;
				EndIf;
				If VersionNumber < MaximumNumberOfVersions Then
					VersionNumbersUsed[VersionNumber] = Version;
					TheOldestVersion = Version;
				Else
					DeletedVersions.Add(Version);
				EndIf;
			EndDo;
			For IndexOf = 0 To MaximumNumberOfVersions - 1 Do
				If VersionNumbersUsed[IndexOf] = Undefined Then
					Break;
				EndIf;
			EndDo;
			If IndexOf >= MaximumNumberOfVersions Then
				DeletedVersions.Add(TheOldestVersion);
				NewVersion.AccessOption = NewVersion.AccessOption
					+ VersionNumbersUsed.Find(TheOldestVersion) * 64;
			Else
				NewVersion.AccessOption = NewVersion.AccessOption + IndexOf * 64;
			EndIf;
			For Each VersionToDelete In DeletedVersions Do
				CurrentVersionsOfTheListFields.Delete(CurrentVersionsOfTheListFields.Find(VersionToDelete));
			EndDo;
			CurrentVersionsOfTheListFields.Insert(0, NewVersion);
		EndIf;
		
		If MainVersionChanged Then
			Parameters.ListsWithTheNewPrimaryAccessOption.Add(
				CurrentVersionsOfTheListFields[0].List);
		EndIf;
		
		UpdateTheUseOfListFieldVersions(CurrentVersionsOfTheListFields, MainVersionChanged,
			PossiblyUnusedVersionsOfListFields, Parameters);
	EndDo;
	
	DisableTheUseOfVersionsOtherThanTheMainOneForUpdatedLists(
		PossiblyUnusedVersionsOfListFields, Parameters);
	
	BasicAccessOptions = Parameters.StoredCurrentVersions.BasicAccessOptions;
	
	For Each KeyAndValue In Parameters.NewVersionsOfListFields Do
		CurrentVersionsOfTheListFields = CurrentVersionsOfListFields.Get(KeyAndValue.Key);
		If CurrentVersionsOfTheListFields = Undefined Then
			CurrentVersionsOfTheListFields = KeyAndValue.Value;
			CurrentVersionsOfListFields.Insert(KeyAndValue.Key, CurrentVersionsOfTheListFields);
			Parameters.ListsWithTheNewPrimaryAccessOption.Add(
				CurrentVersionsOfTheListFields[0].List);
		EndIf;
		AccessOptionsUsed = New Array;
		For Each VersionOfTheListFields In CurrentVersionsOfTheListFields Do
			If VersionOfTheListFields.Used Then
				AccessOptionUsed = NewAccessOptionUsed();
				AccessOptionUsed.AccessOption = VersionOfTheListFields.AccessOption;
				AccessOptionUsed.ConnectionFields = VersionOfTheListFields.ConnectionFields;
				AccessOptionsUsed.Add(New FixedStructure(AccessOptionUsed));
			EndIf;
		EndDo;
		BasicAccessOptions.Insert(CurrentVersionsOfTheListFields[0].List,
			New FixedArray(AccessOptionsUsed));
	EndDo;
	
	For Each KeyAndValue In CurrentVersionsOfListFields Do
		AddListConstraintFields(ListRestrictionsSettings, KeyAndValue.Value);
	EndDo;
	
	ListRestrictionsSettings.SortByPresentation();
	ListsWithRestrictionByFields = StrConcat(ListRestrictionsSettings.UnloadValues(), Chars.LF);
	Parameters.DataHashing.Append(ListsWithRestrictionByFields);
	
	StoredTemplatesParameters = New Structure(StorageForTemplatesInSessions.Get());
	TemplatesParameters = New Structure(StoredTemplatesParameters.TemplatesParameters);
	TemplatesParameters.ListsWithRestrictionByFields = ListsWithRestrictionByFields;
	StoredTemplatesParameters.TemplatesParameters = New FixedStructure(TemplatesParameters);
	StorageForTemplatesInSessions = New ValueStorage(
		New FixedStructure(StoredTemplatesParameters));
	
EndProcedure

// For the FillParametersForTemplatesForUsersKind procedure.
Procedure UpdateTheUseOfListFieldVersions(CurrentVersionsOfTheListFields, MainVersionChanged,
			PossiblyUnusedVersionsOfListFields, Parameters)
	
	MaximumNumberOfConnectionOptions = MaximumNumberOfConnectionOptions();
	NewVersion = CurrentVersionsOfTheListFields[0];
	TemplateFields = StrSplit(Upper(NewVersion.TemplateFields), ",", False);
	
	NumberOfVersionsUsed = 0;
	UsageWasDisabled = False;
	
	For Each CurrentVersion In CurrentVersionsOfTheListFields Do
		If Not CurrentVersion.Used Then
			Continue;
		EndIf;
		If Upper(CurrentVersion.TemplateFields) <> Upper(NewVersion.TemplateFields) Then
			FieldsNames = StrSplit(CurrentVersion.ConnectionFields, ",", False);
			For Each FieldName In FieldsNames Do
				If TemplateFields.Find(Upper(FieldName)) = Undefined Then
					CurrentVersion.Used = False;
					UsageWasDisabled = True;
					Break;
				EndIf;
			EndDo;
		EndIf;
		If Not CurrentVersion.Used Then
			Continue;
		EndIf;
		If NumberOfVersionsUsed >= MaximumNumberOfConnectionOptions Then
			CurrentVersion.Used = False;
			UsageWasDisabled = True;
		Else
			NumberOfVersionsUsed = NumberOfVersionsUsed + 1;
		EndIf;
	EndDo;
	
	If UsageWasDisabled Then
		Parameters.ListsWithOutdatedAccessOptions.Add(
			CurrentVersionsOfTheListFields[0].List);
	EndIf;
	
	If Not MainVersionChanged And NumberOfVersionsUsed > 1 Then
		PossiblyUnusedVersionsOfListFields.Add(CurrentVersionsOfTheListFields);
	EndIf;
	
EndProcedure

// For the FillParametersForTemplatesForUsersKind procedure.
Procedure AddListConstraintFields(ListsWithRestrictionByFields, CurrentVersionsOfTheListFields)
	
	NewVersion = CurrentVersionsOfTheListFields[0];
	FullName = NewVersion.List;
	TemplateFields = StrSplit(Upper(NewVersion.TemplateFields), ",", False);
	ListConstraintSettings = New Array;
	MaximumNumberOfOptions = MaximumNumberOfConnectionOptions();
	
	OptionNumber = 1;
	For Each Version In CurrentVersionsOfTheListFields Do
		If Not Version.Used Then
			Break;
		EndIf;
		
		ConnectionFieldNumber = 1;
		FieldsNames = StrSplit(Version.ConnectionFields, ",", False);
		For Each FieldName In FieldsNames Do
			TemplateFieldNumber = TemplateFields.Find(Upper(FieldName)) + 1;
			ListConstraintSettings.Add(StrTemplate("%1:%2%3=%4;",
				FullName,
				"Variant" + XMLString(OptionNumber),
				"Field" + XMLString(ConnectionFieldNumber),
				"Field" + XMLString(TemplateFieldNumber)));
			ConnectionFieldNumber = ConnectionFieldNumber + 1;
		EndDo;
		
		If Int(Version.AccessOption / 2) = 0 Then
			ListConstraintSettings.Add(StrTemplate("%1:%2%3=0;",
				FullName,
				"Variant" + XMLString(OptionNumber),
				"Version" + XMLString(OptionNumber)));
		Else
			Balance = Int(Version.AccessOption / 64);
			BitNumber = 0;
			While Balance > 0 Do
				NewBalance = Int(Balance / 2);
				If Balance - NewBalance * 2 > 0 Then
					ListConstraintSettings.Add(StrTemplate("%1:%2%3=1;",
						FullName,
						"Version" + XMLString(OptionNumber),
						"Bit" + XMLString(BitNumber)));
				EndIf;
				Balance = NewBalance;
				BitNumber = BitNumber + 1;
			EndDo;
		EndIf;
		
		OptionNumber = OptionNumber + 1;
		If OptionNumber > MaximumNumberOfOptions Then
			Break;
		EndIf;
	EndDo;
	
	ListsWithRestrictionByFields.Add(
		StrConcat(ListConstraintSettings, Chars.LF), FullName);
	
EndProcedure

// For the FillParametersForTemplatesForUsersKind procedure.
Function DatabaseAccessOptions(Parameters)
	
	If Not ValueIsFilled(Parameters.NewVersionsOfListFields) Then
		Return New Map;
	EndIf;
	
	GeneralRequestText =
	"SELECT DISTINCT
	|	CurrentTable.Register AS Register,
	|	CurrentTable.AccessOption AS AccessOption
	|FROM
	|	InformationRegister.AccessKeysForRegisters AS CurrentTable
	|WHERE
	|	CASE
	|			WHEN CurrentTable.AccessOption = 0
	|				THEN FALSE
	|			ELSE CurrentTable.AccessOption - (CAST(CurrentTable.AccessOption / 2 - 0.5 AS NUMBER(15, 0))) * 2 = 1
	|		END = &ForExternalUsers
	|
	|ORDER BY
	|	Register,
	|	AccessOption";
	
	QueriesTexts = New Array;
	QueriesTexts.Add(GeneralRequestText);
	
	FullNames = New Array;
	IndexesOfQueryResults = New Map;
	
	For Each KeyAndValue In Parameters.NewVersionsOfListFields Do
		List = KeyAndValue.Value[0].List;
		ListProperties = Parameters.NewListConstraintProperties.Get(List);
		If ListProperties = Undefined
		 Or Not ValueIsFilled(ListProperties.BasicFields) Then
			Continue;
		EndIf;
		FullNames.Add(List);
		If ValueIsFilled(ListProperties.SeparateKeysRegisterName) Then
			IndexesOfQueryResults.Insert(List, QueriesTexts.Count());
			QueryText =
			"SELECT DISTINCT
			|	CurrentTable.AccessOption AS AccessOption
			|FROM
			|	&CurrentTable AS CurrentTable
			|WHERE
			|	CASE
			|			WHEN CurrentTable.AccessOption = 0
			|				THEN FALSE
			|			ELSE CurrentTable.AccessOption - (CAST(CurrentTable.AccessOption / 2 - 0.5 AS NUMBER(15, 0))) * 2 = 1
			|		END = &ForExternalUsers
			|
			|ORDER BY
			|	AccessOption";
			QueryText = StrReplace(QueryText, "&CurrentTable",
				"InformationRegister." + ListProperties.SeparateKeysRegisterName);
			QueriesTexts.Add(QueryText);
		Else
			IndexesOfQueryResults.Insert(List, 0);
		EndIf;
	EndDo;
	
	ListsIDs = Common.MetadataObjectIDs(FullNames, False);
	
	Query = New Query;
	AccessOption = KeyAndValue.Value[0].AccessOption;
	Query.SetParameter("ForExternalUsers", AccessOption - Int(AccessOption / 2) * 2 > 0);
	Query.Text = StrConcat(QueriesTexts, Common.QueryBatchSeparator());
	QueryResults = Query.ExecuteBatch();
	Upload0 = QueryResults[0].Unload();
	Upload0.Indexes.Add("Register");
	
	Result = New Map;
	
	For Each KeyAndValue In IndexesOfQueryResults Do
		If KeyAndValue.Value = 0 Then
			ListID = ListsIDs.Get(KeyAndValue.Key);
			FoundRows = Upload0.FindRows(New Structure("Register", ListID));
			AccessOptions = New Array;
			For Each FoundRow In FoundRows Do
				AccessOptions.Add(FoundRow.AccessOption);
			EndDo;
			Result.Insert(KeyAndValue.Key, AccessOptions);
		Else
			Result.Insert(KeyAndValue.Key,
				QueryResults[KeyAndValue.Value].Unload().UnloadColumn("AccessOption"));
		EndIf;
	EndDo;
	
	Return Result;
	
EndFunction

// For the FillParametersForTemplatesForUsersKind procedure.
Procedure DisableTheUseOfVersionsOtherThanTheMainOneForUpdatedLists(
			PossiblyUnusedVersionsOfListFields, Parameters)
	
	If Not ValueIsFilled(PossiblyUnusedVersionsOfListFields)
	 Or Not Parameters.Property("DisableAdditionalAccessOptions") Then
		Return;
	EndIf;
	
	Lists = New Array;
	ListFieldVersions_SSLs = New Map;
	For Each ListFieldVersions In PossiblyUnusedVersionsOfListFields Do
		List = ListFieldVersions[0].List;
		Lists.Add(List);
		ListFieldVersions_SSLs.Insert(List, ListFieldVersions);
	EndDo;
	
	ForExternalUsers = ListFieldVersions[0].AccessOption
		- Int(ListFieldVersions[0].AccessOption / 2) * 2 = 1;
	
	IDsTypes = New Array;
	IDsTypes.Add(Type("CatalogRef.MetadataObjectIDs"));
	IDsTypes.Add(Type("CatalogRef.ExtensionObjectIDs"));
	
	ListsIDs = New ValueTable;
	ListsIDs.Columns.Add("ListID", New TypeDescription(IDsTypes));
	
	ListsByIDs = New Map;
	ObjectsIDs = Common.MetadataObjectIDs(Lists, False);
	
	For Each KeyAndValue In ObjectsIDs Do
		If ValueIsFilled(KeyAndValue.Value) Then
			ListsIDs.Add().ListID = KeyAndValue.Value;
			ListsByIDs.Insert(KeyAndValue.Value, KeyAndValue.Key);
		EndIf;
	EndDo;
	
	Query = New Query;
	Query.SetParameter("ForExternalUsers", ForExternalUsers);
	Query.SetParameter("ListsIDs",   ListsIDs);
	Query.Text =
	"SELECT
	|	ListsIDs.ListID AS ListID
	|INTO ListsIDs
	|FROM
	|	&ListsIDs AS ListsIDs
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	ListsIDs.ListID AS ListID
	|FROM
	|	ListsIDs AS ListsIDs
	|WHERE
	|	NOT TRUE IN
	|				(SELECT TOP 1
	|					TRUE
	|				FROM
	|					InformationRegister.DataAccessKeysUpdate AS DataAccessKeysUpdate
	|				WHERE
	|					DataAccessKeysUpdate.List = ListsIDs.ListID
	|					AND DataAccessKeysUpdate.ForExternalUsers = &ForExternalUsers
	|					AND DataAccessKeysUpdate.JobSize = 3)";
	
	Selection = Query.Execute().Select();
	While Selection.Next() Do
		List = ListsByIDs.Get(Selection.ListID);
		ListFieldVersions = ListFieldVersions_SSLs.Get(List);
		BasicVersion = ListFieldVersions[0];
		For Each VersionOfTheListFields In ListFieldVersions Do
			If VersionOfTheListFields = BasicVersion Then
				Continue;
			EndIf;
			If VersionOfTheListFields.Used Then
				VersionOfTheListFields.Used = False;
				Parameters.ListsWithOutdatedAccessOptions.Add(List);
			EndIf;
		EndDo;
	EndDo;
	
EndProcedure

// For the FillParametersForTemplatesForUsersKind procedure.
Procedure AddExistingVersionsOfListFields(CurrentVersionsOfTheListFields, NewVersion,
			DatabaseAccessOptions, Parameters)
	
	AccessOptions = DatabaseAccessOptions.Get(NewVersion.List);
	If Not ValueIsFilled(AccessOptions) Then
		Return;
	EndIf;
	
	CurrentListProperties = Parameters.CurrentListConstraintProperties.Get(NewVersion.List);
	BasicFields = ?(CurrentListProperties = Undefined, Undefined, CurrentListProperties.BasicFields);
	If ValueIsFilled(Parameters.OldCreationDate) And ValueIsFilled(BasicFields) Then
		RequiredAccessOption = BasicFields.UsedItems.Count() * 2
			+ NewVersion.AccessOption - Int(NewVersion.AccessOption / 2) * 2;
	Else
		RequiredAccessOption = NewVersion.AccessOption;
	EndIf;
	
	If AccessOptions.Count() = 1
	   And (Not ValueIsFilled(Parameters.OldCreationDate)
	      Or ValueIsFilled(BasicFields))
	   And (    AccessOptions[0] < 2
	      Or AccessOptions[0] - Int(AccessOptions[0] / 64) * 64 = RequiredAccessOption) Then
		
		// 
		// 
		// 
		If Not ValueIsFilled(Parameters.OldCreationDate) Then
			ConnectionFields = NewVersion.ConnectionFields;
			TemplateFields    = NewVersion.ConnectionFields;
		Else
			ConnectionFields = StrConcat(BasicFields.UsedItems, ",");
			TemplateFields    = StrConcat(BasicFields.All, ",");
		EndIf;
		
		PreviousVersion = NewVersionOfTemplateParameters();
		PreviousVersion.CreationDate   = Parameters.OldCreationDate;
		PreviousVersion.List         = NewVersion.List;
		PreviousVersion.ConnectionFields = ConnectionFields;
		PreviousVersion.TemplateFields    = TemplateFields;
		PreviousVersion.AccessOption = AccessOptions[0];
		
		CurrentVersionsOfTheListFields.Add(PreviousVersion);
	Else
		// 
		// 
		For Each AccessOption In AccessOptions Do
			UnknownVersion = NewVersionOfTemplateParameters();
			UnknownVersion.CreationDate   = Parameters.OldCreationDate;
			UnknownVersion.List         = NewVersion.List;
			UnknownVersion.AccessOption = AccessOption;
			UnknownVersion.Used   = False;
			
			CurrentVersionsOfTheListFields.Add(UnknownVersion);
		EndDo;
	EndIf;
	
EndProcedure

// For the UpdateListFieldsVersionsUsage and AddListRestrictionFields procedures.
Function MaximumNumberOfConnectionOptions()
	
	// 
	Return 3;
	
EndFunction

// For the FillParametersForTemplatesForUsersKind procedure.
Function MaximumNumberOfVersionsInTheAccessOption()
	
	Return 16;
	
EndFunction

// 
// 
// 
//
Function ValueFromStorage(ValueStorage)
	
	Try
		Value = ValueStorage.Get();
	Except
		Value = Undefined;
	EndTry;
	
	Return Value;
	
EndFunction

// For the SetParametersVersion procedure and the StoredAccessRestrictionParameters function.
//
// Returns:
//  FixedStructure:
//    * CacheStructureVersion         - See CacheStructureVersion
//    * ListsRestrictionsVersions    - FixedMap
//    * LeadingLists               - FixedMap
//    * AdditionalContext      - FixedStructure
//    * ListsWithDate                - FixedMap
//    * ExternalUsersEnabled - Boolean
//    * AccessRestrictionEnabled  - Boolean
//    * UsedValuesTypes    - ValueStorage
//
Function StoredWriteParametersStructure(Values)
	
	StoredWriteParameters = NewStoredWriteParametersStructure();
	StoredWriteParameters.CacheStructureVersion = "";
	
	If TypeOf(Values)                             = Type("FixedStructure")
	   And Values.Property("CacheStructureVersion")
	   And TypeOf(Values.CacheStructureVersion)         = Type("String")
	   And Values.Property("ListsRestrictionsVersions")
	   And TypeOf(Values.ListsRestrictionsVersions)    = Type("FixedMap")
	   And Values.Property("LeadingLists")
	   And TypeOf(Values.LeadingLists)               = Type("FixedMap")
	   And Values.Property("AdditionalContext")
	   And TypeOf(Values.AdditionalContext)      = Type("FixedStructure")
	   And Values.Property("ListsWithDate")
	   And TypeOf(Values.ListsWithDate)                = Type("FixedMap")
	   And Values.Property("ExternalUsersEnabled")
	   And TypeOf(Values.ExternalUsersEnabled) = Type("Boolean")
	   And Values.Property("AccessRestrictionEnabled")
	   And TypeOf(Values.AccessRestrictionEnabled)  = Type("Boolean")
	   And Values.Property("UsedValuesTypes")
	   And TypeOf(Values.UsedValuesTypes)    = Type("ValueStorage") Then
		
		FillPropertyValues(StoredWriteParameters, Values);
	EndIf;
	
	Return New FixedStructure(StoredWriteParameters);
	
EndFunction

// For the StoredWriteParametersStructure and StoredAccessRestrictionParameters functions.
//
// Returns:
//  Structure:
//    * CacheStructureVersion         - See CacheStructureVersion
//    * ListsRestrictionsVersions    - Map of KeyAndValue:
//        ** Key     - String - a full list name
//        ** Value - String - the common version of list restriction 
//                               first line — the hash sum of the version properties for users and through Chars.LF
//                               second line — the hash sum of the version properties for external users.
//    
//    * LeadingLists - Map of KeyAndValue:
//        ** Key     - String - a full list name
//        ** Value - See ListPropertiesAsLeadingOne
//    
//    * AdditionalContext - Structure:
//        ** ForUsers        - See NewStoredAdditionalContext
//        ** ForExternalUsers - See NewStoredAdditionalContext
//    
//    * ListsWithDate - Map of KeyAndValue:
//        ** Key     - String - a full list name
//        ** Value - Boolean - True.
//    * ExternalUsersEnabled - Boolean
//    * AccessRestrictionEnabled  - Boolean
//    * UsedValuesTypes    - ValueStorage - see the UsedValuesTypes function.
//
Function NewStoredWriteParametersStructure()
	
	StoredWriteParameters = New Structure;
	StoredWriteParameters.Insert("CacheStructureVersion",         CacheStructureVersion());
	StoredWriteParameters.Insert("ListsRestrictionsVersions",    New Map);
	StoredWriteParameters.Insert("LeadingLists",               New Map);
	StoredWriteParameters.Insert("AdditionalContext",      New Structure);
	StoredWriteParameters.Insert("ListsWithDate",                New Map);
	StoredWriteParameters.Insert("LeadingRoles",                 New Map);
	StoredWriteParameters.Insert("ExternalUsersEnabled", False);
	StoredWriteParameters.Insert("AccessRestrictionEnabled",  False);
	StoredWriteParameters.Insert("UsedValuesTypes",    New ValueStorage(New Map));
	
	Return StoredWriteParameters;
	
EndFunction

// For the SetParametersVersion procedure.
//
// Returns:
//  FixedStructure:
//    * CacheStructureVersion - See CacheStructureVersion
//    * TemplatesVersions      - See AccessRestrictionTemplatesVersions
//    * TemplatesParameters   - See TemplatesParametersStructure
//
Function StoredTemplatesParametersStructure(Values)
	
	StoredTemplatesParameters = NewStoredTemplatesParametersStructure();
	StoredTemplatesParameters.CacheStructureVersion = "";
	
	If TypeOf(Values)                     = Type("FixedStructure")
	   And Values.Property("CacheStructureVersion")
	   And TypeOf(Values.CacheStructureVersion) = Type("String")
	   And Values.Property("TemplatesVersions")
	   And TypeOf(Values.TemplatesVersions)      = Type("String")
	   And Values.Property("TemplatesParameters")
	   And TypeOf(Values.TemplatesParameters)   = Type("FixedStructure") Then
		
		FillPropertyValues(StoredTemplatesParameters, Values);
	EndIf;
	
	Return New FixedStructure(StoredTemplatesParameters);
	
EndFunction

// For the StoredTemplatesParametersStructure, StoredWriteParametersStructure and
// StoredAccessRestrictionParameters functions.
//
// Returns:
//  Structure:
//    * CacheStructureVersion - See CacheStructureVersion
//    * TemplatesVersions      - See AccessRestrictionTemplatesVersions
//    * TemplatesParameters   - See TemplatesParametersStructure
//
Function NewStoredTemplatesParametersStructure()
	
	StoredTemplatesParameters = New Structure;
	StoredTemplatesParameters.Insert("CacheStructureVersion", CacheStructureVersion());
	StoredTemplatesParameters.Insert("TemplatesVersions",      AccessRestrictionTemplatesVersions());
	StoredTemplatesParameters.Insert("TemplatesParameters",   NewTemplatesParametersStructure());
	
	Return StoredTemplatesParameters;
	
EndFunction

// For the SetParametersVersion procedure.
//
// Returns:
//   FixedStructure:
//     * ListsWithAccessGroupsAccessKeysRestriction  - String
//     * ListsWithUsersAccessKeysRestriction - String
//     * ListsWithRestrictionByFields                        - String
//     * ListsWithReadRestrictionDisabled              - String
//
Function TemplatesParametersStructure(Values)
	
	TemplatesParameters = NewTemplatesParametersStructure();
	
	If TypeOf(Values) = Type("FixedStructure")
	   And Values.Count() = TemplatesParameters.Count() Then
		
		Matches = True;
		For Each KeyAndValue In TemplatesParameters Do
			If Not Values.Property(KeyAndValue.Key)
			 Or Not TypeOf(Values[KeyAndValue.Key]) = TypeOf(KeyAndValue.Value) Then
				Matches = False;
				Break;
			EndIf;
		EndDo;
		If Matches Then
			FillPropertyValues(TemplatesParameters, Values);
		EndIf;
	EndIf;
	
	Return New FixedStructure(TemplatesParameters);
	
EndFunction

// For the TemplateParametersStructure, StoredAccessRestrictionParameters and
// NewStoredTemplatesParametersStructure functions.
//
// Returns:
//   Structure:
//     * ListsWithAccessGroupsAccessKeysRestriction  - String
//     * ListsWithUsersAccessKeysRestriction - String
//     * ListsWithRestrictionByFields                        - String
//     * ListsWithReadRestrictionDisabled              - String
//
Function NewTemplatesParametersStructure()
	
	TemplatesParameters = New Structure;
	TemplatesParameters.Insert("ListsWithAccessGroupsAccessKeysRestriction", "");
	TemplatesParameters.Insert("ListsWithUsersAccessKeysRestriction", "");
	TemplatesParameters.Insert("ListsWithRestrictionByFields", "");
	TemplatesParameters.Insert("ListsWithReadRestrictionDisabled", "");
	
	Return TemplatesParameters;
	
EndFunction

// For the SetParametersVersion and FillParametersForTemplates procedures.
//
// Returns:
//   See NewStructureOfStoredVersionsOfTemplateParameters
//
Function StructureOfStoredVersionsOfTemplateParameters(Values)
	
	StoredVersionsOfTemplateParameters = NewStructureOfStoredVersionsOfTemplateParameters();
	StoredVersionsOfTemplateParameters.VersionOfTheVersionStructure = "";
	
	If TypeOf(Values) = Type("Structure")
	   And Values.Property("VersionOfTheVersionStructure")
	   And TypeOf(Values.VersionOfTheVersionStructure) = Type("String")
	   And Values.Property("ForUsers")
	   
	   And TypeOf(Values.ForUsers) = Type("Structure")
	   And Values.ForUsers.Property("TemplatesParametersVersions")
	   And TypeOf(Values.ForUsers.TemplatesParametersVersions) = Type("Map")
	   And Values.ForUsers.Property("BasicAccessOptions")
	   And TypeOf(Values.ForUsers.BasicAccessOptions)  = Type("Map")
	   
	   And Values.Property("ForExternalUsers")
	   And TypeOf(Values.ForExternalUsers) = Type("Structure")
	   And Values.ForExternalUsers.Property("TemplatesParametersVersions")
	   And TypeOf(Values.ForExternalUsers.TemplatesParametersVersions) = Type("Map")
	   And Values.ForExternalUsers.Property("BasicAccessOptions")
	   And TypeOf(Values.ForExternalUsers.BasicAccessOptions)  = Type("Map") Then
		
		FillPropertyValues(StoredVersionsOfTemplateParameters, Values);
	EndIf;
	
	Return StoredVersionsOfTemplateParameters;
	
EndFunction

// For the StoredAccessRestrictionParameters, StoredTemplatesParametersVersionsStructure functions and
// the FillParametersForTemplates procedure.
//
// Returns:
//  Structure:
//    * VersionOfTheVersionStructure - See VersionOfTheTemplateParameterVersionStructure
//    * ForUsers - Structure:
//       ** TemplatesParametersVersions - See TheNewVersionOfTheTemplateParameters
//       ** BasicAccessOptions  - See NewBasicAccessOptions
//    * ForExternalUsers - Structure:
//       ** TemplatesParametersVersions - See TheNewVersionOfTheTemplateParameters
//       ** BasicAccessOptions  - See NewBasicAccessOptions
//
Function NewStructureOfStoredVersionsOfTemplateParameters()
	
	ForUsers = New Structure;
	ForUsers.Insert("TemplatesParametersVersions", TheNewVersionOfTheTemplateParameters());
	ForUsers.Insert("BasicAccessOptions",  NewBasicAccessOptions());
	
	ForExternalUsers = New Structure;
	ForExternalUsers.Insert("TemplatesParametersVersions", TheNewVersionOfTheTemplateParameters());
	ForExternalUsers.Insert("BasicAccessOptions",  NewBasicAccessOptions());
	
	StoredTemplatesParameters = New Structure;
	StoredTemplatesParameters.Insert("VersionOfTheVersionStructure",   VersionOfTheTemplateParameterVersionStructure());
	StoredTemplatesParameters.Insert("ForUsers",        ForUsers);
	StoredTemplatesParameters.Insert("ForExternalUsers", ForExternalUsers);
	
	Return StoredTemplatesParameters;
	
EndFunction

// For the StoredAccessRestrictionParameters and
// NewStoredTemplatesParametersVersionsStructure functions.
//
// Returns:
//   Map of KeyAndValue:
//     * Key  - String - a full register name.
//     * Value - Array of See NewVersionOfTemplateParameters
//
Function TheNewVersionOfTheTemplateParameters()
	
	Return New Map;
	
EndFunction

// For the NewTemplatesParametersVersions function and the SetTemplatesParameters procedure.
//
// Returns:
//  Structure:
//   * CreationDate   - Date   - date and time the new version was added.
//   * List         - String - Full name of a metadata object.
//   * ConnectionFields - String - the list of fields used in join.
//   * TemplateFields    - String - the list of fields specified in the #ForRegister template.
//   * Used   - Boolean - indicates whether the version is used in templates.
//   * AccessOption - Number  - the AccessOption field value in the AccessKeysForRegisters,
//                               AccessKeysToRegister* registers.
//
Function NewVersionOfTemplateParameters()
	
	ParametersVersion = New Structure;
	ParametersVersion.Insert("CreationDate",   '00010101');
	ParametersVersion.Insert("List",         "");
	ParametersVersion.Insert("ConnectionFields", "");
	ParametersVersion.Insert("TemplateFields",    "");
	ParametersVersion.Insert("Used",   True);
	ParametersVersion.Insert("AccessOption", 0);
	
	Return ParametersVersion;
	
EndFunction

// For the NewStoredTemplatesParametersVersionsStructure function.
//
// Returns:
//   Map of KeyAndValue:
//     * Key     - String - a full register name.
//     * Value - Array of See NewAccessOptionUsed
//
Function NewBasicAccessOptions()
	
	Return New Map;
	
EndFunction

// For the FillParametersForTemplatesForUsersKind function.
//
// Returns:
//  Structure:
//    * AccessOption - Number - the AccessOption field value
//                               in the AccessKeysForRegisters, AccessKeysToRegister* registers
//                               starting from the main access option.
//    * ConnectionFields - String - join field names for the access option separated by commas.
//
Function NewAccessOptionUsed()
	
	Return New Structure("AccessOption, ConnectionFields");
	
EndFunction

// For the SetParametersVersion procedure.
//
// Returns:
//   FixedStructure:
//     * CacheStructureVersion - See CacheStructureVersion
//     * TypesRestrictionsPermissionsForUsers        - String
//     * TypesRestrictionsPermissionsForExternalUsers - String
//
Function StoredReportParametersStructure(Values)
	
	ReportParametersToStore = NewStoredReportParametersStructure();
	ReportParametersToStore.CacheStructureVersion = "";
	
	If TypeOf(Values)                        = Type("FixedStructure")
	   And Values.Property("CacheStructureVersion")
	   And TypeOf(Values.CacheStructureVersion)    = Type("String")
	   And Values.Property("TypesRestrictionsPermissionsForUsers")
	   And TypeOf(Values.TypesRestrictionsPermissionsForUsers) = Type("String")
	   And Values.Property("TypesRestrictionsPermissionsForExternalUsers")
	   And TypeOf(Values.TypesRestrictionsPermissionsForExternalUsers) = Type("String") Then
		
		FillPropertyValues(ReportParametersToStore, Values);
	EndIf;
	
	Return New FixedStructure(ReportParametersToStore);
	
EndFunction

// For the StoredReportParametersStructure and StoredAccessRestrictionParameters functions.
//
// Returns:
//   Structure:
//     * CacheStructureVersion    - See CacheStructureVersion
//     * TypesRestrictionsPermissionsForUsers        - String
//     * TypesRestrictionsPermissionsForExternalUsers - String
//
Function NewStoredReportParametersStructure()
	
	ReportParametersToStore = New Structure;
	ReportParametersToStore.Insert("CacheStructureVersion", CacheStructureVersion());
	ReportParametersToStore.Insert("TypesRestrictionsPermissionsForUsers", "");
	ReportParametersToStore.Insert("TypesRestrictionsPermissionsForExternalUsers", "");
	
	Return ReportParametersToStore;
	
EndFunction

// For the StoredAccessRestrictionParameters function.
Function KindsRestrictionsPermissionsString(AccessRestrictionKinds)
	
	List = New ValueList;
	For Each KeyAndValue In AccessRestrictionKinds Do
		List.Add(KeyAndValue.Key);
	EndDo;
	List.SortByValue();
	ConstraintTypesString = StrConcat(List.UnloadValues(), Chars.LF);
	
	Return ConstraintTypesString;
	
EndFunction

#EndRegion

#Region AccessRestrictionParametersForListSeparately

// The main area function, which returns access restriction parameters
// for the list user type, without considering dependencies on other lists
// both by access keys and by presence of the Users and ExternalUsers access kinds.
//
// Returns:
//   Structure:
//     * List                  - String - a full name of the metadata object table.
//     * ForExternalUsers - Boolean - user type, for which the parameters are intended.
//     * Version                  - String - hash of access restriction parameters to track their changes.
//     * LeadingLists           - See NewLeadingLists
//     * AccessDenied          - Boolean - True if the restriction text is "WHERE FALSE",
//                                          and it is also not specified for external users.
//     * RestrictionDisabled    - Boolean - True if the restriction text is not specified or it is specified
//                                          but the restriction is disabled because of disabling the use
//                                          of access kinds involved in it.
//     * RightToWriteRestrictionDisabled - Boolean - True if a reading restriction text is not specified or it is specified
//                                             but the restriction is disabled because of disabling the use
//                                             of access kinds involved in it.
//                                              
//    Owner field, when restriction is possible only by the owner object.
//     * OwnerField - See NewOwnerField
//                                             
//     * RestrictionByOwnerRequired    - Boolean - the optimization flag specified by the developer
//                                                     next to the restriction text.
//     * UsesRestrictionByOwner - Boolean - flag of using optimization
//                                                     calculated on the second pass of the graph.
//     * CalculateUserRights     - Boolean - flag of calculation of rights to access keys for users,
//                                                     not for access groups, calculated on the second pass of the graph.
//                                                     Makes sense only when flag
//                                                     UsesRestrictionByOwner = False.
//     * HasDependantListsWithoutAccessKeysRecords - Boolean - Shows that the leading list must write
//                                                     keys for dependent lists that do not write
//                                                     their own keys.
//     * ReadingAllowedForAllUsers - Boolean - the flag calculated on the second pass of the graph.
//                                                     When HasDependentListsWithoutWriteAccessKeys = True,
//                                                     it indicates that the Read right is available in one of the
//                                                     BasicRights* or BasicExternalUsersRights* roles.
//     * EditionAllowedForAllUsers - Boolean - the flag calculated on the second pass of the graph.
//                                                     When HasDependentListsWithoutWriteAccessKeys = True,
//                                                     it indicates that the Update right is available in one of the
//                                                     BasicRights* or BasicExternalUsersRights* roles.
//     * HasMasterAccessKeys                - Boolean - shows that there are leading access keys in the restriction.
//     * HasHeadRightsLists              - Boolean - shows that there are leading lists by rights in the restriction.
//     * ThereIsAFunctionAccessRightOrRoleAvailable - Boolean - indicates whether there are listed functions in the restriction.
//     * RightsSettingsOwnersTypes        - FixedMap - types of right setting owners used
//                                                     when calculating rights to access keys (see ByRefsTypes). 
//     * RightSettingsTableID  - CatalogRef.MetadataObjectIDs - list
//                                             ID if separate right settings or
//                                             a blank ID are used for it.
//     * HasRightsSettingsOwners         - Boolean - shows if there are restrictions by right settings owner.
//     * UsedAccessValuesTypes   - Array of Type - description of access value types
//                                                           used in access restriction.
//     * AllRightsRestrictionsKinds            - Map - all access restriction kinds not considering usage.
//     * ObjectTablesFields                 - Array of See NewObjectTableFields
//     * SeparateKeysRegisterName       - String - for registers.
//     * BasicFields                       - See NewBasicFieldsDetails
//     * AccessOption                    - Number - the main access option see also NewMainAccessOptions.
//     * FieldsComposition                       - Number  - a number describing attributes used in the key.
//     * HasReadRestriction             - Boolean - it is set if the read restriction differs from "WHERE TRUE".
//     * HasLimitChanges          - Boolean - it is set if the change restriction differs from "WHERE TRUE".
//     * HasUsersRestriction    - Boolean - It is set if User
//                                                 or UsersGroup or ExternalUser
//                                                 or ExternalUsersGroup values are checked for the ValueAllowed
//                                                 or IsAuthorizedUser functions.
//     * ReadRightCalculationStructure       - See RightCalculationStructure
//     * RightCalculationStructureUpdate    - See RightCalculationStructure
//     * Context                          - See ParametersContextByRestrictionStructure
//
Function RestrictionParametersByRestrictionStructure(List, RestrictionStructure,
			ForExternalUsers, CommonContext, AdditionalContext)
	
	LeadingLists = NewLeadingLists();
	
	Result = New Structure;
	Result.Insert("List", List);
	Result.Insert("ForExternalUsers", ForExternalUsers);
	Result.Insert("Version", "");
	Result.Insert("LeadingLists", LeadingLists);
	Result.Insert("AccessDenied", ForExternalUsers);
	Result.Insert("RestrictionDisabled", Not ForExternalUsers);
	Result.Insert("RightToWriteRestrictionDisabled", Not ForExternalUsers);
	Result.Insert("OwnerField");
	Result.Insert("RestrictionByOwnerRequired", False);
	Result.Insert("UsesRestrictionByOwner", False);
	Result.Insert("CalculateUserRights", False);
	Result.Insert("HasDependantListsWithoutAccessKeysRecords", False);
	Result.Insert("ReadingAllowedForAllUsers", False);
	Result.Insert("EditionAllowedForAllUsers", False);
	Result.Insert("HasMasterAccessKeys", False);
	Result.Insert("HasHeadRightsLists", False);
	Result.Insert("ThereIsAFunctionAccessRightOrRoleAvailable", False);
	Result.Insert("RightsSettingsOwnersTypes", CommonContext.RightsSettingsOwnersTypes);
	Result.Insert("RightSettingsTableID", Catalogs.MetadataObjectIDs.EmptyRef());
	Result.Insert("HasRightsSettingsOwners", False);
	Result.Insert("UsedAccessValuesTypes", New Array);
	Result.Insert("AllRightsRestrictionsKinds", New Map);
	Result.Insert("ObjectTablesFields", New Array);
	Result.Insert("SeparateKeysRegisterName", "");
	Result.Insert("BasicFields");
	Result.Insert("AccessOption");
	Result.Insert("FieldsComposition");
	Result.Insert("HasReadRestriction", False);
	Result.Insert("HasLimitChanges", False);
	Result.Insert("HasUsersRestriction", False);
	Result.Insert("ReadRightCalculationStructure",    RightCalculationStructure());
	Result.Insert("RightCalculationStructureUpdate", RightCalculationStructure());
	
	TypeCollectionName = "";
	Result.Insert("IsReferenceType", ?(ValueIsFilled(List),
		IsReferenceTableType(List, TypeCollectionName), False));
	
	Result.Insert("ListWithDate",
		    TypeCollectionName = "Documents"
		Or TypeCollectionName = "BusinessProcesses"
		Or TypeCollectionName = "Tasks");
	
	If TypeCollectionName = "InformationRegisters" Then
		RegisterMetadata = Metadata.InformationRegisters.Find(StrSplit(List, ".")[1]);
		Result.Insert("ListWithPeriod", ?(RegisterMetadata = Undefined, False,
			RegisterMetadata.InformationRegisterPeriodicity
				<> Metadata.ObjectProperties.InformationRegisterPeriodicity.Nonperiodical));
	Else
		Result.Insert("ListWithPeriod",
			    TypeCollectionName = "AccumulationRegisters"
			Or TypeCollectionName = "AccountingRegisters"
			Or TypeCollectionName = "CalculationRegisters");
	EndIf;
	
	Context = ParametersContextByRestrictionStructure();
	Context.Insert("VersionPropertiesString", "");
	Result.Insert("Context", Context);
	
	For Each KeyAndValue In CommonContext Do
		Context.Insert(KeyAndValue.Key, KeyAndValue.Value);
	EndDo;
	For Each KeyAndValue In AdditionalContext Do
		Context.Insert(KeyAndValue.Key, KeyAndValue.Value);
	EndDo;
	
	Context.Insert("List",                  List);
	Context.Insert("ForExternalUsers", ForExternalUsers);
	Context.Insert("IsReferenceType",         Result.IsReferenceType);
	Context.Insert("ListWithDate",            Result.ListWithDate);
	Context.Insert("ListWithPeriod",         Result.ListWithPeriod);
	Context.Insert("TypeCollectionName",        TypeCollectionName);
	Context.Insert("VersionProperties",          New Array);
	Context.Insert("LeadingRoles",             New Map);
	
	AddVersionProperty(Context, Context, "List");
	AddVersionProperty(Context, Context, "ForExternalUsers");
	
	RestrictionDetails = Context.RestrictionsDetails1.Get(Context.List);
	If RestrictionDetails = Undefined Then
		RestrictionDetails = New Structure("Text", "");
	EndIf;
	AddVersionProperty(Context, RestrictionDetails, "Text");
	
	AddVersionProperty(Context, Context, "IsReferenceType");
	AddVersionProperty(Context, Context, "ListWithDate");
	
	// 
	Context.Insert("ObjectTablesFields", NewObjectTablesFieldsDescription(Result));
	
	// Basic fields are not required for reference data types (always Ref).
	FillNewBasicFieldsDetails(Result, Context);
	
	Context.Insert("WithoutMetadataObject", False);
	
	If Context.ListsWithKeysRecordForDependentListsWithoutKeys <> Undefined Then
		Properties = ListRestrictionProperties(Context.List, Context);
		Result.CalculateUserRights     = Properties.CalculateUserRights;
		Result.UsesRestrictionByOwner = Properties.OwnerField <> Undefined
			And Not Properties.OwnerField.Disabled;
		If Context.ListsWithKeysRecordForDependentListsWithoutKeys.Get(List) <> Undefined Then
			Result.HasDependantListsWithoutAccessKeysRecords = True;
			MetadataObject = Common.MetadataObjectByFullName(List);
			Context.WithoutMetadataObject = MetadataObject = Undefined;
			Result.ReadingAllowedForAllUsers =
				RightAllowedForAllUsers("Read",    MetadataObject, ForExternalUsers);
			Result.EditionAllowedForAllUsers =
				RightAllowedForAllUsers("Update", MetadataObject, ForExternalUsers);
		EndIf;
	EndIf;
	Context.Insert("UsesRestrictionByOwner",        Result.UsesRestrictionByOwner);
	Context.Insert("CalculateUserRights",            Result.CalculateUserRights);
	Context.Insert("HasDependantListsWithoutAccessKeysRecords", Result.HasDependantListsWithoutAccessKeysRecords);
	Context.Insert("ReadingAllowedForAllUsers",       Result.ReadingAllowedForAllUsers);
	Context.Insert("EditionAllowedForAllUsers",    Result.EditionAllowedForAllUsers);
	
	If RestrictionStructure = Undefined Then
		If Not Result.HasDependantListsWithoutAccessKeysRecords
		 Or Result.AccessDenied
		 Or Context.WithoutMetadataObject Then
			Return Result;
		EndIf;
		RestrictionStructure = CalculatedRestrictionStructure(List,
			"AllowReadUpdate WHERE TRUE", True, ForExternalUsers);
	EndIf;
	
	Context.Insert("RestrictionStructure",                    RestrictionStructure);
	Context.Insert("LeadingListsByFieldsValues",           LeadingListsDetailsByFieldsValues());
	Context.Insert("LeadingListsByAccessKeys",            LeadingListsDetailsByFieldsRef());
	Context.Insert("LeadingListsByValuesWithGroups",       LeadingListsDetailsByFieldsRef());
	Context.Insert("HasAuthorizedUserCheck", False);
	Context.Insert("UnusedAccessValueTypes",       New Array);
	Context.Insert("AllRightsRestrictionsKinds",                  Result.AllRightsRestrictionsKinds);
	
	If Not Context.IsReferenceType Then
		Result.SeparateKeysRegisterName = Context.SeparateKeysRegisterName;
	EndIf;
	
	FillHasRestrictionByRights(Context, Result, False);
	FillInTheRestrictionOnTheObjectOwnerBeforeSimplifying(Result, Context);
	
	FillFieldProperties(Context);
	
	Result.ThereIsAFunctionAccessRightOrRoleAvailable = Context.ThereIsAFunctionAccessRightOrRoleAvailable;
	
	If ForExternalUsers And Not CommonContext.ExternalUsersEnabled
	 Or ThisIsAnAbsoluteRestriction(Context, Result) Then
		
		Result.AccessDenied = True;
		Result.Version = "  ";
		Return Result;
	EndIf;
	
	Result.AccessDenied = False;
	Result.RestrictionDisabled = True;
	Result.RightToWriteRestrictionDisabled = True;
	
	FillHasRestrictionByRights(Context, Result, True);
	FillInTheRestrictionOnTheObjectOwnerAfterSimplification(Result, Context);
	FillHasLeadingKeysAndListsAndRightsSettingsOwners(Result, Context);
	DeleteNotUsedAccessKindsFields(Result, Context);
	FillHasRestrictionByUsersAccessKind(Result, Context);
	FillHasReadRestriction(Result, Context);
	
	Context.Insert("HasUsersRestriction", Result.HasUsersRestriction);
	
	If Context.ListsWithKeysRecordForDependentListsWithoutKeys = Undefined Then
		Result.CalculateUserRights     = Result.HasUsersRestriction;
		Result.UsesRestrictionByOwner = Result.OwnerField <> Undefined
			And Not Result.OwnerField.Disabled;
		
		Context.Insert("UsesRestrictionByOwner", Result.UsesRestrictionByOwner);
		Context.Insert("CalculateUserRights",     Result.CalculateUserRights);
	EndIf;
	AddVersionProperty(Context, Context, "UsesRestrictionByOwner");
	AddVersionProperty(Context, Context, "CalculateUserRights");
	AddVersionProperty(Context, Context, "HasDependantListsWithoutAccessKeysRecords");
	AddVersionProperty(Context, Context, "ReadingAllowedForAllUsers");
	AddVersionProperty(Context, Context, "EditionAllowedForAllUsers");
	
	Context.Insert("FieldsGroups");
	Context.Insert("ObjectTabularSectionsAliases");
	Context.Insert("AdditionalTablesGroups");
	Context.Insert("KeyTabularSectionsCount");
	
	FillFieldsAndAdditionalTablesGroups(Context);
	
	Result.FieldsComposition = Context.FieldsComposition;
	
	If Result.Context.FieldsProperties.Count() = 0
	   And (Not Result.IsReferenceType
	      Or Not Result.ThereIsAFunctionAccessRightOrRoleAvailable) Then // 
		
		If Result.HasDependantListsWithoutAccessKeysRecords Then
			ConfigureCreationOfAccessKeyForDependentListsWithoutKeys(Result);
			Result.Version = "   ";
		Else
			Result.Version = " ";
		EndIf;
		Return Result;
	EndIf;
	
	Result.RestrictionDisabled = False;
	
	Context.Insert("NameOfRight", "Read");
	FillRightCalculationStructure(Result.ReadRightCalculationStructure,
		Context.RestrictionStructure.ReadRestriction, Context);
	
	Context.Insert("NameOfRight", "Update");
	FillRightCalculationStructure(Result.RightCalculationStructureUpdate,
		Context.RestrictionStructure.UpdateRestriction, Context);
	
	Context.Delete("NameOfRight");
	AddTheVersionPropertyLeadingRoles(Context);
	
	If Result.UsesRestrictionByOwner Then
		Context.LeadingListsByFieldsValues = LeadingListsDetailsByFieldsValues();
	EndIf;
	LeadingLists.ByFieldsValues     = Context.LeadingListsByFieldsValues.Fields;
	LeadingLists.ByAccessKeys      = Context.LeadingListsByAccessKeys.Lists;
	LeadingLists.ByValuesWithGroups = Context.LeadingListsByValuesWithGroups.Lists;
	
	DataHashing = New DataHashing(HashFunction.SHA256);
	VersionPropertiesString = StrConcat(Context.VersionProperties, Chars.LF);
	Context.VersionPropertiesString = VersionPropertiesString;
	DataHashing.Append(VersionPropertiesString);
	Result.Version = Base64String(DataHashing.HashSum);
	
	Return Result;
	
EndFunction

// Lists with fields, on which access restriction depends.
//
// Returns:
//   Structure:
//     * ByFieldsValues     - Map - lists with fields, on which access restriction depends
//                                             (for registering update jobs).
//     * ByAccessKeys      - Map - lists, on whose access keys access restriction depends
//                                             (for setting session parameters and registering update jobs).
//     * ByValuesWithGroups - Map - lists of access values with groups, on which
//                                             access restriction depends (for registering update jobs).
//
Function NewLeadingLists()
	
	LeadingLists = New Structure;
	LeadingLists.Insert("ByFieldsValues",     New Map);
	LeadingLists.Insert("ByAccessKeys",      New Map);
	LeadingLists.Insert("ByValuesWithGroups", New Map);
	
	Return LeadingLists;
	
EndFunction

// Returns:
//   Structure:
//     * VersionPropertiesString     - String
//     * List                  - String
//     * ForExternalUsers - Boolean
//     * IsReferenceType         - Boolean
//     * ListWithDate            - Boolean
//     * ListWithPeriod         - Boolean
//     * TypeCollectionName        - String
//     * VersionProperties          - Array of String
//     * ObjectTablesFields       - See NewObjectTablesFieldsDescription
//     * BasicFields             - See NewBasicFieldsDetails
//     * AccessOption          - Number - the main access option see also NewMainAccessOptions.
//     * UsesRestrictionByOwner        - Boolean
//     * CalculateUserRights            - Boolean
//     * HasDependantListsWithoutAccessKeysRecords - Boolean
//     * ReadingAllowedForAllUsers       - Boolean
//     * EditionAllowedForAllUsers    - Boolean
//     * WithoutMetadataObject                      - Boolean
//     * RestrictionStructure                      - See RestrictionStructure
//     * InitialRestrictionStructure              - See RestrictionStructure
//     * LeadingListsByFieldsValues             - See LeadingListsDetailsByFieldsValues
//     * LeadingListsByAccessKeys              - See LeadingListsDetailsByFieldsRef
//     * LeadingListsByValuesWithGroups         - See LeadingListsDetailsByFieldsRef
//     * HasAuthorizedUserCheck   - Boolean
//     * ThereIsAFunctionAccessRightOrRoleAvailable    - Boolean
//     * IsThereFunctionAccessRightOrRoleAvailableInReadRestriction - Boolean
//     * UnusedAccessValueTypes         - Array of Type
//     * AllRightsRestrictionsKinds                    - Map
//     * HasUsersRestriction            - Boolean
//     * UsesRestrictionByOwner        - Boolean
//     * CalculateUserRights            - Boolean
//     * AllFieldsProperties - Map of KeyAndValue:
//         ** Key     - See NodeDetails
//         ** Value - See FieldProperties
//     * RemainingFieldsAfterSimplify - Map of KeyAndValue:
//         ** Key     - See NodeDetails
//         ** Value - Array of See NodeDetails
//     * AccessKeyFieldsAfterSimplify - Array of See NewAccessKeyField
//     * AccessKeyFieldsProperties - Map of KeyAndValue:
//         ** Key     - See NodeDetails
//         ** Value - See FieldProperties
//     * FieldsGroups - Map of KeyAndValue:
//         ** Key     - String - a field group name (Header?, TabularSection?)
//         ** Value - Array of See FieldProperties
//     * ObjectTabularSectionsAliases - Map of KeyAndValue:
//         ** Key     - Number  - the number of a tabular key part
//         ** Value - String - a table alias
//     * AdditionalTablesGroups - See AdditionalTablesGroups
//     * KeyTabularSectionsCount - Number
//     * AdditionalTablesMergeConditionsFields - Array of Structure:
//         ** FieldNode - See NodeDetails
//         ** ConditionTableAlias - String
//     * NameOfRight - String
//     * RequiredKeyTabularSectionsAttributes - Map of KeyAndValue:
//         ** Key     - String - a key table name (AccessKeyFieldsGroupName)
//         ** Value - Array of String - a key table attribute name (AccessKeyFieldsGroupAttributeName)
//     * VersionPropertiesRightCalculationStructure - Array of String
//     * LeadingRoles - Map of KeyAndValue:
//         ** Key     - String - a role name
//         ** Value - Boolean - Set to True.
//     
//   Properties copied from CommonContext:
//     * AccessKindsProperties         - See AccessKindsProperties
//     * UserTypes             - Array of Type
//     * RightsSettingsOwnersTypes   - FixedMap
//     * SeparateRightsSettingsTables - FixedMap
//     * UsedValuesTypes     - See UsedValuesTypes
//     * ListsWithRestriction          - See AccessManagementInternalCached.ListsWithRestriction
//     * ExternalUsersEnabled  - Boolean
//      
//   Properties copied from AdditionalContext:
//     * RestrictionsDetails1 - Map of KeyAndValue:
//         ** Key     - String - a full list name
//         ** Value - See BriefRestrictionDetails
//     * ListRestrictionsProperties - Map of KeyAndValue:
//         ** Key     - String - a full list name
//         ** Value - See NewListRestrictionProperties
//     * ListsWithRestrictionByOwner - Map of KeyAndValue:
//         ** Key     - String - a full list name
//         ** Value - Boolean - the ByOwner value, except for Undefined.
//     * ListsWithDisabledRestriction - Map of KeyAndValue:
//         ** Key     - String - a full list name
//         ** Value - Boolean - True.
//     * ListsWithReadRestrictionDisabled - Map of KeyAndValue:
//         ** Key     - String - a full list name
//         ** Value - Boolean - True.
//     * ListsWithKeysRecordForDependentListsWithoutKeys - Map of KeyAndValue:
//         ** Key     - String - a full list name
//         ** Value - Boolean - True.
//
Function ParametersContextByRestrictionStructure()
	
	Return New Structure;
	
EndFunction

// A restriction structure adjusted to the format of placing values in access keys.
//
// Returns:
//   Structure:
//     * Node - String -
//         
//         
//         
//         
//
//    
//     * Table   - String - an access key table (Header?, TabularSection?).
//     * Attribute  - String - the name of the access key table attribute (Attribute?).
//     * CheckHasNull - Boolean - True (an optional property).
//
//    The Constant node properties.
//     * Value - Boolean
//                - Number
//                - String
//                - Undefined - 
//                     
//
//    
//     * Arguments - Array of See RightCalculationStructure
//
//    Properties of the Not node.
//     * Argument - See RightCalculationStructure
//
//     * Node - String -
//
//    
//     * Else - See RightCalculationStructure
//     * When - Array of Structure:
//         ** Condition  - See RightCalculationStructure
//         ** Value - See RightCalculationStructure
//      
//     * Node - String - stub to the previous line (for defining the type in EDT)
//     
//    Node properties value Resolved, this is an authorized User,
//                   Changeobjectstate, Essentiallyidentical,
//                   Readespiscare Resolved, Changeespiscare Resolved.
//     * Field - See RightCalculationStructure
//     * ComparisonClarifications - Map of KeyAndValue:
//         ** Key     - String
//                     - Type - 
//                             
//         ** Value - String - result "False", "True".
//
//    Properties of the ForAllLines, ForOneOfLines nodes.
//     * Argument - See RightCalculationStructure
//
Function RightCalculationStructure()
	
	Return New Structure;
	
EndFunction

// For the RestrictionParametersByRestrictionStructure procedure.
Procedure ConfigureCreationOfAccessKeyForDependentListsWithoutKeys(Result)
	
	If Not Result.IsReferenceType Then
		Return;
	EndIf;
	
	If Result.FieldsComposition <> 0 Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Field %2 was calculated incorrectly for list %1.
				|Value %3 is specified, 0 was expected.';"),
			Result.List, "FieldsComposition", Format(Result.FieldsComposition, "NZ=0; NG="));
		Raise ErrorText;
	EndIf;
	
	Result.HasReadRestriction = True;
	Result.HasLimitChanges = True;
	
	Result.ThereIsAFunctionAccessRightOrRoleAvailable = True;
	
	ReadRightCalculationStructure = New Structure;
	ReadRightCalculationStructure.Insert("Node", "AccessRight");
	ReadRightCalculationStructure.Insert("NameOfRight", "Read");
	ReadRightCalculationStructure.Insert("FullMetadataObjectName", Result.List);
	ReadRightCalculationStructure.Insert("RequiredKeyTabularSectionsAttributes", New Map);
	Result.ReadRightCalculationStructure = ReadRightCalculationStructure;
	
	RightCalculationStructureUpdate = New Structure;
	RightCalculationStructureUpdate.Insert("Node", "AccessRight");
	RightCalculationStructureUpdate.Insert("NameOfRight", "Update");
	RightCalculationStructureUpdate.Insert("FullMetadataObjectName", Result.List);
	RightCalculationStructureUpdate.Insert("RequiredKeyTabularSectionsAttributes", New Map);
	Result.RightCalculationStructureUpdate = RightCalculationStructureUpdate;
	
EndProcedure

// For the RestrictionParametersByRestrictionStructure procedure.
Function RightAllowedForAllUsers(NameOfRight, MetadataObject, ForExternalUsers)
	
	If MetadataObject = Undefined Then
		Return False;
	EndIf;
	
	RolesNamesBasicAccess = AccessManagementInternalCached.RolesNamesBasicAccess(ForExternalUsers);
	RoleMetadata = Metadata.Roles;
	
	For Each NameOfRole In RolesNamesBasicAccess Do
		If AccessRight(NameOfRight, MetadataObject, RoleMetadata[NameOfRole]) Then
			Return True;
		EndIf;
	EndDo;
	
	Return False;
	
EndFunction

// For the RestrictionParametersByRestrictionStructure procedure.
Procedure AddTheVersionPropertyLeadingRoles(Context)
	
	If Not ValueIsFilled(Context.LeadingRoles) Then
		Return;
	EndIf;
	
	ValueList = New ValueList;
	For Each KeyAndValue In Context.LeadingRoles Do
		ValueList.Add(KeyAndValue.Key);
	EndDo;
	ValueList.SortByPresentation();
	
	AddVersionItem(Context, "LeadingRoles", ValueList.UnloadValues());
	
EndProcedure

// For the DeleteNotUsedAccessKindsFields procedure and AdditionalTablesGroups function.
Procedure AddVersionProperties(Context, Structure, FieldsNames = "")
	
	If ValueIsFilled(FieldsNames) Then
		StructureToSave = New Structure(FieldsNames);
		FillPropertyValues(StructureToSave, Structure);
	Else
		StructureToSave = Structure;
	EndIf;
	
	ValueList = New ValueList;
	For Each KeyAndValue In StructureToSave Do
		ValueList.Add(KeyAndValue.Value, KeyAndValue.Key)
	EndDo;
	ValueList.SortByPresentation();
	
	For Each ListItem In ValueList Do
		AddVersionItem(Context, ListItem.Presentation, ListItem.Value);
	EndDo;
	
EndProcedure

// For the RestrictionParametersByRestrictionStructure procedure.
Procedure AddVersionProperty(Context, Structure, FieldName)
	
	AddVersionItem(Context, FieldName, Structure[FieldName]);
	
EndProcedure

// For the AddVersionProperties and AddVersionProperty procedures.
Procedure AddVersionItem(Context, FieldName, Value)
	
	If TypeOf(Value) = Type("String") Then
		Context.VersionProperties.Add(FieldName + " = " + Value);
		
	ElsIf TypeOf(Value) = Type("Number") Then
		
		Context.VersionProperties.Add(FieldName + " = " + Format(Value, "NG="));
		
	ElsIf TypeOf(Value) = Type("Boolean") Then
		
		Context.VersionProperties.Add(FieldName + " = " + ?(Value, "Yes", "None"));
		
	ElsIf TypeOf(Value) = Type("Undefined") Then
		
		Context.VersionProperties.Add(FieldName + " = " + "Undefined");
		
	ElsIf TypeOf(Value) = Type("FixedArray") Then
		Context.VersionProperties.Add(FieldName + " = " + DataStringForHashing(New Array(Value)));
		
	ElsIf TypeOf(Value) = Type("TypeDescription")
	      Or TypeOf(Value) = Type("Array") Then
		
		Context.VersionProperties.Add(FieldName + " = " + DataStringForHashing(Value));
	Else
		ErrorText = NStr("en = 'The access restriction version''s data type is invalid.';");
		Raise ErrorText;
	EndIf;
	
EndProcedure

// For the RestrictionParametersByRestrictionStructure function and the AccessUpdateManualControl form.
//
// Returns:
//  Boolean
//
Function IsReferenceTableType(FullName, TypeCollectionName = "") Export
	
	LanguageSyntax = AccessManagementInternalCached.LanguageSyntax();
	NameContent = StrSplit(FullName, ".", False);
	
	TableType = LanguageSyntax.TablesTypes.ByNames.Get(Upper(NameContent[0]));
	If TableType = Undefined Then
		Return False;
	EndIf;
	
	TypeCollectionName = TableType.CollectionName;
	
	Return TableType.IsReferenceType;
	
EndFunction

// Returns:
//  Structure:
//    * FullTableName - String
//    * TabularSection   - String
//    * Fields             - Array of String - with the Reference field.
//    * FieldList      - String - without the Reference field.
//    * TableWithFields   - ValueStorage - with the ValueTable object
//                          with the typed fields (including the Reference field).
//
Function NewObjectTableFields()
	
	TableFields = New Structure;
	TableFields.Insert("FullTableName", "");
	TableFields.Insert("TabularSection", "");
	TableFields.Insert("Fields", New Array);
	TableFields.Insert("FieldList", "");
	TableFields.Insert("TableWithFields", New ValueStorage(New ValueTable));
	
	Return TableFields;
	
EndFunction

// Returns:
//  Structure:
//    * Result - Array of See NewObjectTableFields
//    * Content - Structure:
//        ** Key - String - a full name of an object table.
//        ** Value - Structure:
//             *** Key - String - Field name.
//             *** Value - Structure:
//                   **** Type - TypeDescription - field types.
//                   **** Use - Boolean - the field use.
//    * ByFIeldProperties - Map of KeyAndValue:
//        ** Key     - See NewFieldProperties
//        ** Value - Structure:
//             *** Table - String - a full name of an object table.
//             *** Field    - String - Field name.
//    * ByAdditionalTables - Map of KeyAndValue:
//        ** Key     - String - an additional table
//        ** Value - Structure:
//             *** Key - String - a full name of an object table.
//             *** Value - Array of String - Field name.
//
Function NewObjectTablesFieldsDescription(Result)
	
	Return New Structure("Result, Content", Result.ObjectTablesFields, New Structure);
	
EndFunction

// For the RestrictionParametersByRestrictionStructure function.
//
// Parameters:
//  Result - See RestrictionParametersByRestrictionStructure
//  Context  - See ParametersContextByRestrictionStructure
//
Procedure FillNewBasicFieldsDetails(Result, Context)
	
	BasicFields = NewBasicFieldsDetails();
	Context.Insert("BasicFields", BasicFields);
	Context.Insert("AccessOption", Undefined);
	
	If Context.IsReferenceType Then
		Return;
	EndIf;
	
	If Context.Property("BasicAccessOptions") Then
		AccessOptionsUsed = Context.BasicAccessOptions.Get(Context.List);
		If AccessOptionsUsed <> Undefined Then
			Result.AccessOption = AccessOptionsUsed[0].AccessOption;
		EndIf;
		Context.Insert("AccessOption", Result.AccessOption);
	EndIf;
	
	If StrSplit(Context.List, ".").Count() > 1 Then
		SeparateKeysRegisterName = "AccessKeysToRegister" + StrSplit(Context.List, ".")[1];
		If Metadata.InformationRegisters.Find(SeparateKeysRegisterName) = Undefined Then
			SeparateKeysRegisterName = "";
		EndIf;
	Else
		SeparateKeysRegisterName = "";
	EndIf;
	Context.Insert("SeparateKeysRegisterName", SeparateKeysRegisterName);
	
	BasicFields.MaxCount =
		AccessManagementInternalCached.BasicRegisterFieldsCount(SeparateKeysRegisterName);
	
	BasicFields.MaxQuantity =
		AccessManagementInternalCached.MaxBasicRegisterFieldsCount();
	
	If BasicFields.MaxCount > BasicFields.MaxQuantity Then
		// Increasing the quantity of basic fields in a separate register.
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'The number of basic fields in the %1 information register
			           |exceeds the limit: %2.';"),
			?(SeparateKeysRegisterName = "", "AccessKeysForRegisters", SeparateKeysRegisterName),
			BasicFields.MaxQuantity);
		
		If Context.Property("ErrorOnCallException") Then
			Context.ErrorOnCallException.Text = ErrorText;
		EndIf;
		Raise ErrorText;
	EndIf;
	
	AddVersionProperty(Context, BasicFields, "MaxCount");
	
	Result.BasicFields = New Structure("All, AllItemsTypes, UsedItems, UsedItemsTypes,
	|MaxCount, MaxQuantity");
	FillPropertyValues(Result.BasicFields, Context.BasicFields);
	
EndProcedure

// Returns:
//  Structure:
//    * List                          - ValueList
//    * All                             - Array
//    * AllItemsTypes                        - Array of ValueStorage -
//    * UsedItems                    - Array
//    * UsedItemsTypes                - Array of ValueStorage -
//    * MaxCount          - Number
//    * MaxQuantity - Number
//    * TypesByFieldNames - Map of KeyAndValue:
//        ** Key     - String - the basic field name
//        ** Value - TypeDescription - the basic field types
//    * ByFIeldProperties - Map of KeyAndValue:
//        ** Key     - See NewFieldProperties
//        ** Value - String - the basic field name
//    * ByAdditionalTables - Map of KeyAndValue:
//        ** Key     - String - an additional table
//        ** Value - Array of String - basic field names
//
Function NewBasicFieldsDetails()
	
	BasicFields = New Structure;
	BasicFields.Insert("List",           New ValueList);
	BasicFields.Insert("All",              New Array);
	BasicFields.Insert("AllItemsTypes",         New Array);
	BasicFields.Insert("UsedItems",     New Array);
	BasicFields.Insert("UsedItemsTypes", New Array);
	BasicFields.Insert("MaxCount", 0);
	BasicFields.Insert("MaxQuantity", 0);
	
	Return BasicFields;
	
EndFunction

// For the AccessRestrictionParameters function.
//
// Parameters:
//  Context  - See ParametersContextByRestrictionStructure
//  Result - See RestrictionParametersByRestrictionStructure
//
Function ThisIsAnAbsoluteRestriction(Context, Result)
	
	RestrictionStructure = Context.RestrictionStructure;
	
	Return ValueIsFilled(RestrictionStructure.ReadRestriction)
		And RestrictionStructure.ReadRestriction.Node = "Constant"
		And RestrictionStructure.ReadRestriction.Value = False;
	
EndFunction

// For the AccessRestrictionParameters function.
//
// Parameters:
//  Context  - See ParametersContextByRestrictionStructure
//  Result - See RestrictionParametersByRestrictionStructure
//
Procedure FillHasRestrictionByRights(Context, Result, AfterSimplification)
	
	RestrictionStructure = Context.RestrictionStructure;
	
	Result.HasReadRestriction =
		ValueIsFilled(RestrictionStructure.ReadRestriction)
		And (    RestrictionStructure.ReadRestriction.Node <> "Constant"
		   Or RestrictionStructure.ReadRestriction.Value <> True);
	
	Result.HasLimitChanges =
		ValueIsFilled(RestrictionStructure.UpdateRestriction)
		And (    RestrictionStructure.UpdateRestriction.Node <> "Constant"
		   Or RestrictionStructure.UpdateRestriction.Value <> True);
	
	If AfterSimplification Then
		AddVersionProperty(Context, Result, "HasReadRestriction");
		AddVersionProperty(Context, Result, "HasLimitChanges");
	EndIf;
	
EndProcedure

// For the AccessRestrictionParameters function.
//
// Parameters:
//  Result - See RestrictionParametersByRestrictionStructure
//  Context  - See ParametersContextByRestrictionStructure
//
Procedure FillInTheRestrictionOnTheObjectOwnerBeforeSimplifying(Result, Context)
	
	CustomizingByOwner = Context.ListsWithRestrictionByOwner.Get(Context.List);
	OwnerField = NewOwnerField();
	
	RestrictionByOwnerRequired = False;
	If TypeOf(CustomizingByOwner) = Type("Boolean") Then
		RestrictionByOwnerRequired = CustomizingByOwner;
	EndIf;
	Result.RestrictionByOwnerRequired = RestrictionByOwnerRequired;
	
	ReadRestriction    = Context.RestrictionStructure.ReadRestriction;
	UpdateRestriction = Context.RestrictionStructure.UpdateRestriction;
	
	OptimizationFlagName = ?(Context.ForExternalUsers,
		"ByOwnerWithoutSavingAccessKeysForExternalUsers", "ByOwnerWithoutSavingAccessKeys");
	
	If Result.HasReadRestriction Then
		
		If RestrictionByOwnerRequired Or Not Context.IsReferenceType Then
			If ReadRestriction.Node <> "ObjectReadingAllowed" Then
				If Not RestrictionByOwnerRequired Then
					Return;
				EndIf;
				If ValueIsFilled(UpdateRestriction) Then
					ErrorTemplate =
						NStr("en = 'The optimization option %1 is set
						           |but the specified read and update restriction is applied outside of the function ""%2"".';");
				Else
					ErrorTemplate =
						NStr("en = 'The optimization option %1 is set
						           |but the specified read restriction is applied outside of the function ""%2"".';");
				EndIf;
				ErrorText = StringFunctionsClientServer.SubstituteParametersToString(ErrorTemplate,
					OptimizationFlagName, "ObjectReadingAllowed");
				ErrorText = ErrorTextWithTitle(ErrorText, Context);
				If Context.Property("ErrorOnCallException") Then
					Context.ErrorOnCallException.Text = ErrorText;
				EndIf;
				Raise ErrorText;
			EndIf;
		Else
			ReadRestriction = PossibleRestrictionOnTheObjectOwner(ReadRestriction, False, Context);
			If ReadRestriction = Undefined Then
				Return;
			EndIf;
		EndIf;
		If ValueIsFilled(ReadRestriction) Then
			If Not FunctionWithoutClarificationOfTypesWithFieldWithoutAttachments(ReadRestriction) Then
				If RestrictionByOwnerRequired Then
					ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
						NStr("en = 'The optimization option %1 is set
						           |but the owner field is not the only parameter of the %2 function
						           |.';"),
						OptimizationFlagName,
						"ObjectReadingAllowed");
					ErrorText = ErrorTextWithTitle(ErrorText, Context);
					If Context.Property("ErrorOnCallException") Then
						Context.ErrorOnCallException.Text = ErrorText;
					EndIf;
					Raise ErrorText;
				Else
					Return;
				EndIf;
			EndIf;
			ReadRestrictionField = ReadRestriction.Field; // See NodeDetails
			OwnerField.Name = ReadRestrictionField.Name;
		EndIf;
	EndIf;
	
	If Result.HasLimitChanges Then
		
		If RestrictionByOwnerRequired Or Not Context.IsReferenceType Then
			
			If UpdateRestriction.Node <> "ObjectReadingAllowed"
			   And UpdateRestriction.Node <> "ObjectUpdateAllowed" Then
				
				If Not RestrictionByOwnerRequired Then
					Return;
				EndIf;
				ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("en = 'The optimization option ""%1"" is set
					           |but the specified update restriction is applied outside of the
					           |""%2"" or ""%3"" function.';"),
					OptimizationFlagName, "ObjectReadingAllowed", "ObjectUpdateAllowed");
				ErrorText = ErrorTextWithTitle(ErrorText, Context);
				If Context.Property("ErrorOnCallException") Then
					Context.ErrorOnCallException.Text = ErrorText;
				EndIf;
				Raise ErrorText;
			EndIf;
		Else
			UpdateRestriction = PossibleRestrictionOnTheObjectOwner(UpdateRestriction, True, Context);
			If UpdateRestriction = Undefined Then
				Return;
			EndIf;
		EndIf;
		If ValueIsFilled(UpdateRestriction) Then
			If Not FunctionWithoutClarificationOfTypesWithFieldWithoutAttachments(UpdateRestriction) Then
				If RestrictionByOwnerRequired Then
					ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
						NStr("en = 'The optimization option %1 is set
						           |but the owner field is not the only parameter of the %2 function
						           |.';"),
						OptimizationFlagName,
						UpdateRestriction.Node);
					ErrorText = ErrorTextWithTitle(ErrorText, Context);
					If Context.Property("ErrorOnCallException") Then
						Context.ErrorOnCallException.Text = ErrorText;
					EndIf;
					Raise ErrorText;
				Else
					Return;
				EndIf;
			EndIf;
			UpdateRestrictionField = UpdateRestriction.Field; // See NodeDetails
			
			If OwnerField.Name = "" Then
				OwnerField.Name = UpdateRestrictionField.Name;
				
			ElsIf OwnerField.Name <> UpdateRestrictionField.Name Then
				If RestrictionByOwnerRequired Then
					ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
						NStr("en = 'The optimization option %1 is set
						           |but the owner field value is not the same in the read and update restrictions.';"),
						OptimizationFlagName,
						UpdateRestriction.Node);
					ErrorText = ErrorTextWithTitle(ErrorText, Context);
					If Context.Property("ErrorOnCallException") Then
						Context.ErrorOnCallException.Text = ErrorText;
					EndIf;
					Raise ErrorText;
				Else
					Return;
				EndIf;
			EndIf;
			OwnerField.EditAsRead =
				UpdateRestriction.Node <> "ObjectUpdateAllowed";
		Else
			OwnerField.EditAsRead = True;
		EndIf;
	Else
		OwnerField.EditAsRead = True;
	EndIf;
	
	If Not ValueIsFilled(OwnerField.Name) Then
		If RestrictionByOwnerRequired Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'The optimization option %1 is set
				           |but the specified restriction does not contain any of the following functions:
				           |%2, %3.';"),
				OptimizationFlagName, "ObjectReadingAllowed", "ObjectUpdateAllowed");
			ErrorText = ErrorTextWithTitle(ErrorText, Context);
			If Context.Property("ErrorOnCallException") Then
				Context.ErrorOnCallException.Text = ErrorText;
			EndIf;
			Raise ErrorText;
		Else
			Return;
		EndIf;
	EndIf;
	
	Result.OwnerField = OwnerField;
	
	If Not Context.IsReferenceType Then
		Result.RestrictionByOwnerRequired = True;
	EndIf;
	
EndProcedure

// For the FillRestrictionByOwnerObjectBeforeSimplification procedure.
Function PossibleRestrictionOnTheObjectOwner(Condition, ThisIsALimitationOfTheChange, Context)
	
	If Not ValueIsFilled(Condition) Then
		Return New Structure;
	EndIf;
	
	If Condition.Node = "Field"
	 Or Condition.Node = "IsNull"
	 Or Condition.Node = "="
	 Or Condition.Node = "<>"
	 Or Condition.Node = "In"
	 Or Condition.Node = "Constant"
	 Or Condition.Node = "ValueAllowed"  Then
		
		Return New Structure;
		
	ElsIf Condition.Node = "IsAuthorizedUser"
	      Or Condition.Node = "ListReadingAllowed"
	      Or Condition.Node = "ListUpdateAllowed"
	      Or Condition.Node = "AccessRight"
	      Or Condition.Node = "IsInRole" Then
		
		Return Undefined;
		
	ElsIf Condition.Node = "And"
	      Or Condition.Node = "Or" Then
		
		RestrictionFound = New Structure;
		For Each Argument In Condition.Arguments Do
			If Not APossibleRestrictionOnTheOwnerObjectHasBeenProcessed(Argument,
						ThisIsALimitationOfTheChange, RestrictionFound, Context) Then
				Return Undefined;
			EndIf;
		EndDo;
		Return RestrictionFound;
		
	ElsIf Condition.Node = "Not"
	      Or Condition.Node = "ForAllRows"
	      Or Condition.Node = "ForAtLeastOneRow" Then
		
		Return PossibleRestrictionOnTheObjectOwner(Condition.Argument,
			ThisIsALimitationOfTheChange, Context);
		
	ElsIf Condition.Node = "Case" Then
		RestrictionFound = New Structure;
		For Each When In Condition.When Do
			If Not APossibleRestrictionOnTheOwnerObjectHasBeenProcessed(When.Value,
						ThisIsALimitationOfTheChange, RestrictionFound, Context) Then
				Return Undefined;
			EndIf;
		EndDo;
		If Not APossibleRestrictionOnTheOwnerObjectHasBeenProcessed(Condition.Else,
					ThisIsALimitationOfTheChange, RestrictionFound, Context) Then
			Return Undefined;
		EndIf;
		Return RestrictionFound;
		
	ElsIf Condition.Node = "ObjectReadingAllowed"
	      Or Condition.Node = "ObjectUpdateAllowed" And ThisIsALimitationOfTheChange Then
		
		Return Condition;
	EndIf;
	
	ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
		NStr("en = 'When filling in a possible owner object restriction
		           |for the ""%1"" list,
		           |the ""%2"" node is not supported.';"),
		Context.List,
		Condition.Node);
	
	Raise ErrorText;
	
EndFunction

// For the PossibleRestrictionByOwnerObject function.
Function APossibleRestrictionOnTheOwnerObjectHasBeenProcessed(Condition,
				ThisIsALimitationOfTheChange, RestrictionFound, Context)
	
	NestedConstraint = PossibleRestrictionOnTheObjectOwner(Condition,
		ThisIsALimitationOfTheChange, Context);
	
	If NestedConstraint = Undefined Then
		Return False;
	EndIf;
	
	If ValueIsFilled(NestedConstraint) Then
		If ValueIsFilled(RestrictionFound) Then
			Return False;
		EndIf;
		RestrictionFound = NestedConstraint;
	EndIf;
	
	Return True;
	
EndFunction

// For the AccessRestrictionParameters function.
//
// Parameters:
//  Result - See RestrictionParametersByRestrictionStructure
//  Context  - See ParametersContextByRestrictionStructure
//
Procedure FillInTheRestrictionOnTheObjectOwnerAfterSimplification(Result, Context)
	
	OwnerField = Result.OwnerField;
	If OwnerField = Undefined Then
		Return;
	EndIf;
	RestrictionByOwnerRequired = Result.RestrictionByOwnerRequired;
	
	CustomizingByOwner = Context.ListsWithRestrictionByOwner.Get(Context.List);
	If TypeOf(CustomizingByOwner) = Type("Boolean") Then
		OwnerField.Disabled = Not CustomizingByOwner;
	Else
		OwnerField.Disabled = False;
	EndIf;
	
	ReadRestriction    = Context.RestrictionStructure.ReadRestriction;
	UpdateRestriction = Context.RestrictionStructure.UpdateRestriction;
	
	OptimizationFlagName = ?(Context.ForExternalUsers,
		"ByOwnerWithoutSavingAccessKeysForExternalUsers", "ByOwnerWithoutSavingAccessKeys");
	
	If Not Result.HasReadRestriction
	   And Not Result.HasLimitChanges
	 Or Result.HasReadRestriction
	   And ReadRestriction.Node <> "ObjectReadingAllowed"
	 Or Result.HasLimitChanges
	   And UpdateRestriction.Node <> "ObjectReadingAllowed"
	   And UpdateRestriction.Node <> "ObjectUpdateAllowed" Then
		
		OwnerField.Disabled = True;
	Else
		FieldsProperties = Context.FieldsProperties;
		
		If FieldsProperties.Count() <> 1 Then
			If RestrictionByOwnerRequired And FieldsProperties.Count() <> 0 Then
				ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("en = 'The optimization option %1 is set
					           |but the restriction includes multiple fields.';"),
					OptimizationFlagName);
				ErrorText = ErrorTextWithTitle(ErrorText, Context);
				If Context.Property("ErrorOnCallException") Then
					Context.ErrorOnCallException.Text = ErrorText;
				EndIf;
				Raise ErrorText;
			Else
				OwnerField.Disabled = True;
			EndIf;
		Else
			FieldProperties = FieldsProperties[0];
			
			MOIDType = Type("CatalogRef.MetadataObjectIDs");
			EOIDType = Type("CatalogRef.ExtensionObjectIDs");
			
			IDsTypesCountInFinalField = 0;
			If FieldProperties.EndFieldType.ContainsType(MOIDType) Then
				IDsTypesCountInFinalField = 1;
			EndIf;
			If FieldProperties.EndFieldType.ContainsType(EOIDType) Then
				IDsTypesCountInFinalField = IDsTypesCountInFinalField + 1;
			EndIf;
			
			If FieldProperties.EndFieldType.Types().Count() - IDsTypesCountInFinalField
			  <> FieldProperties.AccessKeySavingTypes.Count() Then
				
				IncorrectTypes = New Array;
				For Each Type In FieldProperties.EndFieldType.Types() Do
					If FieldProperties.AccessKeySavingTypes.Find(Type) <> Undefined
					 Or Type = MOIDType
					 Or Type = EOIDType Then
						Continue;
					EndIf;
					IncorrectTypes.Add(TypeNameInQueryLanguage(Type));
				EndDo;
				If RestrictionByOwnerRequired Then
					ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
						NStr("en = 'The optimization option %1 is selected.
						           |However, you cannot write access keys for the following tables:
						           |%2';"),
						OptimizationFlagName,
						StrConcat(IncorrectTypes, Chars.LF));
					ErrorText = ErrorTextWithTitle(ErrorText, Context);
					If Context.Property("ErrorOnCallException") Then
						Context.ErrorOnCallException.Text = ErrorText;
					EndIf;
					Raise ErrorText;
				Else
					OwnerField.Disabled = True;
				EndIf;
			EndIf;
		EndIf;
	EndIf;
	
	AddVersionProperty(Context, OwnerField, "EditAsRead");
	AddVersionProperty(Context, OwnerField, "Name");
	AddVersionProperty(Context, OwnerField, "Disabled");
	
EndProcedure

// Returns:
//   Structure:
//     * Name - String
//     * EditAsRead - Boolean
//     * Disabled - Boolean
//
Function NewOwnerField()
	
	Return New Structure("Name, EditAsRead, Disabled", "", False, True);
	
EndFunction

// For the FillRestrictionByOwnerObject function and the SetOptimizationByOwnerField procedure.
Function ErrorTextWithTitle(ErrorText, Context)
	
	ErrorsDescription = ErrorsDescription();
	ErrorsDescription.HasErrors = True;
	ErrorsDescription.ErrorsText = ErrorText;
	ErrorsDescription.Errors = New Array(1);
	
	RestrictionDetails = Context.RestrictionsDetails1.Get(Context.List);
	
	ErrorsDescription.Restriction =
		NumberedRestrictionTextWithErrorsMarks(RestrictionDetails.Text,
			New Array, StrLen(Format(StrLineCount(RestrictionDetails.Text), "NG=")));
	
	Return TrimAll(ErrorsTextToCallException(Context.List,
		ErrorsDescription, Context.ForExternalUsers, RestrictionDetails.InManagerModule));
	
EndFunction

// For the FillRestrictionByOwnerObject procedure.
Function FunctionWithoutClarificationOfTypesWithFieldWithoutAttachments(Restriction)
	
	If Restriction.Types.Count() <> 0
	 Or Restriction.ComparisonClarifications.Count() <> 0 Then
		Return False;
	EndIf;
	
	Field = Restriction.Field;
	
	Return Not ValueIsFilled(Field.Cast)
	      And Not ValueIsFilled(Field.Attachment)
	      And Not ValueIsFilled(Field.IsNull);
	
EndFunction

// For the AccessRestrictionParameters function.
//
// Parameters:
//  Result - See RestrictionParametersByRestrictionStructure
//  Context  - See ParametersContextByRestrictionStructure
//
Procedure FillHasLeadingKeysAndListsAndRightsSettingsOwners(Result, Context)
	
	For Each FieldProperties In Context.FieldsProperties Do
		If FieldProperties.AccessKeySavingTypes.Count() > 0 Then
			Result.HasMasterAccessKeys = True;
		EndIf;
		If FieldProperties.HasHeadListType Then
			Result.HasHeadRightsLists = True;
		EndIf;
		If FieldProperties.HasRightsSettingsOwnerType Then
			Result.HasRightsSettingsOwners = True;
		EndIf;
		If FieldProperties.HasAuthorizedUserCheck Then
			Context.HasAuthorizedUserCheck = True;
		EndIf;
		For Each Type In FieldProperties.UsedAccessValuesTypes Do
			If Result.UsedAccessValuesTypes.Find(Type) = Undefined Then
				Result.UsedAccessValuesTypes.Add(Type);
			EndIf;
		EndDo;
	EndDo;
	
	For Each KeyAndValue In Context.SeparateRightsSettingsTables Do
		If KeyAndValue.Value = Context.List Then
			Result.RightSettingsTableID = KeyAndValue.Key;
			Break;
		EndIf;
	EndDo;
	
	AddVersionProperty(Context, Result, "HasMasterAccessKeys");
	AddVersionProperty(Context, Result, "HasHeadRightsLists");
	AddVersionProperty(Context, Result, "HasRightsSettingsOwners");
	AddVersionProperty(Context, Result, "UsedAccessValuesTypes");
	AddVersionProperty(Context, Context,  "UnusedAccessValueTypes");
	
	PropertiesToSave = New Structure("SeparateRightsSettingsTable",
		ValueIsFilled(Result.RightSettingsTableID));
	
	AddVersionProperty(Context, PropertiesToSave, "SeparateRightsSettingsTable");
	
EndProcedure

// For the AccessRestrictionParameters function.
//
// Parameters:
//  Result - See RestrictionParametersByRestrictionStructure
//  Context  - See ParametersContextByRestrictionStructure
//
Procedure DeleteNotUsedAccessKindsFields(Result, Context)
	
	FieldsProperties = Context.FieldsProperties;
	
	If Not Result.HasMasterAccessKeys
	   And Not Result.HasHeadRightsLists
	   And Not Result.HasRightsSettingsOwners
	   And Not Result.ThereIsAFunctionAccessRightOrRoleAvailable
	   And Not Context.HasAuthorizedUserCheck
	   And Result.UsedAccessValuesTypes.Count() = 0
	   And Context.UnusedAccessValueTypes.Count() > 0 Then
		
		FieldsProperties.Clear();
		Return;
	EndIf;
	
	IndexOf = FieldsProperties.Count();
	While IndexOf > 0 Do
		IndexOf = IndexOf - 1;
		FieldProperties = FieldsProperties.Get(IndexOf);
		SetUsingOfObjectTableField(Context, FieldProperties);
		SetBasicFieldUse(Context, FieldProperties);
		AddVersionProperties(Context, FieldProperties,
		"HasAdjustmentNull,
		|HasAdjustmentUndefined,
		|FieldNameForQuery,
		|MultipleValuesGroups,
		|EndFieldType,
		|ValueGroupSavingTypes,
		|ValueSavingTypes,
		|AccessKeySavingTypes,
		|EmptyRefSavingTypes,
		|AllowedTypeSavingTypes,
		|ProhibitedTypeSavingTypes,
		|TypeSavingTypes,
		|ConfigurationTypeSavingTypes,
		|SimpleTypeSavingTypes,
		|ExtensionTypeSavingTypes,
		|TypesString");
	EndDo;
	
EndProcedure

// For the AccessRestrictionParameters function.
//
// Parameters:
//  Result - See RestrictionParametersByRestrictionStructure
//  Context  - See ParametersContextByRestrictionStructure
//
Procedure FillHasRestrictionByUsersAccessKind(Result, Context)
	
	If Result.HasRightsSettingsOwners Then
		Result.HasUsersRestriction = True;
	Else
		For Each FieldProperties In Context.FieldsProperties Do
			If FieldProperties.ValueSavingTypes.Count() = 0 Then
				Continue;
			EndIf;
			TypeDescription = New TypeDescription(FieldProperties.ValueSavingTypes);
			If Not Result.ForExternalUsers
			   And (    TypeDescription.ContainsType(Type("CatalogRef.Users"))
			      Or TypeDescription.ContainsType(Type("CatalogRef.UserGroups")) ) Then
				
				Result.HasUsersRestriction = True;
				Break;
			EndIf;
			If Result.ForExternalUsers
			   And (    TypeDescription.ContainsType(Type("CatalogRef.ExternalUsers"))
			      Or TypeDescription.ContainsType(Type("CatalogRef.ExternalUsersGroups")) ) Then
				
				Result.HasUsersRestriction = True;
				Break;
			EndIf;
		EndDo;
	EndIf;
	
	AddVersionProperty(Context, Result, "HasUsersRestriction");
	
EndProcedure

// For the AccessRestrictionParameters function.
//
// Parameters:
//  Result - See RestrictionParametersByRestrictionStructure
//  Context  - See ParametersContextByRestrictionStructure
//
Procedure FillHasReadRestriction(Result, Context)
	
	If Context.IsThereFunctionAccessRightOrRoleAvailableInReadRestriction Then
		Result.RightToWriteRestrictionDisabled = False;
	Else
		For Each FieldProperties In Context.FieldsProperties Do
			If FieldProperties.Read Then
				Result.RightToWriteRestrictionDisabled = False;
				Break;
			EndIf;
		EndDo;
	EndIf;
	
	AddVersionProperty(Context, Result, "RightToWriteRestrictionDisabled");
	
EndProcedure

// For the AccessRestrictionParameters function.
//
// Parameters:
//  Context - See ParametersContextByRestrictionStructure
//
Procedure FillFieldsAndAdditionalTablesGroups(Context)
	
	// 
	// 
	// 
	// 
	
	LastHeaderAttributeNumberWithSeveralAccessValuesGroups = 0;
	LastObjectTabularSectionNumber = 0;
	ObjectTabularSectionsNumbers = New Map;
	
	For Each FieldProperties In Context.FieldsProperties Do
		If FieldProperties.TableAlias = "CurrentList"
		   And FieldProperties.MultipleValuesGroups Then
			
			LastHeaderAttributeNumberWithSeveralAccessValuesGroups =
				LastHeaderAttributeNumberWithSeveralAccessValuesGroups + 1;
			
		ElsIf FieldProperties.TableAlias <> "CurrentList"
		        And StrStartsWith(FieldProperties.TableAlias, "CurrentList")
			    And ObjectTabularSectionsNumbers.Get(FieldProperties.TableAlias) = Undefined Then
			
			LastObjectTabularSectionNumber = LastObjectTabularSectionNumber + 1;
			ObjectTabularSectionsNumbers.Insert(FieldProperties.TableAlias, LastObjectTabularSectionNumber);
		EndIf;
	EndDo;
	
	AccessKeyDimensions = AccessManagementInternalCached.AccessKeyDimensions();
	
	KeyTabularSectionsCountForObjectHeaderAttributes = Int(
		(LastHeaderAttributeNumberWithSeveralAccessValuesGroups
			+ AccessKeyDimensions.TabularSectionAttributesCount - 1)
		/ AccessKeyDimensions.TabularSectionAttributesCount);
	
	AdditionalTablesGroups = AdditionalTablesGroups(Context);
	KeyTabularSectionsCount = LastObjectTabularSectionNumber
		+ AdditionalTablesGroups.TablesByGroups.Count()
		+ KeyTabularSectionsCountForObjectHeaderAttributes;
	
	FinishPreparingObjectTablesFields(Context);
	CompleteBasicFieldsPreparation(Context);
	
	If KeyTabularSectionsCount > AccessKeyDimensions.TabularSectionsCount Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'In the access restriction of the %1 list,
			           |the number of fields that require separate tabular sections in the access key
			           |is greater than the number of available tabular sections in the access key.
			           |
			           |These fields include:
			           |- Fields of tabular sections.
			           |- Fields of additional tables attached to the list.
			           |- Header fields whose Access Values can have more than one Access Value Group.';"),
			Context.List);
		
		If Context.Property("ErrorOnCallException") Then
			Context.ErrorOnCallException.Text = ErrorText;
		EndIf;
		Raise ErrorText;
	EndIf;
	
	If Not Context.IsReferenceType
	   And Context.BasicFields.All.Count() > Context.BasicFields.MaxCount Then
		
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'In the access restriction of the %1 list,
			           |the number of list fields that are used in the access restriction
			           |exceeds the limit of basic fields: %2.';"),
			Context.List,
			Context.BasicFields.MaxCount);
		
		If Context.Property("ErrorOnCallException") Then
			Context.ErrorOnCallException.Text = ErrorText;
		EndIf;
		Raise ErrorText;
	EndIf;
	
	FieldsGroups = New Map;
	ObjectTabularSectionsAliases = New Map;
	LastHeaderAttributeNumber = 0;
	LastHeaderAttributeNumberWithSeveralAccessValuesGroups = 0;
	
	For Each FieldProperties In Context.FieldsProperties Do
		If FieldProperties.TableAlias = "CurrentList" Then
			
			If FieldProperties.MultipleValuesGroups Then
				LastHeaderAttributeNumberWithSeveralAccessValuesGroups =
					LastHeaderAttributeNumberWithSeveralAccessValuesGroups + 1;
				
				KeyTabularSectionNumber = Int(LastHeaderAttributeNumberWithSeveralAccessValuesGroups
					/ AccessKeyDimensions.TabularSectionAttributesCount) + 1;
				
				FieldsGroupName = "TabularSection" + KeyTabularSectionNumber;
			Else
				LastHeaderAttributeNumber = LastHeaderAttributeNumber + 1;
				If LastHeaderAttributeNumber < 6 Then
					FieldsGroupName = "Header0";
				ElsIf LastHeaderAttributeNumber < 11 Then
					FieldsGroupName = "Header1";
				ElsIf LastHeaderAttributeNumber < 16 Then
					FieldsGroupName = "Header2";
				Else
					ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
						NStr("en = 'In the access restriction of the %1 list,
						           |the number of list fields that are used in the access restriction
						           |exceeds the maximum allowed number: 15.';"),
						Context.List);
					If Context.Property("ErrorOnCallException") Then
						Context.ErrorOnCallException.Text = ErrorText;
					EndIf;
					Raise ErrorText;
				EndIf;
			EndIf;
		Else
			If FieldProperties.TableAlias <> "CurrentList"
			   And StrStartsWith(FieldProperties.TableAlias, "CurrentList") Then
				
				KeyTabularSectionNumber = KeyTabularSectionsCountForObjectHeaderAttributes
					+ ObjectTabularSectionsNumbers.Get(FieldProperties.TableAlias);
				
				If ObjectTabularSectionsAliases.Get(KeyTabularSectionNumber) = Undefined Then
					ObjectTabularSectionsAliases.Insert(KeyTabularSectionNumber, FieldProperties.TableAlias)
				EndIf;
			Else
				KeyTabularSectionNumber = KeyTabularSectionsCountForObjectHeaderAttributes
					+ ObjectTabularSectionsNumbers.Count()
					+ AdditionalTablesGroups.NumbersByAliases.Get(FieldProperties.TableAlias);
			EndIf;
			FieldsGroupName = "TabularSection" + KeyTabularSectionNumber;
		EndIf;
		GroupOfFields = FieldsGroups.Get(FieldsGroupName);
		If GroupOfFields = Undefined Then
			GroupOfFields = New Array;
			FieldsGroups.Insert(FieldsGroupName, GroupOfFields);
		EndIf;
		GroupOfFields.Add(FieldProperties);
		FieldProperties.Insert("AccessKeyFieldsGroupName", FieldsGroupName);
		FieldProperties.Insert("AccessKeyFieldsGroupAttributeName", 
			"Value" + XMLString(GroupOfFields.Count() + ?(FieldsGroupName = "Header1" Or FieldsGroupName = "Header2", 5, 0)));
		
		If Not StrStartsWith(FieldsGroupName, "Header")
		   And GroupOfFields.Count() > AccessKeyDimensions.TabularSectionAttributesCount Then
			
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'In the access restriction of the %1 list,
				           |the number of fields of a single tabular section that are used in the access restriction
				           |exceeds the limit: %2.';"),
				Context.List,
				AccessKeyDimensions.TabularSectionAttributesCount);
			
			If Context.Property("ErrorOnCallException") Then
				Context.ErrorOnCallException.Text = ErrorText;
			EndIf;
			Raise ErrorText;
		EndIf;
	EndDo;
	
	Context.Insert("FieldsGroups",                      FieldsGroups);
	Context.Insert("ObjectTabularSectionsAliases", ObjectTabularSectionsAliases);
	Context.Insert("AdditionalTablesGroups",       AdditionalTablesGroups);
	Context.Insert("KeyTabularSectionsCount",   KeyTabularSectionsCount);
	
	// Calculate the FieldsComposition number.
	
	// 
	// 
	// 
	//
	// 
	// 
	// 
	// 
	
	FieldsComposition = LastHeaderAttributeNumber;
	
	For KeyTabularSectionNumber = 1 To KeyTabularSectionsCount Do
		KeyTabularSectionName = "TabularSection" + KeyTabularSectionNumber;
		GroupOfFields = FieldsGroups.Get(KeyTabularSectionName);
		FieldsComposition = FieldsComposition + GroupOfFields.Count() * Power16(KeyTabularSectionNumber);
	EndDo;
	
	Context.Insert("FieldsComposition", FieldsComposition);
	
EndProcedure

// For the AccessRestrictionParameters function.
//
// Parameters:
//   CalculationCondition - See RightCalculationStructure
//   Condition        - See NodeDetails
//   Context       - See ParametersContextByRestrictionStructure
//
Procedure FillRightCalculationStructure(CalculationCondition, Condition, Context, ConditionRoot = True)
	
	If Not ValueIsFilled(Condition) Then
		Return;
	EndIf;
	
	If ConditionRoot Then
		Context.Insert("RequiredKeyTabularSectionsAttributes", New Map);
		Context.Insert("VersionPropertiesRightCalculationStructure", New Array);
	EndIf;
	
	FieldProperties = Undefined;
	AddCalculationStructureVersionProperty(Context, "Node", Condition.Node);
	
	If Condition.Node = "Field" Then
		FieldProperties = Context.AccessKeyFieldsProperties.Get(Condition);
		
	ElsIf Condition.Node = "And"
	      Or Condition.Node = "Or" Then
		
		CalculationCondition = New Structure("Node, Arguments", Condition.Node, New Array);
		IndexOf = 0;
		For Each Argument In Condition.Arguments Do
			CalculationCondition.Arguments.Add(Undefined);
			FillRightCalculationStructure(CalculationCondition.Arguments[IndexOf], Argument, Context, False);
			IndexOf = IndexOf + 1;
		EndDo;
		FieldProperties = Null;
		
	ElsIf Condition.Node = "Not" Then
		CalculationCondition = New Structure("Node, Argument", Condition.Node, Undefined);
		FillRightCalculationStructure(CalculationCondition.Argument, Condition.Argument, Context, False);
		FieldProperties = Null;
		
	ElsIf Condition.Node = "ForAllRows"
	      Or Condition.Node = "ForAtLeastOneRow" Then
		
		If Not ConditionRoot Then
			RequiredKeyTabularSectionsAttributes = Context.RequiredKeyTabularSectionsAttributes;
			Context.Insert("RequiredKeyTabularSectionsAttributes", New Map);
		EndIf;
		
		CalculationCondition = New Structure("Node, Argument", Condition.Node, Undefined);
		FillRightCalculationStructure(CalculationCondition.Argument, Condition.Argument, Context, False);
		
		If Not ConditionRoot Then
			CalculationCondition.Insert("RequiredKeyTabularSectionsAttributes", Context.RequiredKeyTabularSectionsAttributes);
			Context.Insert("RequiredKeyTabularSectionsAttributes", RequiredKeyTabularSectionsAttributes);
		EndIf;
		FieldProperties = Null;
		
	ElsIf Condition.Node = "IsNull" Then
		FieldProperties = Context.AccessKeyFieldsProperties.Get(Condition.Argument);
		
	ElsIf Condition.Node = "="
	      Or Condition.Node = "<>" Then
		
		FieldProperties = Context.AccessKeyFieldsProperties.Get(Condition.FirstArgument);
		If FieldProperties = Undefined Then
			FieldProperties = Context.AccessKeyFieldsProperties.Get(Condition.SecondArgument);
		EndIf;
		
	ElsIf Condition.Node = "In" Then
		FieldProperties = Context.AccessKeyFieldsProperties.Get(Condition.SearchFor);
		
	ElsIf Condition.Node = "Case" Then
		CalculationCondition = New Structure("Node, When, Else", Condition.Node, New Array, Undefined);
		For Each When In Condition.When Do
			StructureWhen = New Structure("Condition, Value");
			CalculationCondition.When.Add(StructureWhen);
			If Condition.Case = Undefined Then
				FillRightCalculationStructure(StructureWhen.Condition, When.Condition, Context, False);
			Else
				Properties = Context.AccessKeyFieldsProperties.Get(When.Condition);
				AddCalculationStructureVersionProperty(Context, "Node", "Field");
				CalculationConditionField(StructureWhen.Condition, Properties, Context);
			EndIf;
			FillRightCalculationStructure(StructureWhen.Value, When.Value, Context, False);
		EndDo;
		FillRightCalculationStructure(CalculationCondition.Else, Condition.Else, Context, False);
		FieldProperties = Null;
		
	ElsIf Condition.Node = "ValueAllowed"
	      Or Condition.Node = "IsAuthorizedUser"
	      Or Condition.Node = "ObjectReadingAllowed"
	      Or Condition.Node = "ObjectUpdateAllowed"
	      Or Condition.Node = "ListReadingAllowed"
	      Or Condition.Node = "ListUpdateAllowed" Then
		
		CalculationCondition = New Structure("Node, Field", Condition.Node, Undefined);
		CalculationCondition.Insert("ComparisonClarifications", New Map);
		For Each KeyAndValue In Condition.ComparisonClarifications Do
			If KeyAndValue.Key = "Null"
			 Or KeyAndValue.Key = "Undefined"
			 Or KeyAndValue.Key = "EmptyRef"
			 Or KeyAndValue.Key = "Disabled" Then
				CalculationCondition.ComparisonClarifications.Insert(KeyAndValue.Key, KeyAndValue.Value);
			Else
				TypeName = StrReplace(KeyAndValue.Key, ".", "Ref.");
				CalculationCondition.ComparisonClarifications.Insert(Type(TypeName), KeyAndValue.Value);
			EndIf;
		EndDo;
		AddCalculationStructureVersionProperty(Context, "ComparisonClarifications", Condition.ComparisonClarifications);
		FillRightCalculationStructure(CalculationCondition.Field, Condition.Field, Context, False);
		
		If CalculationCondition.Field = Null Then
			CalculationCondition = New Structure("Node, Value", "Constant", True);
		EndIf;
		FieldProperties = Null;
		
	ElsIf Condition.Node = "Constant" Then
		CalculationCondition = New Structure("Node, Value", Condition.Node, Condition.Value);
		AddCalculationStructureVersionProperty(Context, "Value", Condition.Value);
		FieldProperties = Null;
		
	ElsIf Condition.Node = "AccessRight" Then
		CalculationCondition = New Structure("Node, NameOfRight, FullMetadataObjectName",
			Condition.Node, Condition.NameOfRight, Condition.FullMetadataObjectName);
		AddDependencyOnRoles(Context, CalculationCondition);
		AddCalculationStructureVersionProperty(Context, "NameOfRight", Condition.NameOfRight);
		AddCalculationStructureVersionProperty(Context, "FullMetadataObjectName",
			Condition.FullMetadataObjectName);
		FieldProperties = Null;
	
	ElsIf Condition.Node = "IsInRole" Then
		CalculationCondition = New Structure("Node, NameOfRole", Condition.Node, Condition.NameOfRole);
		AddDependencyOnRoles(Context, CalculationCondition);
		AddCalculationStructureVersionProperty(Context, "NameOfRole", Condition.NameOfRole);
		FieldProperties = Null;
	Else
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Cannot fill in the structure required for calculation of the %1 right to the access keys
			           |of the ""%2"" list.
			           |Node ""%3"" is not supported.';"),
			Context.NameOfRight,
			Context.List,
			Condition.Node);
		Raise ErrorText;
	EndIf;
	
	If FieldProperties = Undefined Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Cannot fill in the structure required for calculation of the %1 right to the access keys
			           |of the ""%2"" list.
			           |The field properties are not defined for node ""%3"".';"),
			Context.NameOfRight,
			Context.List,
			Condition.Node);
		Raise ErrorText;
	EndIf;
	
	If FieldProperties <> Null Then
		CalculationConditionField(CalculationCondition, FieldProperties, Context);
	EndIf;
	
	If ConditionRoot Then
		CalculationCondition.Insert("RequiredKeyTabularSectionsAttributes",
			Context.RequiredKeyTabularSectionsAttributes);
		
		AddVersionItem(Context, ?(Context.NameOfRight = "Read",
			"ReadRightCalculationStructure", "RightCalculationStructureUpdate"),
			Context.VersionPropertiesRightCalculationStructure);
		
		Context.Delete("VersionPropertiesRightCalculationStructure");
	EndIf;
	
EndProcedure

// For the FillRightCalculationStructure procedure.
Procedure CalculationConditionField(CalculationCondition, FieldProperties, Context)
	
	If Context.FieldsProperties.Find(FieldProperties) = Undefined Then
		CalculationCondition = Null; // Поле удалено из-
	Else
		CalculationCondition = New Structure("Node", "Field");
		CalculationCondition.Insert("Table",  FieldProperties.AccessKeyFieldsGroupName);
		CalculationCondition.Insert("Attribute", FieldProperties.AccessKeyFieldsGroupAttributeName);
		If StrStartsWith(CalculationCondition.Table, "TabularSection") Then
			Attributes = Context.RequiredKeyTabularSectionsAttributes.Get(CalculationCondition.Table);
			If Attributes = Undefined Then
				Attributes = New Array;
				Context.RequiredKeyTabularSectionsAttributes.Insert(CalculationCondition.Table, Attributes);
			EndIf;
			If Attributes.Find(CalculationCondition.Attribute) = Undefined Then
				Attributes.Add(CalculationCondition.Attribute);
			EndIf;
		EndIf;
		AddCalculationStructureVersionProperty(Context, "Table",  CalculationCondition.Table);
		AddCalculationStructureVersionProperty(Context, "Attribute", CalculationCondition.Attribute);
		If FieldProperties.Property("CheckHasNull") Then
			CalculationCondition.Insert("CheckHasNull");
			AddCalculationStructureVersionProperty(Context, "CheckHasNull", True);
		EndIf;
	EndIf;
	
EndProcedure

// For the FillRightCalculationStructure procedure.
Procedure AddDependencyOnRoles(Context, CalculationCondition)
	
	If CalculationCondition.Property("NameOfRole") Then
		Role = Metadata.Roles.Find(CalculationCondition.NameOfRole);
		Context.LeadingRoles.Insert(Role.Name, True);
		Return;
	EndIf;
	
	TheNameOfTheStandardProps = Undefined;
	MetadataObject = MetadataObjectByFullNameForCheckingTheRight(
		CalculationCondition.FullMetadataObjectName, TheNameOfTheStandardProps);
	
	For Each Role In Metadata.Roles Do
		If AccessRight(CalculationCondition.NameOfRight, MetadataObject, Role, TheNameOfTheStandardProps) Then
			Context.LeadingRoles.Insert(Role.Name, True);
		EndIf;
	EndDo;
	
EndProcedure

// For the FillRightCalculationStructure and CalculationConditionField procedures.
Procedure AddCalculationStructureVersionProperty(Context, Name, Value);
	
	If TypeOf(Value) = Type("Map") Then
		ValueList = New ValueList;
		For Each KeyAndValue In Value Do
			ValueList.Add(KeyAndValue.Value, KeyAndValue.Key);
		EndDo;
		ValueList.SortByPresentation();
		For Each ListItem In ValueList Do
			Context.VersionPropertiesRightCalculationStructure.Add(ListItem.Presentation);
			Context.VersionPropertiesRightCalculationStructure.Add(ListItem.Value);
		EndDo;
	Else
		Context.VersionPropertiesRightCalculationStructure.Add(Name);
		Context.VersionPropertiesRightCalculationStructure.Add(Value);
	EndIf;
	
EndProcedure

// For the FillFieldsAndAdditionalTablesGroups procedure.
Function Power16(Power)
	
	Power16 = 1;
	
	For Counter = 1 To Power Do
		Power16 = Power16 * 16;
	EndDo;
	
	Return Power16;
	
EndFunction

// For the FillFieldsAndAdditionalTablesGroups function.
// 
// Parameters:
//  Context - See ParametersContextByRestrictionStructure
//
// Returns:
//  Structure:
//    * NumbersByAliases - Map of KeyAndValue:
//        ** Key     - String - an additional table alias
//        ** Value - Number  - the group number of additional tables
//         
//    * TablesByGroups - Map of KeyAndValue:
//        ** Key     - Number - the group number of additional tables
//        ** Value - Array of See NewConnectionDetails
//        
//    * TablesWithFiledsAliases - Map of KeyAndValue:
//        ** Key     - String - an additional table alias
//                               with access key fields (except for the join fields).
//        ** Value - Boolean - True.
//
Function AdditionalTablesGroups(Context)
	
	AdditionalTables = Context.RestrictionStructure.AdditionalTables;
	GroupsNumbersByAliases = New Map;
	
	Context.BasicFields.Insert("ByAdditionalTables", New Map);
	Context.ObjectTablesFields.Insert("ByAdditionalTables", New Map);
	Context.Insert("AdditionalTablesMergeConditionsFields", New Array);
	
	LastGroup = 0;
	For Each AdditionalTable In AdditionalTables Do
		AdditionalTable.Insert("RequiredTablesAliases", New Array);
		AdditionalTable.Insert("ConnectionConditionFields", New Array);
		AdditionalTable.Insert("ConnectionTestField", "");
		
		ConnectionConditionText = ConnectionConditionText(AdditionalTable, Context);
		AdditionalTable.Insert("ConnectionConditionText", ?(Left(ConnectionConditionText, 1) = "(",
			ConnectionConditionText, "(" + ConnectionConditionText + ")"));
		
		If Not ValueIsFilled(AdditionalTable.ConnectionTestField) Then
			AccessKeyFields = Context.AccessKeyFieldsAfterSimplify;
			For Each FieldDetails In AccessKeyFields Do
				If FieldDetails.Field.Alias = AdditionalTable.Alias Then
					AdditionalTable.ConnectionTestField =
						AdditionalTable.Alias + "." + FieldDetails.Field.Name;
				EndIf;
			EndDo;
		EndIf;
		
		CurrentGroup_SSLy = GroupsNumbersByAliases.Get(AdditionalTable.Alias);
		If CurrentGroup_SSLy = Undefined Then
			LastGroup = LastGroup + 1;
			CurrentGroup_SSLy = LastGroup;
			GroupsNumbersByAliases.Insert(AdditionalTable.Alias, CurrentGroup_SSLy);
		EndIf;
		
		For Each Alias In AdditionalTable.RequiredTablesAliases Do
			RequiredTableGroup = GroupsNumbersByAliases.Get(Alias);
			If RequiredTableGroup = Undefined Then
				GroupsNumbersByAliases.Insert(Alias, CurrentGroup_SSLy);
				Continue;
			EndIf;
			If RequiredTableGroup = CurrentGroup_SSLy Then
				Continue;
			EndIf;
			GroupToReplaceAliases = New Array;
			For Each KeyAndValue In GroupsNumbersByAliases Do
				If KeyAndValue.Value <> RequiredTableGroup Then
					Continue;
				EndIf;
				GroupToReplaceAliases.Add(KeyAndValue.Key);
			EndDo;
			For Each Alias In GroupToReplaceAliases Do
				GroupsNumbersByAliases.Insert(Alias, CurrentGroup_SSLy);
			EndDo;
		EndDo;
	EndDo;
	
	TablesWithFiledsAliases = New Map;
	For Each FieldProperties In Context.FieldsProperties Do
		If FieldProperties.TableAlias = "CurrentList" Then
			Continue;
		EndIf;
		TablesWithFiledsAliases.Insert(FieldProperties.TableAlias, True);
	EndDo;
	
	GroupsUse = New Map;
	For Group = 1 To LastGroup Do
		For Each KeyAndValue In GroupsNumbersByAliases Do
			If KeyAndValue.Value <> Group Then
				Continue;
			EndIf;
			If GroupsUse.Get(Group) = Undefined Then
				GroupsUse.Insert(Group, False);
			EndIf;
			If TablesWithFiledsAliases.Get(KeyAndValue.Key) <> Undefined Then
				GroupsUse.Insert(Group, True);
			EndIf;
		EndDo;
	EndDo;
	
	NewFolder = 1;
	NewGroups = New Map;
	For Each AdditionalTable In AdditionalTables Do
		OldGroup = GroupsNumbersByAliases.Get(AdditionalTable.Alias);
		If Not GroupsUse.Get(OldGroup) Then
			Continue;
		EndIf;
		If NewGroups.Get(OldGroup) <> Undefined Then
			Continue;
		EndIf;
		NewGroups.Insert(OldGroup, NewFolder);
		NewFolder = NewFolder + 1;
	EndDo;
	
	Groups = New Structure;
	Groups.Insert("NumbersByAliases",     New Map);
	Groups.Insert("TablesByGroups",        New Map);
	Groups.Insert("TablesWithFiledsAliases", TablesWithFiledsAliases);
	
	For Each AdditionalTable In AdditionalTables Do
		OldGroup = GroupsNumbersByAliases.Get(AdditionalTable.Alias);
		If Not GroupsUse.Get(OldGroup) Then
			Continue;
		EndIf;
		SetUsingOfObjectTableField(Context, , AdditionalTable);
		SetBasicFieldUse(Context, , AdditionalTable);
		Group = NewGroups.Get(OldGroup);
		Groups.NumbersByAliases.Insert(AdditionalTable.Alias, Group);
		TablesGroup = Groups.TablesByGroups.Get(Group);
		If TablesGroup = Undefined Then
			TablesGroup = New Array;
			Groups.TablesByGroups.Insert(Group, TablesGroup);
		EndIf;
		TablesGroup.Add(AdditionalTable);
	EndDo;
	
	For Each FieldProperties In Context.FieldsProperties Do
		CurrentProperties = FieldProperties;
		While CurrentProperties <> Undefined Do
			AddLeadingListsByFieldsValues(Context,
				CurrentProperties.FieldNode,
				CurrentProperties.AttachmentProperties,
				?(CurrentProperties.IsListField, Undefined, CurrentProperties.TableAlias));
			CurrentProperties = CurrentProperties.AttachmentProperties;
		EndDo;
	EndDo;
	
	For Each ConditionFieldDetails In Context.AdditionalTablesMergeConditionsFields Do
		Group = Groups.NumbersByAliases.Get(ConditionFieldDetails.ConditionTableAlias);
		If Group <> Undefined Then
			FieldNode = ConditionFieldDetails.FieldNode;
			AddVersionProperties(Context, FieldNode, "Alias, Name, TypesString");
			AddLeadingListsByFieldsValues(Context, FieldNode,,
				Groups.TablesByGroups.Get(Group), ConditionFieldDetails.ConditionTableAlias);
		EndIf;
	EndDo;
	
	For Each LongDesc In Context.LeadingListsByFieldsValues.FiltersConnections Do
		FillFiltersByLeadingListFieldsValues(LongDesc.Key,
			LongDesc.Value, Groups, Context);
	EndDo;
	FillLeadingListsFiltersByFieldRef(Context.LeadingListsByAccessKeys, Groups, Context);
	FillLeadingListsFiltersByFieldRef(Context.LeadingListsByValuesWithGroups, Groups, Context);
	
	Return Groups;
	
EndFunction

// For the AdditionalTablesGroups function.
Function ConnectionConditionText(AdditionalTable, Context,
			Condition = Null, Field = Undefined, Alias = Undefined)
	
	If Condition = Null Then
		Condition = AdditionalTable.ConnectionCondition;
	EndIf;
	
	// Possible nodes: "Field", ''Value", "Constant", "AND", "=".
	
	If Condition.Node = "Field" Then
		Context.AdditionalTablesMergeConditionsFields.Add(New Structure(
			"FieldNode, ConditionTableAlias", Condition, AdditionalTable.Alias));
		AddObjectTableField(Context, Condition, , AdditionalTable);
		If Condition.Alias = Context.RestrictionStructure.MainTableAlias Then
			AddBasicField(Context, Condition, , AdditionalTable);
			Alias = "CurrentList";
			Field = Alias + "." + Condition.Name;
			Return FieldNameExpandingBasicFieldsByTypes(Alias, Condition);
		EndIf;
		Alias = Condition.Alias;
		If Alias = AdditionalTable.Alias Then
			If AdditionalTable.ConnectionTestField = "" Then
				AdditionalTable.ConnectionTestField = Alias + "." + Condition.Name;
			EndIf;
		ElsIf AdditionalTable.RequiredTablesAliases.Find(Alias) = Undefined Then
			AdditionalTable.RequiredTablesAliases.Add(Alias);
		EndIf;
		Field = Alias + "." + Condition.Name;
		Return Field;
	EndIf;
	
	If Condition.Node = "Value"
	 Or Condition.Node = "Constant" Then
		
		Field = ValueOrConstantNodeExpression(Condition);
		Return Field;
	EndIf;
	
	If Condition.Node = "And" Then
		Text = "";
		For Each Argument In Condition.Arguments Do
			Text = Text + ?(Text = "", "", Chars.LF + "And ");
			Text = Text + ConnectionConditionText(AdditionalTable, Context, Argument);
		EndDo;
		Return Text;
	EndIf;
	
	If Condition.Node = "=" Then
		FirstField = NewConnectionConditionField();
		SecondField = NewConnectionConditionField();
		
		FirstArgument = ConnectionConditionText(AdditionalTable,
			Context, Condition.FirstArgument, FirstField.Field, FirstField.Alias);
		
		SecondArgument = ConnectionConditionText(AdditionalTable,
			Context, Condition.SecondArgument, SecondField.Field, SecondField.Alias);
		
		If FirstField.Alias = AdditionalTable.Alias
		 Or Not ValueIsFilled(SecondField.Alias) Then
			ConditionText = "(" + FirstArgument + " = " + SecondArgument + ")";
			ConditionFields = FieldsPairConnectionConditions(FirstField, SecondField);
		Else
			ConditionText = "(" + SecondArgument + " = " + FirstArgument + ")";
			ConditionFields = FieldsPairConnectionConditions(SecondField, FirstField);
		EndIf;
		AdditionalTable.ConnectionConditionFields.Add(ConditionFields);
		Return ConditionText;
	EndIf;
	
	ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
		NStr("en = 'No processing rule is defined for the ""%1"" node.';"), Condition.Node);
	
	Raise ErrorText;
	
EndFunction

// Returns:
//  Structure:
//    * FirstField - See NewConnectionConditionField
//    * SecondField - See NewConnectionConditionField
//
Function FieldsPairConnectionConditions(FirstField, SecondField)
	
	Return New Structure("FirstField, SecondField", FirstField, SecondField);
	
EndFunction

// Returns:
//  Structure:
//    * Field      - String
//    * Alias - String
//
Function NewConnectionConditionField()
	
	Return New Structure("Field, Alias");
	
EndFunction

// For the FieldProperties and ConnectionConditionText functions.
Procedure AddObjectTableField(Context, FieldNode, FieldProperties = Undefined, AdditionalTable = Undefined, TabularSection = "")
	
	If Not Context.IsReferenceType Then
		Return;
	EndIf;
	
	ObjectTableName = Context.List;
	
	If ValueIsFilled(FieldNode.Alias)
	   And FieldNode.Alias <> Context.RestrictionStructure.MainTableAlias
	   And Upper(Context.List) <> Upper(FieldNode.Table) Then
		
		TableNameParts = StrSplit(FieldNode.Table, ".", False);
		If TableNameParts.Count() <> 3 Then
			Return;
		EndIf;
		ObjectTableName = Context.List + "." + TableNameParts[2];
	EndIf;
	
	FieldNameParts = StrSplit(FieldNode.Name, ".", False);
	If ValueIsFilled(TabularSection) Then
		TableFieldName = FieldNameParts[1];
		TableFieldTypes = FieldNode.FieldTypes[1];
		ObjectTableName = Context.List + "." + TabularSection;
	Else
		TableFieldName = FieldNameParts[0];
		TableFieldTypes = FieldNode.FieldTypes[0];
	EndIf;
	
	ObjectTablesFields = Context.ObjectTablesFields;
	ObjectTableName = StrReplace(ObjectTableName, ".", "_");
	
	If FieldProperties <> Undefined Then
		TableFieldDescription = New Structure("Table, Field", ObjectTableName, TableFieldName);
		ObjectTablesFields.ByFIeldProperties.Insert(FieldProperties, TableFieldDescription);
	EndIf;
	
	If AdditionalTable <> Undefined Then
		TablesFields = ObjectTablesFields.ByAdditionalTables.Get(AdditionalTable);
		If TablesFields = Undefined Then
			TablesFields = New Structure;
			ObjectTablesFields.ByAdditionalTables.Insert(AdditionalTable, TablesFields);
		EndIf;
		If Not TablesFields.Property(ObjectTableName) Then
			TablesFields.Insert(ObjectTableName, New Array);
		EndIf;
		TableFields = TablesFields[ObjectTableName]; // Array
		TableFields.Add(TableFieldName);
	EndIf;
	
	If Not ObjectTablesFields.Content.Property(ObjectTableName) Then
		ObjectTablesFields.Content.Insert(ObjectTableName, New Structure);
	EndIf;
	TableFields = ObjectTablesFields.Content[ObjectTableName];
	If Not TableFields.Property(TableFieldName) Then
		TableFields.Insert(TableFieldName, New Structure("Type, Use", TableFieldTypes, False));
	EndIf;
	
EndProcedure

// For the FieldProperties and ConnectionConditionText functions.
Procedure AddBasicField(Context, FieldNode, FieldProperties = Undefined, AdditionalTable = Undefined)
	
	If Not FieldNode.Property("DefaultOrder") Then
		Return;
	EndIf;
	
	Position = StrFind(FieldNode.Name, ".");
	If Position = 0 Then
		BasicFieldName = FieldNode.Name;
	Else
		BasicFieldName = Left(FieldNode.Name, Position - 1);
	EndIf;
	
	BasicFields = Context.BasicFields;
	
	If FieldProperties <> Undefined Then
		BasicFields.ByFIeldProperties.Insert(FieldProperties, BasicFieldName);
	EndIf;
	
	If AdditionalTable <> Undefined Then
		BasicFieldsNames = BasicFields.ByAdditionalTables.Get(AdditionalTable);
		If BasicFieldsNames = Undefined Then
			BasicFieldsNames = New Array;
			BasicFields.ByAdditionalTables.Insert(AdditionalTable, BasicFieldsNames);
		EndIf;
		BasicFieldsNames.Add(BasicFieldName);
	EndIf;
	
	If BasicFields.List.FindByValue(BasicFieldName) = Undefined Then
		BasicFields.List.Add(BasicFieldName, FieldNode.DefaultOrder);
		BasicFieldTypes = FieldNode.FieldTypes[0];
		BasicFields.TypesByFieldNames.Insert(BasicFieldName, BasicFieldTypes);
		If Not ValueIsFilled(Context.SeparateKeysRegisterName) Then
			RestrictedTypes = New Array;
			If HasSimpleType(BasicFieldTypes) Then
				For Each Type In BasicFieldTypes.Types() Do
					If IsSimpleType(Type) Then
						RestrictedTypes.Add(String(Type));
					EndIf;
				EndDo;
				ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("en = 'In the access restriction of the %1 list,
					           |the %2 basic field contains simple types: %3.
					           |
					           |It is not allowed if you use the shared information register ""%4"".
					           |Either exclude simple types from the basic field types,
					           |or create a separate register of access keys for this list.';"),
					Context.List,
					BasicFieldName,
					StrConcat(RestrictedTypes, ", "),
					"AccessKeysForRegisters");
				
				If Context.Property("ErrorOnCallException") Then
					Context.ErrorOnCallException.Text = ErrorText;
				EndIf;
				Raise ErrorText;
			EndIf;
		EndIf;
	EndIf;
	
EndProcedure

// For the DeleteNotUsedAccessKindsFields and AdditionalTablesGroups procedures.
Procedure SetUsingOfObjectTableField(Context, FieldProperties = Undefined, AdditionalTable = Undefined)
	
	If Not Context.IsReferenceType Then
		Return;
	EndIf;
	
	ObjectTablesFields = Context.ObjectTablesFields;
	
	If FieldProperties <> Undefined Then
		FieldDetails = ObjectTablesFields.ByFIeldProperties.Get(FieldProperties);
		If FieldDetails <> Undefined Then
			ObjectTablesFields.Content[FieldDetails.Table][FieldDetails.Field].Use = True;
		EndIf;
	Else
		TablesFields = ObjectTablesFields.ByAdditionalTables.Get(AdditionalTable);
		If TablesFields <> Undefined Then
			For Each FieldsDetails In TablesFields Do
				TableFields = ObjectTablesFields.Content[FieldsDetails.Key];
				For Each FieldName In FieldsDetails.Value Do
					TableFields[FieldName].Use = True;
				EndDo;
			EndDo;
		EndIf;
	EndIf;
	
EndProcedure

// For the DeleteNotUsedAccessKindsFields and AdditionalTablesGroups procedures.
Procedure SetBasicFieldUse(Context, FieldProperties = Undefined, AdditionalTable = Undefined)
	
	BasicFields = Context.BasicFields;
	
	If FieldProperties <> Undefined Then
		BasicFieldName = BasicFields.ByFIeldProperties.Get(FieldProperties);
		If BasicFieldName <> Undefined Then
			BasicFields.List.FindByValue(BasicFieldName).Check = True;
		EndIf;
	Else
		BasicFieldsNames = BasicFields.ByAdditionalTables.Get(AdditionalTable);
		If BasicFieldsNames <> Undefined Then
			For Each BasicFieldName In BasicFieldsNames Do
				BasicFields.List.FindByValue(BasicFieldName).Check = True;
			EndDo;
		EndIf;
	EndIf;
	
EndProcedure

// For the FillFieldsAndAdditionalTablesGroups procedure.
//
// Parameters:
//  Context - See ParametersContextByRestrictionStructure
//
Procedure FinishPreparingObjectTablesFields(Context)
	
	ObjectTablesFields = Context.ObjectTablesFields;
	
	If Not Context.IsReferenceType Then
		ObjectTablesFields.Delete("ByFIeldProperties");
		ObjectTablesFields.Delete("ByAdditionalTables");
		Return;
	EndIf;
	
	FullNameOfMainTable = StrReplace(Context.List, ".", "_");
	RefType = New TypeDescription(CommonClientServer.ValueInArray(
		Type(RefTypeName1(Context.List, Context.RestrictionStructure.InternalData.TablesTypesByNames))));
	
	For Each TableDetails In ObjectTablesFields.Content Do
		TableFields = NewObjectTableFields();
		TableFields.FullTableName = TableDetails.Key;
		ValueTable = New ValueTable;
		HasUsedFields = False;
		For Each FieldDetails In TableDetails.Value Do
			If Not FieldDetails.Value.Use Then
				Continue;
			EndIf;
			HasUsedFields = True;
			If Upper("Ref") = Upper(FieldDetails.Key) Then
				Continue;
			EndIf;
			TableFields.Fields.Add(FieldDetails.Key);
			ValueTable.Columns.Add(FieldDetails.Key, FieldDetails.Value.Type);
		EndDo;
		If Not HasUsedFields Then
			Continue;
		EndIf;
		TableFields.FieldList = StrConcat(TableFields.Fields, ", ");
		TableFields.Fields.Insert(0, "Ref");
		ValueTable.Columns.Add("Ref", RefType);
		TableFields.TableWithFields = New ValueStorage(ValueTable);
		If TableFields.FullTableName <> FullNameOfMainTable Then
			TableFields.TabularSection = Mid(TableFields.FullTableName,
				StrLen(FullNameOfMainTable) + 2);
		EndIf;
		ObjectTablesFields.Result.Add(TableFields);
	EndDo;
	
	ObjectTablesFields.Delete("ByFIeldProperties");
	ObjectTablesFields.Delete("ByAdditionalTables");
	
EndProcedure

// For the FillFieldsAndAdditionalTablesGroups procedure.
//
// Parameters:
//  Context - See ParametersContextByRestrictionStructure
//
Procedure CompleteBasicFieldsPreparation(Context)
	
	BasicFields = Context.BasicFields;
	BasicFields.List.SortByPresentation();
	
	For Each ListItem In BasicFields.List Do
		BasicFields.All.Add(ListItem.Value);
		BasicFields.AllItemsTypes.Add(New ValueStorage(
			BasicFields.TypesByFieldNames.Get(ListItem.Value)));
		
		If ListItem.Check Then
			BasicFields.UsedItems.Add(ListItem.Value);
			BasicFields.UsedItemsTypes.Add(New ValueStorage(
				BasicFields.TypesByFieldNames.Get(ListItem.Value)));
		EndIf;
	EndDo;
	
	BasicFields.Delete("List");
	BasicFields.Delete("TypesByFieldNames");
	BasicFields.Delete("ByFIeldProperties");
	BasicFields.Delete("ByAdditionalTables");
	
EndProcedure

// For the ConnectionConditionText and FieldProperties functions.
Function FieldNameExpandingBasicFieldsByTypes(Alias, FieldNode)
	
	If Not FieldNode.Property("DefaultOrder")
	 Or Not FieldNode.Property("NextFieldTables") Then
		
		Return Alias + "." + FieldNode.Name;
	EndIf;
	
	NumberOfTables = FieldNode.NextFieldTables[0].Count();
	
	If NumberOfTables >= 70 Then // 
		Return Alias + "." + FieldNode.Name;
	EndIf;
	
	Position = StrFind(FieldNode.Name, ".");
	BasicField = Alias + "." + Left(FieldNode.Name, Position - 1);
	OtherFields1 = Mid(FieldNode.Name, Position + 1);
	
	FieldName = "";
	For Each TypeName In FieldNode.NextFieldTables[0] Do
		CurrentFieldName = StrTemplate("CAST (%1 AS %2).%3", BasicField,  TypeName, OtherFields1); // @query-part-1
		If ValueIsFilled(FieldName) Then
			FieldName = // @query-part-1
				"ISNULL(" + CurrentFieldName + ",
				|	" + TextWithIndent(FieldName, "	") + ")";
		Else
			FieldName = CurrentFieldName;
		EndIf;
	EndDo;
	
	Return FieldName;
	
EndFunction

// For the AccessRestrictionParameters function.
Procedure FillFieldProperties(Context)
	
	// 1. Для полей-
	// 
	
	// 
	// 
	// 
	
	// 
	//    
	
	Context.BasicFields.Insert("TypesByFieldNames", New Map);
	Context.BasicFields.Insert("ByFIeldProperties",  New Map);
	Context.ObjectTablesFields.Insert("ByFIeldProperties", New Map);
	
	AllFieldsProperties = New Map;
	AccessKeyFieldsBeforeSimplify = Context.RestrictionStructure.InternalData.AccessKeyFields;
	For Each FieldDetails In AccessKeyFieldsBeforeSimplify Do
		FieldProperties = FieldProperties(FieldDetails.Field, Context);
		AllFieldsProperties.Insert(FieldDetails.Field, FieldProperties);
	EndDo;
	Context.Insert("AllFieldsProperties", AllFieldsProperties);
	
	Context.Insert("RemainingFieldsAfterSimplify", New Map);
	Context.Insert("InitialRestrictionStructure", Context.RestrictionStructure);
	Context.Insert("ThereIsAFunctionAccessRightOrRoleAvailable", False);
	
	RestrictionStructure = New Structure(New FixedStructure(Context.RestrictionStructure)); // See RestrictionStructure
	Context.Insert("NameOfRight", "Read");
	RestrictionStructure.ReadRestriction = SimplifiedRestrictionCondition(
		RestrictionStructure.ReadRestriction, Context, True);
	Context.Insert("IsThereFunctionAccessRightOrRoleAvailableInReadRestriction",
		Context.ThereIsAFunctionAccessRightOrRoleAvailable);
	Context.Insert("NameOfRight", "Update");
	RestrictionStructure.UpdateRestriction = SimplifiedRestrictionCondition(
		RestrictionStructure.UpdateRestriction, Context, True);
	Context.Insert("RestrictionStructure", RestrictionStructure);
	
	AccessKeyFieldsAfterSimplify = New Array; // Array of See NewAccessKeyField
	For Each FieldDetails In AccessKeyFieldsBeforeSimplify Do
		FieldParents = Context.RemainingFieldsAfterSimplify.Get(FieldDetails.Field); // Array of See NodeDetails
		If FieldParents = Undefined Then
			Continue;
		EndIf;
		FieldParents.Add(New Structure("Node", ""));
		FieldDetails.Insert("Parents", FieldParents);
		AccessKeyFieldsAfterSimplify.Add(FieldDetails);
	EndDo;
	Context.Insert("AccessKeyFieldsAfterSimplify", AccessKeyFieldsAfterSimplify);
	
	Context.Insert("AccessKeyFieldsProperties", New Map);
	Context.Insert("ReverseUserType", ?(Context.ForExternalUsers,
		Type("CatalogRef.Users"), Type("CatalogRef.ExternalUsers")));
	Context.Insert("ReverseUserGroupType", ?(Context.ForExternalUsers,
		Type("CatalogRef.UserGroups"), Type("CatalogRef.ExternalUsersGroups")));
	AddedFields = New Map;
	FieldsNamesForQuery = New Array;
	For Each FieldDetails In AccessKeyFieldsAfterSimplify Do
		FieldProperties = AllFieldsProperties.Get(FieldDetails.Field); // See FieldProperties
		FieldProperties.Insert("Read",    FieldDetails.Read);
		FieldProperties.Insert("Update", FieldDetails.Update);
		ClarifyComparisonFieldProperties(FieldProperties, FieldDetails, Context);
		FieldsSet = WhenConditionFieldsSet(FieldProperties, FieldDetails, Context);
		For Each FieldProperties In FieldsSet Do
			AddFieldTypesProperties(FieldProperties, FieldDetails, Context);
			SimilarFields = AddedFields.Get(Upper(FieldProperties.FieldNameForQuery));
			If SimilarFields = Undefined Then
				SimilarFields = New Array;
				AddedFields.Insert(Upper(FieldProperties.FieldNameForQuery), SimilarFields);
				FieldsNamesForQuery.Add(FieldProperties.FieldNameForQuery);
			EndIf;
			SimilarFields.Add(FieldProperties);
		EndDo;
	EndDo;
	
	FieldsProperties = New Array; // Array of See FieldProperties
	CombinedFields = New Map;
	For Each FieldNameForQuery In FieldsNamesForQuery Do
		SimilarFields = AddedFields.Get(Upper(FieldNameForQuery));
		ProcessedSimilarFields = New Array;
		For Each FieldProperties In SimilarFields Do
			CombinedField = ProcessedCombinedField(ProcessedSimilarFields, FieldProperties);
			If CombinedField <> Undefined Then
				CombinedFields.Insert(FieldProperties, CombinedField);
				Continue;
			EndIf;
			ProcessedSimilarFields.Add(FieldProperties);
		EndDo;
		For Each FieldProperties In ProcessedSimilarFields Do
			FieldsProperties.Add(FieldProperties);
		EndDo;
	EndDo;
	
	For Each LongDesc In Context.AccessKeyFieldsProperties Do
		CombinedField = CombinedFields.Get(LongDesc.Value);
		If CombinedField <> Undefined Then
			Context.AccessKeyFieldsProperties[LongDesc.Key] = CombinedField;
		EndIf;
	EndDo;
	
	For Each FieldProperties In FieldsProperties Do
		FieldProperties.Insert("ConfigurationTypeSavingTypes", New Array);
		FieldProperties.Insert("ExtensionTypeSavingTypes",   New Array);
		FieldProperties.Insert("SimpleTypeSavingTypes",      New Array);
		
		For Each Type In FieldProperties.TypeSavingTypes Do
			MetadataObject = Undefined;
			TypeName = TypeNameInQueryLanguage(Type, MetadataObject);
			
			If StrFind(TypeName, ".") = 0 Then
				FieldProperties.SimpleTypeSavingTypes.Add(Type);
				
			ElsIf MetadataObject.ConfigurationExtension() = Undefined Then
				FieldProperties.ConfigurationTypeSavingTypes.Add(Type);
			Else
				FieldProperties.ExtensionTypeSavingTypes.Add(Type);
			EndIf;
		EndDo;
	EndDo;
	
	Context.Insert("FieldsProperties", FieldsProperties);
	
EndProcedure

// For the FillFieldsProperties procedure.
Function SimplifiedRestrictionCondition(Val Condition, Context, ConditionRoot = False, AddRemainingFields = True)
	
	If Not ValueIsFilled(Condition) Then
		Return Condition;
	EndIf;
	
	RemainingFieldsAfterSimplify = Context.RemainingFieldsAfterSimplify;
	Context.RemainingFieldsAfterSimplify = New Map;
	
	If Condition.Node = "Field" Then
		Context.RemainingFieldsAfterSimplify.Insert(Condition, New Array);
		
	ElsIf Condition.Node = "And"
	      Or Condition.Node = "Or" Then
		
		UnconditionalResult = ?(Condition.Node = "And", False, True);
		HasUnconditionalResult = False;
		Arguments = New Array;
		ThereIsAFunctionAccessRightOrRoleAvailable = Context.ThereIsAFunctionAccessRightOrRoleAvailable;
		For Each CurrentArgument In Condition.Arguments Do
			Argument = SimplifiedRestrictionCondition(CurrentArgument, Context);
			If Argument.Node <> "Constant" Then
				Arguments.Add(Argument);
			ElsIf Argument.Value = UnconditionalResult Then
				HasUnconditionalResult = True;
			EndIf;
		EndDo;
		If HasUnconditionalResult Or Arguments.Count() = 0 Then
			Context.ThereIsAFunctionAccessRightOrRoleAvailable = ThereIsAFunctionAccessRightOrRoleAvailable;
			Condition = New Structure("Node, Value", "Constant",
				?(HasUnconditionalResult, UnconditionalResult, True));
		ElsIf Arguments.Count() = 1 Then
			Condition = Arguments[0];
		Else
			Condition = New Structure("Node, Arguments", Condition.Node, Arguments);
		EndIf;
		
	ElsIf Condition.Node = "Not" Then
		Argument = SimplifiedRestrictionCondition(Condition.Argument, Context);
		If Argument.Node = "Constant" Then
			Condition = New Structure("Node, Value", "Constant",
				?(Argument.Value = "Empty", "Empty", Not Argument.Value));
		Else
			Condition = New Structure("Node, Argument", Condition.Node, Argument);
		EndIf;
		
	ElsIf Condition.Node = "ForAllRows"
	      Or Condition.Node = "ForAtLeastOneRow"
	      Or Condition.Node = "IsNull"
	      Or Condition.Node = "ValueType" Then
		
		Argument = SimplifiedRestrictionCondition(Condition.Argument, Context);
		If Argument.Node = "Constant" Then
			Condition = Argument;
		Else
			Condition = New Structure("Node, Argument", Condition.Node, Argument);
		EndIf;
		
	ElsIf Condition.Node = "="
	      Or Condition.Node = "<>" Then
		
		FirstArgument = SimplifiedRestrictionCondition(Condition.FirstArgument, Context);
		SecondArgument = SimplifiedRestrictionCondition(Condition.SecondArgument, Context);
		
		If FirstArgument.Node = "Constant"
		   And SecondArgument.Node = "Constant" Then
			
			Condition = New Structure("Node, Value", "Constant", ?(Condition.Node = "=",
				FirstArgument.Value =  SecondArgument.Value,
				FirstArgument.Value <> SecondArgument.Value));
		Else
			Condition = New Structure("Node, FirstArgument, SecondArgument",
				Condition.Node, FirstArgument, SecondArgument);
		EndIf;
		
	ElsIf Condition.Node = "In" Then
		Condition = New Structure("Node, SearchFor, Values",
			Condition.Node,
			SimplifiedRestrictionCondition(Condition.SearchFor, Context),
			Condition.Values);
		
	ElsIf Condition.Node = "Case" Then
		AllSelectionValuesTrue = True;
		AllSelectionValuesFalse   = True;
		AllSelectionValuesAreEmpty  = True;
		Case = New Structure("Node, Case, When, Else", Condition.Node, Condition.Case, New Array);
		NewConditionElse = Undefined;
		For Each When In Condition.When Do
			If Condition.Case = Undefined Then
				ConditionWhen = SimplifiedRestrictionCondition(When.Condition, Context);
				If ConditionWhen.Node = "Constant" Then
					If ConditionWhen.Value Then
						NewConditionElse = ?(NewConditionElse = Undefined, When.Value, NewConditionElse);
					EndIf;
					ValueWhen = SimplifiedRestrictionCondition(When.Value, Context, , False);
					Continue;
				EndIf;
			Else
				ConditionWhen = When.Condition;
			EndIf;
			ValueWhen = SimplifiedRestrictionCondition(When.Value, Context);
			ProcessSimplifiedSelectionValue(ValueWhen,
				AllSelectionValuesTrue, AllSelectionValuesFalse, AllSelectionValuesAreEmpty);
			StructureWhen = New Structure("Condition, Value", ConditionWhen, ValueWhen);
			Case.When.Add(StructureWhen);
		EndDo;
		ConditionElse = ?(NewConditionElse = Undefined, Condition.Else, NewConditionElse);
		Case.Else = SimplifiedRestrictionCondition(ConditionElse, Context);
		ProcessSimplifiedSelectionValue(Case.Else,
			AllSelectionValuesTrue, AllSelectionValuesFalse, AllSelectionValuesAreEmpty);
		If AllSelectionValuesTrue Or AllSelectionValuesFalse Or AllSelectionValuesAreEmpty Then
			Condition = New Structure("Node, Value", "Constant",
				?(AllSelectionValuesAreEmpty, "Empty", AllSelectionValuesTrue));
		ElsIf Case.When.Count() = 0 Then
			Condition = Case.Else;
		Else
			Condition = Case;
		EndIf;
		
	ElsIf Condition.Node = "ValueAllowed"
	      Or Condition.Node = "ObjectReadingAllowed"
	      Or Condition.Node = "ObjectUpdateAllowed" Then
		
		FieldProperties = Context.AllFieldsProperties.Get(Condition.Field);
		If FieldProperties = Undefined Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'Cannot simplify the restriction for the %1 right
				           |of the ""%2"" list.
				           |The field properties are not defined for node ""%3"".';"),
				Context.NameOfRight,
				Context.List,
				Condition.Node);
			Raise ErrorText;
		EndIf;
		FinalFieldTypes = FieldProperties.EndFieldType.Types();
		
		If Condition.Node = "ValueAllowed" Then
			Result = FunctionResultValueAllowed(Condition, FinalFieldTypes, Context);
		Else
			Result = FunctionResultObjectRightAllowed(Condition, FinalFieldTypes, Context);
		EndIf;
		
		If Result <> Undefined Then
			Condition = New Structure("Node, Value", "Constant", Result);
		Else
			Context.RemainingFieldsAfterSimplify.Insert(Condition.Field, New Array);
		EndIf;
		
	ElsIf Condition.Node = "IsAuthorizedUser"
	      Or Condition.Node = "ListReadingAllowed"
	      Or Condition.Node = "ListUpdateAllowed" Then
		
		Context.RemainingFieldsAfterSimplify.Insert(Condition.Field, New Array);
		
	ElsIf Condition.Node = "AccessRight"
	      Or Condition.Node = "IsInRole" Then
		
		Context.ThereIsAFunctionAccessRightOrRoleAvailable = True;
	
	ElsIf Condition.Node <> "Constant"
	        And Condition.Node <> "Value"
	        And Condition.Node <> "Type" Then
		
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Cannot simplify the restriction for the %1 right
			           |of the ""%2"" list.
			           |Node ""%3"" is not supported.';"),
			Context.NameOfRight,
			Context.List,
			Condition.Node);
		Raise ErrorText;
	EndIf;
	
	If Condition.Node = "Constant" Then
		If ConditionRoot And Condition.Value = "Empty" Then
			Condition.Value = True;
		EndIf;
	ElsIf AddRemainingFields Then
		For Each KeyAndValue In Context.RemainingFieldsAfterSimplify Do
			If Condition.Node <> "Field" Then
				FieldParents = KeyAndValue.Value; // Array of See NodeDetails
				FieldParents.Add(Condition);
			EndIf;
			RemainingFieldsAfterSimplify.Insert(KeyAndValue.Key, KeyAndValue.Value);
		EndDo;
	EndIf;
	Context.RemainingFieldsAfterSimplify = RemainingFieldsAfterSimplify;
	
	Return Condition;
	
EndFunction

// For the SimplifiedRestrictionCondition function.
Procedure ProcessSimplifiedSelectionValue(Condition,
			AllSelectionValuesTrue, AllSelectionValuesFalse, AllSelectionValuesAreEmpty)
	
	If Condition.Node <> "Constant" Then
		AllSelectionValuesTrue = False;
		AllSelectionValuesFalse   = False;
		AllSelectionValuesAreEmpty  = False;
		
	ElsIf Condition.Value = "Empty" Then
		AllSelectionValuesTrue = False;
		AllSelectionValuesFalse   = False;
		
	ElsIf Condition.Value Then
		AllSelectionValuesFalse  = False;
		AllSelectionValuesAreEmpty = False;
	Else
		AllSelectionValuesTrue = False;
		AllSelectionValuesAreEmpty  = False;
	EndIf;
	
EndProcedure

// For the SimplifiedRestrictionCondition function.
Function FunctionResultValueAllowed(Condition, FinalFieldTypes, Context)

	AccessKindsPropertiesByTypes = Context.AccessKindsProperties.ByGroupsAndValuesTypes;
	DisabledAsFalse = TypeClarification(Condition, "Disabled") = "False";
	
	ResultAlwaysFalse   = True;
	ResultAlwaysTrue = True;
	ThereIsResultEmpty    = False;
	
	For Each Type In FinalFieldTypes Do
		TypeName = TypeNameInQueryLanguage(Type);
		
		Refinement = TypeClarification(Condition, TypeName);
		If Refinement = "True" Then
			ResultAlwaysFalse = False;
			Continue;
		ElsIf Refinement = "False" Then
			ResultAlwaysTrue = False;
			Continue;
		EndIf;
		
		If Not CheckingType(Condition, TypeName) Then
			ResultAlwaysTrue = False;
			Continue;
		EndIf;
		
		AccessKindProperties = AccessKindsPropertiesByTypes.Get(Type);
		If AccessKindProperties = Undefined Then
			ResultAlwaysFalse = False;
			Continue;
		EndIf;
		
		If Not TheTypeOfAccessValuesUsed(Context, AccessKindProperties.ValuesType) Then
			If Context.UnusedAccessValueTypes.Find(AccessKindProperties.ValuesType) = Undefined Then
				Context.UnusedAccessValueTypes.Add(AccessKindProperties.ValuesType);
			EndIf;
			If DisabledAsFalse Then
				ResultAlwaysTrue = False;
				ThereIsResultEmpty = True;
			Else
				ResultAlwaysFalse = False;
			EndIf;
		Else
			ResultAlwaysTrue = False;
			ResultAlwaysFalse = False;
		EndIf;
	EndDo;
	
	If ResultAlwaysTrue Then
		Return True;
	ElsIf ResultAlwaysFalse Then
		If ThereIsResultEmpty Then
			Return "Empty";
		Else
			Return False;
		EndIf;
	EndIf;
	
	Return Undefined;
	
EndFunction

// For the FunctionResultValueAllowed function and the AddFieldTypesProperties procedure.
Function TheTypeOfAccessValuesUsed(Context, ValuesType)
	
	UsedValuesTypes = Context.UsedValuesTypes.ByTables.Get(Context.List);
	
	If UsedValuesTypes = Undefined Then
		If Context.UsedValuesTypes.FullTableName = Context.List
		 Or Not ValueIsFilled(Context.UsedValuesTypes.FullTableName) Then
			Return False;
		EndIf;
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'An error occurred when calling function %1 of common module %2:
			           |Access value
			           | types in use are not filled in for table %3.';"),
			"TheTypeOfAccessValuesUsed",
			"AccessManagementInternal",
			Context.List);
		Raise ErrorText;
	EndIf;
	
	Return UsedValuesTypes.Get(ValuesType) <> Undefined;
	
EndFunction

// For the SimplifiedRestrictionCondition function.
Function FunctionResultObjectRightAllowed(Condition, FinalFieldTypes, Context)

	If Context.AccessRestrictionEnabled Then
		Return Undefined;
	EndIf;
	
	ResultAlwaysTrue = True;
	
	For Each Type In FinalFieldTypes Do
		TypeName = TypeNameInQueryLanguage(Type);
		
		Refinement = TypeClarification(Condition, TypeName);
		If Refinement = "True" Then
			Continue;
		ElsIf Refinement = "False" Then
			ResultAlwaysTrue = False;
			Break;
		EndIf;
		
		If Not CheckingType(Condition, TypeName) Then
			ResultAlwaysTrue = False;
			Break;
		EndIf;
		
		Value = Context.RightsSettingsOwnersTypes.Get(Type);
		If Value = Undefined
		 Or Upper(Context.List) <> Upper(Value[0].RightsOwner) Then
		
			ResultAlwaysTrue = False;
			Break;
		EndIf;
	EndDo;
	
	If ResultAlwaysTrue Then
		Return True;
	EndIf;
	
	Return Undefined;
	
EndFunction

// For the FillFieldsProperties procedure.
Function ProcessedCombinedField(ProcessedSimilarFields, FieldProperties)
	
	For Each Field In ProcessedSimilarFields Do
		Compatible1 = True;
		If Field.TableAlias = "CurrentList"
		   And Field.MultipleValuesGroups <> FieldProperties.MultipleValuesGroups Then
			Continue;
		EndIf;
		// 
		// 
		For Each Type In FieldProperties.AccessKeySavingTypes Do
			If Field.ValueSavingTypes.Find(Type)        <> Undefined
			 Or Field.ValueGroupSavingTypes.Find(Type)   <> Undefined
			 Or Field.TypeSavingTypes.Find(Type)           <> Undefined
			 Or Field.ProhibitedTypeSavingTypes.Find(Type) <> Undefined
			 Or Field.AllowedTypeSavingTypes.Find(Type) <> Undefined Then
				Compatible1 = False;
				Break;
			EndIf;
		EndDo;
		For Each Type In Field.AccessKeySavingTypes Do
			If FieldProperties.ValueSavingTypes.Find(Type)        <> Undefined
			 Or FieldProperties.ValueGroupSavingTypes.Find(Type)   <> Undefined
			 Or FieldProperties.TypeSavingTypes.Find(Type)           <> Undefined
			 Or FieldProperties.ProhibitedTypeSavingTypes.Find(Type) <> Undefined
			 Or FieldProperties.AllowedTypeSavingTypes.Find(Type) <> Undefined Then
				Compatible1 = False;
				Break;
			EndIf;
		EndDo;
		If Not Compatible1 Then
			Continue;
		EndIf;
		// 
		// 
		For Each Type In FieldProperties.ValueGroupSavingTypes Do
			If Field.ValueSavingTypes.Find(Type)        <> Undefined
			 Or Field.TypeSavingTypes.Find(Type)           <> Undefined
			 Or Field.ProhibitedTypeSavingTypes.Find(Type) <> Undefined
			 Or Field.AllowedTypeSavingTypes.Find(Type) <> Undefined Then
				Compatible1 = False;
				Break;
			EndIf;
		EndDo;
		For Each Type In Field.ValueGroupSavingTypes Do
			If FieldProperties.ValueSavingTypes.Find(Type)        <> Undefined
			 Or FieldProperties.TypeSavingTypes.Find(Type)           <> Undefined
			 Or FieldProperties.ProhibitedTypeSavingTypes.Find(Type) <> Undefined
			 Or FieldProperties.AllowedTypeSavingTypes.Find(Type) <> Undefined Then
				Compatible1 = False;
				Break;
			EndIf;
		EndDo;
		// 
		// 
		For Each Type In FieldProperties.ProhibitedTypeSavingTypes Do
			If Not IsSimpleType(Type) Then
				Continue;
			EndIf;
			If Field.TypeSavingTypes.Find(Type)           <> Undefined
			 Or Field.AllowedTypeSavingTypes.Find(Type) <> Undefined Then
				Compatible1 = False;
				Break;
			EndIf;
		EndDo;
		For Each Type In Field.ProhibitedTypeSavingTypes Do
			If Not IsSimpleType(Type) Then
				Continue;
			EndIf;
			If FieldProperties.TypeSavingTypes.Find(Type)           <> Undefined
			 Or FieldProperties.AllowedTypeSavingTypes.Find(Type) <> Undefined Then
				Compatible1 = False;
				Break;
			EndIf;
		EndDo;
		If Not Compatible1 Then
			Continue;
		EndIf;
		// 
		Field.HasAdjustmentNull =
			Field.HasAdjustmentNull Or FieldProperties.HasAdjustmentNull;
		Field.HasAdjustmentUndefined =
			Field.HasAdjustmentUndefined Or FieldProperties.HasAdjustmentUndefined;
		Field.HasHeadListType =
			Field.HasHeadListType Or FieldProperties.HasHeadListType;
		Field.HasRightsSettingsOwnerType =
			Field.HasRightsSettingsOwnerType Or FieldProperties.HasRightsSettingsOwnerType;
		Field.HasAuthorizedUserCheck =
			Field.HasAuthorizedUserCheck Or FieldProperties.HasAuthorizedUserCheck;
		// 
		For Each Type In FieldProperties.EmptyRefSavingTypes Do
			If Field.EmptyRefSavingTypes.Find(Type) <> Undefined Then
				Continue;
			EndIf;
			Field.EmptyRefSavingTypes.Add(Type);
		EndDo;
		// 
		For Each Type In FieldProperties.AllowedTypeSavingTypes Do
			If Field.ValueSavingTypes.Find(Type)        <> Undefined
			 Or Field.TypeSavingTypes.Find(Type)           <> Undefined
			 Or Field.AllowedTypeSavingTypes.Find(Type) <> Undefined Then
				Continue;
			EndIf;
			IndexOf = Field.ProhibitedTypeSavingTypes.Find(Type);
			If IndexOf <> Undefined Then
				Field.ProhibitedTypeSavingTypes.Delete(IndexOf);
				Field.TypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			Field.AllowedTypeSavingTypes.Add(Type);
		EndDo;
		// 
		For Each Type In FieldProperties.ProhibitedTypeSavingTypes Do
			If Field.ValueSavingTypes.Find(Type)        <> Undefined
			 Or Field.TypeSavingTypes.Find(Type)           <> Undefined
			 Or Field.ProhibitedTypeSavingTypes.Find(Type) <> Undefined Then
				Continue;
			EndIf;
			IndexOf = Field.AllowedTypeSavingTypes.Find(Type);
			If IndexOf <> Undefined Then
				Field.AllowedTypeSavingTypes.Delete(IndexOf);
				Field.TypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			Field.ProhibitedTypeSavingTypes.Add(Type);
		EndDo;
		// 
		For Each Type In FieldProperties.TypeSavingTypes Do
			If Field.ValueSavingTypes.Find(Type) <> Undefined
			 Or Field.TypeSavingTypes.Find(Type)    <> Undefined Then
				Continue;
			EndIf;
			IndexOf = Field.ProhibitedTypeSavingTypes.Find(Type);
			If IndexOf <> Undefined Then
				Field.ProhibitedTypeSavingTypes.Delete(IndexOf);
			EndIf;
			IndexOf = Field.AllowedTypeSavingTypes.Find(Type);
			If IndexOf <> Undefined Then
				Field.AllowedTypeSavingTypes.Delete(IndexOf);
			EndIf;
			Field.TypeSavingTypes.Add(Type);
		EndDo;
		// 
		For Each Type In FieldProperties.ValueSavingTypes Do
			If Field.ValueSavingTypes.Find(Type) <> Undefined Then
				Continue;
			EndIf;
			IndexOf = Field.TypeSavingTypes.Find(Type);
			If IndexOf <> Undefined Then
				Field.TypeSavingTypes.Delete(IndexOf);
			EndIf;
			IndexOf = Field.ProhibitedTypeSavingTypes.Find(Type);
			If IndexOf <> Undefined Then
				Field.ProhibitedTypeSavingTypes.Delete(IndexOf);
			EndIf;
			IndexOf = Field.AllowedTypeSavingTypes.Find(Type);
			If IndexOf <> Undefined Then
				Field.AllowedTypeSavingTypes.Delete(IndexOf);
			EndIf;
			Field.ValueSavingTypes.Add(Type);
		EndDo;
		// 
		For Each Type In FieldProperties.UnusedAccessValueTypes Do
			If Field.UnusedAccessValueTypes.Find(Type) <> Undefined Then
				Continue;
			EndIf;
			Field.UnusedAccessValueTypes.Add(Type);
		EndDo;
		// 
		For Each Type In FieldProperties.UsedAccessValuesTypes Do
			If Field.UsedAccessValuesTypes.Find(Type) <> Undefined Then
				Continue;
			EndIf;
			Field.UsedAccessValuesTypes.Add(Type);
		EndDo;
		Field.Read = Field.Read Or FieldProperties.Read;
		If Field.TypesString <> FieldProperties.TypesString Then
			Field.TypesString = Field.TypesString + Chars.LF + FieldProperties.TypesString;
		EndIf;
		Return Field;
	EndDo;
	
	Return Undefined;
	
EndFunction

// For the FillFieldsProperties procedure.
Procedure ClarifyComparisonFieldProperties(Properties, FieldDetails, Context)
	
	Context.AccessKeyFieldsProperties.Insert(FieldDetails.Field, Properties);
	
	Parent = FieldDetails.Parents[0];
	
	Nodes = ",ValueType,=,<>,In,IsNull,"; // 
	If StrFind(Nodes, "," + Parent.Node + ",") = 0 Then
		Return;
	EndIf;
	
	If Parent.Node = "ValueType" Then
		ComparisonNodeParent = FieldDetails.Parents[1];
		
		If ComparisonNodeParent.SecondArgument = Parent Then
			NodeType         = ComparisonNodeParent.FirstArgument; // See NodeDetails
			NodeValueType = ComparisonNodeParent.SecondArgument;
		Else
			NodeType         = ComparisonNodeParent.SecondArgument; // See NodeDetails
			NodeValueType = ComparisonNodeParent.FirstArgument;
		EndIf;
		Context.AccessKeyFieldsProperties.Insert(NodeValueType, Properties);
		
		ValueTypeExpression = "VALUETYPE(" + Properties.FieldNameForQuery + ")"; // @query-part-1
		TypeExpression = "TYPE(" + NodeType.Name + ")"; // @query-part-1
		AsOneString = StrLen(ValueTypeExpression) + StrLen(TypeExpression) < 60;
		
		Properties.FieldNameForQuery = ValueTypeExpression + ?(AsOneString, " ", "
		|			") + ComparisonNodeParent.Node + " " + TypeExpression;
		
	ElsIf Parent.Node = "="
	      Or Parent.Node = "<>" Then
		
		ValueOrConstantNode = ?(Parent.SecondArgument = FieldDetails.Field,
			Parent.FirstArgument, Parent.SecondArgument);
		
		NodeExpression = ValueOrConstantNodeExpression(ValueOrConstantNode);
		AsOneString = StrLen(Properties.FieldNameForQuery) + StrLen(NodeExpression) < 60;
		
		Properties.FieldNameForQuery = Properties.FieldNameForQuery + ?(AsOneString, " ", "
		|			") + Parent.Node + " " + NodeExpression;
		
	ElsIf Parent.Node = "In" Then
		
		ValueList = "";
		For Each ValueOrConstantNode In Parent.Values Do
			ValueList = ValueList + ?(ValueList = "", "", ",");
			LastRow = StrGetLine(ValueList, StrLineCount(ValueList));
			If StrLen(LastRow) > 40 Then
				ValueList = ValueList + "
				|			";
			Else
				ValueList = ValueList + " ";
			EndIf;
			ValueList = ValueList
				+ ValueOrConstantNodeExpression(ValueOrConstantNode);
		EndDo;
		Properties.FieldNameForQuery = Properties.FieldNameForQuery + "
		|	IN (" + ValueList + ")";
	
	Else // 
		Properties.FieldNameForQuery = Properties.FieldNameForQuery + " IS NULL";
		Properties.Insert("CheckHasNull");
	EndIf;
	
	Properties.EndFieldType = New TypeDescription("Boolean");
	
EndProcedure

// For the FillFieldsProperties procedure.
Function WhenConditionFieldsSet(InitialFieldProperties, FieldDetails, Context)
	
	Parent = FieldDetails.Parents[0];
	FieldsSet = New Array;
	
	If Parent.Node <> "Case"
	 Or Parent.Case = Undefined Then
		
		FieldsSet.Add(InitialFieldProperties);
		Return FieldsSet;
	EndIf;
	
	// 
	// 
	
	For Each WhenDetails In Parent.When Do
		FixedProperties = New FixedStructure(InitialFieldProperties);
		Properties = New Structure(FixedProperties);
		
		NodeExpression = ValueOrConstantNodeExpression(WhenDetails.Condition);
		AsOneString = StrLen(Properties.FieldNameForQuery) + StrLen(NodeExpression) < 60;
		
		Properties.FieldNameForQuery = Properties.FieldNameForQuery + ?(AsOneString, " = ", "
		|			= ") + NodeExpression;
		
		Properties.EndFieldType = New TypeDescription("Boolean");
		FieldsSet.Add(Properties);
		
		Context.AccessKeyFieldsProperties.Insert(WhenDetails.Condition, Properties);
	EndDo;
	
	Return FieldsSet;
	
EndFunction

// For FieldProperties, ClarifyComparisonFieldProperties, and WhenConditionFieldsSet functions.
Function NoNullValue(FieldProperties, OneAdditionalTableWithFieldsInGroup)
	
	Return StrOccurrenceCount(FieldProperties.FieldNameForQuery, ".") = 1
	      And Not FieldProperties.Property("FieldContainsNull")
	      And (    StrStartsWith(FieldProperties.FieldNameForQuery, "CurrentList")
	         Or OneAdditionalTableWithFieldsInGroup);
	
EndFunction

// For the FillFieldsProperties procedure.
//
// Parameters:
//   Properties     - See FieldProperties
//   FieldDetails - See NewAccessKeyField
//   Context     - See ParametersContextByRestrictionStructure
//
Procedure AddFieldTypesProperties(Properties, FieldDetails, Context)
	
	Properties.Insert("AccessKeySavingTypes",               New Array);
	Properties.Insert("ValueGroupSavingTypes",               New Array);
	Properties.Insert("ValueSavingTypes",                    New Array);
	Properties.Insert("EmptyRefSavingTypes",                New Array);
	Properties.Insert("TypeSavingTypes",                       New Array);
	Properties.Insert("ProhibitedTypeSavingTypes",             New Array);
	Properties.Insert("AllowedTypeSavingTypes",             New Array);
	Properties.Insert("UnusedAccessValueTypes",         New Array);
	Properties.Insert("UsedAccessValuesTypes",           New Array);
	Properties.Insert("MultipleValuesGroups",                    False);
	Properties.Insert("IsAccessValueListWithValueGroups", False);
	Properties.Insert("HasAdjustmentNull",                         False);
	Properties.Insert("HasAdjustmentUndefined",                 False);
	Properties.Insert("HasHeadListType",                     False);
	Properties.Insert("HasRightsSettingsOwnerType",              False);
	Properties.Insert("HasAuthorizedUserCheck",   False);
	
	Parent = FieldDetails.Parents[0];
	
	If Parent.Node = "ObjectReadingAllowed"
	 Or Parent.Node = "ObjectUpdateAllowed"
	 Or Parent.Node = "ListReadingAllowed"
	 Or Parent.Node = "ListUpdateAllowed"
	 Or Parent.Node = "ValueAllowed"
	 Or Parent.Node = "IsAuthorizedUser" Then
		
		HasBlankRefClarification          = TypeClarified(Parent, "EmptyRef");
		Properties.HasAdjustmentNull         = TypeClarified(Parent, "Null") Or Properties.Property("HasExpress");
		Properties.HasAdjustmentUndefined = TypeClarified(Parent, "Undefined");
	EndIf;
	
	If Parent.Node = "ObjectReadingAllowed"
	 Or Parent.Node = "ObjectUpdateAllowed"
	 Or Parent.Node = "ListReadingAllowed"
	 Or Parent.Node = "ListUpdateAllowed" Then
		
		For Each Type In Properties.EndFieldType.Types() Do
			TypeName = TypeNameInQueryLanguage(Type);
			
			Refinement = TypeClarification(Parent, TypeName);
			If Refinement = "True" Then
				Properties.AllowedTypeSavingTypes.Add(Type);
				Continue;
			ElsIf Refinement = "False" Then
				Properties.ProhibitedTypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			
			If Not CheckingType(Parent, TypeName) Then
				Properties.ProhibitedTypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			
			If IsSimpleType(Type) Then
				Properties.AllowedTypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			
			If Type = Type("CatalogRef.MetadataObjectIDs")
			 Or Type = Type("CatalogRef.ExtensionObjectIDs") Then
				Properties.ValueSavingTypes.Add(Type);
				Properties.HasHeadListType = True;
				Continue;
			EndIf;
			
			If Parent.Node = "ListReadingAllowed"
			 Or Parent.Node = "ListUpdateAllowed" Then
				
				Properties.TypeSavingTypes.Add(Type);
				Properties.HasHeadListType = True;
				Continue;
			EndIf;
			
			If Context.ListsWithKeysRecordForDependentListsWithoutKeys <> Undefined
			   And Not Context.UsesRestrictionByOwner
			   And (    Context.ListsWithRestriction.Get(TypeName) = Undefined
			      Or Context.ListsWithDisabledRestriction.Get(TypeName) <> Undefined) Then
				
				Properties.TypeSavingTypes.Add(Type);
				Properties.HasHeadListType = True;
				Continue;
			EndIf;
			
			If HasBlankRefClarification Then
				Properties.EmptyRefSavingTypes.Add(Type);
			EndIf;
			
			HostRightName = ?(Parent.Node = "ObjectReadingAllowed", "Read", "Update");
			
			Value = Context.RightsSettingsOwnersTypes.Get(Type);
			If Value <> Undefined
			   And Upper(Context.List) = Upper(Value[0].RightsOwner) Then
				
				Properties.ValueSavingTypes.Add(Type);
				Properties.HasRightsSettingsOwnerType = True;
				RestrictionKind = "RightsSettings." + TypeName + "." + HostRightName;
				AddRightsRestrictionKind(RestrictionKind, Properties, Context, True);
				Continue;
			EndIf;
			
			Properties.AccessKeySavingTypes.Add(Type);
			If Context.ListsWithKeysRecordForDependentListsWithoutKeys = Undefined
			 Or (  Context.ListsWithRestriction.Get(TypeName) <> Undefined
			      And Context.ListsWithDisabledRestriction.Get(TypeName) = Undefined) Then
			   
				AddLeadingListByFieldRef(Context.LeadingListsByAccessKeys,
					TypeName, FieldDetails, Properties, Context);
				
				RestrictionKind = "Object." + TypeName + "." + HostRightName;
				AddRightsRestrictionKind(RestrictionKind, Properties, Context, True);
			EndIf;
		EndDo;
		
		Return;
	EndIf;
	
	If Parent.Node = "ValueAllowed" Then
		AccessKindsProperties = Context.AccessKindsProperties;
		DisabledAsFalse = TypeClarification(Parent, "Disabled") = "False";
		
		For Each Type In Properties.EndFieldType.Types() Do
			TypeName = TypeNameInQueryLanguage(Type);
			
			Refinement = TypeClarification(Parent, TypeName);
			If Refinement = "True" Then
				Properties.AllowedTypeSavingTypes.Add(Type);
				Continue;
			ElsIf Refinement = "False" Then
				Properties.ProhibitedTypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			
			If Not CheckingType(Parent, TypeName) Then
				Properties.ProhibitedTypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			
			AccessKindProperties = AccessKindsProperties.ByGroupsAndValuesTypes.Get(Type); // See AccessKindProperties
			If AccessKindProperties = Undefined Then
				Properties.AllowedTypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			
			If Type = Context.ReverseUserType
			 Or Type = Context.ReverseUserGroupType Then
				Properties.ProhibitedTypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			
			AddRightsRestrictionKind(AccessKindProperties.Name, Properties, Context);
			
			If Not TheTypeOfAccessValuesUsed(Context, AccessKindProperties.ValuesType) Then
				Properties.UnusedAccessValueTypes.Add(AccessKindProperties.ValuesType);
				
				If DisabledAsFalse Then
					Properties.ProhibitedTypeSavingTypes.Add(Type);
				Else
					Properties.AllowedTypeSavingTypes.Add(Type);
				EndIf;
				Continue;
			EndIf;
			
			Properties.UsedAccessValuesTypes.Add(AccessKindProperties.ValuesType);
			
			If AccessKindsProperties.ByValuesTypes.Get(Type) = Undefined Then
				// Group type of access values.
				If Context.List = Metadata.FindByType(Type).FullName()
				 Or Context.UserTypes.Find(Type) <> Undefined Then
					
					Properties.ValueSavingTypes.Add(Type);
				Else
					Properties.AllowedTypeSavingTypes.Add(Type);
				EndIf;
				Continue;
			EndIf;
			
			If HasBlankRefClarification Then
				Properties.EmptyRefSavingTypes.Add(Type);
			EndIf;
			
			If AccessKindsProperties.AccessValuesTypesWithGroups.Get(Type) = Undefined
			 Or Context.UserTypes.Find(Type) <> Undefined Then
				
				Properties.ValueSavingTypes.Add(Type);
				Continue;
			EndIf;
			Properties.ValueGroupSavingTypes.Add(Type);
			
			If Context.List = TypeName
			   And Upper(Properties.FieldNameForQuery) = Upper("CurrentList.Ref") Then // @query-part-1
				
				Properties.IsAccessValueListWithValueGroups = True;
			Else
				AddLeadingListByFieldRef(Context.LeadingListsByValuesWithGroups,
					TypeName, FieldDetails, Properties, Context);
			EndIf;
			
			If Not AccessKindProperties.MultipleValuesGroups Then
				Continue;
			EndIf;
			Properties.MultipleValuesGroups = True;
		EndDo;
		
		Return;
	EndIf;
	
	If Parent.Node = "IsAuthorizedUser" Then
		Properties.HasAuthorizedUserCheck = True;
		
		For Each Type In Properties.EndFieldType.Types() Do
			TypeName = TypeNameInQueryLanguage(Type);
			
			Refinement = TypeClarification(Parent, TypeName);
			If Refinement = "True" Then
				Properties.AllowedTypeSavingTypes.Add(Type);
				Continue;
			ElsIf Refinement = "False" Then
				Properties.ProhibitedTypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			
			If Not CheckingType(Parent, TypeName) Then
				Properties.ProhibitedTypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			
			If Type <> Type("CatalogRef.Users")
			   And Type <> Type("CatalogRef.ExternalUsers") Then
				
				Properties.ProhibitedTypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			
			If HasBlankRefClarification Then
				Properties.EmptyRefSavingTypes.Add(Type);
			EndIf;
			
			Properties.ValueSavingTypes.Add(Type);
		EndDo;
		
		Return;
	EndIf;
	
	// 
	Properties.ValueSavingTypes.Add(Type("Boolean"));
	
	If Properties.EndFieldType.Types().Count() = 1
	   And Properties.EndFieldType.ContainsType(Type("Boolean")) Then
		Return;
	EndIf;
	Properties.EndFieldType = New TypeDescription("Boolean");
	Properties.FieldNameForQuery = Properties.FieldNameForQuery + " = TRUE"; // @query-part-1
	
EndProcedure

// For the FieldsProperties and AddFieldTypesProperties functions.
Function TypeNameInQueryLanguage(Type, MetadataObject = Undefined)
	
	MetadataObject = Metadata.FindByType(Type);
	If MetadataObject <> Undefined Then
		Return MetadataObject.FullName();
	EndIf;
	
	Return String(Type);
	
EndFunction

// For the AddFieldTypesProperties procedure.
Procedure AddRightsRestrictionKind(RestrictionKind, FieldProperties, Context, ByObject = False)
	
	If FieldProperties.Read Then
		Context.AllRightsRestrictionsKinds.Insert("Read." + RestrictionKind, True);
	EndIf;
	If Not ByObject Or FieldProperties.Update Then
		Context.AllRightsRestrictionsKinds.Insert("Update." + RestrictionKind, True);
	EndIf;
	
EndProcedure

// For the FillFieldsProperties procedure.
//
// Parameters:
//  FieldNode - See NodeDetails
//  Context - See ParametersContextByRestrictionStructure
//  FieldProperties - See FieldProperties
//
// Returns:
//   Structure:
//     * TableAlias  - String
//     * FieldNameForQuery - String
//     * TabularSection    - String
//     * IsListField     - Boolean
//     * NoNullValue   - Boolean
//     * FieldContainsNull  - Undefined
//     * HasExpress      - Undefined
//     * FieldNode          - See NodeDetails
//     * AttachmentProperties  - See FieldProperties
//     * Read            - Boolean
//     * CheckHasNull  - Undefined
//     * AccessKeySavingTypes       - Array of Type
//     * ValueGroupSavingTypes       - Array of Type
//     * ValueSavingTypes            - Array of Type
//     * EmptyRefSavingTypes        - Array of Type
//     * TypeSavingTypes               - Array of Type
//     * ProhibitedTypeSavingTypes     - Array of Type
//     * AllowedTypeSavingTypes     - Array of Type
//     * UnusedAccessValueTypes - Array of Type
//     * UsedAccessValuesTypes   - Array of Type
//     * MultipleValuesGroups                    - Boolean
//     * IsAccessValueListWithValueGroups - Boolean
//     * HasAdjustmentNull                         - Boolean
//     * HasAdjustmentUndefined                 - Boolean
//     * HasHeadListType                     - Boolean
//     * HasRightsSettingsOwnerType              - Boolean
//     * HasAuthorizedUserCheck   - Boolean
//     * ConfigurationTypeSavingTypes     - Array of Type
//     * ExtensionTypeSavingTypes       - Array of Type
//     * SimpleTypeSavingTypes          - Array of Type
//     * AccessKeyFieldsGroupName          - String
//     * AccessKeyFieldsGroupAttributeName - String
//
Function FieldProperties(FieldNode, Context, FieldProperties = Undefined)
	
	Properties = New Structure;
	IsRootNode = FieldProperties = Undefined;
	
	If IsRootNode Then
		FieldProperties = Properties;
		// The IsNull() function can have only a field inside, it cannot have the Express() function.
		If ValueIsFilled(FieldNode.Cast) Then
			Types = New Array;
			Types.Add(RefTypeByFullMetadataName(FieldNode.Cast));
			EndFieldType = New TypeDescription(Types);
		Else
			EndFieldType = FieldNode.FieldTypes[FieldNode.FieldTypes.Count() - 1];
			If ValueIsFilled(FieldNode.IsNull) Then
				Types = New Array;
				Types.Add(ValueOrConstantNodeValueType(FieldNode.IsNull));
				EndFieldType = New TypeDescription(EndFieldType, Types);
			EndIf;
		EndIf;
	EndIf;
	
	If FieldNode.Attachment <> Undefined Then
		AttachmentProperties = FieldProperties(FieldNode.Attachment, Context, FieldProperties);
		TabularSection    = AttachmentProperties.TabularSection;
		TableAlias  = AttachmentProperties.TableAlias;
		FieldNameForQuery = AttachmentProperties.FieldNameForQuery + "." + FieldNode.Name;
		TypesString       = AttachmentProperties.TypesString + Chars.LF + FieldNode.TypesString;
	Else
		If TypeOf(FieldNode.FieldTypes[0]) = Type("TypeDescription") Then
			TabularSection = "";
			If ValueIsFilled(FieldNode.Alias)
			   And FieldNode.Alias <> Context.RestrictionStructure.MainTableAlias Then
				
				TableAlias = FieldNode.Alias;
				FieldNameForQuery = TableAlias + "." + FieldNode.Name;
			Else
				TableAlias = "CurrentList";
				AddBasicField(Context, FieldNode, FieldProperties);
				If Not ValueIsFilled(FieldNode.Cast) Then
					FieldNameForQuery = TextWithIndent(
						FieldNameExpandingBasicFieldsByTypes(TableAlias, FieldNode), "		");
				Else
					FieldNameForQuery = TableAlias + "." + FieldNode.Name;
				EndIf;
			EndIf;
		Else // Первая часть имени поля - 
			TabularSection = FieldNode.FieldTypes[0];
			TableAlias = "CurrentList" + TabularSection;
			NameParts = StrSplit(FieldNode.Name, ".");
			NameParts.Delete(0);
			FieldNameForQuery = TableAlias + "." + StrConcat(NameParts, ".");
		EndIf;
		AddObjectTableField(Context, FieldNode, FieldProperties,, TabularSection);
		TypesString = FieldNode.TypesString;
	EndIf;
	
	// The IsNull() function can have only a field inside, it cannot have the Express() function.
	If ValueIsFilled(FieldNode.IsNull) Then
		FieldNameForQuery = "ISNULL(" + FieldNameForQuery + ", " // @query-part-1
			+ ValueOrConstantNodeExpression(FieldNode.IsNull) + ")";
		
		If IsRootNode Then
			Properties.Insert("NoNullValue", True);
		EndIf;
	EndIf;
	
	If ValueIsFilled(FieldNode.Cast) Then
		FieldNameForQuery = "CAST(" + FieldNameForQuery + " AS " + FieldNode.Cast + ")"; // @query-part-1 @query-part-2
		FieldProperties.Insert("HasExpress");
	EndIf;
	
	Properties.Insert("TableAlias",  TableAlias);
	Properties.Insert("FieldNameForQuery", FieldNameForQuery);
	Properties.Insert("EndFieldType",  EndFieldType);
	Properties.Insert("TypesString",       TypesString);
	
	If FieldNode.Property("FieldContainsNull") Then
		Properties.Insert("FieldContainsNull");
	EndIf;
	
	// 
	Properties.Insert("TabularSection",    TabularSection);
	Properties.Insert("AttachmentProperties",  AttachmentProperties);
	Properties.Insert("FieldNode",          FieldNode);
	Properties.Insert("IsListField",
		TableAlias = "CurrentList"
		Or AttachmentProperties <> Undefined
		  And ValueIsFilled(AttachmentProperties.TabularSection));
	
	Return Properties;
	
EndFunction


// For the RestrictionParametersByRestrictionStructure function.
//
// Returns:
//   Structure:
//     * Fields              - Map
//     * FiltersConnections - Map
//
Function LeadingListsDetailsByFieldsValues()
	
	Return New Structure("Fields, FiltersConnections", New Map, New Map);
	
EndFunction

// For the AdditionalTablesGroups functions.
Procedure AddLeadingListsByFieldsValues(Context, FieldNode, AttachmentProperties = Undefined,
			TablesGroup = Undefined, ConditionTableAlias = Undefined)
	
	AdditionalContext = New Structure;
	AdditionalContext.Insert("ParentFieldProperties",    AttachmentProperties);
	AdditionalContext.Insert("TablesGroup",            TablesGroup);
	AdditionalContext.Insert("ConditionTableAlias", ConditionTableAlias);
	AdditionalContext.Insert("FieldTableAlias",    FieldNode.Alias);
	
	FieldsNames = StrSplit(FieldNode.Name, ".");
	
	If FieldNode.Attachment <> Undefined Then
		AddLeadingListFieldByFieldsValues(Context, FieldNode.Table, FieldsNames[0],
			FieldNode.FieldTypes[0], AdditionalContext, True, True);
		
	ElsIf ValueIsFilled(FieldNode.Alias)
	        And FieldNode.Alias <> Context.RestrictionStructure.MainTableAlias Then
		
		AddLeadingListFieldByFieldsValues(Context, FieldNode.Table, FieldsNames[0],
			FieldNode.FieldTypes[0], AdditionalContext);
	EndIf;
	
	FirstFieldIndex = ?(TypeOf(FieldNode.FieldTypes[0]) = Type("TypeDescription"), 0, 1);
	
	If FirstFieldIndex + 2 > FieldsNames.Count() Then
		Return;
	EndIf;
	
	ParentFieldProperties = New Structure("FieldNameForQuery, TabularSection");
	If AttachmentProperties <> Undefined Then
		FillPropertyValues(ParentFieldProperties, AttachmentProperties);
		ParentFieldProperties.FieldNameForQuery = ParentFieldProperties.FieldNameForQuery + "." + FieldsNames[FirstFieldIndex];
	Else
		If FirstFieldIndex > 0 Then
			ParentFieldProperties.TabularSection = FieldsNames[0];
		EndIf;
		If Not ValueIsFilled(FieldNode.Alias)
		 Or FieldNode.Alias = Context.RestrictionStructure.MainTableAlias Then
			
			ParentFieldAlias = "CurrentList";
			AdditionalContext.TablesGroup = Undefined;
		Else
			ParentFieldAlias = FieldNode.Alias;
		EndIf;
		ParentFieldProperties.FieldNameForQuery = ParentFieldAlias + "." + FieldsNames[FirstFieldIndex];
	EndIf;
	AdditionalContext.ParentFieldProperties = ParentFieldProperties;
	
	For IndexOf = FirstFieldIndex + 1 To FieldsNames.Count()-1 Do
		Field = FieldsNames[IndexOf];
		FieldType = FieldNode.FieldTypes[IndexOf];
		For Each Table In FieldNode.NextFieldTables[IndexOf-1] Do
			AddLeadingListFieldByFieldsValues(Context, Table, Field,
				FieldType, AdditionalContext, True, True);
		EndDo;
		ParentFieldProperties.FieldNameForQuery = ParentFieldProperties.FieldNameForQuery + "." + Field;
	EndDo;
	
EndProcedure

// For the AddLeadingListsByFieldsValues procedure.
Procedure AddLeadingListFieldByFieldsValues(Context, Table, Field, FieldType, AdditionalContext,
			IsMainTable = False, IsReferenceTableType = Undefined)
	
	If Not IsMainTable
	   And StrOccurrenceCount(Table, ".") = 2 Then
		
		NameContent = StrSplit(Table, ".");
		TabularSection = NameContent[2];
		NameContent.Delete(2);
		FullName = StrConcat(NameContent, ".");
	Else
		TabularSection = "";
		FullName = Table;
	EndIf;
	
	If TypeOf(AdditionalContext.TablesGroup) <> Type("Array")
	   And (    Upper(Field) = Upper("Ссылка") // @Non-NLS
	      Or Upper(Field) = Upper("Ref")) Then
		
		If IsReferenceTableType = Undefined Then
			NameContent = StrSplit(Table, ".");
			TableType = Context.RestrictionStructure.InternalData.TablesTypesByNames.Get(Upper(NameContent[0]));
			IsReferenceTableType = TableType.IsReferenceType;
		EndIf;
		If IsReferenceTableType Then
			Return;
		EndIf;
	EndIf;
	
	FieldsDetails      = Context.LeadingListsByFieldsValues.Fields.Get(FullName);
	ConnectionsDetails = Context.LeadingListsByFieldsValues.FiltersConnections.Get(FullName);
	
	If FieldsDetails = Undefined Then
		If IsReferenceTableType = Undefined Then
			NameContent = StrSplit(Table, ".");
			TableType = Context.RestrictionStructure.InternalData.TablesTypesByNames.Get(Upper(NameContent[0]));
			IsReferenceTableType = TableType.IsReferenceType;
		EndIf;
		FieldsDetails = New Structure;
		FieldsDetails.Insert("IsReferenceType", IsReferenceTableType);
		FieldsDetails.Insert("ForTracking", New Structure("HeaderFields, TabularSections",
			New Map, New Map));
		FieldsDetails.Insert("ForFilter", New Structure("HeaderFields, TabularSections",
			New Map, New Map));
		Context.LeadingListsByFieldsValues.Fields.Insert(FullName, FieldsDetails);
		
		ConnectionsDetails = New Structure("HeaderFields, TabularSections", New Map, New Map);
		Context.LeadingListsByFieldsValues.FiltersConnections.Insert(FullName, ConnectionsDetails);
	EndIf;
	
	InsertLeadingListFieldByFieldsValues(FieldsDetails.ForTracking, TabularSection, Field, FieldType);
	
	If ValueIsFilled(TabularSection) Then
		FiltersConnections = ConnectionsDetails.TabularSections.Get(TabularSection);
		If FiltersConnections = Undefined Then
			FiltersConnections = New Map;
			ConnectionsDetails.TabularSections.Insert(TabularSection, FiltersConnections);
		EndIf;
	Else
		FiltersConnections = ConnectionsDetails.HeaderFields;
	EndIf;
	
	If AdditionalContext.ParentFieldProperties <> Undefined Then
		If NameContent = Undefined Then
			NameContent = StrSplit(Table, ".");
			TableType = Context.RestrictionStructure.InternalData.TablesTypesByNames.Get(Upper(NameContent[0]));
		EndIf;
		RefType = New TypeDescription(TableType.LanguageRussian + "Ссылка." + NameContent[1]); // @Non-NLS
		InsertLeadingListFieldByFieldsValues(FieldsDetails.ForTracking, "", "Ref", RefType);
		InsertLeadingListFieldByFieldsValues(FieldsDetails.ForFilter,       "", "Ref", RefType);
		FieldNameForQuery = AdditionalContext.ParentFieldProperties.FieldNameForQuery;
		FilterConnection = FiltersConnections.Get(Upper(FieldNameForQuery));
		If FilterConnection = Undefined Then
			FilterConnection = New Structure;
			FilterConnection.Insert("FieldOrAlias", FieldNameForQuery);
			FilterConnection.Insert("FieldForFilter1",    "Ref");
			FilterConnection.Insert("TabularSection",   AdditionalContext.ParentFieldProperties.TabularSection);
			FilterConnection.Insert("TablesGroup",     AdditionalContext.TablesGroup);
			FiltersConnections.Insert(Upper(FieldNameForQuery), FilterConnection);
		EndIf;
	Else
		If TypeOf(AdditionalContext.TablesGroup) = Type("Array") Then
			FilterConnection = FiltersConnections.Get(Upper(AdditionalContext.FieldTableAlias));
			If FilterConnection = Undefined Then
				FilterConnection = New Structure;
				FilterConnection.Insert("FieldOrAlias", AdditionalContext.FieldTableAlias);
				FilterConnection.Insert("FieldForFilter1",    New Array);
				FilterConnection.Insert("TabularSection",   Undefined);
				FilterConnection.Insert("TablesGroup",     AdditionalContext.TablesGroup);
				FiltersConnections.Insert(Upper(AdditionalContext.FieldTableAlias), FilterConnection);
			EndIf;
			If FilterConnection.FieldForFilter1.Find(Field) = Undefined
			   And AdditionalContext.FieldTableAlias = AdditionalContext.ConditionTableAlias Then
				
				FilterConnection.FieldForFilter1.Add(Field);
				InsertLeadingListFieldByFieldsValues(FieldsDetails.ForFilter, TabularSection, Field, FieldType);
			EndIf;
		EndIf;
	EndIf;
	
EndProcedure

// For the AddLeadingListFieldByFieldsValues procedure.
Procedure InsertLeadingListFieldByFieldsValues(FieldsDetails, TabularSection, Field, FieldType)
	
	If ValueIsFilled(TabularSection) Then
		Fields = FieldsDetails.TabularSections.Get(TabularSection);
		If Fields = Undefined Then
			Fields = New Map;
			FieldsDetails.TabularSections.Insert(TabularSection, Fields);
		EndIf;
	Else
		Fields = FieldsDetails.HeaderFields;
	EndIf;
	
	If Fields.Get(Field) <> Undefined Then
		Return;
	EndIf;
	
	Fields.Insert(Field, New ValueStorage(FieldType));
	
EndProcedure

// For the RestrictionParametersByRestrictionStructure function.
//
// Returns:
//   Structure:
//     * Lists               - Map
//     * QueryKeysByTypes - Map
//     * FiltersConnections    - Map
//     * RefType            - TypeDescription
//
Function LeadingListsDetailsByFieldsRef()
	
	LongDesc = New Structure;
	LongDesc.Insert("Lists",               New Map);
	LongDesc.Insert("QueryKeysByTypes", New Map);
	LongDesc.Insert("FiltersConnections",    New Map);
	LongDesc.Insert("RefType",            New TypeDescription);
	
	Return LongDesc;
	
EndFunction

// For the AddFieldTypesProperties procedure.
Procedure AddLeadingListByFieldRef(LeadingLists, LeadingList, FieldNode, FieldProperties, Context)
	
	NameContent = StrSplit(LeadingList, ".");
	TableType = Context.RestrictionStructure.InternalData.TablesTypesByNames.Get(Upper(NameContent[0]));
	RefTypeName1 = TableType.LanguageRussian + "Ссылка." + NameContent[1]; // @Non-NLS
	
	LeadingLists.RefType = New TypeDescription(LeadingLists.RefType, RefTypeName1);
	RefType = Type(RefTypeName1);
	
	Keys = LeadingLists.QueryKeysByTypes.Get(RefType);
	If Keys = Undefined Then
		Keys = New Array;
		LeadingLists.QueryKeysByTypes.Insert(RefType, Keys);
		LeadingLists.Lists.Insert(LeadingList, True);
	EndIf;
	
	Var_Key = Upper(FieldProperties.FieldNameForQuery);
	If Keys.Find(Var_Key) = Undefined Then
		Keys.Add(Var_Key);
	EndIf;
	
	TablesGroup = ?(FieldProperties.IsListField, Undefined, FieldProperties.TableAlias);
	
	FilterConnection = LeadingLists.FiltersConnections.Get(Var_Key);
	If FilterConnection = Undefined Then
		FilterConnection = New Structure;
		FilterConnection.Insert("FieldOrAlias", FieldProperties.FieldNameForQuery);
		FilterConnection.Insert("FieldForFilter1",    "Ref"); // @query-part-2
		FilterConnection.Insert("TabularSection",   FieldProperties.TabularSection);
		FilterConnection.Insert("TablesGroup",     TablesGroup);
		LeadingLists.FiltersConnections.Insert(Var_Key, FilterConnection);
	EndIf;
	
EndProcedure

// For the AdditionalTablesGroups function.
Procedure FillFiltersByLeadingListFieldsValues(LeadingList, LongDesc, Groups, Context)
	
	FiltersConnections = New Array;
	For Each FilterConnection In LongDesc.HeaderFields Do
		FiltersConnections.Add(FilterConnectionTextByFieldsValues(FilterConnection.Value, Groups, Context));
	EndDo;
	LongDesc.HeaderFields = FiltersConnections;
	
	TabularSections = New Map;
	For Each TabularSectionDetails In LongDesc.TabularSections Do
		FiltersConnections = New Array;
		TabularSections.Insert(TabularSectionDetails.Key, FiltersConnections);
		For Each FilterConnection In TabularSectionDetails.Value Do
			FiltersConnections.Add(FilterConnectionTextByFieldsValues(FilterConnection.Value, Groups, Context));
		EndDo;
	EndDo;
	LongDesc.TabularSections = TabularSections;
	
EndProcedure

// For the AdditionalTablesGroups function.
Procedure FillLeadingListsFiltersByFieldRef(LeadingLists, Groups, Context)
	
	FiltersConnections = New Map;
	For Each FilterConnection In LeadingLists.FiltersConnections Do
		FiltersConnections.Insert(FilterConnection.Key,
			FilterConnectionTextByFieldsValues(FilterConnection.Value, Groups, Context));
	EndDo;
	LeadingLists.FiltersConnections = FiltersConnections;
	
EndProcedure

// For the FillFiltersByLeadingListFieldsValues procedure.
Function FilterConnectionTextByFieldsValues(Condition, Groups, Context)
	
	If Context.IsReferenceType Then
		AdditionalCondition = "
		|		AND (&QueryPlanClarification)"; // @query-part-1
	Else
		// @query-part-1 @query-part-3
		AdditionalCondition = ?(Not ValueIsFilled(Context.SeparateKeysRegisterName), "
		|		AND (CurrentList.Register = &RegisterID)", "") + "
		|		AND (CurrentList.AccessOption = &AccessOption)
		|		AND (&QueryPlanClarification)";
	EndIf;
	
	If Condition.TablesGroup = Undefined Or ValueIsFilled(Condition.TabularSection) Then
		JoinText = // @query-part-1
		"#CurrentDataForFilter AS CurrentDataForFilter
		|	INNER JOIN &CurrentList AS CurrentList
		|	ON (" + Condition.FieldOrAlias + " = CurrentDataForFilter." + Condition.FieldForFilter1 + ")";
		If ValueIsFilled(Condition.TabularSection) Then
			JoinText = StrReplace(JoinText,
				"&CurrentList", "&CurrentList." + Condition.TabularSection);
			JoinText = StrReplace(JoinText,
				"CurrentList" + Condition.TabularSection + ".", "CurrentList.");
		EndIf;
		Return JoinText + AdditionalCondition;
	EndIf;
	
	If TypeOf(Condition.TablesGroup) = Type("String") Then
		IsConnectionConditionField = False;
		FilterFieldsAlias = Condition.TablesGroup;
		Group = Groups.NumbersByAliases.Get(FilterFieldsAlias);
		TablesGroup = Groups.TablesByGroups.Get(Group);
	Else
		IsConnectionConditionField = True;
		TablesGroup = Condition.TablesGroup;
		FieldToReplace = Condition.FieldOrAlias;
		FilterFieldsAlias = StrSplit(FieldToReplace, ".")[0];
	EndIf;
	
	IndexOf = TablesGroup.Count();
	FirstAdditionalTableFound = False;
	BackwardTablesGroup = New Array;
	RequiredAliases = New Map;
	
	While IndexOf >= 1 Do
		IndexOf = IndexOf - 1;
		AdditionalTable = TablesGroup[IndexOf];
		CurrentAlias = AdditionalTable.Alias;
		If Not FirstAdditionalTableFound And CurrentAlias <> FilterFieldsAlias Then
			Continue;
		EndIf;
		FirstAdditionalTableFound = True;
		If CurrentAlias <> FilterFieldsAlias
		   And RequiredAliases.Get(AdditionalTable.Alias) = Undefined Then
			Continue;
		EndIf;
		TableProperties = New Structure("Table, Alias, ConnectionConditionFields",
			AdditionalTable.Table, AdditionalTable.Alias, New Array);
		BackwardTablesGroup.Add(TableProperties);
		For Each FieldsPair In AdditionalTable.ConnectionConditionFields Do
			RequiredAliases.Insert(FieldsPair.FirstField.Alias, True);
			RequiredAliases.Insert(FieldsPair.SecondField.Alias, True);
			TableProperties.ConnectionConditionFields.Add(
				New Structure(New FixedStructure(FieldsPair)));
		EndDo;
	EndDo;
	
	AuxiliaryTable = Undefined;
	FirstTable = BackwardTablesGroup[0];
	AllFieldsReplaceable = True;
	
	If IsConnectionConditionField Then
		For Each FieldsPair In FirstTable.ConnectionConditionFields Do
			If StrFind(FieldsPair.FirstField.Field, FirstTable.Alias + ".") > 0
			   And StrFind(FieldsPair.FirstField.Field, FieldToReplace + ".") = 0 Then
				AllFieldsReplaceable = False;
				Break;
			EndIf;
		EndDo;
	EndIf;
	
	If Not IsConnectionConditionField Or Not AllFieldsReplaceable Then
		AuxiliaryTable = New Structure("Table, Alias, ConnectionConditionFields",
			FirstTable.Table, "CurrentDataForFilter", New Array);
		BackwardTablesGroup.Insert(0, AuxiliaryTable);
		FieldsPair = New Structure("FirstField, SecondField");
		AuxiliaryTable.ConnectionConditionFields.Add(FieldsPair);
		FieldsPair.FirstField = New Structure("Field, Alias",
			Condition.FieldOrAlias, "CurrentDataForFilter");
		FieldsPair.SecondField = New Structure("Field, Alias",
			"CurrentDataForFilter." + Condition.FieldForFilter1, FilterFieldsAlias);
	EndIf;
	
	JoinText =
	"#CurrentDataForFilter AS CurrentDataForFilter";
	RemainingAliases = New Map;
	RemainingAliases.Insert("CurrentList", New Array);
	
	For Each AdditionalTable In BackwardTablesGroup Do
		RemainingAliases.Insert(AdditionalTable.Alias,
			New Array(New FixedArray(AdditionalTable.ConnectionConditionFields)));
	EndDo;
	
	TheFirstAliases = New Map;
	IndexOf = -1;
	For Each AdditionalTable In BackwardTablesGroup Do
		IndexOf = IndexOf + 1;
		
		FirstAlias = AdditionalTable.Alias;
		ConnectionConditionFields = RemainingAliases.Get(FirstAlias);
		RemainingAliases.Delete(FirstAlias);
		TheFirstAliases.Insert(FirstAlias, True);
		
		If IndexOf >= BackwardTablesGroup.Count() - 1 Then
			SecondAlias = "CurrentList";
		Else
			SecondAlias = BackwardTablesGroup[IndexOf + 1].Alias;
		EndIf;
		RemainingConnectionConditionFields = RemainingAliases.Get(SecondAlias);
		For Each FieldsPair In RemainingConnectionConditionFields Do
			ConnectionConditionFields.Add(FieldsPair);
		EndDo;
		RemainingAliases.Insert(SecondAlias, New Array);
		
		ConnectionConditions = New Array;
		For Each FieldsPair In ConnectionConditionFields Do
			If Not ValueIsFilled(FieldsPair.FirstField.Alias)
			   And Not ValueIsFilled(FieldsPair.SecondField.Alias) Then
				
				ConnectionConditions.Add(FieldsPair.FirstField.Field
					+ " = " + FieldsPair.SecondField.Field);
				
			ElsIf TheFirstAliases.Get(FieldsPair.FirstField.Alias) <> Undefined
			        And (Not ValueIsFilled(FieldsPair.SecondField.Alias)
			           Or FieldsPair.SecondField.Alias = SecondAlias)
			      Or FieldsPair.FirstField.Alias = SecondAlias
			        And Not ValueIsFilled(FieldsPair.SecondField.Alias) Then
				
				FirstField = FieldsPair.FirstField.Field;
				
				If TheFirstAliases.Get(FieldsPair.FirstField.Alias) <> Undefined
				   And FieldsPair.FirstField.Alias = FilterFieldsAlias
				   And AuxiliaryTable = Undefined
				   And StrStartsWith(FirstField, FieldToReplace) Then
					
					FieldEnd = Mid(FirstField, StrLen(FieldToReplace) + 1);
					FirstField = "CurrentDataForFilter"
						+ ?(FieldToReplace <> FilterFieldsAlias, ".Ref", "") + FieldEnd; // @query-part-2
				EndIf;
				If StrStartsWith(FirstField, "CurrentDataForFilter.") Then
					ConnectionConditions.Add(FieldsPair.SecondField.Field + " = " + FirstField);
					
				ElsIf StrStartsWith(FieldsPair.SecondField.Field, "CurrentDataForFilter.") Then
					ConnectionConditions.Add(FirstField + " = " + FieldsPair.SecondField.Field);
					
				ElsIf FieldsPair.SecondField.Alias = SecondAlias Then
					ConnectionConditions.Add(FieldsPair.SecondField.Field + " = " + FirstField);
				Else
					ConnectionConditions.Add(FirstField + " = " + FieldsPair.SecondField.Field);
				EndIf;
			Else
				RemainingConditions = RemainingAliases.Get(FieldsPair.FirstField.Alias);
				If RemainingConditions = Undefined Then
					RemainingConditions = RemainingAliases.Get(FieldsPair.SecondField.Alias);
				EndIf;
				RemainingConditions.Add(FieldsPair);
			EndIf;
		EndDo;
		If SecondAlias = "CurrentList" Then
			TableAndAlias = "&CurrentList AS CurrentList";
		Else
			NextTable = BackwardTablesGroup[IndexOf + 1];
			TableAndAlias = NextTable.Table + " AS " + NextTable.Alias;
		EndIf;
		// @query-part-1
		JoinText = JoinText + "
		|	INNER JOIN " + TableAndAlias + "
		|	On (" + StrConcat(ConnectionConditions, ")
		|		AND (") + ")";
	EndDo;
	
	Return JoinText + AdditionalCondition;
	
EndFunction


// For the AddBasicField, AddDimensionTypes, AddFieldTypesProperties, and
// AddCheckByTypes procedures and the FieldProperties function.
//
Function IsSimpleType(Type)
	
	Return Type = Type("Boolean")
	    Or Type = Type("Date")
	    Or Type = Type("String")
	    Or Type = Type("Number")
	    Or Type = Type("UUID")
	    Or Type = Type("ValueStorage");
	
EndFunction

// For the AddFieldTypesProperties function.
Function CheckingType(Node, FullName)
	
	If Node.Types.Count() = 0 Then
		Return True;
	EndIf;
	
	TypeSpecified = False;
	For Each TableName In Node.Types Do
		If Upper(TableName) = Upper(FullName) Then
			TypeSpecified = True;
			Break;
		EndIf;
	EndDo;
	
	Return Node.CheckTypesExceptListed And Not TypeSpecified
	 Or Not Node.CheckTypesExceptListed And    TypeSpecified;
	
EndFunction

// For the AddFieldTypesProperties function.
Function TypeClarified(Node, TypeNameInQueryLanguage)
	
	TypeClarified = False;
	For Each ComparisonClarification In Node.ComparisonClarifications Do
		If Upper(ComparisonClarification.Key) = Upper(TypeNameInQueryLanguage) Then
			TypeClarified = True;
			Break;
		EndIf;
	EndDo;
	
	Return TypeClarified;
	
EndFunction

// For the AddFieldTypesProperties function.
Function TypeClarification(Node, TypeNameInQueryLanguage)
	
	Refinement = "";
	For Each ComparisonClarification In Node.ComparisonClarifications Do
		If Upper(ComparisonClarification.Key) = Upper(TypeNameInQueryLanguage) Then
			Refinement = ComparisonClarification.Value;
			Break;
		EndIf;
	EndDo;
	
	Return Refinement;
	
EndFunction

// For the FieldProperties function.
Function ValueOrConstantNodeValueType(Node)
	
	If Node.Node = "Value" Then
		Return RefTypeByFullPredefinedItemName(Node.Name);
	EndIf;
	
	Return TypeOf(Node.Value);
	
EndFunction

// For the ConnectionConditionText, FieldProperties, and WhenConditionFieldsSet functions and
// the ClarifyComparisonFieldProperties procedure.
//
Function ValueOrConstantNodeExpression(Node)
	
	If Node.Node = "Value" Then
		Expression = "Value(" + Node.Name + ")";
	
	ElsIf TypeOf(Node.Value) = Type("Boolean") Then
		Expression = ?(Node.Value, "True", "False");
		
	ElsIf TypeOf(Node.Value) = Type("Number") Then
		Expression = Format(Node.Value, "NG=");
		
	ElsIf TypeOf(Node.Value) = Type("Undefined") Then
		Expression = "Undefined";
	Else
		Expression = """" + Node.Value + """";
	EndIf;
	
	Return Expression;
	
EndFunction

// For the ValueOrConstantNodeValueType function.
Function RefTypeByFullPredefinedItemName(FullPredefinedItemName)
	
	NameParts = StrSplit(FullPredefinedItemName, ".");
	NameParts.Delete(2);
	
	FullName = StrConcat(NameParts, ".");
	
	Return RefTypeByFullMetadataName(FullName);
	
EndFunction

// For the FieldProperties and RefTypeByFullPredefinedItemName functions.
Function RefTypeByFullMetadataName(FullName)
	
	If IsRussianVersionOfMetadataObjectKind(FullName) Then
		RefTypeName1 = StrReplace(FullName, ".", "Ссылка."); // @Non-NLS-2
	Else
		RefTypeName1 = StrReplace(FullName, ".", "Ref.");
	EndIf;
	
	Return Type(RefTypeName1);
	
EndFunction

// For the TableKey function.
Function RecordKeyTypeByFullMetadataName(FullName)
	
	If IsRussianVersionOfMetadataObjectKind(FullName) Then
		NameOfTheRecordKeyType = StrReplace(FullName, ".", "КлючЗаписи."); // @Non-NLS-2
	Else
		NameOfTheRecordKeyType = StrReplace(FullName, ".", "RecordKey.");
	EndIf;
	
	Return Type(NameOfTheRecordKeyType);
	
EndFunction

// For the TableKey function.
Function RecordsetTypeByFullMetadataName(FullName)
	
	If IsRussianVersionOfMetadataObjectKind(FullName) Then
		NameOfTheRecordsetType = StrReplace(FullName, ".", "НаборЗаписей."); // @Non-NLS-2
	Else
		NameOfTheRecordsetType = StrReplace(FullName, ".", "RecordSet.");
	EndIf;
	
	Return Type(NameOfTheRecordsetType);
	
EndFunction

// For the TableKey function.
Function ObjectManagerTypeByFullMetadataName(FullName)
	
	If IsRussianVersionOfMetadataObjectKind(FullName) Then
		NameOfTheManagerType = StrReplace(FullName, ".", "Менеджер."); // @Non-NLS-2
	Else
		NameOfTheManagerType = StrReplace(FullName, ".", "Manager.");
	EndIf;
	
	Return Type(NameOfTheManagerType);
	
EndFunction

// For the RefTypeByFullMetadataName, RecordKeyTypeByFullMetadataName,
// RecordSetTypeByFullMetadataName, ObjectManagerTypeByFullMetadataName functions.
//
Function IsRussianVersionOfMetadataObjectKind(FullName)
	
	FirstChar = Left(FullName, 1);
	
	Return FirstChar > "А"  // @Non-NLS
	      And FirstChar < "Я"  // @Non-NLS
	    Or FirstChar > "а"  // @Non-NLS
	      And FirstChar < "я"; // @Non-NLS
	
EndFunction

#EndRegion

#Region AccessRestrictionParametersQueryTextsForList

// Returns:
//  Map of KeyAndValue:
//   * Key - String
//   * Value - Array of String
//
Function KeyTableNewAttributes()
	Return New Map;
EndFunction

// The main function of the area, which is the second part
// of the RestrictionParametersByRestrictionStructure function.
// It is not used when preparing stored access restriction parameters,
// but is used when calling the RestrictionParameters function.
//
Procedure AddQueryTextsToRestrictionParameters(Result)
	
	CheckTypeToDefineAccessKeysToRegistersRegisterField(Result.Context);
	
	Context = Result.Context;
	Result.Delete("Context");
	
	// 
	Result.Insert("ReadEditRightsCheckQueryText");
	// 
	Result.Insert("ReadRightsCheckQueryText");
	// 
	Result.Insert("OwnerObjectFieldInRightsValidationQuery");
	
	AddDateQueryTextOfNextDataItem(Result, Context); 
	
	If Result.DoNotWriteAccessKeys Then
		// 
		Result.Insert("ObsoleteDataItemsQueryText");
		AddQueryTextOfObsoleteDataItems(Result, Context);
		
		If Result.UsesRestrictionByOwner Then
			// Generating right checking queries.
			FillReadUpdateRightsCheckQueries(Result, Context);
		EndIf;
		
		Return;
	EndIf;
	
	// 
	Result.Insert("KeyTables");
	// 
	Result.Insert("KeyTablesAttributes");
	
	// 
	Result.Insert("DataItemWithObsoleteKeysQueryText");
	// 
	Result.Insert("DataItemsWithoutAccessKeysQueryText");
	// 
	Result.Insert("NewBasicFieldsValuesCombinationsQueryTextForExistingRecords");
	Result.Insert("NewBasicFieldsValuesCombinationsQueryTextForNewRecords");
	// 
	// 
	Result.Insert("DetailsOfObsoleteAccessKeysForLeadingObjects", New Map);
	// 
	Result.Insert("ObsoleteDataItemsQueryText");
	
	// 
	Result.Insert("CurrentRegisterAccessKeysQueryText");
	
	// 
	Result.Insert("DataItemValueForAccessKeysQueryText");
	// 
	Result.Insert("TextOfQueryForInMemoryObjectsValuesForAccessKeys");
	// 
	Result.Insert("ValueFromAccessKeysInUseForComparisonQueryText");
	// 
	// 
	Result.Insert("ValueFromAllAccessKeysForComparisonQueryText");
	// 
	Result.Insert("KeysForComparisonExistenceQueryText");
	
	// 
	Result.Insert("AccessKeysQueryTextToUpdateRights");
	// 
	Result.Insert("KeysQueryTextByLeadingKeysToUpdateRights");
	// 
	Result.Insert("ValueFromAccessKeysForRightsCalculationQueryText");
	// 
	Result.Insert("ObsoleteAccessKeysQueryText");
	
	Context.Insert("SeparateRegister", True); // 
	
	Context.Insert("KeyTables",                                       New Array);
	Context.Insert("KeyTablesAttributes",                               KeyTableNewAttributes());
	Context.Insert("CheckConditionParts",                               New Array);
	Context.Insert("PartsOfValuesFromObjectsQuery",                     New Array);
	Context.Insert("PartsOfQueryForInMemoryObjectsValues",              New Array);
	Context.Insert("PartsOfValuesFromObjectsQueryToCompare",           New Array);
	Context.Insert("QueryPartsOfKeysExistenceToMap",        New Array);
	Context.Insert("PartsOfValuesFromKeysQueryToCalculateRights",         New Array);
	Context.Insert("ConditionPartsToSelectLeadingAccessKeysRights",         New Array);
	Context.Insert("ConditionPartsToSelectLeadingListsRights",               New Array);
	Context.Insert("ConditionPartsToSelectRightsByRightsSettingsOwners",     New Array);
	Context.Insert("PartsOfFilterConditionByLeadingAccessKeys",           New Array);
	Context.Insert("DetailsOfValidationRequestsOnLeadingObjects",          New Map);
	
	// Generating a query of data items with obsolete keys.
	FillTemplatesOfCheckQueryParts(Context);
	
	For HeaderNumber = 0 To 2 Do
		AddKeyHeaderCheck(Context, HeaderNumber);
	EndDo;
	
	For KeyTabularSectionNumber = 1 To Context.KeyTabularSectionsCount Do
		AddKeyTabularSectionCheck(Context, KeyTabularSectionNumber);
	EndDo;
	ComposeCheckQueryParts(Result, Context);
	
	// Generating queries of values from data items and keys.
	For HeaderNumber = 0 To 2 Do
		AddKeyHeaderFilling(Context, HeaderNumber);
	EndDo;
	AddKeysChoiceWithoutFieldsInHeader(Context);
	
	For KeyTabularSectionNumber = 1 To Context.KeyTabularSectionsCount Do
		AddKeyTabularSectionFilling(Context, KeyTabularSectionNumber);
	EndDo;
	ComposeFillQueryParts(Result, Context);
	
	Result.KeyTables         = Context.KeyTables;
	Result.KeyTablesAttributes = Context.KeyTablesAttributes;
	
	AddQueryTextOfObsoleteDataItems(Result, Context);
	
	// Generating right checking queries.
	FillReadUpdateRightsCheckQueries(Result, Context);
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure CheckTypeToDefineAccessKeysToRegistersRegisterField(Context)
	
	If Context.IsReferenceType Or Context.UsesRestrictionByOwner Then
		Return;
	EndIf;
	
	If Context.Property("SkipTypesToDefineCheck") Then
		Return;
	EndIf;
	
	If ValueIsFilled(Context.SeparateKeysRegisterName) Then
		Dimensions = Metadata.InformationRegisters[Context.SeparateKeysRegisterName].Dimensions;
	Else
		Dimensions = Metadata.InformationRegisters.AccessKeysForRegisters.Dimensions;
	EndIf;
	
	MissingTypes = New Map;
	Fields = New Map;
	MissingTypesList = New ValueList;
	FieldList = New ValueList;
	
	IndexOf = Context.BasicFields.AllItemsTypes.Count() - 1;
	While IndexOf >= 0 Do
		RequiredType = Context.BasicFields.AllItemsTypes.Get(IndexOf).Get();
		DimensionType = Dimensions["Field" + (IndexOf + 1)].Type;
		MissingType = New TypeDescription(RequiredType, , DimensionType.Types());
		For Each Type In MissingType.Types() Do
			If MissingTypes.Get(Type) = Undefined Then
				MissingTypes.Insert(Type, True);
				MissingTypesList.Add(RefTypeName1(TypeNameInQueryLanguage(Type),
					Context.RestrictionStructure.InternalData.TablesTypesByNames));
				Field = Context.BasicFields.All.Get(IndexOf);
				If Fields.Get(Field) = Undefined Then
					Fields.Insert(Field, True);
					FieldList.Add(Field);
				EndIf;
			EndIf;
		EndDo;
		IndexOf = IndexOf - 1;
	EndDo;
	
	If MissingTypesList.Count() = 0 Then
		Return;
	EndIf;
	
	MissingTypesList.SortByValue();
	
	If ValueIsFilled(Context.SeparateKeysRegisterName) Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Cannot prepare access restriction parameters
			           |for the %1 list. Reason:
			           |The following types are missing
			           |	%2
			           |in the information register dimensions:
			           |	-%3,
			           |some fields (%4) have these types in their access restrictions:
			           |	%5';"),
			Context.List,
			Context.SeparateKeysRegisterName,
			StrConcat(MissingTypesList.UnloadValues(), "," + Chars.LF + "	- "),
			StrConcat(FieldList.UnloadValues(), ", "),
			TextWithIndent(Context.RestrictionsDetails1.Get(Context.List).Text, "	"));
	Else
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Cannot prepare access restriction parameters
			           |for the %1 list. Reason:
			           |The following types are missing in the %2 type collection:
			           |	-%3,
			           |some fields (%4) have these types in their access restrictions:
			           |	%5';"),
			Context.List,
			"RegisterAccessKeysRegisterField",
			StrConcat(MissingTypesList.UnloadValues(), "," + Chars.LF + "	- "),
			StrConcat(FieldList.UnloadValues(), ", "),
			TextWithIndent(Context.RestrictionsDetails1.Get(Context.List).Text, "	"));
	EndIf;
	
	Raise ErrorText;
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure AddDateQueryTextOfNextDataItem(Result, Context)
	
	If Not Result.ListWithDate And Not Result.ListWithPeriod Then
		Return;
	EndIf;
	
	If Result.ListWithDate Then
		QueryText =
		"SELECT TOP 1
		|	CurrentList.Date AS Date
		|FROM
		|	&CurrentList AS CurrentList
		|WHERE
		|	CurrentList.Date < &StartDate
		|
		|ORDER BY
		|	CurrentList.Date DESC";
	Else
		QueryText =
		"SELECT TOP 1
		|	CurrentList.Period AS Period
		|FROM
		|	&CurrentList AS CurrentList
		|WHERE
		|	CurrentList.Period < &StartDate
		|
		|ORDER BY
		|	CurrentList.Period DESC";
		If Context.TypeCollectionName = "CalculationRegisters" Then
			QueryText = StrReplace(QueryText, ".Period", ".RegistrationPeriod"); // @query-part-1 @query-part-2
		EndIf;
	EndIf;
	
	QueryText = StrReplace(QueryText, "&CurrentList", Result.List);
	
	Result.Insert("NextDataItemDateQueryText", QueryText);
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure AddQueryTextOfObsoleteDataItems(Result, Context)
	
	If Result.IsReferenceType Then
		RefType = ?(ValueIsFilled(Result.Version)
				Or Common.MetadataObjectByFullName(Result.List) <> Undefined,
			RefTypeByFullMetadataName(Result.List), Undefined);
		RefsTypes = AccessManagementInternalCached.TableFieldTypes("DefinedType.AccessKeysValuesOwner");
		
		If RefsTypes.Get(RefType) = Undefined Then
			QueryText =
			"SELECT TOP 0
			|	AccessKeysForObjects.Object AS CurrentRef
			|FROM
			|	InformationRegister.AccessKeysForObjects AS AccessKeysForObjects"; // @query-part-1
		ElsIf Result.ForExternalUsers Then
			If Result.DoNotWriteAccessKeys
			   And Not Result.DoNotWriteAccessKeysForUsersAndExternalUsers Then
				QueryText =
				"SELECT TOP 995
				|	AccessKeysForObjects.Object AS CurrentRef
				|FROM
				|	InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
				|WHERE
				|	VALUETYPE(AccessKeysForObjects.Object) = TYPE(&CurrentList)
				|	AND CAST(AccessKeysForObjects.Object AS &CurrentList) > &LastProcessedRef
				|	AND AccessKeysForObjects.ExternalUsersAccessKey <> VALUE(Catalog.AccessKeys.EmptyRef)
				|	AND &QueryPlanClarification
				|
				|ORDER BY
				|	AccessKeysForObjects.Object"; // @query-part-1
			Else
				QueryText = "";
			EndIf;
		ElsIf Result.DoNotWriteAccessKeysForUsersAndExternalUsers Then
			QueryText = 
			"SELECT TOP 995
			|	AccessKeysForObjects.Object AS CurrentRef
			|FROM
			|	InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
			|WHERE
			|	VALUETYPE(AccessKeysForObjects.Object) = TYPE(&CurrentList)
			|	AND CAST(AccessKeysForObjects.Object AS &CurrentList) > &LastProcessedRef
			|	AND &QueryPlanClarification
			|
			|ORDER BY
			|	AccessKeysForObjects.Object"; // @query-part-1
		Else
			QueryText =
			"SELECT TOP 995
			|	AccessKeysForObjects.Object AS CurrentRef,
			|	CurrentList.Ref IS NULL AS Delete
			|FROM
			|	InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
			|		LEFT JOIN &CurrentList AS CurrentList
			|		ON (VALUETYPE(AccessKeysForObjects.Object) = TYPE(&CurrentList))
			|			AND (CurrentList.Ref = AccessKeysForObjects.Object)
			|WHERE
			|	VALUETYPE(AccessKeysForObjects.Object) = TYPE(&CurrentList)
			|	AND CAST(AccessKeysForObjects.Object AS &CurrentList) > &LastProcessedRef
			|	AND &QueryCondition
			|	AND &QueryPlanClarification
			|
			|ORDER BY
			|	AccessKeysForObjects.Object"; // @query-part-1
			If Result.DoNotWriteAccessKeys Then
				Condition =
				"(AccessKeysForObjects.UsersAccessKey <> VALUE(Catalog.AccessKeys.EmptyRef)
				|		OR CurrentList.Ref IS NULL)"; // @query-part-1
			Else
				Condition = "CurrentList.Ref IS NULL"; // @query-part-1
			EndIf;
			QueryText = StrReplace(QueryText, "&QueryCondition", Condition);
		EndIf;
		QueryText = StrReplace(QueryText, "&CurrentList", Result.List);
		Result.ObsoleteDataItemsQueryText = QueryText;
		Return;
	EndIf;
	
	If ValueIsFilled(Result.SeparateKeysRegisterName) Then
		RegisterName   = Result.SeparateKeysRegisterName;
		MainFilter = "TRUE"; // @query-part-1
	Else
		RegisterName   = "AccessKeysForRegisters";
		MainFilter = "AccessKeysForRegisters.Register = &RegisterID";
	EndIf;
	
	SelectionByUserType = "CASE
	|			WHEN AccessKeysForRegisters.AccessOption = 0
	|				THEN FALSE
	|			ELSE AccessKeysForRegisters.AccessOption - (CAST(AccessKeysForRegisters.AccessOption / 2 - 0.5 AS NUMBER(15, 0))) * 2 = 1
	|		END = " + ?(Result.ForExternalUsers, "TRUE", "FALSE"); // @query-part-1
	
	BasicFields = Context.BasicFields;
	If BasicFields = Undefined Then
		MaxBasicFieldsCount =
			AccessManagementInternalCached.BasicRegisterFieldsCount(RegisterName);
	Else
		MaxBasicFieldsCount = BasicFields.MaxCount;
	EndIf;
	
	BasicFilterFields = "AccessKeysForRegisters.AccessOption AS AccessOption";
	BasicFieldsForFilter = "";
	BasicFieldsForOrdering = "AccessKeysForRegisters.AccessOption";
	
	For Number = 1 To MaxBasicFieldsCount Do
		// 
		BasicFilterFields = BasicFilterFields + ?(BasicFilterFields = "", "", ",
		|	") + "AccessKeysForRegisters.Field" + Number + " AS Field" + Number; // @query-part-3
		
		// Fields for filter.
		Filter = "";
		For AdditionalNumber = 1 To Number - 1 Do
			Filter = Filter + ?(AdditionalNumber = 1, "", "
			|	AND ") + "AccessKeysForRegisters.Field" + AdditionalNumber + " = &Field" + AdditionalNumber; // @query-part-1
		EndDo;
		Filter = Filter + ?(Filter = "", "", "
		|	AND ") + "AccessKeysForRegisters.Field" + Number + " > &Field" + Number; // @query-part-1
		
		Filter = ?(Number = 1, ?(MaxBasicFieldsCount > 1, "(", "") + Filter, "
		|			OR " + TextWithIndent(Filter, "			")); // @query-part-1
		
		BasicFieldsForFilter = BasicFieldsForFilter + ?(BasicFieldsForFilter = "", "", ?(Number = 1, "
		|	AND ", "")) + Filter; // @query-part-1
		
		// 
		BasicFieldsForOrdering = BasicFieldsForOrdering + ?(BasicFieldsForOrdering = "", "", ",
		|	") + "AccessKeysForRegisters.Field" + Number;
	EndDo;
	If MaxBasicFieldsCount > 1 Then
		BasicFieldsForFilter  = BasicFieldsForFilter  + ")";
	EndIf;
	
	If ValueIsFilled(Result.SeparateKeysRegisterName) Then
		ClearingQueryText = 
		"SELECT TOP 995
		|	&BasicFilterFields
		|FROM
		|	InformationRegister.AccessKeysForRegisters AS AccessKeysForRegisters
		|WHERE
		|	AccessKeysForRegisters.Register = &RegisterID
		|	AND &SelectionByUserType
		|	AND &BasicFieldsForFilter
		|	AND &QueryPlanClarification
		|
		|ORDER BY
		|	&BasicFieldsForOrdering";
		ClearingQueryText = StrReplace(ClearingQueryText, "&BasicFilterFields", BasicFilterFields);
		ClearingQueryText = StrReplace(ClearingQueryText, "&SelectionByUserType", SelectionByUserType);
		ClearingQueryText = StrReplace(ClearingQueryText, "&BasicFieldsForFilter", BasicFieldsForFilter);
		ClearingQueryText = StrReplace(ClearingQueryText, "&BasicFieldsForOrdering", BasicFieldsForOrdering);
		Result.Insert("ObsoleteDataItemsFromCommonRegisterQueryText", ClearingQueryText);
	EndIf;
	
	If Result.DoNotWriteAccessKeys Then
		QueryText =
		"SELECT TOP 995
		|	&BasicFilterFields
		|FROM
		|	#RegisterName AS AccessKeysForRegisters
		|WHERE
		|	&MainFilter
		|	AND &SelectionByUserType
		|	AND &BasicFieldsForFilter
		|	AND &QueryPlanClarification
		|
		|ORDER BY
		|	&BasicFieldsForOrdering";
		QueryText = StrReplace(QueryText, "&BasicFilterFields", BasicFilterFields);
		QueryText = StrReplace(QueryText, "#RegisterName", "InformationRegister." + RegisterName);
		QueryText = StrReplace(QueryText, "&MainFilter", MainFilter);
		QueryText = StrReplace(QueryText, "&SelectionByUserType", SelectionByUserType);
		QueryText = StrReplace(QueryText, "&BasicFieldsForFilter", BasicFieldsForFilter);
		QueryText = StrReplace(QueryText, "&BasicFieldsForOrdering", BasicFieldsForOrdering);
	Else
		Number = 1;
		BasicFilterFieldsOnCheck = "";
		BasicFieldsToMap = "";
		For Each BasicFieldName In BasicFields.UsedItems Do
			// 
			BasicFilterFieldsOnCheck = BasicFilterFieldsOnCheck + ?(BasicFilterFieldsOnCheck = "", "", ",
			|	") + "AccessKeysForRegisters.Field" + Number + " AS Field" + Number; // @query-
			// 
			BasicFieldsToMap = BasicFieldsToMap + ?(BasicFieldsToMap = "", "", "
			|AND ") + "CurrentList." + BasicFieldName + " = AccessKeysForRegisters.Field" + Number; // @query-part-1
			Number = Number + 1;
		EndDo;
		
		QueryText = 
		"SELECT TOP 995
		|	&BasicFilterFields,
		|	NOT AccessKeysForRegisters.AccessOption IN (&AccessOptionsUsed) AS Delete
		|FROM
		|	#RegisterName AS AccessKeysForRegisters
		|WHERE
		|	&MainFilter
		|	AND &SelectionByUserType
		|	AND &BasicFieldsForFilter
		|	AND (NOT AccessKeysForRegisters.AccessOption IN (&AccessOptionsUsed)
		|			OR AccessKeysForRegisters.AccessOption = &AccessOption
		|				AND NOT TRUE IN
		|						(SELECT TOP 1
		|							TRUE
		|						FROM
		|							&CurrentList AS CurrentList
		|						WHERE
		|							&BasicFieldsToMap))
		|	AND &QueryPlanClarification
		|
		|ORDER BY
		|	&BasicFieldsForOrdering";
		QueryText = StrReplace(QueryText, "&BasicFilterFields", BasicFilterFields);
		QueryText = StrReplace(QueryText, "#RegisterName", "InformationRegister." + RegisterName);
		QueryText = StrReplace(QueryText, "&MainFilter", MainFilter);
		QueryText = StrReplace(QueryText, "&SelectionByUserType", SelectionByUserType);
		QueryText = StrReplace(QueryText, "&BasicFieldsForFilter", BasicFieldsForFilter);
		QueryText = StrReplace(QueryText, "&BasicFieldsToMap", 
			TextWithIndent(BasicFieldsToMap, "						"));
		QueryText = StrReplace(QueryText, "&BasicFieldsForOrdering", BasicFieldsForOrdering);

		AccessOptionsUsed = Context.BasicAccessOptions.Get(Context.List);
		StringAccessOptions = New Array;
		If AccessOptionsUsed = Undefined Then
			StringAccessOptions.Add("NULL");
		Else
			For Each AccessOptionUsed In AccessOptionsUsed Do
				StringAccessOptions.Add(XMLString(AccessOptionUsed.AccessOption));
			EndDo;
		EndIf;
		QueryText = StrReplace(QueryText, "&AccessOptionsUsed",
			StrConcat(StringAccessOptions, ","));
		
		StringAccessOption = XMLString(Context.AccessOption);
		StringAccessOption = ?(ValueIsFilled(StringAccessOption), StringAccessOption, "NULL");
		QueryText = StrReplace(QueryText, "&AccessOption", StringAccessOption);
		
		QueryTextChecks =
		"SELECT
		|	&BasicFilterFieldsOnCheck
		|INTO AccessKeysForRegisters
		|FROM
		|	&AccessKeysForRegisters AS AccessKeysForRegisters
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|SELECT
		|	&BasicFilterFieldsOnCheck
		|FROM
		|	AccessKeysForRegisters AS AccessKeysForRegisters
		|WHERE
		|	NOT TRUE IN
		|				(SELECT TOP 1
		|					TRUE
		|				FROM
		|					&CurrentList AS CurrentList
		|				WHERE
		|					&ConditionReferenceFieldsForComparison)
		|	AND &QueryPlanClarification";
		
		QueryTextChecks = StrReplace(QueryTextChecks, "&BasicFilterFieldsOnCheck", BasicFilterFieldsOnCheck);
		QueryTextChecks = StrReplace(QueryTextChecks, "&ConditionReferenceFieldsForComparison",
			TextWithIndent(BasicFieldsToMap, "						"));
		
		QueryText = StrReplace(QueryText, "&CurrentList", Result.List);
		QueryTextChecks = StrReplace(QueryTextChecks, "&CurrentList", Result.List);
		Result.Insert("ObsoleteDataItemsCheckQueryText", QueryTextChecks);
	EndIf;
	
	Result.ObsoleteDataItemsQueryText = QueryText;
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure FillTemplatesOfCheckQueryParts(Context)
	
	If Context.IsReferenceType Then
		FillTemplatesOfObjectCheckQueryParts(Context);
	Else
		FillTemplatesOfRegisterCheckQueryParts(Context);
	EndIf;
	
EndProcedure

// For the FillTemplatesOfCheckQueryParts procedure.
Procedure FillTemplatesOfObjectCheckQueryParts(Context)
	
	Context.Insert("QueryTextChecks");
	Context.Insert("CheckQueryPartText");
	Context.Insert("SpotCheckQueryText");
	
	If Context.ListWithDate Then
		Context.QueryTextChecks =
		"SELECT TOP 995
		|	CurrentList.Ref AS CurrentRef,
		|	CurrentList.Date AS Date
		|FROM
		|	&CurrentList AS CurrentList
		|		LEFT JOIN InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
		|		ON (AccessKeysForObjects.Object = CurrentList.Ref)
		|WHERE
		|	CurrentList.Date BETWEEN &StartDate AND &EndDate
		|	AND (AccessKeysForObjects.Object IS NULL
		|			OR &QueryCondition)
		|	AND &QueryPlanClarification
		|
		|ORDER BY
		|	CurrentList.Date DESC";
		
		Context.CheckQueryPartText = 
		"SELECT DISTINCT TOP 995
		|	CurrentList.Ref AS CurrentRef,
		|	CurrentList.Date AS DATE
		|FROM
		|	&CurrentList AS CurrentList
		|		LEFT JOIN InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
		|		ON (AccessKeysForObjects.Object = CurrentList.Ref)
		|		#Joins
		|WHERE
		|	CurrentList.Date BETWEEN &StartDate AND &EndDate
		|	AND &QueryCondition
		|	AND &QueryPlanClarification
		|
		|ORDER BY
		|	CurrentList.Date DESC"; // @query-part-1
	Else
		Context.QueryTextChecks = 
		"SELECT TOP 995
		|	CurrentList.Ref AS CurrentRef
		|FROM
		|	&CurrentList AS CurrentList
		|		LEFT JOIN InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
		|		ON (AccessKeysForObjects.Object = CurrentList.Ref)
		|WHERE
		|	CurrentList.Ref >= &LastProcessedRef
		|	AND (AccessKeysForObjects.Object IS NULL
		|			OR &QueryCondition)
		|	AND &QueryPlanClarification
		|
		|ORDER BY
		|	CurrentList.Ref"; // @query-part-1
		
		Context.CheckQueryPartText =
		"SELECT DISTINCT TOP 995
		|	CurrentList.Ref AS CurrentRef
		|FROM
		|	&CurrentList AS CurrentList
		|		LEFT JOIN InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
		|		ON (AccessKeysForObjects.Object = CurrentList.Ref)
		|		#Joins
		|WHERE
		|	CurrentList.Ref >= &LastProcessedRef
		|	AND &QueryCondition
		|	AND &QueryPlanClarification
		|
		|ORDER BY
		|	CurrentList.Ref"; // @query-part-1
	EndIf;
	
	Context.SpotCheckQueryText =
	"SELECT
	|	CurrentList.Ref AS CurrentRef
	|FROM
	|	&CurrentList AS CurrentList
	|		INNER JOIN CurrentListByLeadingObjects AS CurrentListByLeadingObjects
	|		ON (CurrentListByLeadingObjects.Ref = CurrentList.Ref)
	|		LEFT JOIN InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
	|		ON (AccessKeysForObjects.Object = CurrentList.Ref)
	|WHERE
	|	(AccessKeysForObjects.Object IS NULL
	|			OR &QueryCondition)
	|	AND &QueryPlanClarification";
	
	If Not Context.Property("DetailsOfValidationRequestsOnLeadingObjects") Then
		Return;
	EndIf;
	
	DataChoiceForSpotCheckWrapperQueryText =
	"SELECT DISTINCT TOP 995
	|	CurrentList.Ref AS Ref
	|INTO CurrentListByLeadingObjects
	|FROM
	|	#DataSelectionRequests AS CurrentList"; 
	
	Context.DetailsOfValidationRequestsOnLeadingObjects.Insert("DataSelectionWrapQueryText",
		DataChoiceForSpotCheckWrapperQueryText);
	
	QueryTemplate =
	"SELECT DISTINCT TOP 995
	|	CurrentList.Ref AS Ref
	|FROM
	|	"; // @query-part-1
	AddCheckQueriesByLeadingLists(QueryTemplate, Context);
	
EndProcedure

// For the FillTemplatesOfCheckQueryParts procedure.
Procedure FillTemplatesOfRegisterCheckQueryParts(Context)
	
	BasicFields = Context.BasicFields;
	BasicFields.Insert("ForSelection",         "");
	BasicFields.Insert("ConnectionCondition", "");
	BasicFields.Insert("ForFilter",         "");
	BasicFields.Insert("ForOrdering",   "");
	
	// For a new combination query.
	BasicFieldsForSelection = "";
	BasicFieldsConnectionCondition = "";
	BasicFieldsForGroupingOrOrdering = "";
	BasicFieldsForFilter = "";
	
	// To request current access keys.
	FilterCriterion = "";
	
	If Not ValueIsFilled(Context.SeparateKeysRegisterName) Then
		Context.SeparateRegister = False;
		// 
		BasicFieldsConnectionCondition  = "(AccessKeysForRegisters.Register = &RegisterID)";
		// 
		FilterCriterion                 = "CurrentList.Register = &RegisterID";
		// 
		BasicFields.ConnectionCondition = "(CurrentListSource.Register = CurrentList.Register)";
		BasicFields.ForFilter         = "CurrentList.Register = &RegisterID";
	EndIf;
	
	// 
	BasicFieldsConnectionCondition = BasicFieldsConnectionCondition + ?(BasicFieldsConnectionCondition = "", "", "
	|			AND ") + "(AccessKeysForRegisters.AccessOption = &AccessOption)"; // @query-part-1
	
	// 
	FilterCriterion = FilterCriterion + ?(FilterCriterion = "", "", "
	|	AND ") + "CurrentList.AccessOption = &AccessOption"; // @query-part-1
	
	// 
	BasicFields.ConnectionCondition = BasicFields.ConnectionCondition + ?(BasicFields.ConnectionCondition = "", "", "
	|	AND ") + "(CurrentListSource.AccessOption = &AccessOption)"; // @query-part-1
	
	BasicFields.ForFilter = BasicFields.ForFilter + ?(BasicFields.ForFilter = "", "", "
	|	AND ") + "CurrentList.AccessOption = &AccessOption"; // @query-part-1
	
	Number = 0;
	For Each BasicFieldName In BasicFields.UsedItems Do
		Number = Number + 1;
		
		// 
		BasicFieldsForSelection = BasicFieldsForSelection + ?(BasicFieldsForSelection = "", "", ",
		|	") + "CurrentRegister." + BasicFieldName + " AS Field" + Number; // @query-part-3
		
		BasicFieldsConnectionCondition = BasicFieldsConnectionCondition + ?(BasicFieldsConnectionCondition = "", "", "
		|			AND ") + "(AccessKeysForRegisters.Field" + Number + " = CurrentRegister." + BasicFieldName + ")"; // @query-part-1
		
		BasicFieldsForGroupingOrOrdering = BasicFieldsForGroupingOrOrdering
			+ ?(BasicFieldsForGroupingOrOrdering = "", "", ", ") + BasicFieldName;
		
		Filter = "";
		For AdditionalNumber = 1 To Number - 1 Do
			CurrentBasicFieldName = BasicFields.UsedItems[AdditionalNumber - 1];
			Filter = Filter + ?(AdditionalNumber = 1, "", "
			|	AND ") + "CurrentRegister." + CurrentBasicFieldName + " = &Field" + AdditionalNumber; // @query-part-1
		EndDo;
		Filter = Filter + ?(Filter = "", "", "
		|	AND ") + "CurrentRegister." + BasicFieldName + " > &Field" + Number; // @query-part-1
		
		Filter = ?(Number = 1, ?(BasicFields.UsedItems.Count() > 1, "(", "") + Filter, "
		|		OR " + TextWithIndent(Filter, "		")); // @query-part-1
		
		BasicFieldsForFilter = BasicFieldsForFilter + ?(BasicFieldsForFilter = "", "", ?(Number = 1, "
		|	AND ", "")) + Filter; // @query-part-1
		
		// 
		FilterCriterion = FilterCriterion + ?(FilterCriterion = "", "", "
		|	AND ") + "CurrentList.Field" + Number + " = &Field" + Number + "_%1"; // @query-part-1
		
		// 
		BasicFields.ForSelection = BasicFields.ForSelection + ?(BasicFields.ForSelection = "", "", ",
		|	") + "CurrentList.Field" + Number + " AS Field" + Number; // @query-part-3
		
		BasicFields.ConnectionCondition = BasicFields.ConnectionCondition + ?(BasicFields.ConnectionCondition = "", "", "
		|	AND ") + "(CurrentListSource.Field" + Number + " = CurrentList.Field" + Number + ")"; // @query-part-1
		
		Filter = "";
		For AdditionalNumber = 1 To Number - 1 Do
			Filter = Filter + ?(AdditionalNumber = 1, "", "
			|		AND ") + "CurrentList.Field" + AdditionalNumber + " = &Field" + AdditionalNumber; // @query-part-1
		EndDo;
		Filter = Filter + ?(Filter = "", "", "
		|		AND ") + "CurrentList.Field" + Number + " > &Field" + Number; // @query-part-1
		
		Filter = ?(Number = 1, ?(BasicFields.UsedItems.Count() > 1, "(", "") + Filter, "
		|			OR " + TextWithIndent(Filter, "		")); // @query-part-1
		
		BasicFields.ForFilter = BasicFields.ForFilter + ?(BasicFields.ForFilter = "", "", ?(Number = 1, "
		|	AND ", "")) + Filter; // @query-part-1
		
		BasicFields.ForOrdering = BasicFields.ForOrdering + ?(BasicFields.ForOrdering = "", "", ", ") + "Field" + Number;
	EndDo;
	
	If BasicFields.UsedItems.Count() > 1 Then
		BasicFieldsForFilter  = BasicFieldsForFilter  + ")";
		BasicFields.ForFilter = BasicFields.ForFilter + ")";
	EndIf;
	
	// Set query templates.
	CheckCombinationsQueryText =
	"SELECT DISTINCT TOP 995
	|	&BasicFieldsForSelection
	|FROM
	|	&CurrentList AS CurrentList
	|WHERE
	|	&BasicFieldsForFilter
	|	AND (&QueryCondition)
	|	AND &QueryPlanClarification
	|
	|ORDER BY
	|	&BasicFieldsForOrdering"; 

	CheckCombinationsQueryText = StrReplace(CheckCombinationsQueryText, "&BasicFieldsForSelection", BasicFields.ForSelection);
	CheckCombinationsQueryText = StrReplace(CheckCombinationsQueryText, "&BasicFieldsForFilter", BasicFields.ForFilter);
	CheckCombinationsQueryText = StrReplace(CheckCombinationsQueryText, "&BasicFieldsForOrdering", BasicFields.ForOrdering);
	Context.Insert("QueryTextChecks", CheckCombinationsQueryText);
	
	SpotCombinationsCheckQueryText =
	"SELECT
	|	&BasicFieldsForSelection
	|FROM
	|	CurrentListByLeadingObjects AS CurrentList
	|WHERE
	|	(&QueryCondition)
	|	AND &QueryPlanClarification";
	
	SpotCombinationsCheckQueryText = StrReplace(SpotCombinationsCheckQueryText, 
		"&BasicFieldsForSelection", BasicFields.ForSelection);
	Context.Insert("SpotCheckQueryText", SpotCombinationsCheckQueryText);
	
	DataChoiceWrapperForSpotCombinationsCheckQueryText =
	"SELECT DISTINCT TOP 995
	|	&BasicFieldsForSelection,
	|	CurrentList.AccessKey AS AccessKey
	|INTO CurrentListByLeadingObjects
	|FROM
	|	#DataSelectionRequests AS CurrentList";
	
	DataChoiceWrapperForSpotCombinationsCheckQueryText = StrReplace(DataChoiceWrapperForSpotCombinationsCheckQueryText, 
		"&BasicFieldsForSelection", BasicFields.ForSelection);
	Context.DetailsOfValidationRequestsOnLeadingObjects.Insert("DataSelectionWrapQueryText",
		DataChoiceWrapperForSpotCombinationsCheckQueryText);
	
	QueryTemplate =
	"SELECT DISTINCT TOP 995
	|	&BasicFieldsForSelection,
	|	CurrentList.AccessKey AS AccessKey
	|FROM
	|	"; // @query-part-1
	QueryTemplate = StrReplace(QueryTemplate, "&BasicFieldsForSelection", BasicFields.ForSelection);
	AddCheckQueriesByLeadingLists(QueryTemplate, Context);
	
	If Context.ListWithPeriod Then
		NewCombinationsQueryText = 
		"SELECT TOP 995
		|	MAX(CurrentRegister.Period) AS Period,
		|	&BasicFieldsForSelection
		|FROM
		|	&CurrentRegister AS CurrentRegister
		|		LEFT JOIN &CurrentList AS AccessKeysForRegisters
		|		ON &BasicFieldsConnectionCondition
		|WHERE
		|	CurrentRegister.Period >= &StartDate
		|	AND (CurrentRegister.Period < &EndDate
		|		OR CurrentRegister.Period = &EndDate
		|			AND &BasicFieldsForFilter)
		|	AND AccessKeysForRegisters.AccessOption IS NULL
		|	AND &QueryPlanClarification
		|
		|GROUP BY
		|	&BasicFieldsForGroupingOrOrdering
		|
		|ORDER BY
		|	Period DESC, &BasicFieldsForGroupingOrOrdering";
		NewCombinationsQueryText = StrReplace(NewCombinationsQueryText, 
			"&BasicFieldsForSelection", BasicFieldsForSelection);
		NewCombinationsQueryText = StrReplace(NewCombinationsQueryText, 
			"&BasicFieldsConnectionCondition", BasicFieldsConnectionCondition);
		NewCombinationsQueryText = StrReplace(NewCombinationsQueryText, 
			"&BasicFieldsForFilter", TextWithIndent(BasicFieldsForFilter, "	"));
		NewCombinationsQueryText = StrReplace(NewCombinationsQueryText, 
			"&BasicFieldsForGroupingOrOrdering", BasicFieldsForGroupingOrOrdering);
		If Context.TypeCollectionName = "CalculationRegisters" Then
			NewCombinationsQueryText = StrReplace(NewCombinationsQueryText,
				".Period", ".RegistrationPeriod");
		EndIf;
	Else
		NewCombinationsQueryText =
		"SELECT DISTINCT TOP 995
		|	&BasicFieldsForSelection
		|FROM
		|	&CurrentRegister AS CurrentRegister
		|		LEFT JOIN &CurrentList AS AccessKeysForRegisters
		|		ON &BasicFieldsConnectionCondition
		|WHERE
		|	&BasicFieldsForFilter
		|	AND AccessKeysForRegisters.AccessOption IS NULL
		|	AND &QueryPlanClarification
		|
		|ORDER BY
		|	&BasicFieldsForGroupingOrOrdering";
		NewCombinationsQueryText = StrReplace(NewCombinationsQueryText, 
			"&BasicFieldsForSelection", BasicFieldsForSelection);
		NewCombinationsQueryText = StrReplace(NewCombinationsQueryText, 
			"&BasicFieldsConnectionCondition", BasicFieldsConnectionCondition);
		NewCombinationsQueryText = StrReplace(NewCombinationsQueryText, 
			"&BasicFieldsForFilter", BasicFieldsForFilter);
		NewCombinationsQueryText = StrReplace(NewCombinationsQueryText, 
			"&BasicFieldsForGroupingOrOrdering", BasicFieldsForGroupingOrOrdering);
	EndIf;
	Context.Insert("NewCombinationsQueryText", NewCombinationsQueryText);
	
	// Current access keys query text.
	CurrentAccessKeysQueryText =
	"SELECT TOP 2
	|	CurrentList.AccessKey AS AccessKey
	|FROM
	|	&CurrentList AS CurrentList
	|WHERE
	|	&FilterCriterion";
	CurrentAccessKeysQueryText = StrReplace(CurrentAccessKeysQueryText, "&FilterCriterion", FilterCriterion);
	Context.Insert("CurrentAccessKeysQueryText", CurrentAccessKeysQueryText);
	
EndProcedure

// For the FillObjectCheckQueryPartsTemplates and FillRegisterCheckQueryPartsTemplates procedures.
Procedure AddCheckQueriesByLeadingLists(QueryTemplate, Context)
	
	QueriesDetails = New Map;
	For Each FilterConnection In Context.LeadingListsByFieldsValues.FiltersConnections Do
		IConnectionShort = FilterConnection.Value;
		Fields = Context.LeadingListsByFieldsValues.Fields.Get(FilterConnection.Key);
		LeadingTable = FilterConnection.Key;
		If IConnectionShort.HeaderFields.Count() > 0 Then
			QueriesDetails.Insert(LeadingTable,
				CheckQueriesByLeadingListsDetails(IConnectionShort.HeaderFields,
					Fields.ForFilter.HeaderFields, LeadingTable, QueryTemplate, Context));
		EndIf;
		For Each TabularSectionDetails In IConnectionShort.TabularSections Do
			LeadingTable = FilterConnection.Key + "." + TabularSectionDetails.Key;
			FieldsTypes = Fields.ForFilter.TabularSections.Get(TabularSectionDetails.Key);
			QueriesDetails.Insert(LeadingTable,
				CheckQueriesByLeadingListsDetails(TabularSectionDetails.Value,
					FieldsTypes, LeadingTable, QueryTemplate, Context));
		EndDo;
	EndDo;
	Context.DetailsOfValidationRequestsOnLeadingObjects.Insert("ByFieldsValues", QueriesDetails);
	
	AddCheckQueriesByLeadingListsRefField("ByValuesWithGroups", QueryTemplate, Context);
	AddCheckQueriesByLeadingListsRefField("ByAccessKeys", QueryTemplate, Context);
	
EndProcedure

// For the AddCheckQueriesByLeadingLists procedure.
Function CheckQueriesByLeadingListsDetails(FiltersConnections, FieldsTypes,
			LeadingTable, QueryTemplate, Context)
	
	LeadingTableWithoutDots = StrReplace(LeadingTable, ".", "_");
	
	Fields = New Array;
	For Each FieldDetails In FieldsTypes Do
		Fields.Add(FieldDetails.Key + " AS " + FieldDetails.Key);
	EndDo;
	
	QueryTextParameters =
	"SELECT
	|	&TableFields
	|INTO #LeadingTableWithoutDots
	|FROM
	|	&LeadingTableWithoutDots AS CurrentDataForFilter";
	QueryTextParameters = StrReplace(QueryTextParameters, "&TableFields", "
		|	CurrentDataForFilter." + StrConcat(Fields, ",
		|	CurrentDataForFilter."));
	QueryTextParameters = StrReplace(QueryTextParameters, "#LeadingTableWithoutDots", LeadingTableWithoutDots);
	QueryTextParameters = StrReplace(QueryTextParameters, "&LeadingTableWithoutDots", "&" + LeadingTableWithoutDots);
	
	QueriesDetails = New Structure;
	QueriesDetails.Insert("FieldsTypes", FieldsTypes);
	QueriesDetails.Insert("QueryTextParameters", QueryTextParameters);
	QueriesDetails.Insert("DataQueryTexts", New Array);
	
	For Each FilterConnection In FiltersConnections Do
		QueryText = QueryTemplate + TextWithIndent(FilterConnection, "	");
		QueryText = StrReplace(QueryText, "#CurrentDataForFilter", LeadingTableWithoutDots);
		InsertCommonParametersIntoQuery(QueryText, Context);
		QueriesDetails.DataQueryTexts.Add(QueryText);
	EndDo;
	
	Return QueriesDetails;
	
EndFunction

// For the AddCheckQueriesByLeadingLists procedure.
Procedure AddCheckQueriesByLeadingListsRefField(LaedingListKind, QueryTemplate, Context)
	
	Properties = ?(LaedingListKind = "ByAccessKeys",
		Context.LeadingListsByAccessKeys, Context.LeadingListsByValuesWithGroups);
	
	If Not ValueIsFilled(Properties.FiltersConnections) Then
		Return;
	EndIf;
	
	TempTableName = "CurrentDataForFilter" + LaedingListKind;
	
	QueryTextParameters =
	"SELECT
	|	CurrentDataForFilter.Ref
	|INTO #TempTableName
	|FROM
	|	&LaedingListKind AS CurrentDataForFilter";
	QueryTextParameters = StrReplace(QueryTextParameters, "#TempTableName", TempTableName);
	QueryTextParameters = StrReplace(QueryTextParameters, "&LaedingListKind", "&" + LaedingListKind);

	QueriesTextsByKeys = New Map;
	For Each FilterConnection In Properties.FiltersConnections Do
		QueryText = QueryTemplate + TextWithIndent(FilterConnection.Value, "	");
		QueryText = StrReplace(QueryText, "#CurrentDataForFilter", TempTableName);
		InsertCommonParametersIntoQuery(QueryText, Context);
		QueriesTextsByKeys.Insert(FilterConnection.Key, QueryText);
	EndDo;
	
	QueriesDetails = New Structure;
	QueriesDetails.Insert("RefType",              New ValueStorage(Properties.RefType));
	QueriesDetails.Insert("QueryKeysByTypes",   Properties.QueryKeysByTypes);
	QueriesDetails.Insert("QueriesTextsByKeys", QueriesTextsByKeys);
	QueriesDetails.Insert("QueryTextParameters", QueryTextParameters);
	
	Context.DetailsOfValidationRequestsOnLeadingObjects.Insert(LaedingListKind, QueriesDetails);
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure ComposeCheckQueryParts(Result, Context)
	
	Condition = "";
	For Each ConditionPartText In Context.CheckConditionParts Do
		If ValueIsFilled(Condition) Then
			Condition = Condition + "
			|		OR "; // @query-part-1
		EndIf;
		Condition = Condition + TextWithIndent(ConditionPartText, "			");
	EndDo;
	Condition = TextWithIndent(Condition, "	");
	
	Context.QueryTextChecks = StrReplace(Context.QueryTextChecks,
		"&QueryCondition", ?(Context.IsReferenceType, Condition, TextWithIndent(Condition, "		")));
	InsertCommonParametersIntoQuery(Context.QueryTextChecks, Context);
	Result.DataItemWithObsoleteKeysQueryText = Context.QueryTextChecks;
	
	QueryText = StrReplace(Context.SpotCheckQueryText, "&QueryCondition", Condition);
	InsertCommonParametersIntoQuery(QueryText, Context);
	Context.DetailsOfValidationRequestsOnLeadingObjects.Insert("SpotCheckQueryText", QueryText);
	
	Result.DetailsOfObsoleteAccessKeysForLeadingObjects =
		Context.DetailsOfValidationRequestsOnLeadingObjects;
	
	If Not Context.IsReferenceType Then
		InsertCommonParametersIntoQuery(Context.NewCombinationsQueryText, Context);
		Result.DataItemsWithoutAccessKeysQueryText = Context.NewCombinationsQueryText;
		
		InsertCommonParametersIntoQuery(Context.CurrentAccessKeysQueryText, Context);
		Result.CurrentRegisterAccessKeysQueryText = Context.CurrentAccessKeysQueryText;
	EndIf;
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure ComposeFillQueryParts(Result, Context)
	
	QueryText = StrConcat(Context.PartsOfValuesFromObjectsQuery,
		Common.QueryBatchSeparator());
	InsertCommonParametersIntoQuery(QueryText, Context);
	Result.DataItemValueForAccessKeysQueryText = QueryText;
	
	If ValueIsFilled(Context.PartsOfQueryForInMemoryObjectsValues) Then
		QueryText = StrConcat(Context.PartsOfQueryForInMemoryObjectsValues,
			Common.QueryBatchSeparator());
		TempTableName = StrReplace(Context.List, ".", "_");
		QueryText = StrReplace(QueryText, "&CurrentList.", TempTableName + "_");
		QueryText = StrReplace(QueryText, "&CurrentList", TempTableName);
		InsertCommonParametersIntoQuery(QueryText, Context);
		Result.TextOfQueryForInMemoryObjectsValuesForAccessKeys = QueryText;
	EndIf;
	
	QueryText = StrConcat(Context.PartsOfValuesFromObjectsQueryToCompare,
		Common.QueryBatchSeparator());
	InsertCommonParametersIntoQuery(QueryText, Context);
	Result.ValueFromAccessKeysInUseForComparisonQueryText = QueryText;
	Result.ValueFromAllAccessKeysForComparisonQueryText = StrReplace(QueryText,
		".NotUsedSince = DATETIME(1, 1, 1)", ".List = &List"); // @query-part-1
	
	QueryText = StrConcat(Context.QueryPartsOfKeysExistenceToMap,
		Common.QueryBatchSeparator());
	InsertCommonParametersIntoQuery(QueryText, Context);
	Result.KeysForComparisonExistenceQueryText = QueryText;
	
	AddQueryPartOfLeadingKeysRightsSelection(Context);
	AddQueryPartOfLeadingListsRightsSelection(Context);
	AddQueryPartOfRightsSelectionByRightsSettingsOwners(Context);
	QueryText = StrConcat(Context.PartsOfValuesFromKeysQueryToCalculateRights,
		Common.QueryBatchSeparator());
	InsertCommonParametersIntoQuery(QueryText, Context);
	Result.ValueFromAccessKeysForRightsCalculationQueryText = QueryText;
	
	Result.AccessKeysQueryTextToUpdateRights =
		AccessKeysQueryTextToUpdateRights(Context);
	
	Result.KeysQueryTextByLeadingKeysToUpdateRights =
		KeysQueryTextByLeadingKeysToUpdateRights(Context);
	
	Result.ObsoleteAccessKeysQueryText =
		ObsoleteAccessKeysQueryText(Context);
	
EndProcedure

// For the ComposeFillQueriesParts procedure.
Procedure AddQueryPartOfLeadingKeysRightsSelection(Context)
	
	If Context.ConditionPartsToSelectLeadingAccessKeysRights.Count() = 0 Then
		Return;
	EndIf;
	
	If Context.ConditionPartsToSelectLeadingAccessKeysRights.Count() = 1 Then
		FilterCriterion = Context.ConditionPartsToSelectLeadingAccessKeysRights[0];
	Else
		FilterCriterion = "(" + StrConcat(Context.ConditionPartsToSelectLeadingAccessKeysRights,
			Chars.LF + "			OR ") + ")"; // @query-part-1
	EndIf;
	
	QueryText =
	"SELECT
	|	RightsToLeadingAccessKeysLists.Table AS List,
	|	RightsToLeadingAccessKeysLists.AccessGroup AS AccessGroup,
	|	RightsToLeadingAccessKeysLists.RightUpdate AS RightUpdate
	|FROM
	|	InformationRegister.AccessGroupsTables AS RightsToLeadingAccessKeysLists
	|WHERE
	|	RightsToLeadingAccessKeysLists.Table IN
	|			(SELECT DISTINCT
	|				HeadAccessKeyLists.List
	|			FROM
	|				Catalog.AccessKeys AS HeadAccessKeyLists
	|			WHERE
	|				&FilterCriterion)
	|	AND &QueryPlanClarification
	|TOTALS BY
	|	List";
	
	QueryText = StrReplace(QueryText, "&FilterCriterion",
		StrReplace(FilterCriterion, "#FieldToCheck", "HeadAccessKeyLists.Ref"));
	
	Context.PartsOfValuesFromKeysQueryToCalculateRights.Add(QueryText);
	
	QueryText =
	"SELECT
	|	HeadAccessKeyLists.Ref AS AccessKey,
	|	HeadAccessKeyLists.List AS List
	|FROM
	|	Catalog.AccessKeys AS HeadAccessKeyLists
	|WHERE
	|	&FilterCriterion
	|	AND &QueryPlanClarification";
	
	QueryText = StrReplace(QueryText, "&FilterCriterion",
		StrReplace(FilterCriterion, "#FieldToCheck", "HeadAccessKeyLists.Ref"));
	
	Context.PartsOfValuesFromKeysQueryToCalculateRights.Add(QueryText);
	
	If Not Context.CalculateUserRights Then
		QueryText =
		"SELECT
		|	RightsToAccessKeys.AccessKey AS AccessKey,
		|	RightsToAccessKeys.AccessGroup AS RightsOwner,
		|	RightsToAccessKeys.RightUpdate AS RightUpdate
		|FROM
		|	InformationRegister.AccessGroupsAccessKeys AS RightsToAccessKeys
		|WHERE
		|	VALUETYPE(RightsToAccessKeys.AccessGroup) = TYPE(Catalog.AccessGroups)
		|	AND &FilterCriterion
		|	AND &QueryPlanClarification
		|TOTALS BY
		|	AccessKey";
	ElsIf Not Context.ForExternalUsers Then
		QueryText =
		"SELECT
		|	RightsToAccessKeys.AccessKey AS AccessKey,
		|	RightsToAccessKeys.AccessGroup AS RightsOwner,
		|	RightsToAccessKeys.RightUpdate AS RightUpdate
		|FROM
		|	InformationRegister.AccessGroupsAccessKeys AS RightsToAccessKeys
		|WHERE
		|	&FilterCriterion
		|	AND &QueryPlanClarification
		|
		|UNION ALL
		|
		|SELECT
		|	RightsToAccessKeys.AccessKey,
		|	RightsToAccessKeys.User.User,
		|	RightsToAccessKeys.RightUpdate
		|FROM
		|	InformationRegister.UsersAccessKeys AS RightsToAccessKeys
		|WHERE
		|	RightsToAccessKeys.AreGroupSetRights = FALSE
		|	AND ISNULL(RightsToAccessKeys.User.User, VALUE(Catalog.Users.EmptyRef)) <> VALUE(Catalog.Users.EmptyRef)
		|	AND &FilterCriterion
		|TOTALS BY
		|	AccessKey";
	Else
		QueryText =
		"SELECT
		|	RightsToAccessKeys.AccessKey AS AccessKey,
		|	RightsToAccessKeys.AccessGroup AS RightsOwner,
		|	RightsToAccessKeys.RightUpdate AS RightUpdate
		|FROM
		|	InformationRegister.AccessGroupsAccessKeys AS RightsToAccessKeys
		|WHERE
		|	&FilterCriterion
		|	AND &QueryPlanClarification
		|
		|UNION ALL
		|
		|SELECT
		|	RightsToAccessKeys.AccessKey,
		|	RightsToAccessKeys.ExternalUser.User,
		|	RightsToAccessKeys.RightUpdate
		|FROM
		|	InformationRegister.ExternalUsersAccessKeys AS RightsToAccessKeys
		|WHERE
		|	RightsToAccessKeys.AreGroupSetRights = FALSE
		|	AND ISNULL(RightsToAccessKeys.ExternalUser.User, VALUE(Catalog.Users.EmptyRef)) <> VALUE(Catalog.Users.EmptyRef)
		|	AND &FilterCriterion
		|TOTALS BY
		|	AccessKey";
	EndIf;
	
	QueryText = StrReplace(QueryText, "&FilterCriterion",
		StrReplace(FilterCriterion, "#FieldToCheck", "RightsToAccessKeys.AccessKey"));
	
	Context.PartsOfValuesFromKeysQueryToCalculateRights.Add(QueryText);
	
EndProcedure

// For the ComposeFillQueriesParts procedure.
Procedure AddQueryPartOfLeadingListsRightsSelection(Context)
	
	If Context.ConditionPartsToSelectLeadingListsRights.Count() = 0 Then
		Return;
	EndIf;
	
	If Context.Property("HeadListsWithTypesRightsSelectionCriteriaParts") Then
		QueryText =
		"SELECT
		|	RightsToLists.Table AS List,
		|	VALUETYPE(RightsToLists.Table.EmptyRefValue) AS ValueType,
		|	RightsToLists.AccessGroup AS RightsOwner,
		|	RightsToLists.RightUpdate AS RightUpdate
		|FROM
		|	InformationRegister.AccessGroupsTables AS RightsToLists
		|WHERE
		|	&FilterCriterion
		|	AND &QueryPlanClarification
		|TOTALS BY
		|	List";
	Else
		QueryText =
		"SELECT
		|	RightsToLists.Table AS List,
		|	RightsToLists.AccessGroup AS RightsOwner,
		|	RightsToLists.RightUpdate AS RightUpdate
		|FROM
		|	InformationRegister.AccessGroupsTables AS RightsToLists
		|WHERE
		|	&FilterCriterion
		|	AND &QueryPlanClarification
		|TOTALS BY
		|	List";
	EndIf;
	
	If Context.ConditionPartsToSelectLeadingListsRights.Count() = 1 Then
		FilterCriterion = Context.ConditionPartsToSelectLeadingListsRights[0];
	Else
		FilterCriterion = "(" + StrConcat(Context.ConditionPartsToSelectLeadingListsRights,
			Chars.LF + "			OR ") + ")"; // @query-part-1
	EndIf;
	FilterCriterion = StrReplace(FilterCriterion, "#FieldToCheck", "RightsToLists.Table");
	QueryText = StrReplace(QueryText, "&FilterCriterion", FilterCriterion);
	
	Context.PartsOfValuesFromKeysQueryToCalculateRights.Add(QueryText);
	
EndProcedure

// For the ComposeFillQueriesParts procedure.
Procedure AddQueryPartOfRightsSelectionByRightsSettingsOwners(Context)
	
	If Context.ConditionPartsToSelectRightsByRightsSettingsOwners.Count() = 0 Then
		Return;
	EndIf;
	
	QueryText =
	"SELECT DISTINCT
	|	SettingsInheritance.Object AS Object
	|INTO ObjectsWithReadProhibition
	|FROM
	|	InformationRegister.ObjectsRightsSettings AS RightsSettings
	|		INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
	|		ON RightsSettings.Object = SettingsInheritance.Parent
	|			AND (SettingsInheritance.UsageLevel < RightsSettings.ReadingProhibitionLevel)
	|			AND (&FilterCriterion)
	|			AND (&QueryPlanClarification)
	|
	|INDEX BY
	|	Object
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT DISTINCT
	|	SettingsInheritance.Object AS Object
	|INTO ObjectsWithEditProhibition
	|FROM
	|	InformationRegister.ObjectsRightsSettings AS RightsSettings
	|		INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
	|		ON RightsSettings.Object = SettingsInheritance.Parent
	|			AND (RightsSettings.Table = &RightSettingsTableID)
	|			AND (SettingsInheritance.UsageLevel < RightsSettings.ChangingProhibitionLevel)
	|			AND (&FilterCriterion)
	|			AND (&QueryPlanClarification)
	|
	|INDEX BY
	|	Object
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	ReadRightsSettings.Object AS Object,
	|	ReadRightsSettings.User AS User
	|INTO ReadRightsSettings
	|FROM
	|	(SELECT DISTINCT
	|		SettingsInheritance.Object AS Object,
	|		CASE
	|			WHEN SettingsInheritance.Object IN
	|					(SELECT
	|						ObjectsWithReadProhibition.Object
	|					FROM
	|						ObjectsWithReadProhibition)
	|				THEN UserGroupCompositions.User
	|			ELSE UserGroupCompositions.UsersGroup
	|		END AS User,
	|		TRUE AS ReadingAllowed,
	|		FALSE AS ReadProhibited
	|	FROM
	|		InformationRegister.ObjectsRightsSettings AS RightsSettings
	|			INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
	|			ON RightsSettings.Object = SettingsInheritance.Parent
	|				AND (SettingsInheritance.UsageLevel < RightsSettings.ReadingPermissionLevel)
	|				AND (&FilterCriterion)
	|				AND (&QueryPlanClarification)
	|			INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|			ON (UserGroupCompositions.UsersGroup = RightsSettings.User)
	|				AND (VALUETYPE(UserGroupCompositions.User) = TYPE(Catalog.Users))
	|				AND (UserGroupCompositions.Used)
	|				AND (UserGroupCompositions.User.IBUserID <> &BlankUUID)
	|	
	|	UNION ALL
	|	
	|	SELECT DISTINCT
	|		SettingsInheritance.Object,
	|		UserGroupCompositions.User,
	|		FALSE,
	|		TRUE
	|	FROM
	|		InformationRegister.ObjectsRightsSettings AS RightsSettings
	|			INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
	|			ON (SettingsInheritance.Object IN
	|					(SELECT
	|						ObjectsWithReadProhibition.Object
	|					FROM
	|						ObjectsWithReadProhibition))
	|				AND RightsSettings.Object = SettingsInheritance.Parent
	|				AND (SettingsInheritance.UsageLevel < RightsSettings.ReadingProhibitionLevel)
	|				AND (&FilterCriterion)
	|			INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|			ON (UserGroupCompositions.UsersGroup = RightsSettings.User)
	|				AND (VALUETYPE(UserGroupCompositions.User) = TYPE(Catalog.Users))
	|				AND (UserGroupCompositions.Used)
	|				AND (UserGroupCompositions.User.IBUserID <> &BlankUUID)) AS ReadRightsSettings
	|
	|GROUP BY
	|	ReadRightsSettings.Object,
	|	ReadRightsSettings.User
	|
	|HAVING
	|	MAX(ReadRightsSettings.ReadingAllowed) = TRUE AND
	|	MAX(ReadRightsSettings.ReadProhibited) = FALSE
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	UpdateRightsSettings.Object AS Object,
	|	UpdateRightsSettings.User AS User
	|INTO UpdateRightsSettings
	|FROM
	|	(SELECT DISTINCT
	|		SettingsInheritance.Object AS Object,
	|		CASE
	|			WHEN SettingsInheritance.Object IN
	|					(SELECT
	|						ObjectsWithEditProhibition.Object
	|					FROM
	|						ObjectsWithEditProhibition)
	|				THEN UserGroupCompositions.User
	|			ELSE UserGroupCompositions.UsersGroup
	|		END AS User,
	|		TRUE AS EditionAllowed,
	|		FALSE AS DataChangesDenied
	|	FROM
	|		InformationRegister.ObjectsRightsSettings AS RightsSettings
	|			INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
	|			ON RightsSettings.Object = SettingsInheritance.Parent
	|				AND (RightsSettings.Table = &RightSettingsTableID)
	|				AND (SettingsInheritance.UsageLevel < RightsSettings.ChangingPermissionLevel)
	|				AND (&FilterCriterion)
	|			INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|			ON (UserGroupCompositions.UsersGroup = RightsSettings.User)
	|				AND (VALUETYPE(UserGroupCompositions.User) = TYPE(Catalog.Users))
	|				AND (UserGroupCompositions.Used)
	|				AND (UserGroupCompositions.User.IBUserID <> &BlankUUID)
	|			INNER JOIN ReadRightsSettings AS ReadRightsSettings
	|			ON (ReadRightsSettings.Object = SettingsInheritance.Object)
	|				AND (ReadRightsSettings.User = UserGroupCompositions.UsersGroup
	|					OR ReadRightsSettings.User = UserGroupCompositions.User)
	|	
	|	UNION ALL
	|	
	|	SELECT DISTINCT
	|		SettingsInheritance.Object,
	|		UserGroupCompositions.User,
	|		FALSE,
	|		TRUE
	|	FROM
	|		InformationRegister.ObjectsRightsSettings AS RightsSettings
	|			INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
	|			ON (SettingsInheritance.Object IN
	|					(SELECT
	|						ObjectsWithEditProhibition.Object
	|					FROM
	|						ObjectsWithEditProhibition))
	|				AND RightsSettings.Object = SettingsInheritance.Parent
	|				AND (RightsSettings.Table = &RightSettingsTableID)
	|				AND (SettingsInheritance.UsageLevel < RightsSettings.ChangingProhibitionLevel)
	|				AND (&FilterCriterion)
	|			INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|			ON (UserGroupCompositions.UsersGroup = RightsSettings.User)
	|				AND (VALUETYPE(UserGroupCompositions.User) = TYPE(Catalog.Users))
	|				AND (UserGroupCompositions.Used)
	|				AND (UserGroupCompositions.User.IBUserID <> &BlankUUID)
	|			INNER JOIN ReadRightsSettings AS ReadRightsSettings
	|			ON (ReadRightsSettings.Object = SettingsInheritance.Object)
	|				AND (ReadRightsSettings.User = UserGroupCompositions.UsersGroup
	|					OR ReadRightsSettings.User = UserGroupCompositions.User)) AS UpdateRightsSettings
	|
	|GROUP BY
	|	UpdateRightsSettings.Object,
	|	UpdateRightsSettings.User
	|
	|HAVING
	|	MAX(UpdateRightsSettings.EditionAllowed) = TRUE AND
	|	MAX(UpdateRightsSettings.DataChangesDenied) = FALSE
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	RightsSettings.Object AS RightsSettingsOwner,
	|	RightsSettings.User AS RightsOwner,
	|	MAX(RightsSettings.RightUpdate) AS RightUpdate
	|FROM
	|	(SELECT
	|		ReadRightsSettings.Object AS Object,
	|		ReadRightsSettings.User AS User,
	|		FALSE AS RightUpdate
	|	FROM
	|		ReadRightsSettings AS ReadRightsSettings
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		UpdateRightsSettings.Object,
	|		UpdateRightsSettings.User,
	|		TRUE
	|	FROM
	|		UpdateRightsSettings AS UpdateRightsSettings) AS RightsSettings
	|
	|GROUP BY
	|	RightsSettings.Object,
	|	RightsSettings.User
	|TOTALS BY
	|	RightsSettingsOwner";
	
	If Context.ForExternalUsers Then
		QueryText = StrReplace(QueryText, "Catalog.Users", "Catalog.ExternalUsers");
	EndIf;
	
	If Context.ConditionPartsToSelectRightsByRightsSettingsOwners.Count() = 1 Then
		FilterCriterion = Context.ConditionPartsToSelectRightsByRightsSettingsOwners[0];
	Else
		FilterCriterion =  StrConcat(Context.ConditionPartsToSelectRightsByRightsSettingsOwners,
			Chars.LF + "			OR "); // @query-part-1
	EndIf;
	FilterCriterion = StrReplace(FilterCriterion, "#FieldToCheck", "SettingsInheritance.Object");
	QueryText = StrReplace(QueryText, "&FilterCriterion", TextWithIndent(FilterCriterion, "	"));
	
	Context.PartsOfValuesFromKeysQueryToCalculateRights.Add(QueryText);
	
EndProcedure

// For the ComposeFillQueriesParts procedure.
Function AccessKeysQueryTextToUpdateRights(Context)
	
	QueryText =
	"SELECT TOP 995
	|	AccessKeys.Ref AS Ref
	|FROM
	|	Catalog.AccessKeys AS AccessKeys
	|WHERE
	|	AccessKeys.List = &List
	|	AND AccessKeys.FieldsComposition = &FieldsComposition
	|	AND AccessKeys.ForExternalUsers = &ForExternalUsers
	|	AND AccessKeys.Ref > &LastAccessKey
	|	AND &QueryPlanClarification
	|
	|ORDER BY
	|	AccessKeys.Ref";
	
	InsertCommonParametersIntoQuery(QueryText, Context);
	Return QueryText;
	
EndFunction

// For the ComposeFillQueriesParts procedure.
Function KeysQueryTextByLeadingKeysToUpdateRights(Context)
	
	If Context.PartsOfFilterConditionByLeadingAccessKeys.Count() = 0 Then
		Return "";
	EndIf;
	
	QueryText =
	"SELECT TOP 995
	|	AccessKeys.Ref AS Ref
	|FROM
	|	Catalog.AccessKeys AS AccessKeys
	|WHERE
	|	AccessKeys.List = &List
	|	AND AccessKeys.FieldsComposition = &FieldsComposition
	|	AND AccessKeys.ForExternalUsers = &ForExternalUsers
	|	AND &FilterCriterion
	|	AND &QueryPlanClarification
	|
	|ORDER BY
	|	AccessKeys.Ref";
	
	InsertCommonParametersIntoQuery(QueryText, Context);
	If Context.PartsOfFilterConditionByLeadingAccessKeys.Count() = 1 Then
		FilterCriterion = Context.PartsOfFilterConditionByLeadingAccessKeys[0];
	Else
		FilterCriterion = "(" + StrConcat(Context.PartsOfFilterConditionByLeadingAccessKeys,
			Chars.LF + "			OR ") + ")"; // @query-part-1
	EndIf;
	
	QueryText = StrReplace(QueryText, "&FilterCriterion", FilterCriterion);
	
	Return QueryText;
	
EndFunction

// For the ComposeFillQueriesParts procedure.
Function ObsoleteAccessKeysQueryText(Context)
	
	If Context.IsReferenceType Then
		UsedKeysQueryText = // @query-part-1
		"SELECT DISTINCT
		|	AccessKeysForObjects.#UsersAccessKey AS AccessKey
		|INTO AccessKeysToUse
		|FROM
		|	InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
		|WHERE
		|	VALUETYPE(AccessKeysForObjects.Object) = TYPE(&CurrentList)
		|	AND AccessKeysForObjects.#UsersAccessKey > &LastAccessKey
		|	AND &QueryPlanClarification
		|
		|INDEX BY
		|	AccessKey"; // @query-part
	Else
		UsedKeysQueryText =
		"SELECT DISTINCT
		|	AccessKeysForRegisters.AccessKey AS AccessKey
		|INTO AccessKeysToUse
		|FROM
		|	&CurrentList AS AccessKeysForRegisters
		|WHERE
		|	AccessKeysForRegisters.Register = &List
		|	AND AccessKeysForRegisters.AccessOption = &AccessOption
		|	AND AccessKeysForRegisters.AccessKey > &LastAccessKey
		|	AND &QueryPlanClarification
		|
		|INDEX BY
		|	AccessKey";
		If ValueIsFilled(Context.SeparateKeysRegisterName) Then
			UsedKeysQueryText = StrReplace(UsedKeysQueryText,
				"AccessKeysForRegisters.Register = &List
				|	AND ", ""); // @query-part-1
		EndIf;
	EndIf;
	
	QueryText =
	"SELECT TOP 995
	|	AccessKeys.Ref AS Ref,
	|	AccessKeys.List AS List,
	|	AccessKeys.FieldsComposition AS FieldsComposition,
	|	AccessKeys.Hash AS Hash,
	|	NOT AccessKeysToUse.AccessKey IS NULL AS Used,
	|	AccessKeys.NotUsedSince <> DATETIME(1, 1, 1)
	|		AND AccessKeys.NotUsedSince < &ExpirationDate AS Delete
	|FROM
	|	Catalog.AccessKeys AS AccessKeys
	|		LEFT JOIN AccessKeysToUse AS AccessKeysToUse
	|		ON (AccessKeysToUse.AccessKey = AccessKeys.Ref)
	|WHERE
	|	AccessKeys.List = &List
	|	AND AccessKeys.ForExternalUsers = &ForExternalUsers
	|	AND AccessKeys.Ref > &LastAccessKey
	|	AND CASE
	|			WHEN AccessKeys.NotUsedSince = DATETIME(1, 1, 1)
	|				THEN AccessKeysToUse.AccessKey IS NULL
	|			ELSE NOT AccessKeysToUse.AccessKey IS NULL
	|					OR AccessKeys.NotUsedSince < &ExpirationDate
	|		END
	|	AND &QueryPlanClarification
	|
	|ORDER BY
	|	AccessKeys.Ref";
	
	QueryText = UsedKeysQueryText
		+ Common.QueryBatchSeparator() + QueryText;
	
	InsertCommonParametersIntoQuery(QueryText, Context);
	Return QueryText;
	
EndFunction

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure FillReadUpdateRightsCheckQueries(Result, Context)
	
	If Context.TypeCollectionName = "DocumentJournals" Then
		Return;
	EndIf;
	
	Properties = ListRestrictionProperties(Context.List, Context);
	
	If Context.IsReferenceType
	 Or Result.UsesRestrictionByOwner Then
		
		If Properties.TemplateRestrictionsWithUserAccessKeysAndAccessGroups
		 Or Properties.TemplateRestrictionsWithUserAccessKeys Then
			If Context.ForExternalUsers Then
				QueryText =
				"SELECT TOP 1
				|	TRUE AS TrueValue
				|FROM
				|	InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
				|WHERE
				|	AccessKeysForObjects.Object = &Object
				|	AND (TRUE IN
				|				(SELECT TOP 1
				|					TRUE
				|				FROM
				|					InformationRegister.ExternalUsersAccessKeys AS AllowedAccessKeys
				|				WHERE
				|					AllowedAccessKeys.AccessKey = AccessKeysForObjects.ExternalUsersAccessKey
				|					AND AllowedAccessKeys.ExternalUser IN (&AllowedUser, &AllowedUserGroupsSet)
				|					AND AllowedAccessKeys.RightUpdate)
				|			OR TRUE IN
				|				(SELECT TOP 1
				|					TRUE
				|				FROM
				|					InformationRegister.AccessGroupSetsAccessKeys AS AllowedAccessKeys
				|				WHERE
				|					AllowedAccessKeys.AccessKey = AccessKeysForObjects.ExternalUsersAccessKey
				|					AND AllowedAccessKeys.AccessGroupsSet IN (&AllowedAccessGroupsSet, &AllowedBlankAccessGroupsSet)
				|					AND AllowedAccessKeys.RightUpdate))";
			Else
				QueryText =
				"SELECT TOP 1
				|	TRUE AS TrueValue
				|FROM
				|	InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
				|WHERE
				|	AccessKeysForObjects.Object = &Object
				|	AND (TRUE IN
				|				(SELECT TOP 1
				|					TRUE
				|				FROM
				|					InformationRegister.UsersAccessKeys AS AllowedAccessKeys
				|				WHERE
				|					AllowedAccessKeys.AccessKey = AccessKeysForObjects.UsersAccessKey
				|					AND AllowedAccessKeys.User IN (&AllowedUser, &AllowedUserGroupsSet)
				|					AND AllowedAccessKeys.RightUpdate)
				|			OR TRUE IN
				|				(SELECT TOP 1
				|					TRUE
				|				FROM
				|					InformationRegister.AccessGroupSetsAccessKeys AS AllowedAccessKeys
				|				WHERE
				|					AllowedAccessKeys.AccessKey = AccessKeysForObjects.UsersAccessKey
				|					AND AllowedAccessKeys.AccessGroupsSet IN (&AllowedAccessGroupsSet, &AllowedBlankAccessGroupsSet)
				|					AND AllowedAccessKeys.RightUpdate))";
			EndIf;
		Else
			If Context.ForExternalUsers Then
				QueryText =
				"SELECT TOP 1
				|	TRUE AS TrueValue
				|FROM
				|	InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
				|		INNER JOIN InformationRegister.AccessGroupSetsAccessKeys AS AllowedAccessKeys
				|		ON (AccessKeysForObjects.Object = &Object)
				|			AND (AllowedAccessKeys.AccessKey = AccessKeysForObjects.ExternalUsersAccessKey)
				|			AND (AllowedAccessKeys.AccessGroupsSet IN (&AllowedAccessGroupsSet, &AllowedBlankAccessGroupsSet))
				|			AND (AllowedAccessKeys.RightUpdate)";
			Else
				QueryText =
				"SELECT TOP 1
				|	TRUE AS TrueValue
				|FROM
				|	InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
				|		INNER JOIN InformationRegister.AccessGroupSetsAccessKeys AS AllowedAccessKeys
				|		ON (AccessKeysForObjects.Object = &Object)
				|			AND (AllowedAccessKeys.AccessKey = AccessKeysForObjects.UsersAccessKey)
				|			AND (AllowedAccessKeys.AccessGroupsSet IN (&AllowedAccessGroupsSet, &AllowedBlankAccessGroupsSet))
				|			AND (AllowedAccessKeys.RightUpdate)";
			EndIf;
		EndIf;
	EndIf;
	
	If Not Result.UsesRestrictionByOwner Then
		QueryTextWithCheckByRightsSettingsOwners = "";
	Else
		EndFieldType = Context.FieldsProperties[0].EndFieldType;
		FieldRightsSettingsOwnersTypes = New Map;
		If Context.AccessRestrictionEnabled Then
			For Each KeyAndValue In Context.RightsSettingsOwnersTypes Do
				If EndFieldType.ContainsType(KeyAndValue.Key) Then
					FieldRightsSettingsOwnersTypes.Insert(KeyAndValue.Key,
						TypeNameInQueryLanguage(KeyAndValue.Key));
				EndIf;
			EndDo;
		EndIf;
		If FieldRightsSettingsOwnersTypes.Count() = 0 Then
			QueryTextWithCheckByRightsSettingsOwners = "";
			
		ElsIf EndFieldType.Types().Count() = FieldRightsSettingsOwnersTypes.Count() Then
			QueryTextWithCheckByRightsSettingsOwners =
				QueryTextWithCheckByRightsSettingsOwners();
		Else
			If Context.IsReferenceType Then
				QueryTextWithCheckByRightsSettingsOwners =
				"SELECT TOP 1
				|	TRUE AS TrueValue
				|WHERE
				|	CASE
				|			WHEN &RightsSettingsOwnerTypeCheckCondition
				|				THEN &ConditionWithRightsSettingsOwnersCheck
				|			ELSE TRUE IN
				|				(&StandardCheckQueryText)
				|		END";
			Else
				QueryTextWithCheckByRightsSettingsOwners =
				"SELECT TOP 1
				|	FALSE AS FalseValue
				|FROM
				|	&CurrentTable AS CurrentTable
				|WHERE
				|	&FilterByDimensions
				|	AND CASE
				|			WHEN &RightsSettingsOwnerTypeCheckCondition
				|				THEN &ConditionWithRightsSettingsOwnersCheck
				|			ELSE TRUE IN
				|				(&StandardCheckQueryText)
				|		END";
				QueryTextWithCheckByRightsSettingsOwners = StrReplace(QueryTextWithCheckByRightsSettingsOwners,
					"&CurrentTable", Context.List)
			EndIf;
			TypeCheckCondition = "";
			For Each TypeProperties In FieldRightsSettingsOwnersTypes Do
				TypeCheckCondition = TypeCheckCondition + ?(TypeCheckCondition = "", "", "
				|					") + "VALUETYPE(&Object) = TYPE(" + TypeProperties.Value + ")"; // @query-part-2
			EndDo;
			QueryTextWithCheckByRightsSettingsOwners = StrReplace(
				QueryTextWithCheckByRightsSettingsOwners,
				"&RightsSettingsOwnerTypeCheckCondition",
				TypeCheckCondition);
			
			QueryTextWithCheckByRightsSettingsOwners = StrReplace(
				QueryTextWithCheckByRightsSettingsOwners,
				"&ConditionWithRightsSettingsOwnersCheck",
				TextWithIndent(ConditionFromQueryWithCheckByRightsSettingsOwners(),
					"				"));
			
			QueryTextWithCheckByRightsSettingsOwners = StrReplace(
				QueryTextWithCheckByRightsSettingsOwners,
				"&StandardCheckQueryText",
				TextWithIndent(QueryText, "				"));
		EndIf;
	EndIf;
	
	If Result.UsesRestrictionByOwner Then
		If Context.IsReferenceType Then
			ObjectField = "CAST(&Object AS " + Context.List + ")." + Result.OwnerField.Name; // @query-part-1
			Result.OwnerObjectFieldInRightsValidationQuery = ObjectField;
		Else
			ObjectField = "CurrentTable." + Result.OwnerField.Name;
		EndIf;
		QueryText = StrReplace(QueryText, "&Object", ObjectField);
		QueryTextWithCheckByRightsSettingsOwners =
			StrReplace(QueryTextWithCheckByRightsSettingsOwners, "&Object", ObjectField);
		
	ElsIf Not Context.IsReferenceType Then
		
		If Properties.TemplateRestrictionsWithUserAccessKeysAndAccessGroups
		 Or Properties.TemplateRestrictionsWithUserAccessKeys Then
			
			If Context.ForExternalUsers Then
				QueryText =
				"SELECT TOP 1
				|	TRUE AS TrueValue
				|FROM
				|	InformationRegister.AccessKeysForRegisters AS AccessKeysForRegisters
				|WHERE
				|	AccessKeysForRegisters.Register = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				|	AND AccessKeysForRegisters.Field1 = &CurrentTableField1
				|	AND (TRUE IN
				|				(SELECT TOP 1
				|					TRUE
				|				FROM
				|					InformationRegister.ExternalUsersAccessKeys AS AllowedAccessKeys
				|				WHERE
				|					AllowedAccessKeys.AccessKey = AccessKeysForRegisters.AccessKey
				|					AND AllowedAccessKeys.ExternalUser IN (&AllowedUser, &AllowedUserGroupsSet)
				|					AND AllowedAccessKeys.RightUpdate)
				|			OR TRUE IN
				|				(SELECT TOP 1
				|					TRUE
				|				FROM
				|					InformationRegister.AccessGroupSetsAccessKeys AS AllowedAccessKeys
				|				WHERE
				|					AllowedAccessKeys.AccessKey = AccessKeysForRegisters.AccessKey
				|					AND AllowedAccessKeys.AccessGroupsSet IN (&AllowedAccessGroupsSet, &AllowedBlankAccessGroupsSet)
				|					AND AllowedAccessKeys.RightUpdate))";
			Else
				QueryText =
				"SELECT TOP 1
				|	TRUE AS TrueValue
				|FROM
				|	InformationRegister.AccessKeysForRegisters AS AccessKeysForRegisters
				|WHERE
				|	AccessKeysForRegisters.Register = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				|	AND AccessKeysForRegisters.Field1 = &CurrentTableField1
				|	AND (TRUE IN
				|				(SELECT TOP 1
				|					TRUE
				|				FROM
				|					InformationRegister.UsersAccessKeys AS AllowedAccessKeys
				|				WHERE
				|					AllowedAccessKeys.AccessKey = AccessKeysForRegisters.AccessKey
				|					AND AllowedAccessKeys.User IN (&AllowedUser, &AllowedUserGroupsSet)
				|					AND AllowedAccessKeys.RightUpdate)
				|			OR TRUE IN
				|				(SELECT TOP 1
				|					TRUE
				|				FROM
				|					InformationRegister.AccessGroupSetsAccessKeys AS AllowedAccessKeys
				|				WHERE
				|					AllowedAccessKeys.AccessKey = AccessKeysForRegisters.AccessKey
				|					AND AllowedAccessKeys.AccessGroupsSet IN (&AllowedAccessGroupsSet, &AllowedBlankAccessGroupsSet)
				|					AND AllowedAccessKeys.RightUpdate))";
			EndIf;
		Else
			QueryText =
			"SELECT TOP 1
			|	TRUE AS TrueValue
			|FROM
			|	InformationRegister.AccessKeysForRegisters AS AccessKeysForRegisters
			|		INNER JOIN InformationRegister.AccessGroupSetsAccessKeys AS AllowedAccessKeys
			|		ON (AccessKeysForRegisters.Register = VALUE(Catalog.MetadataObjectIDs.EmptyRef))
			|			AND (AccessKeysForRegisters.Field1 = &CurrentTableField1)
			|			AND (AllowedAccessKeys.AccessKey = AccessKeysForRegisters.AccessKey)
			|			AND (AllowedAccessKeys.AccessGroupsSet IN (&AllowedAccessGroupsSet, &AllowedBlankAccessGroupsSet))
			|			AND (AllowedAccessKeys.RightUpdate)";
		EndIf;
		
		ClarifyKeysRegisterAndConnectionCondition(QueryText, Result, Context);
		
		NewBasicFieldsValuesCombinationsQueryTextForExistingRecords =
		"SELECT DISTINCT
		|	&CurrentTableField1 AS Field1
		|FROM
		|	&List AS CurrentTable
		|		LEFT JOIN InformationRegister.AccessKeysForRegisters AS AccessKeysForRegisters
		|		ON (AccessKeysForRegisters.Register = VALUE(Catalog.MetadataObjectIDs.EmptyRef))
		|			AND (AccessKeysForRegisters.Field1 = &CurrentTableField1)
		|WHERE
		|	&FilterByDimensions
		|	AND AccessKeysForRegisters.AccessOption IS NULL";
		NewBasicFieldsValuesCombinationsQueryTextForNewRecords =
		"SELECT
		|	&CurrentTableField1 AS CurrentTableField1
		|INTO BasicFieldsValuesCombinations
		|FROM
		|	&BasicFieldsValuesCombinations AS CurrentTable
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|SELECT DISTINCT
		|	&CurrentTableField1 AS Field1
		|FROM
		|	BasicFieldsValuesCombinations AS CurrentTable
		|		LEFT JOIN InformationRegister.AccessKeysForRegisters AS AccessKeysForRegisters
		|		ON (AccessKeysForRegisters.Register = VALUE(Catalog.MetadataObjectIDs.EmptyRef))
		|			AND (AccessKeysForRegisters.Field1 = &CurrentTableField1)
		|WHERE
		|	AccessKeysForRegisters.AccessOption IS NULL";
		ClarifyKeysRegisterAndConnectionCondition(NewBasicFieldsValuesCombinationsQueryTextForExistingRecords,
			Result, Context, True);
		ClarifyKeysRegisterAndConnectionCondition(NewBasicFieldsValuesCombinationsQueryTextForNewRecords,
			Result, Context, True);
		
		Result.NewBasicFieldsValuesCombinationsQueryTextForExistingRecords =
			NewBasicFieldsValuesCombinationsQueryTextForExistingRecords;
		Result.NewBasicFieldsValuesCombinationsQueryTextForNewRecords =
			NewBasicFieldsValuesCombinationsQueryTextForNewRecords;
	EndIf;
	
	If Not Context.IsReferenceType Then
		RegisterRequestText =
		"SELECT TOP 1
		|	FALSE AS FalseValue
		|FROM
		|	&CurrentTable AS CurrentTable
		|WHERE
		|	&FilterByDimensions
		|	AND NOT TRUE IN
		|				(&QueryCondition)";
		RegisterRequestText = StrReplace(RegisterRequestText, "&CurrentTable", Context.List);
		QueryText = StrReplace(RegisterRequestText, "&QueryCondition", TextWithIndent(QueryText, "				"));
	EndIf;
	
	If ValueIsFilled(QueryTextWithCheckByRightsSettingsOwners) Then
		Result.ReadEditRightsCheckQueryText = QueryTextWithCheckByRightsSettingsOwners;
	Else
		Result.ReadEditRightsCheckQueryText = QueryText;
	EndIf;
	
	If Not Result.RightToWriteRestrictionDisabled Then
		Result.ReadRightsCheckQueryText = StrReplace(QueryText,
			"AllowedAccessKeys.RightUpdate", "True");
	EndIf;
	
	If Result.UsesRestrictionByOwner
	   And Result.OwnerField.EditAsRead Then
		
		Result.ReadEditRightsCheckQueryText = Result.ReadRightsCheckQueryText;
	EndIf;
	
EndProcedure

// For the FillReadUpdateRightsCheckQueries procedure.
Function ConditionFromQueryWithCheckByRightsSettingsOwners()
	
	Rows = StrSplit(QueryTextWithCheckByRightsSettingsOwners(), Chars.LF, "");
	Rows.Delete(0);
	Rows.Delete(0);
	Rows.Delete(0);
	
	Return TrimAll(StrConcat(Rows, Chars.LF));
	
EndFunction

// For the FillReadUpdateRightsCheckQueries procedure.
Function QueryTextWithCheckByRightsSettingsOwners()
	
	Return
	"SELECT TOP 1
	|	TRUE AS TrueValue
	|WHERE
	|	TRUE IN
	|			(SELECT TOP 1
	|				TRUE
	|			FROM
	|				InformationRegister.ObjectsRightsSettings AS RightsSettings
	|					INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
	|					ON
	|						SettingsInheritance.Object = &Object
	|							AND RightsSettings.Object = SettingsInheritance.Parent
	|							AND RightsSettings.Table = &RightSettingsTableID
	|							AND SettingsInheritance.UsageLevel < RightsSettings.ChangingPermissionLevel
	|					INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|					ON
	|						UserGroupCompositions.User = &AuthorizedUser
	|							AND UserGroupCompositions.UsersGroup = RightsSettings.User)
	|	AND NOT FALSE IN
	|				(SELECT TOP 1
	|					FALSE
	|				FROM
	|					InformationRegister.ObjectsRightsSettings AS RightsSettings
	|						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
	|						ON
	|							SettingsInheritance.Object = &Object
	|								AND RightsSettings.Object = SettingsInheritance.Parent
	|								AND RightsSettings.Table = &RightSettingsTableID
	|								AND SettingsInheritance.UsageLevel < RightsSettings.ChangingProhibitionLevel
	|						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|						ON
	|							UserGroupCompositions.User = &AuthorizedUser
	|								AND UserGroupCompositions.UsersGroup = RightsSettings.User)";
	
EndFunction

// For the FillReadUpdateRightsCheckQueries procedure.
Procedure ClarifyKeysRegisterAndConnectionCondition(QueryText, Result, Context, AddSelectionFields = False)
	
	If ValueIsFilled(Result.SeparateKeysRegisterName) Then
		QueryText = StrReplace(QueryText,
			"InformationRegister.AccessKeysForRegisters",
			"InformationRegister." + Result.SeparateKeysRegisterName);
		QueryText = StrReplace(QueryText,
			"AccessKeysForRegisters.Register = VALUE(Catalog.MetadataObjectIDs.EmptyRef)", // @query-part-1
			"TRUE");
	Else
		QueryText = StrReplace(QueryText,
			"MetadataObjectIDs.EmptyRef",
			AccessManagementInternalCached.PredefinedMetadataObjectIDDetails(
				Context.List));
	EndIf;
	
	AccessOptionsUsed = Context.BasicAccessOptions.Get(Context.List);
	If AccessOptionsUsed = Undefined Then
		AccessOptionUsed = NewAccessOptionUsed();
		AccessOptionUsed.AccessOption = Result.AccessOption;
		AccessOptionUsed.ConnectionFields = StrConcat(Result.BasicFields.UsedItems, ",");
		AccessOptionsUsed = New Array;
		AccessOptionsUsed.Add(AccessOptionUsed);
	EndIf;
	If AddSelectionFields Then
		AccessOptionUsed = AccessOptionsUsed[0];
		AccessOptionsUsed = New Array;
		AccessOptionsUsed.Add(AccessOptionUsed);
	EndIf;
	
	FilterConditions = New Array;
	ConnectionConditions = New Array;
	For Each AccessOptionUsed In AccessOptionsUsed Do
		Condition = New Array;
		StringAccessOption = XMLString(AccessOptionUsed.AccessOption);
		StringAccessOption = ?(ValueIsFilled(StringAccessOption), StringAccessOption, "NULL");
		Condition.Add("AccessKeysForRegisters.AccessOption = " + StringAccessOption);
		FieldNumber = 1;
		FieldsNames = StrSplit(AccessOptionUsed.ConnectionFields, ",", False);
		For Each FieldName In FieldsNames Do
			Condition.Add("AccessKeysForRegisters.Field" + FieldNumber + " = CurrentTable." + FieldName);
			FieldNumber = FieldNumber + 1;
		EndDo;
		If AccessOptionsUsed.Count() = 1 Then
			FilterConditions.Add("AND " + StrConcat(Condition, Chars.LF + "AND ")); // @query-part-1 @query-part-2
			ConnectionConditions.Add("AND (" + StrConcat(Condition, ")" + Chars.LF + "AND (") + ")"); // @query-part-1 @query-part-3
		Else
			FilterConditions.Add(StrConcat(Condition, Chars.LF + "			And "));
			ConnectionConditions.Add(StrConcat(Condition, Chars.LF + "		And "));
		EndIf;
	EndDo;
	
	If AccessOptionsUsed.Count() = 1 Then
		FilterCriterion = FilterConditions[0];
		ConnectionCondition = ConnectionConditions[0];
	Else
		FilterCriterion = "AND (" + StrConcat(FilterConditions, Chars.LF + "		OR ") + ")"; // @query-part-1 @query-part-2
		ConnectionCondition =  "AND (" + StrConcat(ConnectionConditions, Chars.LF + " OR ") + ")"; // @query-part-1 @query-part-2
	EndIf;
	
	QueryText = StrReplace(QueryText,
		"AND AccessKeysForRegisters.Field1 = &CurrentTableField1", // @query-part-1
		TextWithIndent(TrimL(FilterCriterion), "	"));
	QueryText = StrReplace(QueryText,
		"AND (AccessKeysForRegisters.Field1 = &CurrentTableField1)", // @query-part-1
		TextWithIndent(TrimL(ConnectionCondition), "			"));
	
	If Not AddSelectionFields Then
		Return;
	EndIf;
	
	BasicFields = "";
	SelectionFields = "";
	FieldNumber = 1;
	For Each Field In Result.BasicFields.UsedItems Do
		BasicFields = BasicFields + ?(BasicFields = "", "", "," + Chars.LF)
			+ "CurrentTable." + Field + " AS " + Field; // @query-part-2
		SelectionFields = SelectionFields + ?(SelectionFields = "", "", "," + Chars.LF)
			+ "CurrentTable." + Field + " AS Field" + FieldNumber; // @query-part-2
		FieldNumber = FieldNumber + 1;
	EndDo;
	
	QueryText = StrReplace(QueryText,
		"&CurrentTableField1 AS CurrentTableField1", // @query-part-1
		TextWithIndent(TrimL(BasicFields), "	"));
	
	QueryText = StrReplace(QueryText,
		"&CurrentTableField1 AS Field1", // @query-part-1
		TextWithIndent(TrimL(SelectionFields), "	"));
	
	QueryText = StrReplace(QueryText, "&List", Context.List);
	
EndProcedure

// For the ComposeQueriesParts function.
Procedure InsertCommonParametersIntoQuery(QueryText, Context)
	
	If Context.ForExternalUsers Then
		QueryText = StrReplace(QueryText, "#ObjectUserAccessKey", "ExternalUsersAccessKey");
	Else
		QueryText = StrReplace(QueryText, "#ObjectUserAccessKey", "UsersAccessKey");
	EndIf;
	
	If Context.IsReferenceType Then
		QueryText = StrReplace(QueryText, "&CurrentList", Context.List);
		QueryText = StrReplace(QueryText, "#DataAccessKeys", "AccessKeysForObjects");
		
		If Context.ForExternalUsers Then
			QueryText = StrReplace(QueryText, "#UsersAccessKey", "ExternalUsersAccessKey");
		Else
			QueryText = StrReplace(QueryText, "#UsersAccessKey", "UsersAccessKey");
		EndIf;
	Else
		QueryText = StrReplace(QueryText, "&CurrentRegister", Context.List);
		QueryText = StrReplace(QueryText, "#DataAccessKeys", "CurrentList");
		QueryText = StrReplace(QueryText, "CurrentList.Register = &RegisterID", "#1");
		QueryText = StrReplace(QueryText, "CurrentList.AccessOption = &AccessOption", "#2");
		Number = 0;
		For Each BasicFieldName In Context.BasicFields.UsedItems Do
			Number = Number + 1;
			QueryText = StrReplace(QueryText, "CurrentList."
				+ BasicFieldName, "CurrentList.Field" + Number);
			
			QueryText = StrReplace(QueryText, "CurrentListSource."
				+ BasicFieldName, "CurrentListSource.Field" + Number);
		EndDo;
		QueryText = StrReplace(QueryText, "#1", "CurrentList.Register = &RegisterID");
		QueryText = StrReplace(QueryText, "#2", "CurrentList.AccessOption = &AccessOption");
		QueryText = StrReplace(QueryText, "&CurrentList", ?(Context.SeparateKeysRegisterName = "",
			"InformationRegister.AccessKeysForRegisters", "InformationRegister." + Context.SeparateKeysRegisterName));
		
		QueryText = StrReplace(QueryText, "#UsersAccessKey", "AccessKey");
	EndIf;
	
	QueryText = StrReplace(QueryText, "&FieldsComposition", Format(Context.FieldsComposition, "NZ=0; NG="));
	QueryText = StrReplace(QueryText, "&AccessOption", XMLString(Context.AccessOption));
	QueryText = StrReplace(QueryText, "&ForExternalUsers",
		?(Context.ForExternalUsers, "TRUE", "FALSE"));
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure AddKeyHeaderCheck(Context, HeaderNumber)
	
	GroupOfFields = Context.FieldsGroups.Get("Header" + HeaderNumber);
	If GroupOfFields = Undefined Then
		If HeaderNumber > 0 Then
			Return;
		EndIf;
		ConnectionsAndFields = New Structure("Joins, Fields", "", "");
	Else
		ConnectionsAndFields = ConnectionsAndFieldsByTables(GroupOfFields,
			False, HeaderNumber).Get("CurrentList");
	EndIf;
	
	If HeaderNumber = 0 Then
		Joins = ConnectionsAndFields.Joins + "
		|LEFT JOIN Catalog.AccessKeys AS Header0
		|ON (Header0.Ref = #DataAccessKeys.#UsersAccessKey)" // @query-part-1 
		+ ?(Context.FieldsComposition = 0, "
		|	AND (Header0.List = &List)", "") // @query-part-1 
		+ "
		|	AND (Header0.FieldsComposition = &FieldsComposition)"; // @query-part-1
	Else
		Joins = ConnectionsAndFields.Joins + "
		|LEFT JOIN Catalog.AccessKeys.Header AS Header?
		|ON (Header?.Ref = #DataAccessKeys.#UsersAccessKey)
		|	AND (Header?.LineNumber = &HeaderNumber)"; // @query-part-1
		Joins = StrReplace(Joins, "&HeaderNumber", HeaderNumber);
	EndIf;
	
	Joins = TrimL(Joins) + TextWithIndent(ConnectionsAndFields.Fields, "	");
	Joins = TextWithIndent(Joins, "		");
	
	ConditionPartTextTemplate =
	"NOT TRUE IN
	|(SELECT TOP 1
	|	TRUE
	|FROM
	|	(SELECT
	|		TRUE AS TrueValue) AS TrueValue
	|		#Joins
	|WHERE
	|	&QueryCondition)"; // @query-part-1
	
	ConditionPartText = ConditionPartTextTemplate;
	ConditionPartText = StrReplace(ConditionPartText, "#Joins", Joins);
	ConditionPartText = StrReplace(ConditionPartText, "&QueryCondition", 
		TextWithIndent("NOT Header?.Ref IS NULL", "	")); // @query-part-1
	ConditionPartText = StrReplace(ConditionPartText, "Header?", "Header" + HeaderNumber);
	Context.CheckConditionParts.Add(ConditionPartText);
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure AddKeyTabularSectionCheck(Context, KeyTabularSectionNumber)
	
	TablesByGroups  = Context.AdditionalTablesGroups.TablesByGroups;
	AdditionalTablesGroup = TablesByGroups.Get(KeyTabularSectionNumber
		- (Context.KeyTabularSectionsCount - TablesByGroups.Count()));
	
	KeyTabularSectionName = "TabularSection" + KeyTabularSectionNumber;
	GroupOfFields = Context.FieldsGroups.Get(KeyTabularSectionName);
	
	ConnectionsAndFieldsByTables = ConnectionsAndFieldsByTables(GroupOfFields,
		True, , , OneAdditionalTableWithFieldsInGroup(Context, AdditionalTablesGroup));
	
	Joins = "";
	Condition = "";
	Fields = "";
	
	If AdditionalTablesGroup = Undefined Then
		ObjectTabularSectionAlias = Context.ObjectTabularSectionsAliases.Get(KeyTabularSectionNumber);
		If ObjectTabularSectionAlias = Undefined Then
			ConnectionsAndFields = ConnectionsAndFieldsByTables.Get("CurrentList");
			Condition = "TRUE";
		Else
			ObjectTabularSectionName = StrReplace(ObjectTabularSectionAlias, "CurrentList", "");
			ConnectionsAndFields = ConnectionsAndFieldsByTables.Get(ObjectTabularSectionAlias);
			// @query-part-1 @query-part-2
			Joins = Joins + "
			|LEFT JOIN &CurrentList." + ObjectTabularSectionName + " AS " + ObjectTabularSectionAlias + "
			|On " + ObjectTabularSectionAlias + ".Ref = CurrentList.Ref"; // @query-part-1
			Condition = ObjectTabularSectionAlias + ".Ref #CheckNULL";
		EndIf;
		Joins = Joins + ConnectionsAndFields.Joins;
		Fields = ConnectionsAndFields.Fields;
	Else
		For Each AdditionalTable In AdditionalTablesGroup Do
			// @query-part-1 @query-part-2
			Joins = Joins + "
			|LEFT JOIN " + AdditionalTable.Table + " AS " + AdditionalTable.Alias + "
			|On " + TextWithIndent(AdditionalTable.ConnectionConditionText, "	"); // @query-part-1
			ConnectionsAndFields = ConnectionsAndFieldsByTables.Get(AdditionalTable.Alias);
			If ConnectionsAndFields = Undefined Then
				Continue;
			EndIf;
			Joins = Joins + ConnectionsAndFields.Joins;
			Condition = Condition + ?(Condition = "", "", "
			|OR ") + AdditionalTable.ConnectionTestField + " #CheckNULL"; // @query-part-1
			Fields = Fields + ConnectionsAndFields.Fields;
		EndDo;
		If StrLineCount(Condition) > 1 Then
			Condition = "(" + Condition + ")";
		EndIf;
	EndIf;
	InitialConnections = Joins;
	InitialCondition = Condition;
	
	ConditionPartTextTemplate =
	"FALSE IN
	|(SELECT TOP 1
	|	FALSE
	|FROM
	|	(SELECT
	|		TRUE AS TrueValue) AS TrueValue
	|		#Joins
	|WHERE
	|	&QueryCondition)"; // @query-part
	
	// 
	Joins = InitialConnections + "
	|LEFT JOIN Catalog.AccessKeys.TabularSection? AS TabularSection?
	|ON (TabularSection?.Ref = #DataAccessKeys.#UsersAccessKey)"; // @query-part
	Joins = TrimL(Joins) + TextWithIndent(Fields, "	");
	Joins = TextWithIndent(Joins, "		");
	
	Condition =
	"TabularSection?.Ref IS NULL
	|AND " + TextWithIndent(TrimL(InitialCondition), "	"); // @query-part-1
	Condition = TextWithIndent(Condition, "	");
	Condition = StrReplace(Condition, "#CheckNULL", "IS NOT NULL"); // @query-part-2
	
	ConditionPartText = ConditionPartTextTemplate;
	ConditionPartText = StrReplace(ConditionPartText, "#Joins",     Joins);
	ConditionPartText = StrReplace(ConditionPartText, "&QueryCondition", Condition);
	ConditionPartText = StrReplace(ConditionPartText, "TabularSection?", KeyTabularSectionName);
	Context.CheckConditionParts.Add(ConditionPartText);
	
	// Reversed connection (checking if there are excess records in the key).
	If AdditionalTablesGroup = Undefined
	 Or AdditionalTablesGroup.Count() = 1 Then
		
		Joins =
		"LEFT JOIN Catalog.AccessKeys.TabularSection? AS TabularSection?
		|ON (TabularSection?.Ref = #DataAccessKeys.#UsersAccessKey)"; // @query-part-1
		
		If AdditionalTablesGroup = Undefined Then
			If ObjectTabularSectionName = Undefined Then
				AliasOfTheIntermediateTable = "IntermediateTable" + KeyTabularSectionNumber;
				Joins = Joins + "
				|LEFT JOIN (SELECT
				|	TRUE AS TrueValue) AS " + AliasOfTheIntermediateTable // @query-part-1 @query-part-2
					  + TextWithIndent(ConnectionsAndFields.Joins, "	") + "
				|On TRUE" // @query-part-1
				      + TextWithIndent(ConnectionsAndFields.Fields, "	");
				InitialCondition = AliasOfTheIntermediateTable + ".TrueValue #CheckNULL";
			Else
				Joins = Joins + "
				|LEFT JOIN &CurrentList." + ObjectTabularSectionName + " AS " + ObjectTabularSectionAlias // @query-part-1 @query-part-2
					  + TextWithIndent(ConnectionsAndFields.Joins, "	") + "
				|On " + ObjectTabularSectionAlias + ".Ref = CurrentList.Ref" // @query-part-1
				      + TextWithIndent(ConnectionsAndFields.Fields, "	");
			EndIf;
		Else
			AdditionalTable = AdditionalTablesGroup[0];
			ConnectionsAndFields = ConnectionsAndFieldsByTables.Get(AdditionalTable.Alias);
			Joins = Joins + "
			|LEFT JOIN " + AdditionalTable.Table + " AS " + AdditionalTable.Alias // @query-part-1 @query-part-2
				  + TextWithIndent(ConnectionsAndFields.Joins, "	") + "
			|On " + TextWithIndent(AdditionalTable.ConnectionConditionText, "	") // @query-part-1
			      + TextWithIndent(ConnectionsAndFields.Fields, "	");
		EndIf;
		Joins = TextWithIndent(Joins, "		");
		
		Condition =
		"TabularSection?.Ref IS NOT NULL
		|AND " + TrimL(InitialCondition); // @query-part-1
		Condition = TextWithIndent(Condition, "	");
		Condition = StrReplace(Condition, "#CheckNULL", "IS NULL"); // @query-part-2
	Else
		Joins =
		"LEFT JOIN Catalog.AccessKeys.TabularSection? AS TabularSection?
		|ON (TabularSection?.Ref = #DataAccessKeys.#UsersAccessKey)
		|LEFT JOIN &CurrentList AS CurrentListSource" // @query-part-1
			+ TextWithIndent(InitialConnections, "	") + "
		|On " + ?(Context.IsReferenceType, "(CurrentListSource.Ref = CurrentList#.Ref)", // @query-part-1
			Context.BasicFields.ConnectionCondition);
		
		Joins = Joins + TextWithIndent(Fields, "	");
		Joins = TextWithIndent(Joins, "		");
		Joins = StrReplace(Joins, "CurrentList.", "CurrentListSource.");
		Joins = StrReplace(Joins, "CurrentList#.", "CurrentList.");
		
		If Context.IsReferenceType Then
			Condition =
			"TabularSection?.Ref IS NOT NULL
			|AND CurrentListSource.Ref IS NULL"; // @query-part-1
		Else
			Condition =
			"TabularSection?.Ref IS NOT NULL
			|AND CurrentListSource.Field1 IS NULL"; // @query-part-1
		EndIf;
		Condition = TextWithIndent(Condition, "	");
	EndIf;
	
	ConditionPartText = ConditionPartTextTemplate;
	ConditionPartText = StrReplace(ConditionPartText, "#Joins",     Joins);
	ConditionPartText = StrReplace(ConditionPartText, "&QueryCondition", Condition);
	ConditionPartText = StrReplace(ConditionPartText, "TabularSection?", KeyTabularSectionName);
	Context.CheckConditionParts.Add(ConditionPartText);
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure AddKeyHeaderFilling(Context, HeaderNumber)
	
	If Not Context.IsReferenceType And HeaderNumber = 0 Then
		QueryText =
		"SELECT
		|	CurrentList.CurrentRef AS CurrentRef,
		|	&BasicFieldsForSelection
		|	INTO CurrentList
		|FROM
		|	&BasicFieldsValues AS CurrentList";
		QueryText = StrReplace(QueryText, "&BasicFieldsForSelection", Context.BasicFields.ForSelection);
		Context.PartsOfValuesFromObjectsQuery.Add(QueryText);
		
	ElsIf HeaderNumber = 0 Then
		For Each TableDetails In Context.ObjectTablesFields.Result Do
			QueryText = 
			"SELECT
			|	&TableFields
			|	INTO #FullTableName
			|FROM
			|	&FullTableName AS CurrentTable";
			QueryText = StrReplace(QueryText, "&TableFields", 
				"CurrentTable." + StrConcat(TableDetails.Fields, ",
					|	CurrentTable."));
			QueryText = StrReplace(QueryText, "#FullTableName", TableDetails.FullTableName);
			QueryText = StrReplace(QueryText, "&FullTableName", "&" + TableDetails.FullTableName);
			Context.PartsOfQueryForInMemoryObjectsValues.Add(QueryText);
		EndDo;
	EndIf;
	
	GroupOfFields = Context.FieldsGroups.Get("Header" + HeaderNumber);
	If GroupOfFields = Undefined Then
		Return;
	EndIf;
	AddKeyTableDetails("Header" + HeaderNumber, GroupOfFields, Context);
	
	ConnectionsAndFields = ConnectionsAndFieldsByTables(GroupOfFields, False,
		HeaderNumber, True).Get("CurrentList");
	
	// Selecting values from objects to search and create access keys.
	If Context.IsReferenceType Then
		QueryText =
		"SELECT
		|	CurrentList.Ref AS CurrentRef
		|	,&QueryFields
		|FROM
		|	&CurrentList AS CurrentList
		|	#RequestConnections
		|WHERE
		|	CurrentList.Ref IN (&ObjectsRefs)
		|	AND &QueryPlanClarification
		|
		|ORDER BY
		|	CurrentRef
		|TOTALS BY
		|	CurrentRef"; // @query-part-1
	Else
		QueryText =
		"SELECT
		|	CurrentList.CurrentRef AS CurrentRef
		|	,&QueryFields
		|FROM
		|	CurrentList AS CurrentList
		|	#RequestConnections
		|WHERE
		|	&QueryPlanClarification
		|
		|ORDER BY
		|	CurrentRef, 
		|	&BasicFieldsForOrdering
		|TOTALS BY
		|	CurrentRef"; // @query-part-1
		QueryText = StrReplace(QueryText, "&BasicFieldsForOrdering", Context.BasicFields.ForOrdering);
	EndIf;
	QueryText = StrReplace(QueryText, ",&QueryFields", TextWithIndent(ConnectionsAndFields.Fields, "	"));
	QueryText = StrReplace(QueryText, "#RequestConnections", TextWithIndent(ConnectionsAndFields.Joins, "	"));
	
	Context.PartsOfValuesFromObjectsQuery.Add(QueryText);
	Context.PartsOfQueryForInMemoryObjectsValues.Add(QueryText);
	
	// Selecting values from access keys to compare with the required key values.
	If HeaderNumber = 0 Then
		QueryText = 
		"SELECT
		|	Header0.Ref AS CurrentRef
		|	,&Attributes
		|FROM
		|	Catalog.AccessKeys AS Header0
		|WHERE
		|	Header0.Hash IN(&Hashes)
		|	AND Header0.List = &List
		|	AND Header0.FieldsComposition = &FieldsComposition
		|	AND Header0.ForExternalUsers = &ForExternalUsers
		|	AND Header0.NotUsedSince = DATETIME(1, 1, 1)
		|	AND &QueryPlanClarification
		|
		|ORDER BY
		|	CurrentRef
		|TOTALS BY
		|	CurrentRef";
	Else
		
		QueryText =
		"SELECT
		|	Header?.Ref AS CurrentRef
		|	,&Attributes
		|FROM
		|	Catalog.AccessKeys.Header AS Header?
		|WHERE
		|	&HeaderNumberCondition
		|	AND Header?.Ref.Hash IN(&Hashes)
		|	AND Header?.Ref.List = &List
		|	AND Header?.Ref.FieldsComposition = &FieldsComposition
		|	AND Header?.Ref.ForExternalUsers = &ForExternalUsers
		|	AND Header?.Ref.NotUsedSince = DATETIME(1, 1, 1)
		|	AND &QueryPlanClarification
		|
		|ORDER BY
		|	CurrentRef
		|TOTALS BY
		|	CurrentRef"; // @query-part
		QueryText = StrReplace(QueryText, "&HeaderNumberCondition", 
			"Header" + HeaderNumber + ".LineNumber = " + HeaderNumber);
	EndIf;
	
	QueryText = StrReplace(QueryText, ",&Attributes", TextWithIndent(ConnectionsAndFields.Attributes, "	"));
	QueryText = StrReplace(QueryText, "Header?", "Header" + HeaderNumber);
	Context.PartsOfValuesFromObjectsQueryToCompare.Add(QueryText);
	
	// Checking if access key exists before writing a new key.
	If HeaderNumber = 0 Then
		QueryText =
		"SELECT
		|	TRUE AS TrueValue
		|FROM
		|	Catalog.AccessKeys AS Header0
		|WHERE
		|	Header0.Hash = &Hash
		|	AND Header0.List = &List
		|	AND Header0.FieldsComposition = &FieldsComposition
		|	AND Header0.ForExternalUsers = &ForExternalUsers
		|	AND &QueryPlanClarification";
		Context.QueryPartsOfKeysExistenceToMap.Add(QueryText);
	EndIf;
	
	// Query of access keys by leading keys to update users and access groups, for which they are allowed.
	AddFilterConditionByLeadingAccessKeys(Context, GroupOfFields, HeaderNumber);
	
	// Selecting values from access keys to calculate users and access groups, to which they are allowed.
	If HeaderNumber = 0 Then
		QueryText =
		"SELECT
		|	AccessKeys.Ref AS Ref
		|INTO KeysBatch
		|FROM
		|	&AccessKeys AS AccessKeys
		|
		|INDEX BY
		|	Ref";
		Context.PartsOfValuesFromKeysQueryToCalculateRights.Add(QueryText);
	EndIf;
	
	If HeaderNumber = 0 Then
		QueryText = // @query-part-1
		"SELECT
		|	KeysBatch.Ref AS Ref
		|	,&Attributes
		|FROM
		|	KeysBatch AS KeysBatch
		|	LEFT JOIN @Catalog.AccessKeys AS Header0
		|	ON
		|		Header0.Ref = KeysBatch.Ref
		|		AND &QueryPlanClarification
		|
		|ORDER BY
		|	Ref
		|TOTALS BY
		|	Ref"; // @query-part
	Else
		QueryText =
		"SELECT
		|	KeysBatch.Ref AS Ref
		|	,&Attributes
		|FROM
		|	KeysBatch AS KeysBatch
		|	LEFT JOIN @Catalog.AccessKeys.Header AS Header?
		|	ON
		|		Header?.Ref = KeysBatch.Ref
		|		AND &HeaderNumberCondition
		|		AND &QueryPlanClarification
		|
		|ORDER BY
		|	Ref
		|TOTALS BY
		|	Ref"; // @query-part
		QueryText = StrReplace(QueryText, "&HeaderNumberCondition", 
			"Header" + HeaderNumber + ".LineNumber = " + HeaderNumber); 
	EndIf;
	
	QueryText = StrReplace(QueryText, ",&Attributes", TextWithIndent(ConnectionsAndFields.Attributes, "	"));
	QueryText = StrReplace(QueryText, "Header?", "Header" + HeaderNumber);
	Context.PartsOfValuesFromKeysQueryToCalculateRights.Add(QueryText);
	
	// The filter condition of leading access key rights.
	AddRightsFilterConditionForKeyHeader(Context, GroupOfFields, HeaderNumber, "ForLeadingKeys");
	
	// The filter condition of leading list rights.
	AddRightsFilterConditionForKeyHeader(Context, GroupOfFields, HeaderNumber, "ForLeadingLists");
	
	// The filter condition of rights by right setting owners.
	AddRightsFilterConditionForKeyHeader(Context, GroupOfFields, HeaderNumber, "ForRightSettingsOwners");
	
EndProcedure

// For the AddKeyHeaderFilling procedure.
Procedure AddRightsFilterConditionForKeyHeader(Context, GroupOfFields, HeaderNumber, ConditionAssignment)
	
	// The selection condition of leading access key rights.
	For Each FieldProperties In GroupOfFields Do
		If ConditionAssignment = "ForLeadingKeys"
		   And FieldProperties.AccessKeySavingTypes.Count() = 0
		 Or ConditionAssignment = "ForLeadingLists"
		   And Not FieldProperties.HasHeadListType
		 Or ConditionAssignment = "ForRightSettingsOwners"
		   And Not FieldProperties.HasRightsSettingsOwnerType Then
			Continue;
		EndIf;
		
		If ConditionAssignment = "ForLeadingLists"
		   And FieldProperties.ValueSavingTypes.Count() > 0 Then
			
			Context.Insert("HeadListsWithTypesRightsSelectionCriteriaParts");
			FilterCriterion = // @query-part-1
			"#FieldToCheck IN
			|				(SELECT
			|					ISNULL(ConfigurationTypes.Ref, ISNULL(ExtensionTypes.Ref, Header?.Attribute?))
			|				FROM
			|					KeysBatch AS KeysBatch
			|						LEFT JOIN @Catalog.AccessKeys AS Header?
			|						ON
			|							Header?.Ref = KeysBatch.Ref
			|							
			|						LEFT JOIN Catalog.MetadataObjectIDs AS ConfigurationTypes
			|						ON
			|							Header?.Attribute? <> UNDEFINED
			|							AND VALUETYPE(Header?.Attribute?) <> TYPE(Catalog.MetadataObjectIDs)
			|							AND VALUETYPE(Header?.Attribute?) <> TYPE(Catalog.ExtensionObjectIDs)
			|							AND VALUETYPE(ConfigurationTypes.EmptyRefValue) = VALUETYPE(Header?.Attribute?)
			|							
			|						LEFT JOIN Catalog.ExtensionObjectIDs AS ExtensionTypes
			|						ON
			|							Header?.Attribute? <> UNDEFINED
			|							AND VALUETYPE(ExtensionTypes.EmptyRefValue) = VALUETYPE(Header?.Attribute?))";
		Else
			FilterCriterion = // @query-part-1
			"#FieldToCheck IN
			|				(SELECT
			|					Header?.Attribute?
			|				FROM
			|					KeysBatch AS KeysBatch
			|						LEFT JOIN @Catalog.AccessKeys AS Header?
			|						ON
			|							Header?.Ref = KeysBatch.Ref)";
		EndIf;
		If HeaderNumber > 0 Then
			FilterCriterion = StrReplace(FilterCriterion,
				"Catalog.AccessKeys AS Header?", "Catalog.AccessKeys.Header AS Header?"); // @query-part-1
			FilterCriterion = StrReplace(FilterCriterion,
				"Header?.Ref = KeysBatch.Ref", TextWithIndent(
				"Header?.Ref = KeysBatch.Ref
				|	AND Header?.LineNumber = " + HeaderNumber, "							")); // @query-part-1
		EndIf;
		FilterCriterion = StrReplace(FilterCriterion, "Header?", "Header" + HeaderNumber);
		FilterCriterion = StrReplace(FilterCriterion, "Attribute?", FieldProperties.AccessKeyFieldsGroupAttributeName);
		
		If ConditionAssignment = "ForLeadingKeys" Then
			Context.ConditionPartsToSelectLeadingAccessKeysRights.Add(FilterCriterion);
			
		ElsIf ConditionAssignment = "ForLeadingLists" Then
			Context.ConditionPartsToSelectLeadingListsRights.Add(FilterCriterion);
		Else
			Context.ConditionPartsToSelectRightsByRightsSettingsOwners.Add(FilterCriterion);
		EndIf;
	EndDo;
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure AddKeysChoiceWithoutFieldsInHeader(Context)
	
	If Context.FieldsGroups.Get("Header0") <> Undefined Then
		Return;
	EndIf;
	
	// Selecting values from access keys to compare with the required key values.
	QueryText =
	"SELECT
	|	AccessKeys.Ref AS CurrentRef
	|FROM
	|	Catalog.AccessKeys AS AccessKeys
	|WHERE
	|	AccessKeys.Hash IN(&Hashes)
	|	AND AccessKeys.List = &List
	|	AND AccessKeys.FieldsComposition = &FieldsComposition
	|	AND AccessKeys.ForExternalUsers = &ForExternalUsers
	|	AND AccessKeys.NotUsedSince = DATETIME(1, 1, 1)
	|	AND &QueryPlanClarification
	|
	|ORDER BY
	|	CurrentRef";
	
	Context.PartsOfValuesFromObjectsQueryToCompare.Add(QueryText);
	
	// 
	QueryText =
	"SELECT
	|	TRUE AS TrueValue
	|FROM
	|	Catalog.AccessKeys AS Header0
	|WHERE
	|	Header0.Hash = &Hash
	|	AND Header0.List = &List
	|	AND Header0.FieldsComposition = &FieldsComposition
	|	AND Header0.ForExternalUsers = &ForExternalUsers
	|	AND &QueryPlanClarification";
	Context.QueryPartsOfKeysExistenceToMap.Add(QueryText);
	
	// 
	QueryText =
	"SELECT
	|	AccessKeys.Ref AS Ref
	|INTO KeysBatch
	|FROM
	|	&AccessKeys AS AccessKeys
	|
	|INDEX BY
	|	Ref";
	Context.PartsOfValuesFromKeysQueryToCalculateRights.Add(QueryText);
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure AddKeyTabularSectionFilling(Context, KeyTabularSectionNumber)
	
	TablesByGroups  = Context.AdditionalTablesGroups.TablesByGroups;
	AdditionalTablesGroup = TablesByGroups.Get(KeyTabularSectionNumber
		- (Context.KeyTabularSectionsCount - TablesByGroups.Count()));
	
	KeyTabularSectionName = "TabularSection" + KeyTabularSectionNumber;
	GroupOfFields = Context.FieldsGroups.Get(KeyTabularSectionName);
	
	AddKeyTableDetails(KeyTabularSectionName, GroupOfFields, Context);
	
	ConnectionsAndFieldsByTables = ConnectionsAndFieldsByTables(GroupOfFields,
		True, , True, OneAdditionalTableWithFieldsInGroup(Context, AdditionalTablesGroup));
	
	// Selecting values from objects to search and create access keys.
	If AdditionalTablesGroup = Undefined Then
		ObjectTabularSectionAlias = Context.ObjectTabularSectionsAliases.Get(KeyTabularSectionNumber);
		If ObjectTabularSectionAlias = Undefined Then
			ConnectionsAndFields = ConnectionsAndFieldsByTables.Get("CurrentList");
		Else
			ConnectionsAndFields = ConnectionsAndFieldsByTables.Get(ObjectTabularSectionAlias);
		EndIf;
		SelectionFields = TextWithIndent(ConnectionsAndFields.Fields, "	");
		Joins = TextWithIndent(ConnectionsAndFields.Joins, "	");
		OrderingFields = ConnectionsAndFields.OrderingFields;
		Attributes        = ConnectionsAndFields.Attributes;
		If ObjectTabularSectionAlias = Undefined Then
			QueryText =
			"SELECT DISTINCT
			|	CurrentList.Ref AS CurrentRef
			|	,&SelectionFields
			|FROM
			|	&CurrentList AS CurrentList
			|	#Joins
			|WHERE
			|	CurrentList.Ref IN (&ObjectsRefs)
			|
			|ORDER BY
			|	CurrentRef
			|	,&OrderingFields
			|TOTALS BY
			|	CurrentRef"; // @query-part-1
		Else
			ObjectTabularSectionName = StrReplace(ObjectTabularSectionAlias, "CurrentList", "");
			QueryText =
			"SELECT DISTINCT
			|	ObjectTabularSectionAlias.Ref AS CurrentRef
			|	,&SelectionFields
			|FROM
			|	ObjectTabularSectionName AS ObjectTabularSectionAlias
			|	#Joins
			|WHERE
			|	ObjectTabularSectionAlias.Ref IN (&ObjectsRefs)
			|
			|ORDER BY
			|	CurrentRef
			|	,&OrderingFields
			|TOTALS BY
			|	CurrentRef"; // @query-part-1

			QueryText = StrReplace(QueryText, "ObjectTabularSectionAlias", ObjectTabularSectionAlias); 
			QueryText = StrReplace(QueryText, "ObjectTabularSectionName", "&CurrentList." + ObjectTabularSectionName); 
		EndIf;
		QueryText = StrReplace(QueryText, ",&SelectionFields", SelectionFields); 
		QueryText = StrReplace(QueryText, ",&OrderingFields", OrderingFields); 
		QueryText = StrReplace(QueryText, "#Joins", Joins); 
	Else
		SelectionFields = "";
		Joins = "";
		ConnectionsInDatabase = "";
		ConnectionsInMemory = "";
		Condition = "";
		OrderingFields = "";
		Attributes = "";
		For Each AdditionalTable In AdditionalTablesGroup Do
			ConnectionsAndFields = ConnectionsAndFieldsByTables.Get(AdditionalTable.Alias);
			// @query-part-1
			CurrentConnection = "
			|LEFT JOIN " + AdditionalTable.Table + " AS " + AdditionalTable.Alias + "
			|On " + TextWithIndent(AdditionalTable.ConnectionConditionText, "	"); // @query-part-1
			Joins = Joins + CurrentConnection;
			If Context.IsReferenceType Then
				If Upper(Context.List) = Upper(AdditionalTable.Table) Then
					AdditionalName = "&CurrentList";
				ElsIf StrStartsWith(Upper(AdditionalTable.Table), Upper(Context.List) + ".") Then
					AdditionalName = "&CurrentList." + StrSplit(AdditionalTable.Table, ".")[2];
				Else
					AdditionalName = AdditionalTable.Table;
				EndIf;
				If AdditionalName = AdditionalTable.Table Then
					ConnectionsInDatabase = ConnectionsInDatabase  + CurrentConnection;
					ConnectionsInMemory     = ConnectionsInMemory      + CurrentConnection;
				Else
					// @query-part-1
					ConnectionsInDatabase = ConnectionsInDatabase + "
					|LEFT JOIN " + AdditionalTable.Table + " AS " + AdditionalTable.Alias + "
					|On " + TextWithIndent(AdditionalTable.ConnectionConditionText, "	") + "
					|	AND NOT " + AdditionalTable.Alias + ".Ref IN (&ObjectsRefs)"; // @query-part-1 @query-part-2
					// @query-part-1
					ConnectionsInMemory = ConnectionsInMemory + "
					|LEFT JOIN " + AdditionalName + " AS " + AdditionalTable.Alias + "
					|On " + TextWithIndent(AdditionalTable.ConnectionConditionText, "	"); // @query-part-1
				EndIf;
			EndIf;
			If ConnectionsAndFields = Undefined Then
				Continue;
			EndIf;
			Joins = Joins + ConnectionsAndFields.Joins;
			If Context.IsReferenceType Then
				ConnectionsInDatabase = ConnectionsInDatabase + ConnectionsAndFields.Joins;
				ConnectionsInMemory     = ConnectionsInMemory     + ConnectionsAndFields.Joins;
			EndIf;
			Condition = Condition + ?(Condition = "", "", "
			|OR ") + AdditionalTable.ConnectionTestField + " IS NOT NULL"; // @query-part-1 @query-part-2
			SelectionFields       = SelectionFields       + ConnectionsAndFields.Fields;
			OrderingFields = OrderingFields + ConnectionsAndFields.OrderingFields;
			Attributes        = Attributes        + ConnectionsAndFields.Attributes;
		EndDo;
		If StrLineCount(Condition) > 1 Then
			Condition = "(" + Condition + ")";
		EndIf;
		If Context.IsReferenceType Then
			QueryText = // @query-part-1
			"SELECT DISTINCT
			|	CurrentList.Ref AS CurrentRef" + TextWithIndent(SelectionFields, "	") + "
			|FROM
			|	&CurrentList AS CurrentList" + TextWithIndent(Joins, "	") + "
			|WHERE
			|	CurrentList.Ref IN (&ObjectsRefs)
			|	AND " + TextWithIndent(Condition, "	") + "
			|
			|ORDER BY
			|	CurrentRef" + OrderingFields + "
			|TOTALS BY
			|	CurrentRef"; // @query-part-1
			If ConnectionsInMemory <> ConnectionsInDatabase Then
				// 
				// 
				InMemoryQueryText = // @query-part-1
				"SELECT DISTINCT
				|	CurrentList.Ref AS CurrentRef" + TextWithIndent(SelectionFields, "	") + "
				|FROM
				|	&CurrentList AS CurrentList" + TextWithIndent(ConnectionsInDatabase, "	") + "
				|WHERE
				|	CurrentList.Ref IN (&ObjectsRefs)
				|	AND " + TextWithIndent(Condition, "	") + "
				|
				|UNION
				|
				|SELECT DISTINCT
				|	CurrentList.Ref AS CurrentRef" + TextWithIndent(SelectionFields, "	") + "
				|FROM
				|	&CurrentList AS CurrentList" + TextWithIndent(ConnectionsInMemory, "	") + "
				|WHERE
				|	CurrentList.Ref IN (&ObjectsRefs)
				|	AND " + TextWithIndent(Condition, "	") + "
				|
				|ORDER BY
				|	CurrentRef" + OrderingFields + "
				|TOTALS BY
				|	CurrentRef"; // 
				// 
			EndIf;
		Else
			QueryText = // @query-part-1
			"SELECT
			|	CurrentList.CurrentRef AS CurrentRef"  + TextWithIndent(SelectionFields, "	") + "
			|FROM
			|	CurrentList AS CurrentList" + TextWithIndent(Joins, "	") + "
			|WHERE
			|	" + TextWithIndent(Condition, "	") + "
			|
			|ORDER BY
			|	CurrentRef, " + Context.BasicFields.ForOrdering + OrderingFields + "
			|TOTALS BY
			|	CurrentRef"; // @query-part-1
		EndIf;
	EndIf;
	
	Context.PartsOfValuesFromObjectsQuery.Add(QueryText);
	Context.PartsOfQueryForInMemoryObjectsValues.Add(
		?(ValueIsFilled(InMemoryQueryText), InMemoryQueryText, QueryText));
	
	// Query of access keys by leading keys to update users and access groups, for which they are allowed.
	AddFilterConditionByLeadingAccessKeys(Context, GroupOfFields, , KeyTabularSectionNumber);
	
	// 
	QueryText =
	"SELECT
	|	TabularSection?.Ref AS CurrentRef
	|	,&Attributes
	|FROM
	|	Catalog.AccessKeys.TabularSection? AS TabularSection?
	|WHERE
	|	TabularSection?.Ref.Hash IN(&Hashes)
	|	AND TabularSection?.Ref.List = &List
	|	AND TabularSection?.Ref.FieldsComposition = &FieldsComposition
	|	AND TabularSection?.Ref.ForExternalUsers = &ForExternalUsers
	|	AND TabularSection?.Ref.NotUsedSince = DATETIME(1, 1, 1)
	|	AND &QueryPlanClarification
	|
	|ORDER BY
	|	CurrentRef
	|	,&OrderingFields
	|TOTALS BY
	|	CurrentRef"; // @query-part
	
	QueryText = StrReplace(QueryText, ",&Attributes", TextWithIndent(Attributes, "	"));
	QueryText = StrReplace(QueryText, ",&OrderingFields", OrderingFields);
	QueryText = StrReplace(QueryText, "TabularSection?", "TabularSection" + KeyTabularSectionNumber);
	Context.PartsOfValuesFromObjectsQueryToCompare.Add(QueryText);
	
	// 
	QueryText =
	"SELECT
	|	KeysBatch.Ref AS Ref
	|	,&Attributes
	|FROM
	|	KeysBatch AS KeysBatch
	|	LEFT JOIN @Catalog.AccessKeys.TabularSection? AS TabularSection?
	|	ON
	|		TabularSection?.Ref = KeysBatch.Ref
	|
	|ORDER BY
	|	Ref
	|TOTALS BY
	|	Ref"; // @query-part-1
	
	QueryText = StrReplace(QueryText, ",&Attributes", TextWithIndent(Attributes, "	"));
	QueryText = StrReplace(QueryText, "TabularSection?", "TabularSection" + KeyTabularSectionNumber);
	Context.PartsOfValuesFromKeysQueryToCalculateRights.Add(QueryText);
	
	// The filter condition of leading access key rights.
	AddRightsFilterConditionForKeyTabularSection(Context,
		GroupOfFields, KeyTabularSectionNumber, "ForLeadingKeys");
	
	// The filter condition of leading list rights.
	AddRightsFilterConditionForKeyTabularSection(Context,
		GroupOfFields, KeyTabularSectionNumber, "ForLeadingLists");
	
	// The filter condition of rights by right setting owners.
	AddRightsFilterConditionForKeyTabularSection(Context,
		GroupOfFields, KeyTabularSectionNumber, "ForRightSettingsOwners");
	
EndProcedure

// For the AddKeyTabularSectionFilling procedure.
Procedure AddRightsFilterConditionForKeyTabularSection(Context, GroupOfFields,
			KeyTabularSectionNumber, ConditionAssignment)
	
	For Each FieldProperties In GroupOfFields Do
		If ConditionAssignment = "ForLeadingKeys"
		   And FieldProperties.AccessKeySavingTypes.Count() = 0
		 Or ConditionAssignment = "ForLeadingLists"
		   And Not FieldProperties.HasHeadListType
		 Or ConditionAssignment = "ForRightSettingsOwners"
		   And Not FieldProperties.HasRightsSettingsOwnerType Then
			Continue;
		EndIf;
		
		If ConditionAssignment = "ForLeadingLists"
		   And FieldProperties.ValueSavingTypes.Count() > 0 Then
			
			Context.Insert("HeadListsWithTypesRightsSelectionCriteriaParts");
			FilterCriterion = // @query-part-1
			"#FieldToCheck IN
			|				(SELECT
			|					ISNULL(ConfigurationTypes.Ref, ISNULL(ExtensionTypes.Ref, TabularSection?.Attribute?))
			|				FROM
			|					KeysBatch AS KeysBatch
			|						LEFT JOIN @Catalog.AccessKeys.TabularSection? AS TabularSection?
			|						ON
			|							TabularSection?.Ref = KeysBatch.Ref
			|							
			|						LEFT JOIN Catalog.MetadataObjectIDs AS ConfigurationTypes
			|						ON
			|							TabularSection?.Attribute? <> UNDEFINED
			|							AND VALUETYPE(TabularSection?.Attribute?) <> TYPE(Catalog.MetadataObjectIDs)
			|							AND VALUETYPE(TabularSection?.Attribute?) <> TYPE(Catalog.ExtensionObjectIDs)
			|							AND VALUETYPE(ConfigurationTypes.EmptyRefValue) = VALUETYPE(TabularSection?.Attribute?)
			|							
			|						LEFT JOIN Catalog.ExtensionObjectIDs AS ExtensionTypes
			|						ON
			|							TabularSection?.Attribute? <> UNDEFINED
			|							AND VALUETYPE(ExtensionTypes.EmptyRefValue) = VALUETYPE(TabularSection?.Attribute?))";
		Else
			FilterCriterion = // @query-part-1
			"#FieldToCheck IN
			|				(SELECT
			|					TabularSection?.Attribute?
			|				FROM
			|					KeysBatch AS KeysBatch
			|						LEFT JOIN @Catalog.AccessKeys.TabularSection? AS TabularSection?
			|						ON
			|							TabularSection?.Ref = KeysBatch.Ref)";
		EndIf;
		
		FilterCriterion = StrReplace(FilterCriterion, "TabularSection?", "TabularSection" + KeyTabularSectionNumber);
		FilterCriterion = StrReplace(FilterCriterion, "Attribute?", FieldProperties.AccessKeyFieldsGroupAttributeName);
		
		If ConditionAssignment = "ForLeadingKeys" Then
			Context.ConditionPartsToSelectLeadingAccessKeysRights.Add(FilterCriterion);
			
		ElsIf ConditionAssignment = "ForLeadingLists" Then
			Context.ConditionPartsToSelectLeadingListsRights.Add(FilterCriterion);
		Else
			Context.ConditionPartsToSelectRightsByRightsSettingsOwners.Add(FilterCriterion);
		EndIf;
	EndDo;
	
EndProcedure

// For the AddKeyHeaderFilling and AddKeyTabularSectionFilling procedures.
Procedure AddKeyTableDetails(KeyTableName, GroupOfFields, Context)
	
	KeyTableFields = New Array;
	
	For Each FieldProperties In GroupOfFields Do
		KeyTableFields.Add(FieldProperties.AccessKeyFieldsGroupAttributeName);
	EndDo;
	
	Context.KeyTables.Add(KeyTableName);
	Context.KeyTablesAttributes.Insert(KeyTableName, KeyTableFields);
	
EndProcedure

// For the AddKeyHeaderFilling and AddKeyTabularSectionFilling procedure.
Procedure AddFilterConditionByLeadingAccessKeys(Context, GroupOfFields, HeaderNumber = 0, KeyTabularSectionNumber = 0)
	
	FilterCriterion = "";
	AttributeNumber = ?(HeaderNumber = 0, 0, 5);
	
	For Each FieldProperties In GroupOfFields Do
		AttributeNumber = AttributeNumber + 1;
		
		If FieldProperties.AccessKeySavingTypes.Count() = 0 Then
			Continue;
		EndIf;
		
		FilterCriterion = // @query-part-1
		"AccessKeys.Ref IN
		|				(SELECT
		|					Header?.Ref
		|				FROM
		|					Catalog.AccessKeys AS Header?
		|				WHERE
		|					Header?.Value? IN (&LeadingAccessKeys))";
		
		FilterCriterion = StrReplace(FilterCriterion, "Value?", "Value" + AttributeNumber);
		
		If HeaderNumber > 0 Then
			FilterCriterion = StrReplace(FilterCriterion,
				"Catalog.AccessKeys AS Header?", "Catalog.AccessKeys.Header AS Header?"); // @query-part-1 @query-part-2
		EndIf;
		
		If KeyTabularSectionNumber = 0 Then
			FilterCriterion = StrReplace(FilterCriterion, "Header?", "Header" + HeaderNumber);
		Else
			TabularSectionName = "TabularSection" + KeyTabularSectionNumber;
			FilterCriterion = StrReplace(FilterCriterion, " AS", "." + TabularSectionName + " AS"); // @query-part-1 @query-part-3
			FilterCriterion = StrReplace(FilterCriterion, "Header?", TabularSectionName);
		EndIf;
		
		Context.PartsOfFilterConditionByLeadingAccessKeys.Add(FilterCriterion);
	EndDo;
	
EndProcedure

// For the AddKeyHeaderCheck and AddKeyTabularSectionCheck procedures.
Function ConnectionsAndFieldsByTables(GroupOfFields, KeyTabularSection, HeaderNumber = 0, ForValuesSelection = False,
			OneAdditionalTableWithFieldsInGroup = False)
	
	ConnectionsAndFieldsByTables = New Map;
	AttributeNumber = 1 + ?(HeaderNumber = 0, 0, 5);
	
	For Each FieldProperties In GroupOfFields Do
		
		ConnectionsAndFields = ConnectionsAndFieldsByTables.Get(FieldProperties.TableAlias);
		If ConnectionsAndFields = Undefined Then
			ConnectionsAndFields = New Structure;
			ConnectionsAndFields.Insert("Joins",       "");
			ConnectionsAndFields.Insert("Fields",             "");
			ConnectionsAndFields.Insert("OrderingFields", "");
			ConnectionsAndFields.Insert("Attributes",        "");
			ConnectionsAndFieldsByTables.Insert(FieldProperties.TableAlias, ConnectionsAndFields);
		EndIf;
		
		Joins = "";
		If FieldProperties.AccessKeySavingTypes.Count() > 0 Then
			// @query-part-1
			Joins = Joins + "
			|LEFT JOIN InformationRegister.AccessKeysForObjects AS AccessKeysForObjects?
			|ON (AccessKeysForObjects?.Object = #FieldNameForQuery)";
		EndIf;
		
		If FieldProperties.ValueGroupSavingTypes.Count() > 0 Then
			If Not FieldProperties.IsAccessValueListWithValueGroups Then
				// @query-part-1
				Joins = Joins + "
				|LEFT JOIN InformationRegister.AccessValuesGroups AS ValueGroups?
				|ON (ValueGroups?.AccessValue = #FieldNameForQuery)
				|	AND (ValueGroups?.DataGroup = 0)";
			ElsIf FieldProperties.MultipleValuesGroups Then
				// @query-part-1
				Joins = Joins + "
				|LEFT JOIN &CurrentList.AccessGroups AS ValueGroups?
				|ON (ValueGroups?.Ref = #FieldNameForQuery)";
			EndIf;
		EndIf;
		
		If FieldProperties.ConfigurationTypeSavingTypes.Count() > 0 Then
			// @query-part-1
			Joins = Joins + "
			|LEFT JOIN Catalog.MetadataObjectIDs AS ConfigurationTypes?
			|ON (#FieldNameForQuery <> UNDEFINED)
			|	AND (VALUETYPE(ConfigurationTypes?.EmptyRefValue) = VALUETYPE(#FieldNameForQuery))";
		EndIf;
		
		If FieldProperties.ExtensionTypeSavingTypes.Count() > 0 Then
			// @query-part-1
			Joins = Joins + "
			|LEFT JOIN Catalog.ExtensionObjectIDs AS ExtensionTypes?
			|ON (#FieldNameForQuery <> UNDEFINED)
			|	AND (VALUETYPE(ExtensionTypes?.EmptyRefValue) = VALUETYPE(#FieldNameForQuery))";
		EndIf;
		
		Field = FieldComparison(FieldProperties, OneAdditionalTableWithFieldsInGroup);
		
		If ForValuesSelection Then
			Field = StrReplace(Field, "Header?.Value? = ", "");
			Field = StrReplace(Field, "						", "			");
			Position = StrLen(Chars.LF + "AND ()"); // @query-part-1
			Field = "," + Chars.LF + Mid(Field, Position, StrLen(Field) - Position) + " AS " + "Value?"; // @query-part-2
			
			ConnectionsAndFields.OrderingFields = ConnectionsAndFields.OrderingFields
				+ ", " + "Value" + AttributeNumber;
			
			ConnectionsAndFields.Attributes  = ConnectionsAndFields.Attributes + ",
			|Header?.Value"  + AttributeNumber + " AS " + "Value" + AttributeNumber; // @query-part-2
		EndIf;
		
		FillAliasByAttributeNumber(Joins, Field, AttributeNumber, "Value?");
		FillAliasByAttributeNumber(Joins, Field, AttributeNumber, "ValueGroups?");
		FillAliasByAttributeNumber(Joins, Field, AttributeNumber, "AccessKeysForObjects?");
		FillAliasByAttributeNumber(Joins, Field, AttributeNumber, "ConfigurationTypes?");
		FillAliasByAttributeNumber(Joins, Field, AttributeNumber, "ExtensionTypes?");
		
		Joins = StrReplace(Joins, "#FieldNameForQuery", FieldProperties.FieldNameForQuery);
		Field       = StrReplace(Field,       "#FieldNameForQuery", FieldProperties.FieldNameForQuery);
		
		If KeyTabularSection Then
			Field = StrReplace(Field, "Header?", "TabularSection?");
			ConnectionsAndFields.Attributes = StrReplace(ConnectionsAndFields.Attributes, "Header?", "TabularSection?");
		EndIf;
		
		ConnectionsAndFields.Joins = ConnectionsAndFields.Joins + Joins;
		ConnectionsAndFields.Fields       = ConnectionsAndFields.Fields       + Field;
		AttributeNumber = AttributeNumber + 1;
	EndDo;
	
	Return ConnectionsAndFieldsByTables;
	
EndFunction

// For the ConnectionsAndFieldsByTables function.
Function OneAdditionalTableWithFieldsInGroup(Context, AdditionalTablesGroup)
	
	If AdditionalTablesGroup = Undefined Then
		Return False;
	EndIf;
	
	If AdditionalTablesGroup.Count() = 1 Then
		Return True;
	EndIf;
	
	TablesWithFiledsAliases = Context.AdditionalTablesGroups.TablesWithFiledsAliases;
	
	AdditionalTablesWithFieldsCount = 0;
	For Each AdditionalTable In AdditionalTablesGroup Do
		If TablesWithFiledsAliases.Get(AdditionalTable.Alias) = Undefined Then
			Continue;
		EndIf;
		AdditionalTablesWithFieldsCount = AdditionalTablesWithFieldsCount + 1;
	EndDo;
	
	Return AdditionalTablesWithFieldsCount = 1;
	
EndFunction

// For the ConnectionsAndFieldsByTables function.
Function FieldComparison(FieldProperties, OneAdditionalTableWithFieldsInGroup)
	
	FieldTypesCount = FieldProperties.EndFieldType.Types().Count();
	
	WithoutUndefinedValue = FieldTypesCount = 1;
	If FieldProperties.Property("NoNullValue") Then
		NoNullValue = FieldProperties.NoNullValue;
	Else
		NoNullValue = NoNullValue(FieldProperties, OneAdditionalTableWithFieldsInGroup);
	EndIf;
	
	WithoutClarificationUndefined = Not FieldProperties.HasAdjustmentUndefined Or WithoutUndefinedValue;
	WithoutClarificationNull         = Not FieldProperties.HasAdjustmentNull         Or NoNullValue;
	
	// Saving access keys only.
	If FieldProperties.EmptyRefSavingTypes.Count() = 0
	   And WithoutClarificationUndefined
	   And WithoutClarificationNull
	   And FieldProperties.AccessKeySavingTypes.Count() = FieldTypesCount Then
		Return "
		|AND (Header?.Value? = ISNULL(AccessKeysForObjects?.#ObjectUserAccessKey,
		|						VALUE(Enum.AdditionalAccessValues.Null)))"; // @query-part-1
	EndIf;
	
	// Saving access value groups only.
	If FieldProperties.EmptyRefSavingTypes.Count() = 0
	   And WithoutClarificationUndefined
	   And WithoutClarificationNull
	   And FieldProperties.ValueGroupSavingTypes.Count() = FieldTypesCount Then
		
		If Not FieldProperties.IsAccessValueListWithValueGroups Then
			Return "
			|AND (Header?.Value? = ISNULL(ValueGroups?.AccessValuesGroup,
			|						VALUE(Enum.AdditionalAccessValues.Null)))"; // @query-part-1
		ElsIf FieldProperties.MultipleValuesGroups Then
			Return "
			|AND (Header?.Value? = ISNULL(ValueGroups?.AccessGroup,
			|						VALUE(Enum.AdditionalAccessValues.Null)))"; // @query-part-1
		Else
			Return "
			|AND (Header?.Value? = ISNULL(CurrentList.AccessGroup,
			|						VALUE(Enum.AdditionalAccessValues.Null)))"; // @query-part-1
		EndIf;
	EndIf;
	
	// Saving values only.
	If Not HasSimpleType(FieldProperties.EndFieldType)
	   And FieldTypesCount = 1
	   And FieldProperties.ValueSavingTypes.Count() = FieldTypesCount Then
		
		If NoNullValue Then
			Return "
			|AND (Header?.Value? = #FieldNameForQuery)"; // @query-part-1
		Else
			Return "
			|AND (Header?.Value? = ISNULL(#FieldNameForQuery,
			|						VALUE(Enum.AdditionalAccessValues.Null)))";  // @query-part-1
		EndIf;
	EndIf;
	
	// Saving a reference type.
	If WithoutClarificationNull
	   And FieldTypesCount = 1
	   And FieldProperties.TypeSavingTypes.Count() = FieldTypesCount
	   And FieldProperties.SimpleTypeSavingTypes.Count() = 0 Then
		
		If FieldProperties.ExtensionTypeSavingTypes.Count() = 0 Then
			Return "
			|AND (Header?.Value? = ISNULL(ConfigurationTypes?.Ref,
			|						VALUE(Catalog.MetadataObjectIDs.EmptyRef)))"; // @query-part-1
		ElsIf FieldProperties.ConfigurationTypeSavingTypes.Count() = 0 Then
			Return "
			|AND (Header?.Value? = ISNULL(ExtensionTypes?.Ref,
			|						VALUE(Catalog.ExtensionObjectIDs.EmptyRef)))"; // @query-part-1
		EndIf;
	EndIf;
	
	// Saving one simple type.
	If WithoutClarificationNull
	   And FieldTypesCount = 1
	   And FieldProperties.SimpleTypeSavingTypes.Count() = 1 Then
		
		Return "
		|AND (Header?.Value? = VALUE(Enum.AdditionalAccessValues.ValidType))"; // @query-part-1
	EndIf;
	
	If FieldProperties.ProhibitedTypeSavingTypes.Count() = FieldTypesCount Then
		Return "
		|AND (Header?.Value? = VALUE(Enum.AdditionalAccessValues.ProhibitedType))"; // @query-part-1
	EndIf;
	
	// Saving the ValidType value only.
	If FieldProperties.AllowedTypeSavingTypes.Count() = FieldTypesCount Then
		Return "
		|AND (Header?.Value? = VALUE(Enum.AdditionalAccessValues.ValidType))"; // @query-part-1
	EndIf;
	
	FieldComparison = "
	|AND (CASE
	|	#SelectionContent
	|END)"; // @query-part-1
	SelectionContent = "";
	
	SaveBooleanValue = FieldProperties.ValueSavingTypes.Find(Type("Boolean")) <> Undefined;
	
	If Not NoNullValue
	   And Not (SaveBooleanValue And FieldTypesCount = 1) Then
		SelectionContent = SelectionContent + "
		|WHEN #FieldNameForQuery IS NULL
		|	THEN Header?.Value? = VALUE(Enum.AdditionalAccessValues.Null)"; // @query-part-1
	EndIf;
	If FieldTypesCount > 1 Then
		SelectionContent = SelectionContent + "
		|WHEN #FieldNameForQuery = UNDEFINED
		|	THEN Header?.Value? = VALUE(Enum.AdditionalAccessValues.Undefined)"; // @query-part-1
	EndIf;
	If SaveBooleanValue Then
		If FieldTypesCount > 1 Then
			SelectionContent = SelectionContent + "
			|WHEN #FieldNameForQuery
			|	THEN Header?.Value? = VALUE(Enum.AdditionalAccessValues.True)
			|WHEN NOT #FieldNameForQuery
			|	THEN Header?.Value? = VALUE(Enum.AdditionalAccessValues.False)"; // @query-part-1
		Else
			SelectionContent = SelectionContent + "
			|WHEN #FieldNameForQuery
			|	THEN Header?.Value? = VALUE(Enum.AdditionalAccessValues.True)
			|ELSE Header?.Value? = VALUE(Enum.AdditionalAccessValues.False)"; // @query-part-1
		EndIf;
	EndIf;
	
	ChecksByTypes = New ValueList;
	
	AddCheckByTypes(ChecksByTypes, FieldProperties.SimpleTypeSavingTypes,
		"Header?.Value? = VALUE(Enum.AdditionalAccessValues.ValidType)"); // @query-part-1
	
	AddCheckByTypes(ChecksByTypes, FieldProperties.AccessKeySavingTypes,
		"Header?.Value? = ISNULL(AccessKeysForObjects?.#ObjectUserAccessKey,
		|					VALUE(Enum.AdditionalAccessValues.Null))"); // @query-part-1
	
	If Not FieldProperties.IsAccessValueListWithValueGroups Then
		AddCheckByTypes(ChecksByTypes, FieldProperties.ValueGroupSavingTypes,
			"Header?.Value? = ISNULL(ValueGroups?.AccessValuesGroup,
			|					VALUE(Enum.AdditionalAccessValues.Null))"); // @query-part-1
	ElsIf FieldProperties.MultipleValuesGroups Then
		AddCheckByTypes(ChecksByTypes, FieldProperties.ValueGroupSavingTypes,
			"Header?.Value? = ISNULL(ValueGroups?.AccessGroup,
			|					VALUE(Enum.AdditionalAccessValues.Null))"); // @query-part-1
	Else
		AddCheckByTypes(ChecksByTypes, FieldProperties.ValueGroupSavingTypes,
			"Header?.Value? = ISNULL(CurrentList.AccessGroup,
			|					VALUE(Enum.AdditionalAccessValues.Null))"); // @query-part-1
	EndIf;
	
	AddCheckByTypes(ChecksByTypes, FieldProperties.ValueSavingTypes,
		"Header?.Value? = #FieldNameForQuery", , SaveBooleanValue);
	
	AddCheckByTypes(ChecksByTypes, FieldProperties.EmptyRefSavingTypes,
		"Header?.Value? = VALUE(Enum.AdditionalAccessValues.EmptyRefAnyType)", // @query-part-1
		"IsEmptyRefCheck");
	
	AddCheckByTypes(ChecksByTypes, FieldProperties.ConfigurationTypeSavingTypes,
		"Header?.Value? = ISNULL(ConfigurationTypes?.Ref,
		|					VALUE(Catalog.MetadataObjectIDs.EmptyRef))"); // @query-part-1
	
	AddCheckByTypes(ChecksByTypes, FieldProperties.ExtensionTypeSavingTypes,
		"Header?.Value? = ISNULL(ExtensionTypes?.Ref,
		|					VALUE(Catalog.ExtensionObjectIDs.EmptyRef))"); // @query-part-1
	
	AddCheckByTypes(ChecksByTypes, FieldProperties.ProhibitedTypeSavingTypes,
		"Header?.Value? = VALUE(Enum.AdditionalAccessValues.ProhibitedType)"); // @query-part-1
	
	AddCheckByTypes(ChecksByTypes, FieldProperties.AllowedTypeSavingTypes,
		"Header?.Value? = VALUE(Enum.AdditionalAccessValues.ValidType)"); // @query-part-1
	
	ChecksByTypes.SortByPresentation();
	
	For Each CheckByTypes In ChecksByTypes Do
		If CheckByTypes.Value.Types.Count() = 0 Then
			Continue;
		EndIf;
		If ChecksByTypes.IndexOf(CheckByTypes) < ChecksByTypes.Count() - 1 Then
			TypesCheck = "";
			For Each Type In CheckByTypes.Value.Types Do
				If IsSimpleType(Type) Then
					TypeName = String(Type);
				Else
					TypeName = Metadata.FindByType(Type).FullName();
				EndIf;
				If TypesCheck <> "" Then
					TypesCheck = TypesCheck + "
					|			OR ";
				EndIf;
				CheckTemplate1 = ?(CheckByTypes.Value.Property("IsEmptyRefCheck"),
					"#FieldNameForQuery = VALUE(#TypeName.EmptyRef)",
					"VALUETYPE(#FieldNameForQuery) = TYPE(#TypeName)");  // @query-part-1
				TypesCheck = TypesCheck + StrReplace(CheckTemplate1, "#TypeName", TypeName);
			EndDo;
			Validation = "
			|WHEN #TypesCheck
			|	THEN #Validation"; // @query-part-1
			Validation = StrReplace(Validation, "#TypesCheck", TypesCheck);
		Else
			Validation = "
			|ELSE #Validation"; // @query-part-1
		EndIf;
		Validation = StrReplace(Validation, "#Validation", CheckByTypes.Value.Validation);
		SelectionContent = SelectionContent + Validation;
	EndDo;
	
	Return StrReplace(FieldComparison, "#SelectionContent", TextWithIndent(TrimL(SelectionContent), "	"));
	
EndFunction

// For the FieldComparison function.
Procedure AddCheckByTypes(ChecksByTypes, InitialTypes, Validation, AdditionalProperty = "", SkipBoolean = False)
	
	Types = New Array;
	For Each Type In InitialTypes Do
		If SkipBoolean And Type = Type("Boolean") Then
			Continue;
		EndIf;
		Types.Add(Type);
	EndDo;
	
	If Types.Count() = 0 Then
		Return;
	EndIf;
	
	Structure = New Structure("Types, Validation", Types, Validation);
	ChecksByTypes.Add(Structure, Format(Structure.Types.Count(), "ND=10; NLZ=; NG="));
	
	If AdditionalProperty = "" Then
		Return;
	EndIf;
	
	Structure.Insert(AdditionalProperty);
	
EndProcedure

// For the AddKeyHeaderCheck function.
Procedure FillAliasByAttributeNumber(Joins, Field, AttributeNumber, Alias)
	
	AliasWithNumber = StrReplace(Alias, "?", AttributeNumber);
	
	Joins = StrReplace(Joins, Alias, AliasWithNumber);
	Field       = StrReplace(Field,       Alias, AliasWithNumber);
	
EndProcedure

// For the AddKeyHeaderCheck and FieldComparison functions.
Function TextWithIndent(Text, Indent)
	
	Return StrReplace(Text, Chars.LF, Chars.LF + Indent);
	
EndFunction

// For the FieldComparison and AddBasicField functions.
Function HasSimpleType(TypeDescription)
	
	Return TypeDescription.ContainsType(Type("Boolean"))
	    Or TypeDescription.ContainsType(Type("Date"))
	    Or TypeDescription.ContainsType(Type("String"))
	    Or TypeDescription.ContainsType(Type("Number"))
	    Or TypeDescription.ContainsType(Type("UUID"))
	    Or TypeDescription.ContainsType(Type("ValueStorage"));
	
EndFunction

#EndRegion

#EndRegion

#Region TransformRestrictionsTextsIntoStructures

// See also AccessManagement.ParsedRestriction.
//
// Returns:
//  Structure:
//    * TablesFields       - See NewTablesFields
//    * InternalData - See NewInternalData
//
Function ParsedRestriction(MainTable, RestrictionText) Export
	
	InternalData = NewInternalData();
	InternalData.Insert("MainTable",  MainTable);
	InternalData.Insert("RestrictionText", TrimAll(RestrictionText));
	
	InternalData.Insert("LanguageSyntax", AccessManagementInternalCached.LanguageSyntax());
	InternalData.Insert("TablesFields",     NewTablesFields());
	InternalData.Insert("Aliases",     New Map);
	
	InternalData.Insert("AccessKeyFields", New Array);
	
	InternalData.Insert("CharsetsTable", CharsetsTable(InternalData));
	InternalData.Insert("RestrictionParts",       RestrictionParts(InternalData));
	
	Result = New Structure;
	Result.Insert("InternalData", InternalData);
	Result.Insert("TablesFields", InternalData.TablesFields);
	
	Return Result;
	
EndFunction

// Returns:
//   Structure:
//     * MainTable        - String - the table being restricted.
//     * RestrictionText       - String
//     * LanguageSyntax         - See LanguageSyntax
//     * TablesFields             - See NewTablesFields
//     * Aliases             - Map
//     * AccessKeyFields       - Array of See NewAccessKeyField
//     * CharsetsTable - See CharsetsTable
//     * RestrictionParts       - See RestrictionParts
//
Function NewInternalData()
	
	Return New Structure;
	
EndFunction

// Returns:
//   Structure:
//     * MainTable        - String - the table being restricted.
//     * RestrictionText       - String
//     * LanguageSyntax         - See LanguageSyntax
//     * TablesFields             - See NewTablesFields
//     * Aliases             - Map
//     * AccessKeyFields       - Array of See NewAccessKeyField
//     * CharsetsTable - See CharsetsTable
//     * RestrictionParts       - See RestrictionParts
//     * IsMergeCondition   - Boolean
//     * IsConditionWhen        - Boolean
//     * IsValueThenElse  - Boolean
//     * RootNode           - See NodeDetails
//
Function ExtendedInternalData(InternalData)
	
	FixedContext = New FixedStructure(InternalData);
	Return New Structure(FixedContext);
	
EndFunction

// Returns:
//   Map of KeyAndValue:
//     * Key     - String - a name of the metadata object collection, for example, Catalogs.
//     * Value - See NewCollectionComponents
//
Function NewTablesFields()
	
	Return New Map;
	
EndFunction

// Returns:
//   Map of KeyAndValue:
//     * Key     - String - a table (metadata object) name in uppercase.
//     * Value - See NewTableProperties
//
Function NewCollectionComponents()
	
	Return New Map;
	
EndFunction

// Returns:
//   Structure:
//     * TableExists - Boolean - False (True to fill in, if exists).
//     * IsMainTable - Boolean
//     * Sources - Array
//     * FirstField - Undefined
//     * Fields - Map of KeyAndValue:
//         ** Key     - String - an attribute name in uppercase, including dot-separated,
//                                for example, OWNER.COMPANY, GOODS.PRODUCTS.
//         ** Value - See NewFieldProperties
//     * Predefined - Map of KeyAndValue:
//         ** Key     - String - a predefined item name.
//         ** Value - See NewPredefinedOptionProperties
//     * Extensions - Map of KeyAndValue:
//         ** Key - String - a name of the third table name, for example, a tabular section name.
//         ** Value - See NewExtensionProperties
//
Function NewTableProperties()
	
	Return New Structure;
	
EndFunction

// Returns:
//   Structure:
//     * FieldWithError - Number - 0 (for filling, if the field has an error.
//          If 1, then there is an error in the name of the first part of the field.
//          If 2, then an error is in the name of the second part of the field, i.e. after the first dot).
//     * ErrorKind - String - NotFound, TabularSectionWithoutField,
//          TabularSectionAfterDot.
//     * Collection - String - a blank row (for filling, if the first part
//           of the field exists, i.e. a field part before the first dot). Options: Attributes,
//           TabularSections, StandardAttributes, StandardTabularSections,
//           Dimensions, Resources, Graphs, AccountingFlags, ExtDimensionAccountingFlags,
//           AddressingAttributes, SpecialFields. Special fields are
//           Value - for the Constant.* tables,
//           Recorder and Period - for the Sequence.* tables,
//           RecalculationObject, CalculationType for the CalculationRegister.<Name>.<RecalculationName> tables.
//           Fields after the first dot can be related only to the following collections: Attributes,
//           StandardAttributes, AccountingFlags, and AddressingAttributes. You do not need to specify a collection
//           for these parts of the field name.
//     * ContainsTypes - Map of KeyAndValue:
//         ** Key - String - a full name of the reference table in uppercase.
//         ** Value - Structure:
//              *** TypeName     - String - a type name whose presence you need to check.
//              *** ContainsType - Boolean - False (True for filling in,
//                                         if the field of the last field has a type).
//     * FirstSource - Structure:
//         ** Key     - ValueTableRow - a string source of the first field.
//         ** Value - String - a table
//
Function NewFieldProperties()
	
	Return New Structure;
	
EndFunction

// Returns:
//   Structure:
//     * NameExists - Boolean - False (True to fill in, if there is a predefined item).
//     * Sources - Array
//
Function NewPredefinedOptionProperties()
	
	Return New Structure;
	
EndFunction

// Returns:
//   Structure:
//     * TableExists - Boolean - False (True to fill in, if exists).
//     * Sources - Array
//     * FirstField - Undefined
//     * Fields - Map of KeyAndValue:
//         ** Key     - String - an attribute name in uppercase, including dot-separated,
//                                for example, OWNER.COMPANY, GOODS.PRODUCTS.
//         ** Value - See NewFieldProperties
//
Function NewExtensionProperties()
	
	Return New Structure;
	
EndFunction


// See also AccessManagement.RestrictionStructure
//
// Parameters:
//  ParsedRestriction - See ParsedRestriction
//
// Returns:
//   Structure:
//     * ErrorsDescription           - See ErrorsDescription
//     * AdditionalTables    - Array of See NewConnectionDetails
//     * MainTableAlias - String - filled in if additional tables are specified.
//     * ReadRestriction        - See NodeDetails
//     * UpdateRestriction     - See NodeDetails
//
Function RestrictionStructure(ParsedRestriction) Export
	
	InternalData = ParsedRestriction.InternalData;
	
	MarkIncorrectFieldsTablesAndFieldsTypesNames(ParsedRestriction.TablesFields,
		InternalData);
	
	// Populate the found errors.
	ErrorsDescription = ErrorsDescription();
	
	Table = InternalData.CharsetsTable;
	FilterRowsWithoutErrors = New Structure("ErrorText", "");
	If Table.Count() <> Table.FindRows(FilterRowsWithoutErrors).Count() Then
		ErrorsDescription.HasErrors = True;
		AdditionRequired = False;
		RowNumberLength = StrLen(Format(StrLineCount(InternalData.RestrictionText), "NG="));
		For Each String In Table Do
			If String.ErrorText = "" Then
				Continue;
			EndIf;
			AddError(String, ErrorsDescription, InternalData, RowNumberLength);
			If String.ErrorPosition = -1 Then
				AdditionRequired = True;
			EndIf;
		EndDo;
		ErrorsDescription.Restriction = NumberedRestrictionTextWithErrorsMarks(
			InternalData.RestrictionText, ErrorsDescription.Errors, RowNumberLength);
		If AdditionRequired Then
			ErrorsDescription.AddOn = AllowedTemplatesDetails();
		EndIf;
	EndIf;
	
	RestrictionParts = InternalData.RestrictionParts;
	
	RestrictionStructure = New Structure;
	RestrictionStructure.Insert("ErrorsDescription",           ErrorsDescription);
	RestrictionStructure.Insert("AdditionalTables",    RestrictionParts.AdditionalTables);
	RestrictionStructure.Insert("MainTableAlias", RestrictionParts.MainTableAlias);
	RestrictionStructure.Insert("ReadRestriction",        RestrictionParts.ReadRestriction);
	RestrictionStructure.Insert("UpdateRestriction",     RestrictionParts.UpdateRestriction);
	
	// Additional information for internal use.
	TableTypeName = StrSplit(InternalData.MainTable, ".")[0];
	TablesTypeProperties = InternalData.LanguageSyntax.TablesTypes.ByNames.Get(Upper(TableTypeName));
	
	NewInternalData = New Structure;
	NewInternalData.Insert("AccessKeyFields",   InternalData.AccessKeyFields);
	NewInternalData.Insert("IsReferenceType",    TablesTypeProperties.IsReferenceType);
	NewInternalData.Insert("TypeCollectionName",   TablesTypeProperties.CollectionName);
	NewInternalData.Insert("TablesTypesByNames", InternalData.LanguageSyntax.TablesTypes.ByNames);
	
	RestrictionStructure.Insert("InternalData", NewInternalData);
	
	For Each String In InternalData.CharsetsTable Do
		String.Rows.Clear();
		String.EndString = Undefined;
	EndDo;
	InternalData.CharsetsTable.Clear();
	InternalData.RestrictionParts.Clear();
	InternalData.Clear();
	
	Return RestrictionStructure;
	
EndFunction

// Returns:
//   Structure:
//     * HasErrors  - Boolean
//     * ErrorsText - String
//     * Restriction - String
//     * Errors      - Array of See ErrorProperties
//     * AddOn  - String
// 
Function ErrorsDescription()
	
	ErrorsDescription = New Structure;
	ErrorsDescription.Insert("HasErrors",  False);
	ErrorsDescription.Insert("ErrorsText", "");
	ErrorsDescription.Insert("Restriction", "");
	ErrorsDescription.Insert("Errors",      New Array);
	ErrorsDescription.Insert("AddOn",  "");
	
	Return ErrorsDescription;
	
EndFunction

// Returns:
//  Structure:
//    * LineNumber    - Number  - the number of the restriction text string where an error was found.
//    * PositionInRow - Number  - the position in the restriction text string where an error was found.
//    * ErrorText    - String - Error details.
//    * ErrorString   - String - the restriction text string where an error was found.
//
Function ErrorProperties()
	
	Return New Structure;
	
EndFunction

// Generates a full text of errors in access restriction description with an addition
// that can be specified as a text to call an exception.
//
// Parameters:
//  FullName               - String    - a full name of a list table.
//  ErrorsDescription          - Structure - a value returned by the RestrictionStructure function.
//  ForExternalUsers - Boolean    - if True is passed, an error text will contain
//                                        the restriction purpose for external users.
//
// Returns:
//  String - 
//
Function ErrorsTextToCallException(FullName, ErrorsDescription, ForExternalUsers, InManagerModule)
	
	If Not ErrorsDescription.HasErrors Then
		Return "";
	EndIf;
	
	If ErrorsDescription.Errors.Count() = 1 Then
		Refinement = "";
		If InManagerModule = Undefined Then
			If ForExternalUsers Then
				ErrorTitle = 
					NStr("en = 'Cannot restrict external user access to the ""%1"" list.';");
			Else
				ErrorTitle = 
					NStr("en = 'Cannot restrict user access to the ""%1"" list.';");
			EndIf;
		ElsIf InManagerModule Then
			If ForExternalUsers Then
				ErrorTitle =
					NStr("en = 'An error in restriction of external user access to the ""%1"" list
					           |specified in procedure ""%2"" of the metadata object manager module:';");
			Else
				ErrorTitle =
					NStr("en = 'An error in restriction of user access to the ""%1"" list
					           |specified in procedure ""%2"" of the metadata object manager module:';");
			EndIf;
			Refinement = "OnFillAccessRestriction";
		Else
			If ForExternalUsers Then
				ErrorTitle =
					NStr("en = 'An error in restriction of external user access to the ""%1"" list
					           |specified in procedure ""%2"":';");
			Else
				ErrorTitle =
					NStr("en = 'An error in restriction of user access to the ""%1"" list
					           |specified in procedure ""%2"":';");
			EndIf;
			Refinement = "AccessManagementOverridable.OnFillAccessRestriction";
		EndIf;
	Else
		If InManagerModule = Undefined Then
			If ForExternalUsers Then
				ErrorTitle = 
					NStr("en = 'Cannot restrict external user access to the ""%1"" list.';");
			Else
				ErrorTitle = 
					NStr("en = 'Cannot restrict user access to the ""%1"" list.';");
			EndIf;
		ElsIf InManagerModule Then
			If ForExternalUsers Then
				ErrorTitle = 
					NStr("en = 'Errors in restriction of external user access to the ""%1"" list
					           |specified in procedure ""%2"" of the metadata object manager module:';");
			Else
				ErrorTitle = 
					NStr("en = 'Errors in restriction of user access to the ""%1"" list
					           |specified in procedure ""%2"" of the metadata object manager module:';");
			EndIf;
			Refinement = "OnFillAccessRestriction";
		Else
			If ForExternalUsers Then
				ErrorTitle = 
					NStr("en = 'Errors in restriction of external user access to the ""%1"" list
					           |specified in procedure ""%2"":';");
			Else
				ErrorTitle = 
					NStr("en = 'Errors in restriction of user access to the ""%1"" list
					           |specified in procedure ""%2"":';");
			EndIf;
			Refinement = "AccessManagementOverridable.OnFillAccessRestriction";
		EndIf;
	EndIf;
	
	ErrorText = StringFunctionsClientServer.SubstituteParametersToString(ErrorTitle, FullName, Refinement);
	ErrorText = ErrorText + Chars.LF + Chars.LF + ErrorsDescription.ErrorsText;
	ErrorText = ErrorText + Chars.LF + Chars.LF + ErrorsDescription.Restriction;
	
	If ValueIsFilled(ErrorsDescription.AddOn) Then
		ErrorText = ErrorText + Chars.LF + Chars.LF + ErrorsDescription.AddOn;
	EndIf;
	
	Return Chars.LF + ErrorText + Chars.LF;
	
EndFunction

// For the RestrictionStructure function.
Procedure AddError(String, ErrorsDescription, InternalData, RowNumberLength)
	
	PositionInText = String.Position;
	ErrorPositionInRowEnd = False;
	RestrictionText = InternalData.RestrictionText;
	
	If String.ErrorPosition > 0 Then
		PositionInText = PositionInText + String.ErrorPosition;
		If String.ErrorPosition = StrLen(String.Chars) Then
			PositionInText = PositionInText - 1;
			ErrorPositionInRowEnd = True;
		EndIf;
	ElsIf String.Position > StrLen(RestrictionText) Then
		PositionInText = PositionInText - 1;
		ErrorPositionInRowEnd = True;
	EndIf;
	
	Coordinates = PositionCoordinatesInText(RestrictionText, PositionInText);
	Coordinates.PositionInRow = Coordinates.PositionInRow + ?(ErrorPositionInRowEnd, 1, 0);
	
	ErrorString = StrGetLine(RestrictionText, Coordinates.LineNumber);
	ErrorString = Left(ErrorString, Coordinates.PositionInRow - 1)
		+ "<<?>>" + Mid(ErrorString, Coordinates.PositionInRow);
	
	Error = ErrorProperties();
	Error.Insert("LineNumber",    Coordinates.LineNumber);
	Error.Insert("PositionInRow", Coordinates.PositionInRow);
	Error.Insert("ErrorText",    String.ErrorText);
	Error.Insert("ErrorString",   ErrorString);
	
	ErrorsDescription.Errors.Add(Error);
	
	If ValueIsFilled(ErrorsDescription.ErrorsText) Then
		ErrorsDescription.ErrorsText = ErrorsDescription.ErrorsText + Chars.LF + Chars.LF;
	EndIf;
	
	ErrorsDescription.ErrorsText = ErrorsDescription.ErrorsText
		+ "{(" + Format(Error.LineNumber, "ND=" + RowNumberLength + "; NLZ=; NG=")
		+ ", " + Format(Error.PositionInRow, "NG=") + ")}:"
		+ " " + Error.ErrorText + Chars.LF + Error.ErrorString;
	
EndProcedure

// For the RestrictionStructure function.
Function NumberedRestrictionTextWithErrorsMarks(RestrictionText, Errors, RowNumberLength)
	
	RowsCount = StrLineCount(RestrictionText);
	RestrictionTextRows = New Array;
	
	For LineNumber = 1 To RowsCount Do
		String = StrGetLine(RestrictionText, LineNumber);
		RestrictionTextRows.Add(String);
	EndDo;
	
	IndexOf = Errors.Count() - 1;
	While IndexOf >= 0 Do
		Error = Errors[IndexOf];
		String = RestrictionTextRows[Error.LineNumber - 1];
		RestrictionTextRows[Error.LineNumber - 1] = Left(String, Error.PositionInRow - 1)
			+ "<<?>>" + Mid(String, Error.PositionInRow);
		IndexOf = IndexOf - 1;
	EndDo;
	
	Text = "";
	LineNumber = 1;
	
	For Each String In RestrictionTextRows Do
		Text = Text + ?(Text = "", "", Chars.LF)
			+ ?(StrFind(String, "<<?>>") > 0, "*", " ")
			+ " " + Format(LineNumber, "ND=" + RowNumberLength + "; NLZ=; NG=") + " " + String;
		LineNumber = LineNumber + 1;
	EndDo;
	
	Return Text;
	
EndFunction

// For the RestrictionStructure function.
Function AllowedTemplatesDetails()
	
	If ScriptVariantRussian() Then
		Template1 =
		"        РазрешитьЧтениеИзменение
		|        ГДЕ ..."; // @Non-NLS
		
		Template2 =
		"        РазрешитьЧтение
		|        ГДЕ ...
		|        ;
		|        РазрешитьИзменениеЕслиРазрешеноЧтение
		|        ГДЕ ..."; // @Non-NLS
		
		Template3 =
		"        ПрисоединитьДополнительныеТаблицы
		|        ЭтотСписок КАК <Псевдоним>
		|        ЛЕВОЕ СОЕДИНЕНИЕ ...
		|        ;
		|        РазрешитьЧтение
		|        ГДЕ ...
		|        ;
		|        РазрешитьИзменениеЕслиРазрешеноЧтение
		|        ГДЕ ..."; // @Non-NLS
	Else
		Template1 =
		"        AllowReadWrite
		|        WHERE ...";
		
		Template2 =
		"        AllowRead
		|        WHERE ...
		|        ;
		|        AllowWriteIfAllowRead
		|        WHERE ...";
		
		Template3 =
		"        AttachAdditionalTables
		|        LIST AS <Alias>
		|        LEFT/INNER JOIN ...
		|        ;
		|        AllowRead
		|        WHERE ...
		|        ;
		|        AllowWriteIfAllowRead
		|        WHERE ...";
	EndIf;
	
	LongDesc = StringFunctionsClientServer.SubstituteParametersToString(
		NStr("en = 'A restriction can contain 1-3 parts. The following options are available:
		           |1. Identical read and update restrictions:
		           |%1
		           |2. Different read and update restrictions:
		           |%2
		           |3. Any of these two options with additional tables, for instance:
		           |%3';"),
		Template1, Template2, Template3);
	
	Return LongDesc;
	
EndFunction

// For the AddError procedure.
Function PositionCoordinatesInText(Text, PositionInText)
	
	Result = New Structure;
	Result.Insert("LineNumber", 0);
	Result.Insert("PositionInRow", 0);
	
	RowsCount = StrLineCount(Text);
	RowBeginningPosition = 1;
	For LineNumber = 1 To RowsCount Do
		CurrentRowLength = StrLen(StrGetLine(Text, LineNumber));
		If PositionInText < RowBeginningPosition + CurrentRowLength Then
			Break;
		EndIf;
		RowBeginningPosition = RowBeginningPosition + CurrentRowLength + 1;
	EndDo;
	
	Result.LineNumber = LineNumber;
	Result.PositionInRow = PositionInText - RowBeginningPosition + 1;
	
	Return Result;
	
EndFunction

#Region LexicalAnalysis

// For the ParsedRestriction function.
// Splits the text in a table of character sets, in which:
// - There are no indent characters (spaces, tabs, line breaks).
// - Characters of arbitrary strings and numbers are highlighted.
// - Keywords and operations are defined.
// - Format of names and numbers is checked.
// - Errors with description are added.
// 
// Parameters:
//  RestrictionText - String - an access restriction text.
//
// Returns:
//  ValueTable:
//    * Chars       - String - a character, a pair of characters, or a word.
//    * Position       - Number  - a position of characters in the restriction text.
//    * Kind           - String - "KeyWord", "Operation", "Name", "Separator",
//                               "Number", "ArbitraryString", "ProhibitedChar", "End".
//    * Type           - String - a type for the "KeyWord" and "Operation" kinds.
//    * Priority     - Number  - a priority for the "KeyWord" and "Operation" kinds.
//    * Refinement     - Number  - a numeric value for the "Number" kind.
//                    - String - 
//    * IsReserve     - Boolean - if True, this is a reserved operation or a keyword.
//    * ErrorPosition - Number  - an error position in a restriction text if the error text is not blank.
//    * ErrorText   - String - an error text if an error occurs.
//
Function CharsetsTable(InternalData)
	
	CharsetsTable = New ValueTable;
	CharsetsTable.Columns.Add("Chars",       New TypeDescription("String"));
	CharsetsTable.Columns.Add("Position",       New TypeDescription("Number"));
	CharsetsTable.Columns.Add("Kind",           New TypeDescription("String"));
	CharsetsTable.Columns.Add("Type",           New TypeDescription("String"));
	CharsetsTable.Columns.Add("Priority",     New TypeDescription("Number"));
	CharsetsTable.Columns.Add("Refinement",     New TypeDescription("Number, String"));
	CharsetsTable.Columns.Add("IsReserve",     New TypeDescription("Boolean"));
	CharsetsTable.Columns.Add("ErrorPosition", New TypeDescription("Number"));
	CharsetsTable.Columns.Add("ErrorText",   New TypeDescription("String"));
	
	RestrictionText = InternalData.RestrictionText;
	
	If Not ValueIsFilled(RestrictionText) Then
		Return CharsetsTable;
	EndIf;
	
	RestrictionTextLength = StrLen(RestrictionText);
	
	LanguageSyntax = InternalData.LanguageSyntax;
	LanguageChars = LanguageSyntax.LanguageChars;
	
	CharsetKind = ""; // 
	CharsetPosition = 0;
	Charset = New Array;
	TableRow = Undefined;
	
	For CharacterNumber = 1 To RestrictionTextLength Do
		Char = Mid(RestrictionText, CharacterNumber, 1);
		CharType = LanguageChars.Get(Char);
		// Processing word characters first as they are the most common.
		If CharType = "WordChar" And CharsetKind = "Word" Then
			Charset.Add(Char);
			Continue;
		EndIf;
		// Processing an arbitrary string of characters.
		If CharsetKind = "ArbitraryLine" Then
			If CharType = "LineLimiter" Then
				If Mid(RestrictionText, CharacterNumber + 1, 1) <> Char Then
					TableRow.Refinement = StrConcat(Charset);
					TableRow.Position = CharsetPosition;
					Charset = New Array;
					CharsetKind = "";
					Continue;
				Else
					CharacterNumber = CharacterNumber + 1;
				EndIf;
			EndIf;
			Charset.Add(Char);
			Continue;
		EndIf;
		If CharsetKind = "Word" Then
			// 
			// 
			CharsetKind = "";
			AddWordToCharsetsTable(CharsetsTable,
				Charset, CharsetPosition, LanguageSyntax);
			Charset = New Array;
		EndIf;
		// Processing a set of composite separators.
		If CharsetKind = "Operation" Then
			If CharType = "OperationChar" Then
				Charset.Add(Char);
				Continue;
			EndIf;
			CharsetKind = "";
			AddOperationToCharsetsTable(CharsetsTable,
				Charset, CharsetPosition, LanguageSyntax);
			Charset = New Array;
		EndIf;
		// Processing the first character of character sets.
		If CharsetKind = "" Then
			If CharType = "WordChar" Then
				CharsetKind = "Word";
				CharsetPosition = CharacterNumber;
				Charset.Add(Char);
				Continue;
			EndIf;
			If CharType = "OperationChar" Then
				CharsetKind = "Operation";
				CharsetPosition = CharacterNumber;
				Charset.Add(Char);
				Continue;
			EndIf;
			If CharType = "LineLimiter" Then
				CharsetKind = "ArbitraryLine";
				CharsetPosition = CharacterNumber;
				TableRow = CharsetsTable.Add();
				TableRow.Chars = Char;
				TableRow.Kind = CharsetKind;
				Continue;
			EndIf;
		EndIf;
		// Process individual characters.
		If CharType = "Indent" Then
			Continue;
		EndIf;
		If CharType = "Separator" Then
			TableRow = CharsetsTable.Add();
			TableRow.Chars = Char;
			TableRow.Position = CharacterNumber;
			TableRow.Kind = "Separator";
			Continue;
		EndIf;
		TableRow = CharsetsTable.Add();
		TableRow.Chars = Char;
		TableRow.Position = CharacterNumber;
		TableRow.Kind = "InvalidChar";
		TableRow.ErrorText   = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Invalid character ""%1"" with code %2.';"), Char, CharCode(Char));
	EndDo;
	
	If CharsetKind = "Word" Then
		AddWordToCharsetsTable(CharsetsTable,
			Charset, CharsetPosition, LanguageSyntax);
		
	ElsIf CharsetKind = "Operation" Then
		AddOperationToCharsetsTable(CharsetsTable,
			Charset, CharsetPosition, LanguageSyntax);
		
	ElsIf CharsetKind = "ArbitraryLine" Then
		TableRow.Refinement = StrConcat(Charset);
		TableRow.Position = CharsetPosition;
		TableRow.ErrorPosition = CharacterNumber - CharsetPosition;
		TableRow.ErrorText   = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'The end character %1 of the string constant is missing.';"), TableRow.Chars);
	EndIf;
	
	LastRow = CharsetsTable.Add();
	LastRow.Position = StrLen(RestrictionText) + 1;
	LastRow.Kind = "End"; // 
	CharsetsTable.Indexes.Add("Kind, Refinement");
	
	Return CharsetsTable;
	
EndFunction

// For the CharsetsTable function.
Procedure AddWordToCharsetsTable(Table,
			Charset, CharsetPosition, LanguageSyntax)
	
	CharacterString = StrConcat(Charset);
	WordProperties  = LanguageSyntax.LanguageWords.Get(Upper(CharacterString)); // See WordProperties
	
	NewRow = Table.Add();
	NewRow.Chars = CharacterString;
	NewRow.Position = CharsetPosition;
	
	If WordProperties <> Undefined Then
		NewRow.Kind       = "Keyword";
		NewRow.Type       = WordProperties.Type;
		NewRow.Priority = WordProperties.Priority;
		NewRow.Refinement = WordProperties.Id;
		NewRow.IsReserve = WordProperties.IsReserve;
		
		If WordProperties.IsReserve Then
			NewRow.ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'The ""%1"" keyword is not supported.';"), CharacterString);
		EndIf;
		Return;
	EndIf;
	
	// The word is a name or a number.
	NumbersChars = LanguageSyntax.NumbersChars;
	
	If Charset[0] = "." Then
		If Charset.Count() > 1 Then
			IsNumber = False;
		Else
			NewRow.Kind = "Name";
			NewRow.ErrorText = NStr("en = 'A name cannot start with a dot.';");
			Return;
		EndIf;
	Else
		IsNumber = NumbersChars.Get(Charset[0]) <> Undefined;
	EndIf;
	
	If IsNumber Then
		NewRow.Kind = "Number";
		CharacterNumber = 1;
		For Each Char In Charset Do
			If NumbersChars.Get(Char) = Undefined Then
				NewRow.ErrorPosition = CharacterNumber - 1;
				NewRow.ErrorText   = NStr("en = 'A number must contain only digits.';");
				Return;
			EndIf;
			CharacterNumber = CharacterNumber + 1;
		EndDo;
		NumberChars = Left(CharacterString, CharacterNumber - 1);
		If StrLen(NumberChars) > 16 Then
			NewRow.ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'The number ""%1"" is too big.';"), NumberChars);
			Return;
		EndIf;
		NewRow.Refinement = Number(NumberChars);
	Else
		NewRow.Kind = "Name";
		NameParts = StrSplit(CharacterString, ".");
		NamePartPosition = 1;
		For Each NamePart In NameParts Do
			If NamePart = "" And NamePartPosition > 1 Then
				NewRow.ErrorPosition = NamePartPosition - 1;
				NewRow.ErrorText   = NStr("en = 'A name is expected after the dot.';");
				Return;
			ElsIf NumbersChars.Get(Left(NamePart, 1)) <> Undefined Then
				NewRow.ErrorPosition = NamePartPosition - 1;
				NewRow.ErrorText   = NStr("en = 'In a name, a number cannot follow a dot.';");
				Return;
			EndIf;
			NamePartPosition = NamePartPosition + StrLen(NamePart) + 1;
		EndDo;
	EndIf;
	
EndProcedure

// For the CharsetsTable function.
Procedure AddOperationToCharsetsTable(Table,
			Charset, CharsetPosition, LanguageSyntax)
	
	CharacterString = StrConcat(Charset);
	OperationProperties = LanguageSyntax.LanguageOperations.Get(CharacterString);
	
	NewRow = Table.Add();
	NewRow.Chars   = CharacterString;
	NewRow.Position   = CharsetPosition;
	NewRow.Kind       = "Operation";
	NewRow.Type       = OperationProperties.Type;
	NewRow.Priority = OperationProperties.Priority;
	NewRow.IsReserve = OperationProperties.IsReserve;
	
	If OperationProperties = Undefined Then
		NewRow.ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Invalid operation: ""%1"".';"), CharacterString);
		
	ElsIf OperationProperties.IsReserve Then
		NewRow.ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Unsupported operation: ""%1"".';"), CharacterString);
	EndIf;
	
EndProcedure

// For the ParsedRestriction function and for many other functions indirectly.
//
// Returns:
//  FixedStructure:
//    * LanguageChars  - See LanguageChars
//    * NumbersChars   - See NumbersChars
//    * LanguageOperations - See LanguageOperations
//    * LanguageWords    - See LanguageWords
//    * TablesTypes    - See TablesTypes
//
Function LanguageSyntax() Export
	
	LanguageSyntax = New Structure;
	LanguageSyntax.Insert("LanguageChars",  LanguageChars());
	LanguageSyntax.Insert("NumbersChars",   NumbersChars());
	LanguageSyntax.Insert("LanguageOperations", LanguageOperations());
	LanguageSyntax.Insert("LanguageWords",    LanguageWords());
	LanguageSyntax.Insert("TablesTypes",    TablesTypes());
	
	Return New FixedStructure(LanguageSyntax);
	
EndFunction

// For the LanguageSyntax function.
//
// Returns:
//  FixedMap of KeyAndValue:
//    * Key - String - a char
//    * Value - String - a char kind
//
Function LanguageChars()
	
	LanguageChars = New Map;
	
	For CharCode = CharCode("А") // @Non-NLS
	 To CharCode("Я") Do // @Non-NLS
		
		LanguageChars.Insert(Char(CharCode), "WordChar");
	EndDo;
	For CharCode = CharCode("а") // @Non-NLS
	 To CharCode("я") Do // @Non-NLS
		
		LanguageChars.Insert(Char(CharCode), "WordChar");
	EndDo;
	For CharCode = CharCode("A") To CharCode("Z") Do
	
		LanguageChars.Insert(Char(CharCode), "WordChar");
	EndDo;
	For CharCode = CharCode("a") To CharCode("z") Do
	
		LanguageChars.Insert(Char(CharCode), "WordChar");
	EndDo;
	
	LanguageChars.Insert("_", "WordChar");
	LanguageChars.Insert(".", "WordChar");
	
	For CharCode = CharCode("0") To CharCode("9") Do
		LanguageChars.Insert(Char(CharCode), "WordChar");
	EndDo;
	
	LanguageChars.Insert(" ",         "Indent");
	LanguageChars.Insert(Chars.Tab, "Indent");
	LanguageChars.Insert(Chars.LF,  "Indent");
	
	LanguageChars.Insert("""", "LineLimiter");
	
	LanguageChars.Insert("(", "Separator");
	LanguageChars.Insert(")", "Separator");
	LanguageChars.Insert(",", "Separator");
	LanguageChars.Insert(";", "Separator");
	LanguageChars.Insert("=", "OperationChar");
	LanguageChars.Insert("<", "OperationChar");
	LanguageChars.Insert(">", "OperationChar");
	
	// 
	LanguageChars.Insert("+", "OperationChar");
	LanguageChars.Insert("-", "OperationChar");
	LanguageChars.Insert("*", "OperationChar");
	LanguageChars.Insert("/", "OperationChar");
	
	Return New FixedMap(LanguageChars);
	
EndFunction

// For the LanguageSyntax function.
//
// Returns:
//  FixedMap of KeyAndValue:
//    * Key - String - a char
//    * Value - Boolean - True.
//
Function NumbersChars()
	
	NumbersChars = New Map;
	
	For CharCode = CharCode("0") To CharCode("9") Do
		NumbersChars.Insert(Char(CharCode), True);
	EndDo;
	
	Return New FixedMap(NumbersChars);
	
EndFunction

// For the LanguageSyntax function.
//
// Returns:
//  FixedMap of KeyAndValue:
//    * Key - String - the word's English and Russian translation.
//    * Value - See WordProperties
//
Function LanguageWords()
	
	Words = New Map;
	
	AddLanguageWord(Words, "ПрисоединитьДополнительныеТаблицы",     // @Non-NLS
	                                                                   "AttachAdditionalTables",      "Begin",       False);
	AddLanguageWord(Words, "ЭтотСписок",                            // @Non-NLS
	                                                                   "ThisList",                    "StartList", False);
	AddLanguageWord(Words, "РазрешитьЧтениеИзменение",              // @Non-NLS
	                                                                   "AllowReadUpdate",             "Begin",       False);
	AddLanguageWord(Words, "РазрешитьЧтение",                       // @Non-NLS
	                                                                   "AllowRead",                   "Begin",       False);
	AddLanguageWord(Words, "РазрешитьИзменениеЕслиРазрешеноЧтение", // @Non-NLS
	                                                                   "AllowUpdateIfReadingAllowed", "Begin",       False);
	AddLanguageWord(Words, "Где",                                   // @Non-NLS
	                                                                   "Where",                       "StartWhere");
	
	AddLanguageWord(Words, "Левое",      // @Non-NLS
	                                        "Left", "Joining");
	AddLanguageWord(Words, "Соединение", // @Non-NLS
	                                        "Join", "Joining");
	AddLanguageWord(Words, "По",         // @Non-NLS
	                                        "On",   "Joining");
	
	AddLanguageWord(Words, "И",      // @Non-NLS
	                                    "And",    "Connector", , 2);
	AddLanguageWord(Words, "Или",    // @Non-NLS
	                                    "Or",     "Connector", , 1);
	AddLanguageWord(Words, "В",      // @Non-NLS
	                                    "In",     "Connector", , 5);
	AddLanguageWord(Words, "Как",    // @Non-NLS
	                                    "As",     "Connector");
	AddLanguageWord(Words, "Кроме",  // @Non-NLS
	                                    "Except", "Connector");
	AddLanguageWord(Words, "Только", // @Non-NLS
	                                    "Only",   "Connector");
	AddLanguageWord(Words, "Есть",   // @Non-NLS
	                                    "Is",     "Connector", , 7);
	AddLanguageWord(Words, "Не",     // @Non-NLS
	                                    "Not",    "Operator",    , 3);
	
	AddLanguageWord(Words, "Выбор",  // @Non-NLS
	                                    "Case",   "SelectionWord");
	AddLanguageWord(Words, "Когда",  // @Non-NLS
	                                    "When",   "SelectionWord");
	AddLanguageWord(Words, "Тогда",  // @Non-NLS
	                                    "Then",   "SelectionWord");
	AddLanguageWord(Words, "Иначе",  // @Non-NLS
	                                    "Else",   "SelectionWord");
	AddLanguageWord(Words, "Конец", // @Non-NLS
	                                    "End",    "SelectionWord");
	
	AddLanguageWord(Words, "ЕстьNull",                      // @Non-NLS
	                                                           "IsNull",               "Function", False);
	AddLanguageWord(Words, "Выразить",                      // @Non-NLS
	                                                           "Cast",                 "Function", False);
	AddLanguageWord(Words, "Значение",                      // @Non-NLS
	                                                           "Value",                "Function", False);
	AddLanguageWord(Words, "ТипЗначения",                   // @Non-NLS
	                                                           "ValueType",            "Function", False);
	AddLanguageWord(Words, "Тип",                           // @Non-NLS
	                                                           "Type",                 "Function", False);
	AddLanguageWord(Words, "ЗначениеРазрешено",             // @Non-NLS
	                                                           "ValueAllowed",         "Function", False);
	AddLanguageWord(Words, "ЧтениеОбъектаРазрешено",        // @Non-NLS
	                                                           "ObjectReadingAllowed", "Function", False);
	AddLanguageWord(Words, "ИзменениеОбъектаРазрешено",     // @Non-NLS
	                                                           "ObjectUpdateAllowed",  "Function", False);
	AddLanguageWord(Words, "ЧтениеСпискаРазрешено",         // @Non-NLS
	                                                           "ListReadingAllowed",   "Function", False);
	AddLanguageWord(Words, "ИзменениеСпискаРазрешено",      // @Non-NLS
	                                                           "ListUpdateAllowed",    "Function", False);
	AddLanguageWord(Words, "ДляВсехСтрок",                  // @Non-NLS
	                                                           "ForAllRows",           "Function", False);
	AddLanguageWord(Words, "ДляОднойИзСтрок",               // @Non-NLS
	                                                           "ForAtLeastOneRow",     "Function", False);
	AddLanguageWord(Words, "ЭтоАвторизованныйПользователь", // @Non-NLS
	                                                           "IsAuthorizedUser",     "Function", False);
	AddLanguageWord(Words, "ПравоДоступа",                  // @Non-NLS
	                                                           "AccessRight",          "Function", False);
	AddLanguageWord(Words, "РольДоступна",                  // @Non-NLS
	                                                           "IsInRole",             "Function", False);
	
	AddLanguageWord(Words, "ПустаяСсылка", // @Non-NLS
	                                          "EmptyRef",  "ComparisonValue");
	AddLanguageWord(Words, "Отключено",    // @Non-NLS
	                                          "Disabled",  "ComparisonValue");
	AddLanguageWord(Words, "Неопределено", // @Non-NLS
	                                          "Undefined", "ComparisonValue");
	AddLanguageWord(Words, "Null",         // @Non-NLS
	                                          "Null",      "ComparisonValue");
	AddLanguageWord(Words, "Ложь",         // @Non-NLS
	                                          "False",     "ClarificationValue");
	AddLanguageWord(Words, "Истина",       // @Non-NLS
	                                          "True",      "ClarificationValue");
	
	AddLanguageWord(Words, "Строка",       // @Non-NLS
	                                          "String",    "TypeName");
	AddLanguageWord(Words, "Число",        // @Non-NLS
	                                          "Number",    "TypeName");
	AddLanguageWord(Words, "Дата",         // @Non-NLS
	                                          "Date",      "TypeName");
	AddLanguageWord(Words, "Булево",       // @Non-NLS
	                                          "Boolean",   "TypeName");
	
	// Not supported, reserved words.
	AddLanguageWord(Words, "Выбрать",             // @Non-NLS
	                                                 "Select",          "NotDefined",   , , True);
	AddLanguageWord(Words, "Первые",              // @Non-NLS
	                                                 "Top",             "NotDefined",   , , True);
	AddLanguageWord(Words, "Различные",           // @Non-NLS
	                                                 "Distinct",        "NotDefined",   , , True);
	AddLanguageWord(Words, "Из",                  // @Non-NLS
	                                                 "From",            "NotDefined",   , , True);
	AddLanguageWord(Words, "Внутреннее",          // @Non-NLS
	                                                 "Inner",           "Joining", , , True);
	AddLanguageWord(Words, "Полное",              // @Non-NLS
	                                                 "Full",            "Joining", , , True);
	AddLanguageWord(Words, "Сгруппировать",       // @Non-NLS
	                                                 "Group",           "NotDefined",   , , True);
	AddLanguageWord(Words, "Имеющие",             // @Non-NLS
	                                                 "Having",          "NotDefined",   , , True);
	AddLanguageWord(Words, "Упорядочить",         // @Non-NLS
	                                                 "Order",           "NotDefined",   , , True);
	AddLanguageWord(Words, "Итоги",               // @Non-NLS
	                                                 "Totals",          "NotDefined",   , , True);
	AddLanguageWord(Words, "Год",                 // @Non-NLS
	                                                 "Year",            "Function",   False, , True);
	AddLanguageWord(Words, "Квартал",             // @Non-NLS
	                                                 "Quarter",         "Function",   False, , True);
	AddLanguageWord(Words, "Месяц",               // @Non-NLS
	                                                 "Month",           "Function",   False, , True);
	AddLanguageWord(Words, "ДеньГода",            // @Non-NLS
	                                                 "DayOfYear",       "Function",   False, , True);
	AddLanguageWord(Words, "День",                // @Non-NLS
	                                                 "Day",             "Function",   False, , True);
	AddLanguageWord(Words, "Неделя",              // @Non-NLS
	                                                 "Week",            "Function",   False, , True);
	AddLanguageWord(Words, "ДеньНедели",          // @Non-NLS
	                                                 "Weekday",         "Function",   False, , True);
	AddLanguageWord(Words, "Час",                 // @Non-NLS
	                                                 "Hour",            "Function",   False, , True);
	AddLanguageWord(Words, "Минута",              // @Non-NLS
	                                                 "Minute",          "Function",   False, , True);
	AddLanguageWord(Words, "Секунда",             // @Non-NLS
	                                                 "Second",          "Function",   False, , True);
	AddLanguageWord(Words, "НачалоПериода",       // @Non-NLS
	                                                 "BeginOfPeriod",   "Function",   False, , True);
	AddLanguageWord(Words, "КонецПериода",        // @Non-NLS
	                                                 "EndOfPeriod",     "Function",   False, , True);
	AddLanguageWord(Words, "ДобавитьКДате",       // @Non-NLS
	                                                 "DateAdd",         "Function",   False, , True);
	AddLanguageWord(Words, "РазностьДат",         // @Non-NLS
	                                                 "DateDiff",        "Function",   False, , True);
	AddLanguageWord(Words, "Сумма",               // @Non-NLS
	                                                 "Sum",             "Function",   False, , True);
	AddLanguageWord(Words, "Минимум",             // @Non-NLS
	                                                 "Min",             "Function",   False, , True);
	AddLanguageWord(Words, "Максимум",            // @Non-NLS
	                                                 "Max",             "Function",   False, , True);
	AddLanguageWord(Words, "Среднее",             // @Non-NLS
	                                                 "Avg",             "Function",   False, , True);
	AddLanguageWord(Words, "Количество",          // @Non-NLS
	                                                 "Count",           "Function",   False, , True);
	AddLanguageWord(Words, "Представление",       // @Non-NLS
	                                                 "Presentation",    "Function",   False, , True);
	AddLanguageWord(Words, "ПредставлениеСсылки", // @Non-NLS
	                                                 "RefPresentation", "Function",   False, , True);
	
	Return New FixedMap(Words);
	
EndFunction

// For the LanguageSyntax function.
// 
// Returns:
//  FixedMap of KeyAndValue:
//    * Key - String - the word's English and Russian translation.
//    * Value - See WordProperties
//
Function LanguageOperations()
	
	LanguageOperations = New Map;
	
	AddLanguageWord(LanguageOperations, "=",  "=",  "Connector", , 4);
	AddLanguageWord(LanguageOperations, "<>", "<>", "Connector", , 4);
	
	// 
	AddLanguageWord(LanguageOperations, "<",  "<",  "Connector", , 4, True);
	AddLanguageWord(LanguageOperations, "<=", "<=", "Connector", , 4, True);
	AddLanguageWord(LanguageOperations, ">",  ">",  "Connector", , 4, True);
	AddLanguageWord(LanguageOperations, ">=", ">=", "Connector", , 4, True);
	AddLanguageWord(LanguageOperations, "+",  "+",  "Connector", , 1, True);
	AddLanguageWord(LanguageOperations, "-",  "-",  "Connector", , 1, True);
	AddLanguageWord(LanguageOperations, "*",  "*",  "Connector", , 6, True);
	AddLanguageWord(LanguageOperations, "/",  "/",  "Connector", , 6, True);
	
	Return New FixedMap(LanguageOperations);
	
EndFunction

// For the LanguageWords and LanguageOperations functions.
Procedure AddLanguageWord(Words, LanguageRussian, LanguageEnglish, WordType,
			Uppercase = True, Priority = 0, IsReserve = False)
	
	WordProperties = WordProperties(LanguageRussian,
		LanguageEnglish, WordType, Uppercase, Priority, IsReserve);
	
	Words.Insert(Upper(LanguageRussian),    WordProperties);
	Words.Insert(Upper(LanguageEnglish), WordProperties);
	
EndProcedure

// For the AddLanguageWord procedure.
//
// Returns:
//  FixedStructure:
//    * Id  - String - the word in the configuration language (English or Russian).
//    * LanguageRussian    - String - the word in Russian.
//    * LanguageEnglish - String - the word in English.
//    * Type            - String - a word type name.
//    * Uppercase - Boolean
//    * Priority      - Number
//    * IsReserve      - Boolean
//
Function WordProperties(LanguageRussian, LanguageEnglish, WordType, Uppercase, Priority, IsReserve)
	
	WordProperties = New Structure;
	WordProperties.Insert("Id",  ?(CharCode(Left(WordType, 1)) > 122, LanguageRussian, LanguageEnglish));
	WordProperties.Insert("LanguageRussian",    LanguageRussian);
	WordProperties.Insert("LanguageEnglish", LanguageEnglish);
	WordProperties.Insert("Type",            WordType);
	WordProperties.Insert("Uppercase", Uppercase);
	WordProperties.Insert("Priority",      Priority);
	WordProperties.Insert("IsReserve",      IsReserve);
	
	Return New FixedStructure(WordProperties);
	
EndFunction

// For the LanguageSyntax function.
//
// Returns:
//   Structure:
//     * ByNames - Map of KeyAndValue:
//         ** Key - String - a table type name in English and Russian.
//         ** Value - See TablesTypeProperties
//     * ByCollections - Map of KeyAndValue:
//         ** Key - String - the collection name in the configuration language (English or Russian).
//         ** Value - See TablesTypeProperties
//
Function TablesTypes()
	
	TablesTypes = New Structure;
	TablesTypes.Insert("ByNames",     New Map);
	TablesTypes.Insert("ByCollections", New Map);
	
	// Setting table type names.
	AddTablesType(TablesTypes, "ПланОбмена",             // @Non-NLS
	                                                        "ExchangePlan",               "ExchangePlans");
	AddTablesType(TablesTypes, "КритерийОтбора",         // @Non-NLS
	                                                        "FilterCriterion",            "FilterCriteria");
	AddTablesType(TablesTypes, "Константы",              // @Non-NLS
	                                                        "Constants",                  "");
	AddTablesType(TablesTypes, "Константа",              // @Non-NLS
	                                                        "Constant",                   "Constants");
	AddTablesType(TablesTypes, "Справочник",             // @Non-NLS
	                                                        "Catalog",                    "Catalogs");
	AddTablesType(TablesTypes, "Последовательность",     // @Non-NLS
	                                                        "Sequence",                   "Sequences");
	AddTablesType(TablesTypes, "Документ",               // @Non-NLS
	                                                        "Document",                   "Documents");
	AddTablesType(TablesTypes, "ЖурналДокументов",       // @Non-NLS
	                                                        "DocumentJournal",            "DocumentJournals");
	AddTablesType(TablesTypes, "Перечисление",           // @Non-NLS
	                                                        "Enum",                       "Enums");
	AddTablesType(TablesTypes, "ПланВидовХарактеристик", // @Non-NLS
	                                                        "ChartOfCharacteristicTypes", "ChartsOfCharacteristicTypes");
	AddTablesType(TablesTypes, "ПланСчетов",             // @Non-NLS
	                                                        "ChartOfAccounts",            "ChartsOfAccounts");
	AddTablesType(TablesTypes, "ПланВидовРасчета",       // @Non-NLS
	                                                        "ChartOfCalculationTypes",    "ChartsOfCalculationTypes");
	AddTablesType(TablesTypes, "РегистрСведений",        // @Non-NLS
	                                                        "InformationRegister",        "InformationRegisters");
	AddTablesType(TablesTypes, "РегистрНакопления",      // @Non-NLS
	                                                        "AccumulationRegister",       "AccumulationRegisters");
	AddTablesType(TablesTypes, "РегистрБухгалтерии",     // @Non-NLS
	                                                        "AccountingRegister",         "AccountingRegisters");
	AddTablesType(TablesTypes, "РегистрРасчета",         // @Non-NLS
	                                                        "CalculationRegister",        "CalculationRegisters");
	AddTablesType(TablesTypes, "БизнесПроцесс",          // @Non-NLS
	                                                        "BusinessProcess",            "BusinessProcesses");
	AddTablesType(TablesTypes, "Задача",                 // @Non-NLS
	                                                        "Task",                       "Tasks");
	
	// Setting main properties of the main table types.
	TablesTypesNames = "ExchangePlan,Catalog,Document,ChartOfCharacteristicTypes,ChartOfAccounts,ChartOfCalculationTypes,BusinessProcess,Task";
	SetTablesTypeProperty(TablesTypes, TablesTypesNames, "IsReferenceType", True);
	SetTablesTypeProperty(TablesTypes, TablesTypesNames, "HasLimit", True);
	SetTablesTypeProperty(TablesTypes, TablesTypesNames, "CommonAttributes",  "Allowed2");
	SetTablesTypeProperty(TablesTypes, TablesTypesNames, "Use",   "Allowed1");
	
	AddTablesTypeFieldsCollection(TablesTypes, TablesTypesNames, "Attributes",            "Allowed2");
	AddTablesTypeFieldsCollection(TablesTypes, TablesTypesNames, "StandardAttributes", "Allowed2");
	
	AddTablesTypeTabularSectionsCollection(TablesTypes, TablesTypesNames, "TabularSections", "Allowed2");
	
	AddTablesTypeField(TablesTypes, TablesTypesNames, "ВерсияДанных",  // @Non-NLS
	                                                                      "DataVersion",  "Prohibited");
	AddTablesTypeField(TablesTypes, TablesTypesNames, "Представление", // @Non-NLS
	                                                                      "Presentation", "Prohibited");
	
	AddTablesTypeExtension(TablesTypes, TablesTypesNames, "Изменения", // @Non-NLS
	                                                                        "Changes", "Prohibited");
	
	// 
	TablesTypesNames = "InformationRegister,CalculationRegister";
	SetTablesTypeProperty(TablesTypes,     TablesTypesNames, "CommonAttributes",       "Allowed2");
	AddTablesTypeFieldsCollection(TablesTypes, TablesTypesNames, "Resources",              "Allowed2");
	AddTablesTypeFieldsCollection(TablesTypes, TablesTypesNames, "Attributes",            "Allowed2");
	AddTablesTypeFieldsCollection(TablesTypes, TablesTypesNames, "StandardAttributes", "Allowed2");
	
	TablesTypesNames = "AccumulationRegister,AccountingRegister";
	SetTablesTypeProperty(TablesTypes,     TablesTypesNames, "CommonAttributes",       "Illegal1");
	AddTablesTypeFieldsCollection(TablesTypes, TablesTypesNames, "Resources",              "Illegal1");
	AddTablesTypeFieldsCollection(TablesTypes, TablesTypesNames, "Attributes",            "Illegal1");
	AddTablesTypeFieldsCollection(TablesTypes, TablesTypesNames, "StandardAttributes", "Illegal1");
	
	TablesTypesNames = "InformationRegister,AccumulationRegister,AccountingRegister,CalculationRegister";
	SetTablesTypeProperty(TablesTypes, TablesTypesNames, "HasLimit", True);
	AddTablesTypeFieldsCollection(TablesTypes, TablesTypesNames, "Dimensions", "Allowed2");
	
	AddTablesTypeExtension(TablesTypes, TablesTypesNames, "Изменения", // @Non-NLS
	                                                                        "Changes", "Prohibited");
	
	// Setting some of the earlier mentioned properties for other table types.
	SetTablesTypeProperty(TablesTypes,     "Sequence", "HasLimit", True);
	AddTablesTypeFieldsCollection(TablesTypes, "Sequence", "Dimensions", "Allowed2");
	
	SetTablesTypeProperty(TablesTypes,     "DocumentJournal", "CommonAttributes",       "Allowed2");
	AddTablesTypeFieldsCollection(TablesTypes, "DocumentJournal", "StandardAttributes", "Allowed2");
	
	SetTablesTypeProperty(TablesTypes,     "Enum", "IsReferenceType", True);
	AddTablesTypeFieldsCollection(TablesTypes, "Enum", "StandardAttributes", "Allowed2");
	
	TablesTypesNames = "Constant,InformationRegister";
	SetTablesTypeProperty(TablesTypes, TablesTypesNames, "Use", "Allowed1");
	SetTablesTypeProperty(TablesTypes, "FilterCriterion", "Use", "Illegal");
	
	AddTablesTypeExtension(TablesTypes, "Constant",       "Изменения",     // @Non-NLS-2
	                                                                             "Changes",
	                                                                             "Prohibited");
	AddTablesTypeExtension(TablesTypes, "InformationRegister", "СрезПервых",    // @Non-NLS-2
	                                                                             "SliceFirst",
	                                                                             "Illegal");
	AddTablesTypeExtension(TablesTypes, "InformationRegister", "СрезПоследних", // @Non-NLS-2
	                                                                             "SliceLast",
	                                                                             "Illegal");
	AddTablesTypeExtension(TablesTypes, "BusinessProcess",   "Точки",         // @Non-NLS-2
	                                                                             "Points",
	                                                                             "Prohibited");
	
	// Setting special properties.
	SetTablesTypeProperty(TablesTypes, "ChartOfAccounts", "ExtDimensionAccountingFlags", "Allowed2");
	
	AddTablesTypeFieldsCollection(TablesTypes, "DocumentJournal", "Columns",              "Allowed2");
	AddTablesTypeFieldsCollection(TablesTypes, "ChartOfAccounts",       "AccountingFlags",      "Allowed2");
	AddTablesTypeFieldsCollection(TablesTypes, "Task",           "AddressingAttributes", "Allowed2");
	
	AddTablesTypeTabularSectionsCollection(TablesTypes, "ChartOfAccounts",       "StandardTabularSections", "Allowed2");
	AddTablesTypeTabularSectionsCollection(TablesTypes, "ChartOfCalculationTypes", "StandardTabularSections", "Allowed2");
	
	TablesTypesNames = "Catalog,Enum,ChartOfCharacteristicTypes,ChartOfAccounts,ChartOfCalculationTypes";
	SetTablesTypeProperty(TablesTypes, TablesTypesNames, "HasPredefined", True);
	
	// 
	TablesTypesNames = "Document,InformationRegister,AccumulationRegister,AccountingRegister";
	AddTablesTypeField(TablesTypes, TablesTypesNames, "МоментВремени", // @Non-NLS
	                                                                      "PointInTime", "Illegal");
	
	TablesTypesNames = "Catalog,ChartOfCharacteristicTypes,ChartOfAccounts,ChartOfCalculationTypes";
	AddTablesTypeField(TablesTypes, TablesTypesNames, "ИмяПредопределенныхДанных", // @Non-NLS
	                                                                                  "PredefinedDataName", "Prohibited");
	
	AddTablesTypeField(TablesTypes, "Constant",          "Значение",    // @Non-NLS-2
	                                                                        "Value",
	                                                                        "Allowed1");
	AddTablesTypeField(TablesTypes, "Sequence", "Регистратор", // @Non-NLS-2
	                                                                        "Recorder", 
	                                                                        "Allowed1");
	AddTablesTypeField(TablesTypes, "Sequence", "Период",      // @Non-NLS-2
	                                                                        "Period",
	                                                                        "Allowed1");
	AddTablesTypeField(TablesTypes, "DocumentJournal",   "Тип",         // @Non-NLS-2
	                                                                        "Type",
	                                                                        "Illegal");
	AddTablesTypeField(TablesTypes, "Enum",       "Порядок",     // @Non-NLS-2
	                                                                        "Order",
	                                                                        "Prohibited");
	
	Return TablesTypes;
	
EndFunction

// For the TablesTypes function.
Procedure AddTablesType(TablesTypes, LanguageRussian, LanguageEnglish, CollectionName)
	
	TablesTypeProperties = TablesTypeProperties(LanguageRussian, LanguageEnglish, CollectionName);
	
	TablesTypes.ByNames.Insert(Upper(LanguageRussian),    TablesTypeProperties);
	TablesTypes.ByNames.Insert(Upper(LanguageEnglish), TablesTypeProperties);
	
	If ValueIsFilled(CollectionName) Then
		TablesTypes.ByCollections.Insert(CollectionName, TablesTypeProperties);
	EndIf;
	
EndProcedure

// For the AddLanguageWord procedure.
//
// Returns:
//  FixedStructure:
//    * CollectionName             - String - the collection name in the configuration language (English or Russian).
//    * LanguageRussian              - String - a table type name in Russian.
//    * LanguageEnglish           - String - a table type name in English.
//    * IsReferenceType          - Boolean
//    * HasLimit          - Boolean
//    * HasPredefined     - Boolean
//    * FieldsCollections           - Map of KeyAndValue:
//        ** Key - String - the field collection name in the configuration language (English or Russian).
//        ** Value - String - 
//             "Allowed" — can be used with no restrictions.
//             "NotAllowed" — cannot be used in 1C:Enterprise platform access restriction.
//
//    * TabularPartCollections - Map of KeyAndValue:
//        ** Key - String - the tabular section collection name in the configuration language (English or Russian).
//        ** Value - String - 
//             "Allowed" — can be used with no restrictions.
//             "NotAllowed" — cannot be used in 1C:Enterprise platform access restriction.
//
//    * CommonAttributes           - String -
//        "Allowed" — can be used with no restrictions.
//        "NotAllowed" — cannot be used in 1C:Enterprise platform access restriction.
//        "Missing" — do not exist for metadata objects.
//
//    * ExtDimensionAccountingFlags    - String -
//        "Allowed" — can be used with no restrictions.
//        "NotAllowed" — cannot be used in 1C:Enterprise platform access restriction.
//        "Missing" — do not exist for metadata objects.
//
//    * FieldsClarification           - Map of KeyAndValue:
//        ** Key     - String - a table field name in English and Russian.
//        ** Value - See FieldClarification
//
//    * TablesClarification          - Map of KeyAndValue:
//        ** Key     - String - a table extension name in English and Russian.
//        ** Value - See TablesClarification
//
//    * Use            - String -
//        "Allowed" — can be used with no restrictions.
//        "NotAllowed" — cannot be used in 1C:Enterprise platform access restriction.
//        "Prohibited" — it is prohibited to connect as an additional table in the SSL access restriction.
//
Function TablesTypeProperties(LanguageRussian, LanguageEnglish, CollectionName)
	
	TablesTypeProperties = New Structure;
	TablesTypeProperties.Insert("CollectionName",             CollectionName);
	TablesTypeProperties.Insert("LanguageRussian",              LanguageRussian);
	TablesTypeProperties.Insert("LanguageEnglish",           LanguageEnglish);
	TablesTypeProperties.Insert("IsReferenceType",          False);
	TablesTypeProperties.Insert("HasLimit",          False);
	TablesTypeProperties.Insert("HasPredefined",     False);
	TablesTypeProperties.Insert("FieldsCollections",           New Map);
	TablesTypeProperties.Insert("TabularPartCollections", New Map);
	TablesTypeProperties.Insert("CommonAttributes",           "Missing1");
	TablesTypeProperties.Insert("ExtDimensionAccountingFlags",    "Missing1");
	TablesTypeProperties.Insert("FieldsClarification",           New Map);
	TablesTypeProperties.Insert("TablesClarification",          New Map);
	TablesTypeProperties.Insert("Use",            "Prohibited");
	
	Return TablesTypeProperties;
	
EndFunction

// For the TablesTypes function.
Procedure SetTablesTypeProperty(TablesTypes, TablesTypesNames, Property, Value)
	
	For Each TableTypeName In StrSplit(TablesTypesNames, ",", False) Do
		TablesTypeProperties = TablesTypes.ByNames.Get(Upper(TableTypeName));
		TablesTypeProperties[Property] = Value;
	EndDo;
	
EndProcedure

// For the TablesTypes function.
Procedure AddTablesTypeFieldsCollection(TablesTypes, TablesTypesNames, CollectionName, Use)
	
	For Each TableTypeName In StrSplit(TablesTypesNames, ",", False) Do
		TablesTypeProperties = TablesTypes.ByNames.Get(Upper(TableTypeName));
		TablesTypeProperties.FieldsCollections.Insert(CollectionName, Use);
	EndDo;
	
EndProcedure

// For the TablesTypes function.
Procedure AddTablesTypeTabularSectionsCollection(TablesTypes, TablesTypesNames, CollectionName, Use)
	
	For Each TableTypeName In StrSplit(TablesTypesNames, ",", False) Do
		TablesTypeProperties = TablesTypes.ByNames.Get(Upper(TableTypeName));
		TablesTypeProperties.TabularPartCollections.Insert(CollectionName, Use);
	EndDo;
	
EndProcedure

// For the TablesTypes function.
Procedure AddTablesTypeField(TablesTypes, TablesTypesNames, LanguageRussian, LanguageEnglish, Use)
	
	For Each TableTypeName In StrSplit(TablesTypesNames, ",", False) Do
		FieldClarification = FieldClarification(LanguageRussian, LanguageEnglish, Use);
		TablesTypeProperties = TablesTypes.ByNames.Get(Upper(TableTypeName));
		
		TablesTypeProperties.FieldsClarification.Insert(Upper(LanguageRussian),    FieldClarification);
		TablesTypeProperties.FieldsClarification.Insert(Upper(LanguageEnglish), FieldClarification);
	EndDo;
	
EndProcedure

// For the AddTablesTypeField procedure.
//
// Returns:
//  Structure:
//    * LanguageRussian    - String - a table field name in Russian.
//    * LanguageEnglish - String - a table field name in English.
//    * Use  - String -
//        "Allowed" — can be used with no restrictions.
//        "NotAllowed" — cannot be used in 1C:Enterprise platform access restriction.
//        "Prohibited" — it is prohibited to use in the SSL access restriction.
//
Function FieldClarification(LanguageRussian, LanguageEnglish, Use)
	
	FieldClarification = New Structure;
	FieldClarification.Insert("LanguageRussian",    LanguageRussian);
	FieldClarification.Insert("LanguageEnglish", LanguageEnglish);
	FieldClarification.Insert("Use",  Use);
	
	Return FieldClarification;
	
EndFunction

// For the TablesTypes function.
Procedure AddTablesTypeExtension(TablesTypes, TablesTypesNames, LanguageRussian, LanguageEnglish, Use)
	
	For Each TableTypeName In StrSplit(TablesTypesNames, ",", False) Do
		TablesClarification = TablesClarification(LanguageRussian, LanguageEnglish, Use);
		TablesTypeProperties = TablesTypes.ByNames.Get(Upper(TableTypeName));
		
		TablesTypeProperties.TablesClarification.Insert(Upper(LanguageRussian),    TablesClarification);
		TablesTypeProperties.TablesClarification.Insert(Upper(LanguageEnglish), TablesClarification);
	EndDo;
	
EndProcedure

// For the AddTablesTypeField procedure.
//
// Returns:
//  Structure:
//    * LanguageRussian    - String - a table extension name in Russian.
//    * LanguageEnglish - String - a table extension name in English.
//    * Use  - String -
//        "Allowed" — can be used with no restrictions.
//        "NotAllowed" — cannot be used in 1C:Enterprise platform access restriction.
//        "Prohibited" — it is prohibited to use in the SSL access restriction.
//
Function TablesClarification(LanguageRussian, LanguageEnglish, Use)
	
	TablesClarification = New Structure;
	TablesClarification.Insert("LanguageRussian",    LanguageRussian);
	TablesClarification.Insert("LanguageEnglish", LanguageEnglish);
	TablesClarification.Insert("Use",  Use);
	
	Return TablesClarification;
	
EndFunction

#EndRegion

#Region Parsing

// For the ParsedRestriction function.
//
// Parameters:
//   InternalData - See NewInternalData
//
// Returns:
//   Structure:
//     * AdditionalTables    - Array of See NewConnectionDetails
//     * MainTableAlias - String
//     * ReadRestriction        - Structure
//     * UpdateRestriction     - Structure
//
Function RestrictionParts(InternalData)
	
	RestrictionParts = New Structure;
	RestrictionParts.Insert("AdditionalTables",    New Array);
	RestrictionParts.Insert("MainTableAlias", "");
	RestrictionParts.Insert("ReadRestriction",        New Structure);
	RestrictionParts.Insert("UpdateRestriction",     New Structure);
	
	CharsetsTable = InternalData.CharsetsTable;
	
	If CharsetsTable.Count() = 0 Then
		Return RestrictionParts;
	EndIf;
	
	CharsetsTable.Columns.Add("Rows", New TypeDescription("Array"));
	CharsetsTable.Columns.Add("EndString");
	
	// Separating a restriction into main parts.
	Rows = CharsetsTable.FindRows(New Structure("Chars, Kind", ";", "Separator"));
	
	SeparatorRowsIndexes = New Array;
	For Each String In Rows Do
		SeparatorRowsIndexes.Add(CharsetsTable.IndexOf(String));
	EndDo;
	SeparatorRowsIndexes.Add(CharsetsTable.Count() - 1);
	
	PartsProperties = New Array; // Array of See NewPartProperties
	RowIndex = 0;
	For Each SeparatorRowIndex In SeparatorRowsIndexes Do
		PartRows = New Array; // Array of ValueTableRow: см. ТаблицаНаборовСимволов
		While RowIndex < SeparatorRowIndex Do
			PartRow = CharsetsTable[RowIndex];
			If PartRow.Kind <> "InvalidChar" Then
				PartRows.Add(PartRow);
			EndIf;
			RowIndex = RowIndex + 1;
		EndDo;
		SeparatorRow = CharsetsTable[SeparatorRowIndex];
		If PartRows.Count() = 0 Then
			PartRows.Add(SeparatorRow);
		EndIf;
		PartProperties = NewPartProperties();
		PartProperties.Insert("Rows", PartRows);
		PartProperties.Insert("SeparatorRow", SeparatorRow);
		PartsProperties.Add(PartProperties);
		TheFirstLineOfThePart = PartRows[0];
		If TheFirstLineOfThePart.Kind = "Keyword"
		   And TheFirstLineOfThePart.Type = "Begin" Then
			
			PartProperties.Insert("Name",           TheFirstLineOfThePart.Refinement);
			PartProperties.Insert("Presentation", TheFirstLineOfThePart.Chars);
			
			ParseRestrictionPart(PartProperties, InternalData);
		Else
			PartProperties.Insert("Name",           "");
			PartProperties.Insert("Presentation", "");
		EndIf;
		RowIndex = SeparatorRowIndex + 1;
	EndDo;
	
	AddDefaultAliases(InternalData);
	
	// Part 1 analysis.
	PartProperties1 = PartsProperties[0];
	
	If PartProperties1.Name = "" Then
		SetPartBeginningError(PartProperties1, InsertKeywordsIntoString(InternalData,
			NStr("en = 'None of the following keywords are found at the beginning of the first part of the restriction text:
			           |""%1"", ""%2"", or ""%3"".';"),
			"AllowReadUpdate,AllowRead,AttachAdditionalTables"));
		Return RestrictionParts;
		
	ElsIf PartProperties1.Name = "AllowUpdateIfReadingAllowed" Then
		SetPartBeginningError(PartProperties1,
			NStr("en = 'Invalid keyword at the beginning of the first part of the restriction text.';"));
		Return RestrictionParts;
		
	ElsIf PartsProperties.Count() = 1
	        And (    PartProperties1.Name = "AttachAdditionalTables"
	           Or PartProperties1.Name = "AllowRead" ) Then
		
		SetPartBeginningError(CharsetsTable,
			StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'A restriction text cannot have a single part
				           |with the ""%1"" keyword.';"), PartProperties1.Presentation));
		Return RestrictionParts;
	EndIf;
	
	SetRestrictionPart(RestrictionParts, PartProperties1);
	
	If PartsProperties.Count() < 2 Then
		Return RestrictionParts;
	EndIf;
	
	// Part 2 analysis.
	PartProperties2 = PartsProperties[1];
	
	If PartProperties1.Name = "AllowReadUpdate" Then
		SetPartBeginningError(PartProperties1.SeparatorRow,
			StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'A restriction text with the ""%1"" keyword in the first part
				           |cannot contain the second part.';"), PartProperties1.Presentation));
		Return RestrictionParts;
	EndIf;
	
	If PartProperties2.Name = "" Then
		If PartProperties1.Name = "AllowRead" Then
			SetPartBeginningError(PartProperties2, InsertKeywordsIntoString(InternalData,
				NStr("en = 'Keyword ""%1"" is not found
				           |at the beginning of the second part of the restriction text.';"),
				"AllowUpdateIfReadingAllowed"));
		Else // Part1Properties.Name = "AttachAdditionalTables".
			SetPartBeginningError(PartProperties2, InsertKeywordsIntoString(InternalData,
				NStr("en = 'Neither ""%1"" nor ""%2""
				           |keywords are found at the beginning of the second part of the restriction text.';"),
				"AllowReadUpdate,AllowRead"));
		EndIf;
		Return RestrictionParts;
		
	ElsIf PartProperties1.Name = "AllowRead"
	        And PartProperties2.Name <> "AllowUpdateIfReadingAllowed"
	      Or PartProperties1.Name = "AttachAdditionalTables"
	        And PartProperties2.Name <> "AllowReadUpdate"
	        And PartProperties2.Name <> "AllowRead" Then
		
		SetPartBeginningError(PartProperties2,
			NStr("en = 'Invalid keyword at the beginning of the second part of the restriction text.';"));
		Return RestrictionParts;
		
	ElsIf PartsProperties.Count() = 2
	        And PartProperties2.Name = "AllowRead" Then
		
		SetPartBeginningError(CharsetsTable,
			StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'The restriction text cannot contain only two parts when
				           |the ""%1"" keyword is present in the second part.';"), PartProperties2.Presentation));
		Return RestrictionParts;
	EndIf;
	
	SetRestrictionPart(RestrictionParts, PartProperties2);
	
	If PartsProperties.Count() < 3 Then
		Return RestrictionParts;
	EndIf;
	
	// Part 3 analysis.
	PartProperties3 = PartsProperties[2];
	
	If PartProperties2.Name = "AllowReadUpdate" Then
		SetPartBeginningError(PartProperties2.SeparatorRow,
			StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'A restriction text with the ""%1"" keyword in the second part
				           |cannot contain the third part.';"), PartProperties2.Presentation));
		Return RestrictionParts;
	EndIf;
	
	If PartProperties3.Name = "" Then
		SetPartBeginningError(PartProperties3, InsertKeywordsIntoString(InternalData,
			NStr("en = 'Keyword ""%1"" is not found
			           |at the beginning of the third part of the restriction text.';"),
			"AllowUpdateIfReadingAllowed"));
		Return RestrictionParts;
		
	ElsIf PartProperties2.Name = "AllowRead"
	        And PartProperties3.Name <> "AllowUpdateIfReadingAllowed" Then
		
		SetPartBeginningError(PartProperties3,
			NStr("en = 'Invalid keyword at the beginning of the third part of the restriction text.';"));
		Return RestrictionParts;
	EndIf;
	
	SetRestrictionPart(RestrictionParts, PartProperties3);
	
	Return RestrictionParts;
	
EndFunction

// 
//  See CharsetsTable
//           
//  See CharsetsTable
//  
//              See CharsetsTable
//
Procedure RowAdd(Parent, String, Context)
	
	If TypeOf(String) = Type("ValueTableRow") Then
		Parent.Rows.Add(Context.CharsetsTable.IndexOf(String));
	Else
		Parent.Rows.Add(String);
	EndIf;
	
EndProcedure

// Parameters:
//  RowDescription - Number -
//                 - ValueTableRow of See CharsetsTable
//                 - Structure - See AdditionalString1
//  Context - Structure:
//              * Table - See CharsetsTable
//
// Returns:
//   See AdditionalString1
//
Function TableRow(RowDescription, Context)
	
	If TypeOf(RowDescription) = Type("Number") Then
		String = Context.CharsetsTable[RowDescription];
	Else
		String = RowDescription;
	EndIf;
	
	Return String;
	
EndFunction

// Returns:
//   Structure:
//     * Rows                   - Array of ValueTableRow: см. ТаблицаНаборовСимволов
//     * SeparatorRow        - ValueTableRow of See CharsetsTable
//     * Name                      - String
//     * Presentation            - String
//
Function NewPartProperties()
	
	Return New Structure;
	
EndFunction

// Returns:
//   Structure:
//     * Table           - String
//     * Alias         - String
//     * ConnectionCondition - See NodeDetails
//     * RequiredTablesAliases - Array of String
//     * ConnectionConditionFields  - Array of See FieldsPairConnectionConditions
//     * ConnectionTestField - String
//     * ConnectionConditionText - String
//
Function NewConnectionDetails()
	
	Return New Structure;
	
EndFunction


// Returns:
//   Structure:
//     * Source - ValueTableRow of See CharsetsTable
//     
//     * Node - String - one of the lines "Field", "Value", "Constant",
//         "And", "Or", "Not", "=", "<>", "In" "IsNull", "Type", "ValueType", "Choice",
//         "ValueAllowed", "IsAuthorizedUser"
//         "ReadObjectAllowed", "EditObjectAllowed",
//         "ReadListAllowed", "EditListAllowed",
//         "ForAllLines", "ForOneOfLines",
//         "AccessRight", 'RoleAvailable'.
//     
//     Field node properties.
//      * Name       - String -
//      * Table   - String - a table name of this field (or a blank row for the main table).
//      * Alias - String - an attached table alias name (or a blank row for the main table),
//                      for example, "SettingInformationRegister" for the "MainCompany" field.
//      * Cast  - String - a table name (if used), for example, to describe a field as:
//                     CAST(CAST(Owner AS Catalog.Files).FileOwner AS Catalog.Companies).Ref".
//      * Attachment  - Structure - the Field node that contains the CAST nested action (with or without IsNull).
//                  - Undefined - 
//      * IsNull  - Structure - the Value Or Constant node, for example, to describe an expression of the following type:
//                      "IsNULL(Owner, Value(Catalog.Files.BlankRef))".
//                  - Undefined - 
//      * NameSource      - ValueTableRow
//                         - Undefined
//      * CastSource - ValueTableRow
//                         - Undefined
//      * IsNullSource - ValueTableRow
//                         - Undefined
//
//     Properties of the Value and Type nodes.
//      * Name - String -
//                                               
//                       
//
//     
//      * Value - Boolean
//                 - Number
//                 - String
//                 - Undefined - 
//                     
//
//     
//      * Arguments - Array of See NodeDetails
//
//     Properties of the Not node (any node except for Value or Constant).
//       * Argument - See NodeDetails
//       
//       * Name - String -
//
//     
//                           
//       * FirstArgument - See NodeDetails
//       * SecondArgument - See NodeDetails
//       
//       * Name - String -
//
//     
//       * SearchFor  - See NodeDetails
//       * Values - Array of See NodeDetails
//
//     Properties of the IsNull node (the Field node - an expression of the "<Field> IS NULL" kind).
//       * Argument - See NodeDetails 
//
//       * Name - String -
//       
//     
//       * Argument - See NodeDetails
//
//       * Name - String -
//       
//     
//               
//                    
//                    
//               
//                   
//                              
//                   
//               
//                   
//       * Case - See NodeDetails
//       * When - Array of Structure:
//           ** Condition  - See NodeDetails
//           ** Value - See NodeDetails
//       * Else - See NodeDetails
//
//       * Name - String - stub to the previous line (for defining the type in EDT)
//       
//     Node properties value Resolved, this is an authorized User,
//                    Changeobjectstate, Essentiallyidentical,
//                    Readespiscare Resolved, Changeespiscare Resolved.
//              In the Field property, the field node.
//       * Field - See NodeDetails
//       * Types - Array of String - a full table name.
//       * CheckTypesExceptListed - Boolean - if True, all types of the Field property,
//                                                except for those specified in the Types property.
//       * ComparisonClarifications - Map of KeyAndValue:
//           ** Key     - String - a clarified value is Undefined, Null, or BlankRef,
//                                  <a full table name>, "Number", "String", "Date", and "Boolean".
//           ** Value - String - result "False", "True".
//
//     Properties of the ForAllLines, ForOneOfLines nodes (any node).
//       * Argument - See NodeDetails.
//
Function NodeDetails()
	
	Return New Structure;
	
EndFunction

// For the RestrictionParts function.
Procedure SetRestrictionPart(RestrictionParts, PartProperties)
	
	If PartProperties.Name = "AllowReadUpdate"
	 Or PartProperties.Name = "AllowRead" Then
		
		PropertyName = "ReadRestriction";
		
	ElsIf PartProperties.Name = "AllowUpdateIfReadingAllowed" Then
		
		PropertyName = "UpdateRestriction";
		
	Else // ПрисоединитьДополнительныеТаблицы.
		
		PropertyName = "AdditionalTables";
		RestrictionParts.MainTableAlias = PartProperties.MainTableAlias;
	EndIf;
	
	RestrictionParts[PropertyName] = PartProperties.Content;
	
EndProcedure

// For the RestrictionParts function and the ParseAdditionalTables and ParseRestrictionCondition procedures.
// Parameters:
//  PartProperties - See NewPartProperties
//  ErrorText - String
//
Procedure SetPartBeginningError(PartProperties, ErrorText)
	
	If TypeOf(PartProperties) = Type("ValueTable") Then
		RowWithError = PartProperties[PartProperties.Count() - 1];
		
	ElsIf TypeOf(PartProperties) = Type("ValueTableRow") Then
		RowWithError = PartProperties;
	Else
		RowWithError = PartProperties.Rows[0];
	EndIf;
	
	RowWithError.ErrorText = ErrorText;
	
	// 
	RowWithError.ErrorPosition = -1;
	
EndProcedure

// For the ParseConnection procedure.
//  Parameters:
//   Rows - Array of ValueTableRow: см. ТаблицаНаборовСимволов
//   RowIndex - Number
//   ErrorText - String
//
Procedure SetErrorInsidePart(Rows, RowIndex, ErrorText)
	
	If RowIndex < Rows.Count() Then
		RowWithError = Rows[RowIndex];
	Else
		RowWithError = Rows[RowIndex - 1];
		// 
		RowWithError.ErrorPosition = StrLen(RowWithError.Chars);
	EndIf;
	
	RowWithError.ErrorText = ErrorText;
	
EndProcedure

// For the ExpressionsInParenthesesInAttachments and ExpressionsWhenThenSelectionInAttachments function.
Procedure SetErrorInRow(String, ErrorText, InWordEnd = False, WordNumber = 1)
	
	If ValueIsFilled(String.ErrorText) Then
		Return;
	EndIf;
	
	If InWordEnd Then
		String.ErrorPosition = StrLen(String.Chars);
		
	ElsIf WordNumber > 1 Then
		NameContent = StrSplit(String.Chars, ".");
		If NameContent.Count() > 1 Then
			String.ErrorPosition = StrLen(NameContent[0]) + 1;
		EndIf;
	EndIf;
	
	String.ErrorText = ErrorText;
	
EndProcedure

// For the RestrictionParts function.
Procedure ParseRestrictionPart(PartProperties, InternalData)
	
	If PartProperties.Name = "AttachAdditionalTables" Then
		PartProperties.Insert("Content", New Array);
		PartProperties.Insert("MainTableAlias", "");
		ParseAdditionalTables(PartProperties, InternalData);
	Else
		PartProperties.Insert("Content", NodeDetails());
		ParseRestrictionCondition(PartProperties, InternalData);
	EndIf;
	
EndProcedure

// For the ParseRestrictionPart procedure.
Procedure ParseAdditionalTables(PartProperties, InternalData)
	
	PartRows = PartProperties.Rows; // Array of ValueTableRow: см. ТаблицаНаборовСимволов
	
	If PartRows.Count() < 2
	 Or PartRows[1].Kind <> "Keyword"
	 Or PartRows[1].Refinement <> "ThisList" Then
		SetPartBeginningError(
			?(PartRows.Count() < 3, PartProperties.SeparatorRow, PartRows[1]),
			StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'Keyword ""%2"" is not found
				           |after keyword ""%1"".';"),
				PartProperties.Presentation,
				KeywordRegardingLanguage("ThisList", InternalData)));
		Return;
	EndIf;
	
	ChangeKeywordTypeListToName(PartRows, PartRows[1]);
	
	If PartRows.Count() < 3
	 Or PartRows[2].Kind <> "Keyword"
	 Or PartRows[2].Refinement <> "As" Then
		SetPartBeginningError(
			?(PartRows.Count() < 3, PartProperties.SeparatorRow, PartRows[2]),
				InsertKeywordsIntoString(InternalData,
					NStr("en = 'Keyword ""%2"" is not found after keyword ""%1"".';"),
					"ThisList,As"));
		Return;
	EndIf;
	
	If PartRows.Count() < 4
	 Or PartRows[3].Kind <> "Name" Then
		SetPartBeginningError(
			?(PartRows.Count() < 4, PartProperties.SeparatorRow, PartRows[3]),
				InsertKeywordsIntoString(InternalData,
					NStr("en = 'No alias is found after keyword ""%1"".';"),
					"As"));
		Return;
	EndIf;
	
	SetAlias(PartRows[3], PartProperties.MainTableAlias, InternalData);
	
	// Dividing description into groups of left connections.
	Joins = New Array;
	CurrentConnection = New Array; // Array of ValueTableRow: см. ТаблицаНаборовСимволов
	
	For IndexOf = 4 To PartRows.Count()-1 Do
		PartRow = PartRows[IndexOf];
		
		If PartRow.Kind = "Keyword"
		   And PartRow.Refinement = "Left" Then
			
			If CurrentConnection.Count() > 0 Then
				Joins.Add(CurrentConnection);
			EndIf;
			CurrentConnection = New Array;
			CurrentConnection.Add(PartRow);
			
			If IndexOf + 1 < PartRows.Count()
			   And PartRows[IndexOf + 1].Kind = "Keyword"
			   And PartRows[IndexOf + 1].Refinement = "Join" Then
				
				IndexOf = IndexOf + 1;
				CurrentConnection.Add(PartRows[IndexOf]);
			EndIf;
			
			Continue;
		EndIf;
		CurrentConnection.Add(PartRow);
	EndDo;
	
	If CurrentConnection.Count() > 0
	 Or Joins.Count() = 0 Then
		
		Joins.Add(CurrentConnection);
	EndIf;
	
	InternalData.Insert("AvailableAliases",
		New Map(New FixedMap(InternalData.Aliases)));
	
	For Each Join In Joins Do
		// 
		// 
		ParseConnection(Join, PartProperties, InternalData);
	EndDo;
	
	// Continue parsing after filling in the aliases of all additional tables.
	For Each IConnectionShort In PartProperties.Content Do
		InternalData.AvailableAliases.Insert(Upper(IConnectionShort.Alias), True);
		// 
		// 
		ParseConnectionConditionFieldsAndMarkProhibitions(IConnectionShort, InternalData);
	EndDo;
	
EndProcedure

// For the ParseAdditionalTables procedure.
//
// Parameters:
//    Join - Array of ValueTableRow: см. ТаблицаНаборовСимволов
//
Procedure ParseConnection(Join, PartProperties, InternalData)
	
	IConnectionShort = NewConnectionDetails();
	IConnectionShort.Insert("Table", "");
	IConnectionShort.Insert("Alias", "");
	IConnectionShort.Insert("ConnectionCondition", Undefined);
	
	If Join[0].Kind <> "Keyword"
	 Or Join[0].Refinement <> "Left" Then
		SetErrorInsidePart(Join, 0, InsertKeywordsIntoString(InternalData,
			NStr("en = 'Keyword ""%1"" is not found.';"), "Left"));
		
		If Join[0].Kind <> "Keyword"
		 Or Join[0].Refinement <> "Inner"
		   And Join[0].Refinement <> "Full" Then
			
			Return;
		EndIf;
	EndIf;
	
	If Join.Count() < 2
	 Or Join[1].Kind <> "Keyword"
	 Or Join[1].Refinement <> "Join" Then
		SetErrorInsidePart(Join, 1,
			StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'Keyword ""%2"" is not found after keyword ""%1"".';"),
				Join[0].Chars,
				KeywordRegardingLanguage("Join", InternalData)));
		Return;
	EndIf;
	
	If Join.Count() < 3
	 Or Join[2].Kind <> "Name" Then
		SetErrorInsidePart(Join, 2,
			StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'No table name is found after keyword ""%1"".';"),
				Join[1].Chars));
		Return;
	EndIf;
	
	SetTableName(Join[2], IConnectionShort, InternalData);
	
	If Join.Count() < 4
	 Or Join[3].Kind <> "Keyword"
	 Or Join[3].Refinement <> "As" Then
		SetErrorInsidePart(Join, 3, InsertKeywordsIntoString(InternalData,
			NStr("en = 'Keyword ""%1"" is not found after the table name.';"), "As"));
		Return;
	EndIf;
	
	If Join.Count() < 5
	 Or Join[4].Kind <> "Name" Then
		SetErrorInsidePart(Join, 4, InsertKeywordsIntoString(InternalData,
			NStr("en = 'No table alias is found after keyword ""%1"".';"), "As"));
		Return;
	EndIf;
	
	SetAlias(Join[4], IConnectionShort, InternalData);
	
	If Join.Count() < 6
	 Or Join[5].Kind <> "Keyword"
	 Or Join[5].Refinement <> "On" Then
		SetErrorInsidePart(Join, 5, InsertKeywordsIntoString(InternalData,
			NStr("en = 'Keyword ""%1"" is not found after the table alias.';"), "On"));
		Return;
	EndIf;
	
	Condition = New Array(New FixedArray(Join));
	For IndexOf = 0 To 5 Do
		Condition.Delete(0);
	EndDo;
	
	ParseCondition(Condition, IConnectionShort.ConnectionCondition, InternalData);
	
	PartProperties.Content.Add(IConnectionShort);
	
EndProcedure

// For the ParseAdditionalTables procedure.
Procedure ParseConnectionConditionFieldsAndMarkProhibitions(IConnectionShort, InternalData)
	
	// Marking incorrect operation arguments and prohibited features.
	CommonNodes = New Map(AccessManagementInternalCached.NodesToCheckAvailability(
		"Field,Value,Constant,And,=", False));
	
	CommonNodes.Insert("Field", New Structure("Cast, Attachment, IsNull", False, False, False));
	
	AvailableNodes = New Structure;
	AvailableNodes.Insert("Overall",          CommonNodes);
	AvailableNodes.Insert("NodesWhen",      CommonNodes);
	AvailableNodes.Insert("NodesThenElse", CommonNodes);
	
	Context = ExtendedInternalData(InternalData);
	Context.Insert("IsMergeCondition",  True);
	Context.Insert("IsConditionWhen",       False);
	Context.Insert("IsValueThenElse", False);
	Context.Insert("RootNode",          IConnectionShort.ConnectionCondition);
	
	MarkIncorrectArgumentsAndProhibitedNodes(IConnectionShort.ConnectionCondition,
		AvailableNodes, Context);
	
	DeleteSourceProperty(IConnectionShort.ConnectionCondition);
	
EndProcedure

// For the ParseConnectionCondition and ParseRestrictionCondition procedures.
//
// Parameters:
//  List - String - a list of node names separated by commas.
//  IsExceptionsList - Boolean - if True, add nodes except for the specified ones.
//
// Returns:
//  FixedMap of KeyAndValue:
//    * Key - String - a node name
//    * Value - Boolean
//               - Structure:
//       ** Cast - Boolean
//       ** Attachment - Boolean
//       ** IsNull - Boolean
//
Function NodesToCheckAvailability(List, IsExceptionsList) Export
	
	AllNodes = New Map;
	AllNodes.Insert("Field", New Structure("Cast, Attachment, IsNull", True, True, True));
	AllNodes.Insert("Value",    True);
	AllNodes.Insert("Constant",   True);
	AllNodes.Insert("And",           True);
	AllNodes.Insert("Or",         True);
	AllNodes.Insert("Not",          True);
	AllNodes.Insert("=",           True);
	AllNodes.Insert("<>",          True);
	AllNodes.Insert("In",           True);
	AllNodes.Insert("IsNull",    True);
	AllNodes.Insert("Type",         True);
	AllNodes.Insert("ValueType", True);
	AllNodes.Insert("Case",       True);
	AllNodes.Insert("ValueAllowed",             True);
	AllNodes.Insert("IsAuthorizedUser", True);
	AllNodes.Insert("ObjectReadingAllowed",        True);
	AllNodes.Insert("ObjectUpdateAllowed",     True);
	AllNodes.Insert("ListReadingAllowed",         True);
	AllNodes.Insert("ListUpdateAllowed",      True);
	AllNodes.Insert("ForAllRows",                  True);
	AllNodes.Insert("ForAtLeastOneRow",               True);
	AllNodes.Insert("AccessRight",                  True);
	AllNodes.Insert("IsInRole",                  True);
	
	NodesArray = StrSplit(List, ",", False);
	Nodes = New Map;
	
	For Each Node In AllNodes Do
		If IsExceptionsList Then
			If NodesArray.Find(Node.Key) = Undefined Then
				Nodes.Insert(Node.Key, Node.Value);
			EndIf;
		Else
			If NodesArray.Find(Node.Key) <> Undefined Then
				Nodes.Insert(Node.Key, Node.Value);
			EndIf;
		EndIf;
	EndDo;
	
	Return New FixedMap(Nodes);
	
EndFunction

// For the ParseConnectionCondition and ParseRestrictionCondition procedures.
//
// Parameters:
//  Condition       - See NodeDetails
//  AvailableNodes - Structure
//  Context      - See ExtendedInternalData
//  Parent      - See NodeDetails
//
Procedure MarkIncorrectArgumentsAndProhibitedNodes(Condition, AvailableNodes, Context, Parent = Undefined)
	
	If Not ValueIsFilled(Condition) Then
		Return;
	EndIf;
	
	If Context.IsConditionWhen Then
		CurrentAvailableNodes = AvailableNodes.NodesWhen;
		
	ElsIf Context.IsValueThenElse Then
		CurrentAvailableNodes = AvailableNodes.NodesThenElse;
	Else
		CurrentAvailableNodes = AvailableNodes.Overall;
	EndIf;
	
	NodeAvailability = CurrentAvailableNodes.Get(Condition.Node);
	
	If NodeAvailability = Undefined Then
		SetNodeProhibitedError(Condition.Source, Context);
	EndIf;
	
	If Condition.Node = "Field" Then
		
		If Not Context.IsMergeCondition Then
			AccessKeyField = NewAccessKeyField();
			AccessKeyField.Insert("Field",   Condition);
			AccessKeyField.Insert("Read",    Context.Read);
			AccessKeyField.Insert("Update", Context.Update);
			Context.AccessKeyFields.Add(AccessKeyField);
		EndIf;
		
		SelectFieldAlias(Condition, Context);
		
		If Not NodeAvailability.Cast
		   And Condition.Cast <> Undefined Then
			
			SetNodeProhibitedError(Condition.Source, Context);
			
		ElsIf Not NodeAvailability.Attachment
		        And Condition.Attachment <> Undefined Then
		
			SetNodeProhibitedError(Condition.Attachment.Source, Context);
			
		ElsIf Not NodeAvailability.IsNull
		        And Condition.IsNull <> Undefined Then
		
			SetNodeProhibitedError(Condition.IsNullSource, Context);
		EndIf;
		
	ElsIf Condition.Node = "And"
	      Or Condition.Node = "Or" Then
		
		For Each Argument In Condition.Arguments Do
			MarkIncorrectArgumentsAndProhibitedNodes(Argument, AvailableNodes, Context);
		EndDo;
		
	ElsIf Condition.Node = "Not"
	      Or Condition.Node = "IsNull"
	      Or Condition.Node = "ForAllRows"
	      Or Condition.Node = "ForAtLeastOneRow" Then
		
		// Validate the parameter.
		If Condition.Node = "IsNull"
		   And (    Condition.Argument = Undefined
		      Or Condition.Argument.Node <> "Field" ) Then
			
			SetErrorInRow(Condition.Source,
				StringFunctionsClientServer.SubstituteParametersToString(
					NStr("en = 'The ""%1"" operation is allowed only after a field.';"),
					Condition.Source.Chars));
		EndIf;
		MarkIncorrectArgumentsAndProhibitedNodes(Condition.Argument, AvailableNodes, Context);
		
	ElsIf Condition.Node = "="
	      Or Condition.Node = "<>" Then
		
		NodesCombinations = New Map;
		NodesCombinations.Insert("Value",  ",Field,");
		NodesCombinations.Insert("Constant", ",Field,Constant,");
		
		If Context.IsMergeCondition Then
			NodesCombinations.Insert("Field",        ",Field,Value,Constant,");
		Else
			NodesCombinations.Insert("Field",        ",Value,Constant,");
			NodesCombinations.Insert("Type",         ",ValueType,");
			NodesCombinations.Insert("ValueType", ",Type,");
		EndIf;
		
		FirstArgumentCombinations = NodesCombinations.Get(Condition.FirstArgument.Node);
		SecondArgumentCombinations = NodesCombinations.Get(Condition.SecondArgument.Node);
		
		ErrorInFirstArgument  = FirstArgumentCombinations = Undefined;
		ErrorInSecondArgument = SecondArgumentCombinations = Undefined
			Or FirstArgumentCombinations <> Undefined
			  And StrFind(FirstArgumentCombinations, "," + Condition.SecondArgument.Node + ",") = 0;
		
		If ErrorInFirstArgument Or ErrorInSecondArgument Then
			If Context.IsMergeCondition Then
				ErrorText =
					NStr("en = 'The ""%1"" operation is allowed only for a field (with a field, a value, or a constant).';");
			Else
				ErrorText =
					NStr("en = 'The ""%1"" operation is allowed only for a field (with a value or a constant),
					           |or for a value type (with a type.)';");
			EndIf;
			If ErrorInFirstArgument Then
				ConditionFirstArgument = Condition.FirstArgument; // See NodeDetails
				SetErrorInRow(ConditionFirstArgument.Source,
					StringFunctionsClientServer.SubstituteParametersToString(
						ErrorText, Condition.Source.Chars),
					True);
			EndIf;
			If ErrorInSecondArgument Then
				ConditionSecondArgument = Condition.SecondArgument; // See NodeDetails
				SetErrorInRow(ConditionSecondArgument.Source,
					StringFunctionsClientServer.SubstituteParametersToString(
						ErrorText, Condition.Source.Chars));
			EndIf;
		EndIf;
		
		MarkIncorrectArgumentsAndProhibitedNodes(Condition.FirstArgument, AvailableNodes, Context, Condition);
		MarkIncorrectArgumentsAndProhibitedNodes(Condition.SecondArgument, AvailableNodes, Context, Condition);
		
	ElsIf Condition.Node = "In" Then
		MarkIncorrectArgumentsAndProhibitedNodes(Condition.SearchFor, AvailableNodes, Context);
		For Each Value In Condition.Values Do
			MarkIncorrectArgumentsAndProhibitedNodes(Value, AvailableNodes, Context);
		EndDo;
		
	ElsIf Condition.Node = "ValueType"
	      Or Condition.Node = "Type" Then
		
		If Parent = Undefined
		 Or Parent.Node <> "="
		   And Parent.Node <> "<>" Then
		
			SetErrorInRow(Condition.Source,
				StringFunctionsClientServer.SubstituteParametersToString(
					NStr("en = 'The ""%1"" function is allowed only in ""="" and ""<>"" operations.';"),
					Condition.Source.Chars));
		EndIf;
		
		If Condition.Node = "ValueType" Then
			MarkIncorrectArgumentsAndProhibitedNodes(Condition.Argument, AvailableNodes, Context);
		EndIf;
		
	ElsIf Condition.Node = "Case" Then
		If Condition.Case <> Undefined Then
			MarkIncorrectArgumentsAndProhibitedNodes(Condition.Case, AvailableNodes, Context);
		EndIf;
		FixedContext = New FixedStructure(Context);
		ContextWhen = New Structure(FixedContext);
		ContextWhen.IsConditionWhen = True;
		ContextThenElse = New Structure(FixedContext);
		ContextThenElse.IsValueThenElse = True;
		
		For Each When In Condition.When Do
			MarkIncorrectArgumentsAndProhibitedNodes(When.Condition,  AvailableNodes, ContextWhen);
			MarkIncorrectArgumentsAndProhibitedNodes(When.Value, AvailableNodes, ContextThenElse);
		EndDo;
		MarkIncorrectArgumentsAndProhibitedNodes(Condition.Else, AvailableNodes, ContextThenElse);
		
	ElsIf Condition.Node = "ValueAllowed"
	      Or Condition.Node = "IsAuthorizedUser"
	      Or Condition.Node = "ObjectReadingAllowed"
	      Or Condition.Node = "ObjectUpdateAllowed"
	      Or Condition.Node = "ListReadingAllowed"
	      Or Condition.Node = "ListUpdateAllowed" Then
		
		MarkIncorrectArgumentsAndProhibitedNodes(Condition.Field, AvailableNodes, Context);
		MarkTypesRepetitionsAmongThoseToCheckAndClarify(Condition, Context);
		
		// 
		Field = Condition.Field; // See NodeDetails
		Clarifications = New Map;
		For Each ComparisonClarification In Condition.ComparisonClarifications Do
			If TypeOf(ComparisonClarification.Key) <> Type("ValueTableRow") Then
				Clarifications.Insert(ComparisonClarification.Key, ComparisonClarification.Value);
				Continue;
			EndIf;
			Clarifications.Insert(ComparisonClarification.Key.Chars, ComparisonClarification.Value);
			AddRequiredTableField(Context, Field.Table, Field.Name, Field.NameSource,
				ComparisonClarification.Key.Chars, ComparisonClarification.Key);
		EndDo;
		
		// 
		Condition.ComparisonClarifications = Clarifications;
		
		Types = New Array;
		For Each Type In Condition.Types Do
			Types.Add(Type.Chars);
		EndDo;
		Condition.Types = Types;
	EndIf;
	
EndProcedure

// Returns:
//  Structure:
//    * Field   - See NodeDetails
//    * Read - Boolean
//    * Parents - Array of See NodeDetails
//
Function NewAccessKeyField()
	
	Return New Structure;
	
EndFunction

// For the MarkIncorrectArgumentsAndProhibitedNodes procedure.
Procedure SelectFieldAlias(FieldNode, Context)
	
	If FieldNode.Attachment <> Undefined Then
		Attachment = FieldNode.Attachment;
		SelectFieldAlias(Attachment, Context);
		If ValueIsFilled(Attachment.Cast) Then
			FieldNode.Table = Attachment.Cast;
		EndIf;
		
	ElsIf Not ValueIsFilled(FieldNode.Name) Then
		Return;
	Else
		NameContent = StrSplit(FieldNode.Name, ".");
		If NameContent.Count() > 1 Then
			Properties = Context.Aliases.Get(Upper(NameContent[0]));
			If Properties <> Undefined Then
				FieldNode.Alias = Properties.Alias;
				NameContent.Delete(0);
				FieldNode.Name = StrConcat(NameContent, ".");
				If ValueIsFilled(Properties.Table) Then
					FieldNode.Table = Properties.Table;
				EndIf;
			EndIf;
		EndIf;
		If Context.IsMergeCondition Then
			If Not ValueIsFilled(FieldNode.Alias) Then
				SetErrorInRow(FieldNode.NameSource,
					NStr("en = 'In the join condition, an alias is required before the field name.';"));
			ElsIf Context.AvailableAliases.Get(Upper(FieldNode.Alias)) = Undefined Then
				SetErrorInRow(FieldNode.NameSource,
					NStr("en = 'An alias from the next join is not allowed.';"));
			EndIf;
		EndIf;
	EndIf;
	
	If ValueIsFilled(FieldNode.Cast) Then
		AddRequiredTableAsReferenceType(Context, FieldNode.Cast, FieldNode.CastSource);
	EndIf;
	
	AddRequiredTableField(Context, FieldNode.Table, FieldNode.Name, FieldNode.NameSource,
		FieldNode.Cast, FieldNode.CastSource, FieldNode);
	
EndProcedure

// For the ParseConnectionCondition and ParseRestrictionCondition procedures.
Procedure DeleteSourceProperty(Condition)
	
	If TypeOf(Condition) = Type("ValueTableRow") Then
		ErrorText = NStr("en = 'Some of the sources of character sets are not deleted.';");
		Raise ErrorText;
		
	ElsIf TypeOf(Condition) <> Type("Structure") Then
		Return;
	EndIf;
	
	If Condition.Property("Source") Then
		Condition.Delete("Source");
	EndIf;
	
	If Condition.Property("NameSource") Then
		Condition.Delete("NameSource");
	EndIf;
	
	If Condition.Property("CastSource") Then
		Condition.Delete("CastSource");
	EndIf;
	
	If Condition.Property("IsNullSource") Then
		Condition.Delete("IsNullSource");
	EndIf;
	
	For Each KeyAndValue In Condition Do
		Value = KeyAndValue.Value;
		
		If TypeOf(Value) = Type("Array") Then
			For Each Item In Value Do
				DeleteSourceProperty(Item);
			EndDo;
			
		ElsIf TypeOf(Value) = Type("Map") Then
			For Each KeyAndValue In Value Do
				DeleteSourceProperty(KeyAndValue.Key);
				DeleteSourceProperty(KeyAndValue.Value);
			EndDo;
		Else
			DeleteSourceProperty(Value);
		EndIf;
	EndDo;
	
EndProcedure

// For the MarkIncorrectArgumentsAndProhibitedNodes procedure.
Procedure SetNodeProhibitedError(String, Context)
	
	If String.Type = "Function" Then
		If Context.IsMergeCondition Then
			ErrorTemplate = NStr("en = 'The ""%1"" function is not allowed in join conditions.';");
			
		ElsIf Context.IsConditionWhen Then
			ErrorTemplate = InsertKeywordsIntoString(Context,
				NStr("en = 'The ""%3"" function is not allowed in the restriction condition of the ""%1"" operation in ""%2"" clauses.';"),
				"Case,When", String.Chars);
			
		ElsIf Context.IsValueThenElse Then
			ErrorTemplate = InsertKeywordsIntoString(Context,
				NStr("en = 'The ""%4"" function is not allowed in the restriction condition of the ""%1"" operation in ""%2"" and ""%3"" clauses.';"),
				"Case,Then,Else", String.Chars);
		Else
			ErrorTemplate = NStr("en = 'The ""%1"" function is not allowed in restriction conditions.';");
		EndIf;
	Else
		If Context.IsMergeCondition Then
			ErrorTemplate = NStr("en = 'The ""%1"" operation is not allowed in join conditions.';");
			
		ElsIf Context.IsConditionWhen Then
			ErrorTemplate = InsertKeywordsIntoString(Context,
				NStr("en = 'The ""%3"" operation is not allowed in the restriction condition of the ""%1"" operation in ""%2"" clauses.';"),
				"Case,When", String.Chars);
			
		ElsIf Context.IsValueThenElse Then
			ErrorTemplate = InsertKeywordsIntoString(Context,
				NStr("en = 'The ""%4"" operation is not allowed in the restriction condition of the ""%1"" operation in ""%2"" and ""%3"" clauses.';"),
				"Case,Then,Else", String.Chars);
		Else
			ErrorTemplate = NStr("en = 'The ""%1"" operation is not allowed in restriction conditions.';");
		EndIf;
	EndIf;
	
	SetErrorInRow(String, StringFunctionsClientServer.SubstituteParametersToString(
		ErrorTemplate, String.Chars));
	
EndProcedure

// For the MarkIncorrectArgumentsAndProhibitedNodes procedure.
Procedure MarkTypesRepetitionsAmongThoseToCheckAndClarify(Node, Context)
	
	TypesInList = New Map;
	
	For Each TypeInList In Node.Types Do
		If TypesInList.Get(Upper(TypeInList.Chars)) = Undefined Then
			TypesInList.Insert(Upper(TypeInList.Chars), True);
		Else
			SetErrorInRow(TypeInList, StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'The ""%1"" type is already in the list.';"), TypeInList.Chars));
		EndIf;
	EndDo;
	
	TypesToClarify = New Map;
	
	For Each ComparisonClarification In Node.ComparisonClarifications Do
		If TypeOf(ComparisonClarification.Key) <> Type("ValueTableRow") Then
			Continue;
		EndIf;
		TypeSource = ComparisonClarification.Key;
		
		If Not Node.CheckTypesExceptListed
		   And TypesInList.Get(Upper(TypeSource.Chars)) <> Undefined Then
			
			SetErrorInRow(TypeSource, InsertKeywordsIntoString(Context,
				NStr("en = 'The ""%2"" type is already in the list of types for the ""%1"" keyword.';"),
				"Only",
				TypeSource.Chars));
			
		ElsIf Node.CheckTypesExceptListed
		        And TypesInList.Get(Upper(TypeSource.Chars)) = Undefined Then
			
			SetErrorInRow(TypeSource, InsertKeywordsIntoString(Context,
				NStr("en = 'The ""%2"" type is not in the list of types for the ""%1"" keyword.';"),
				"Not",
				TypeSource.Chars));
			
		ElsIf TypesToClarify.Get(Upper(TypeSource.Chars)) <> Undefined Then
			SetErrorInRow(TypeSource, StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'Type ""%1"" already has a refiner';"), TypeSource.Chars));
		Else
			TypesToClarify.Insert(Upper(TypeSource.Chars), True);
		EndIf;
	EndDo;
	
EndProcedure

// For the ParseRestrictionPart procedure.
//
// Parameters:
//  PartProperties - See NewPartProperties
//  InternalData - See NewInternalData
//
Procedure ParseRestrictionCondition(PartProperties, InternalData)
	
	PartRows = PartProperties.Rows;
	ChangeKeywordTypeListToName(PartRows);
	
	If PartRows.Count() < 2
	 Or PartRows[1].Kind <> "Keyword"
	 Or PartRows[1].Refinement <> "Where" Then
		SetPartBeginningError(
			?(PartRows.Count() < 2, PartProperties.SeparatorRow, PartRows[1]),
				StringFunctionsClientServer.SubstituteParametersToString(
					NStr("en = 'Keyword ""%2"" is not found
					           |after keyword ""%1"".';"),
					PartProperties.Presentation,
					KeywordRegardingLanguage("Where", InternalData)));
		Return;
	EndIf;
	
	Condition = New Array(New FixedArray(PartRows));
	For IndexOf = 0 To 1 Do
		Condition.Delete(0);
	EndDo;
	
	ParseCondition(Condition, PartProperties.Content, InternalData);
	
	// Marking incorrect parameters of operations and unsupported functionality.
	CommonNodes = AccessManagementInternalCached.NodesToCheckAvailability("", True);
	
	NodesWhen = AccessManagementInternalCached.NodesToCheckAvailability(
		"Field,Value,Constant,And,Or,Not,=,<>,In,IsNull,Type,ValueType", False);
	
	NodesThenElse = AccessManagementInternalCached.NodesToCheckAvailability(
		"Case,ForAllRows,ForAtLeastOneRow", True);
	
	AvailableNodes = New Structure;
	AvailableNodes.Insert("Overall",          CommonNodes);
	AvailableNodes.Insert("NodesWhen",      NodesWhen);
	AvailableNodes.Insert("NodesThenElse", NodesThenElse);
	
	FixedContext = New FixedStructure(InternalData);
	Context = New Structure(FixedContext);
	Context.Insert("IsMergeCondition",  False);
	Context.Insert("IsConditionWhen",       False);
	Context.Insert("IsValueThenElse", False);
	Context.Insert("RootNode",          PartProperties.Content);
	Context.Insert("Read",
		    PartProperties.Name = "AllowReadUpdate"
		Or PartProperties.Name = "AllowRead");
	Context.Insert("Update",
		    PartProperties.Name = "AllowReadUpdate"
		Or PartProperties.Name = "AllowUpdateIfReadingAllowed");
	
	AddDefaultAliases(Context);
	
	MarkIncorrectArgumentsAndProhibitedNodes(PartProperties.Content, AvailableNodes, Context);
	
	DeleteSourceProperty(PartProperties.Content);
	
EndProcedure

// For the RestrictionParts and ParseRestrictionCondition procedures.
Procedure AddDefaultAliases(Context);
	
	If Context.Aliases.Count() > 0 Then
		Return;
	EndIf;
	
	Context.Aliases.Insert(Upper("ThisList"), New Structure("Alias, Table", "ThisList"));
	Context.Aliases.Insert(Upper("ThisList"),   New Structure("Alias, Table", "ThisList"));
	
EndProcedure

// For the ParseConnectionCondition and ParseRestrictionCondition procedures.
//
// Parameters:
//  Condition          - Array of ValueTableRow
//  Content           - See NodeDetails
//  InternalData - See NewInternalData
//
Procedure ParseCondition(Condition, Content, InternalData)
	
	ExpressionsInParenthesesInAttachments = ExpressionsInParenthesesInAttachments(Condition, InternalData);
	
	FunctionsWithExpressionsInParentheses = FunctionsWithExpressionsInParentheses(
		ExpressionsInParenthesesInAttachments, InternalData);
	
	ExpressionsSelectionWhenThenInAttachments = ExpressionsSelectionWhenThenInAttachments(
		FunctionsWithExpressionsInParentheses, InternalData);
	
	Condition = ExpressionsSelectionWhenThenInAttachments;
	
	ParseExpression(Condition, Content, InternalData, False);
	
	UnionNestedLogicalOperations(Content);
	
EndProcedure

// For the ParseCondition procedure.
Procedure UnionNestedLogicalOperations(Content)
	
	If Content = Undefined Then
		Return;
	EndIf;
	
	If Content.Node = "And"
	 Or Content.Node = "Or" Then
		
		IndexOf = Content.Arguments.Count() - 1;
		While IndexOf >= 0 Do
			
			Argument = Content.Arguments[IndexOf];
			UnionNestedLogicalOperations(Argument);
			
			If Argument.Node = Content.Node Then
				Content.Arguments.Delete(IndexOf);
				NestedIndex = Argument.Arguments.Count() - 1;
				While NestedIndex >= 0 Do
					Content.Arguments.Insert(IndexOf, Argument.Arguments[NestedIndex]);
					NestedIndex = NestedIndex - 1;
				EndDo;
			EndIf;
			IndexOf = IndexOf - 1;
		EndDo;
	EndIf;
	
EndProcedure


// For the ParseCondition, ParseFunction, and ParseChoice procedures.
//
// Parameters:
//    Condition - Array of See TableRow.RowDescription
//
Procedure ParseExpression(Condition, Content, CurrentContext, NestedExpression = True)
	
	FixedContext = New FixedStructure(CurrentContext);
	Context = New Structure(FixedContext);
	Context.Insert("Attachments", New Array);
	Context.Insert("LongDesc");
	Context.Insert("String");
	
	For Each RowDescription In Condition Do
		String = TableRow(RowDescription, CurrentContext);
		Context.String = String;
		
		If String.Kind = "Name"
		 Or String.Kind = "Number"
		 Or String.Kind = "ArbitraryLine"
		 Or String.Kind = "Keyword" 
		   And (    String.Refinement = "True"
		      Or String.Refinement = "False"
		      Or String.Refinement = "Undefined" ) Then
			
			NewDetails = FieldNodeOrConstantNodeDetails(String);
			AddArgumentFunctionChoiceOperator(Context, NewDetails);
			
		ElsIf String.Kind = "Keyword" Then
			
			If String.Type = "Function"
			 Or String.Refinement = "In" Then
				
				If String.Type = "Function" Then
					ParseFunction(Context);
				Else
					ParseConnectorIn(Context);
				EndIf;
				
			ElsIf String.Type = "Connector" Then
				ParseConnector(Context);
			
			ElsIf String.Type = "Operator" Then
				ParseOperator(Context);
				
			ElsIf String.Type = "SelectionWord" Then
				ParseChoice(Context);
			Else
				ParseErrorKeyword(Context);
			EndIf;
			
		ElsIf String.Kind = "Operation" Then
			ParseConnector(Context, True);
			
		ElsIf String.Kind = "Separator" Then
			If String.Chars = "(" Then
				NewDetails = Undefined; // See NodeDetails
				ParseExpression(String.Rows, NewDetails, Context);
				AddArgumentFunctionChoiceOperator(Context, NewDetails);
				If NewDetails <> Undefined Then
					NewDetails.Source.Priority = 99;
				EndIf;
			Else
				Context.LongDesc = Undefined;
				SetErrorInRow(String,
					NStr("en = 'A comma is only allowed as a separator for function parameters.';"));
			EndIf;
		Else
			Context.LongDesc = Undefined;
			SetErrorInRow(String, StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'There is no processing algorithm defined for the ""%1"" keyword.';"), String.Chars));
		EndIf;
		
		If Context.LongDesc = Undefined Then
			// An error that stops further parsing (preventing from false starts) occurred.
			Break;
		EndIf;
	EndDo;
	
	If Context.LongDesc = Undefined Then
		If NestedExpression Then
			Content = New Structure("Source, Node, Value", String, "Constant", False);
		Else
			Content = Undefined;
		EndIf;
		
	ElsIf Context.Attachments.Count() = 0 Then
		Content = Context.LongDesc;
	Else
		Content = Context.Attachments[Context.Attachments.Count() - 1];
	EndIf;
	
EndProcedure

// For the ParseExpression, ParseFirstCheckingFunctionParameter,
// ParseValueTypeFunctionParameters, ParseChoice procedures and
// the FieldNodeDetailsFromIsNullFunction function.
//
Function FieldNodeOrConstantNodeDetails(String)
	
	// <Field name>, <Number>, <Arbitrary string>, True, False, Undefined.
	
	If String.Kind = "Name" Then
		NewDetails = FieldNodeDetails(String);
		NewDetails.Name         = String.Chars;
		NewDetails.NameSource = String;
	Else
		NodeProperties = "Source, Node, Value";
		NewDetails = New Structure(NodeProperties, String, "Constant");
		
		If String.Kind = "Keyword" Then
			If String.Refinement = "True" Then
				NewDetails.Value = True;
				
			ElsIf String.Refinement = "False" Then
				NewDetails.Value = False;
				
			Else // 
				NewDetails.Value = Undefined;
			EndIf;
		Else // 
			NewDetails.Value = String.Refinement;
		EndIf;
	EndIf;
	
	Return NewDetails;
	
EndFunction

// For the FieldNodeOrConstantNodeDetails, FieldNodeDetailsFromExpressFunction, and FieldNodeDetailsFromIsNullFunction functions.
Function FieldNodeDetails(String)
	
	NodeProperties = "Source, Node, Name, Table, Alias, Cast, Attachment, IsNull";
	NewDetails = New Structure(NodeProperties, String, "Field");
	
	NewDetails.Insert("NameSource",      Undefined);
	NewDetails.Insert("CastSource", Undefined);
	NewDetails.Insert("IsNullSource", Undefined);
	
	Return NewDetails;
	
EndFunction

// For the ParseExpression procedure.
Procedure ParseConnector(Context, IsOperation = False)
	
	// 
	// 
	
	String = Context.String; // ValueTableRow of See CharsetsTable
	
	NewDetails = New Structure("Source, Node", String,
		?(String.Kind = "Operation", String.Chars, String.Refinement));
	
	If String.Refinement = "And"
	 Or String.Refinement = "Or" Then
		
		NewDetails.Insert("Arguments", New Array);
		NewDetails.Arguments.Add(Undefined);
		AddConnector(Context, NewDetails, NewDetails.Arguments[0]);
	
	ElsIf String.Refinement = "Is" Then
		NewDetails.Node = "IsNull";
		NewDetails.Insert("Argument", Undefined);
		AddConnector(Context, NewDetails, NewDetails.Argument);
		// 
		// 
		
	ElsIf String.Kind = "Operation" Then
		NewDetails.Insert("FirstArgument", Undefined);
		NewDetails.Insert("SecondArgument", Undefined);
		AddConnector(Context, NewDetails, NewDetails.FirstArgument);
		// 
		// 
		
	ElsIf String.Refinement = "As"
	      Or String.Refinement = "Not"
	      Or String.Refinement = "Only" Then
		
		Context.LongDesc = Undefined;
		SetErrorInRow(String, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'The ""%1"" keyword can be used only in function parameters.';"), String.Chars));
	Else
		Context.LongDesc = Undefined;
		SetErrorInRow(String, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'There is no processing algorithm defined for the ""%1"" keyword.';"), String.Chars));
	EndIf;
	
EndProcedure

// For the ParseExpression procedure.
Procedure ParseConnectorIn(Context)
	
	String = Context.String;
	
	NewDetails = New Structure("Source, Node", String, String.Refinement);
	NewDetails.Insert("SearchFor",  Undefined);
	NewDetails.Insert("Values", New Array);
	
	ParametersContent = CommaSeparatedParameters(String, Context);
	// The parameter missing error is already set in the FunctionsWithExpressionsInParentheses function.
	
	For Each ParameterDetails In ParametersContent Do
		ParameterDescriptionLines = ParameterDetails.Rows; // Array of ValueTableRow: см. ТаблицаНаборовСимволов
		For Each Substring In ParameterDescriptionLines Do
			
			ParseConnectorValueIn(Context, Substring, NewDetails);
			
			If ParameterDetails.Rows[0] <> Substring Then
				SetErrorInRow(Substring, NStr("en = 'A comma preceding a parameter is missing.';"));
			EndIf;
			
		EndDo;
	EndDo;
	
	AddConnector(Context, NewDetails, NewDetails.SearchFor);
	
	If NewDetails.SearchFor.Node <> "Field" Then
		SetErrorInRow(String, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'The ""%1"" operation is allowed only after a field name.';"), String.Chars));
	EndIf;
	
EndProcedure

// For the ParseConnectorIn procedure.
Procedure ParseConnectorValueIn(Context, Substring, NewDetails)
	
	String = Context.String;
	
	If Substring.Kind = "Number"
	 Or Substring.Kind = "ArbitraryLine" Then
		
		ConstantDetails = New Structure("Source, Node", Substring, "Constant");
		ConstantDetails.Insert("Value", Substring.Refinement);
		NewDetails.Values.Add(ConstantDetails);
		
	ElsIf Substring.Kind = "Keyword" Then
		
		If Substring.Refinement = "Value" Then
			NewContext = NewContext(Context, Substring, Undefined);
			ParseFunction(NewContext);
			If NewContext.LongDesc <> Undefined Then
				NewDetails.Values.Add(NewContext.LongDesc);
			EndIf;
		Else
			SetErrorInRow(Substring, StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'The ""%2"" keyword is not allowed in the list of values of the ""%1"" operation.';"),
				String.Chars, Substring.Chars));
		EndIf;
		
	ElsIf Substring.Kind = "Name" Then
		SetErrorInRow(Substring, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Field names are not allowed in the list of values of the ""%1"" operation.';"), String.Chars));
		
	ElsIf Substring.Chars = "(" Then
		SetErrorInRow(Substring, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Parentheses are allowed only for function parameters in the list of values of the ""%1"" operation.';"), String.Chars));
	Else
		SetErrorInRow(Substring, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Only values are allowed in the list of values of the ""%1"" operation.';"), String.Chars));
	EndIf;
	
EndProcedure

// For the ParseConnectorValueIn procedure.
Function NewContext(Context, String = null, LongDesc = null)
	
	FixedContext = New FixedStructure(Context);
	NewContext = New Structure(FixedContext);
	
	If String <> null Then
		NewContext.String = String;
	EndIf;
	
	If LongDesc <> null Then
		NewContext.LongDesc = LongDesc;
	EndIf;
	
	Return NewContext;
	
EndFunction

// For the ParseConnector, ParseConnectorIn, and InsertConnectorConsideringPriority procedures.
Procedure AddConnector(Context, NewDetails, FirstArgument);
	
	// 
	
	LongDesc = Context.LongDesc; // See NodeDetails
	
	If LongDesc = Undefined Then
		Context.LongDesc = NewDetails;
		
	ElsIf LongDesc.Node = "And"
	      Or LongDesc.Node = "Or" Then
		
		If LongDesc.Arguments.Count() = 1 Then
			LongDesc.Arguments.Add(Undefined);
			ProcessMissingArgumentAfterConnector(Context, LongDesc.Arguments[1]);
		EndIf;
		InsertConnectorConsideringPriority(Context,
			LongDesc.Arguments[1], NewDetails, FirstArgument);
		
	ElsIf LongDesc.Node = "Not" Then
		If Not ValueIsFilled(LongDesc.Argument) Then
			ProcessMissingArgumentAfterConnector(Context, LongDesc.Argument);
		EndIf;
		InsertConnectorConsideringPriority(Context,
			LongDesc.Argument, NewDetails, FirstArgument);
		
	ElsIf LongDesc.Source.Kind = "Operation" Then
		If Not ValueIsFilled(LongDesc.SecondArgument) Then
			ProcessMissingArgumentAfterConnector(Context, LongDesc.SecondArgument, False);
		EndIf;
		InsertConnectorConsideringPriority(Context,
			LongDesc.SecondArgument, NewDetails, FirstArgument);
		
	ElsIf StrFind(",Field,Value,Constant,In,IsNull,Case,", "," + LongDesc.Node + ",") > 0
	      Or LongDesc.Source.Type = "Function" Then
		// 
		// 
		// 
		InsertConnectorConsideringPriority(Context, Undefined, NewDetails, FirstArgument);
	Else
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'There is no processing algorithm defined for node ""%1"".';"), LongDesc.Node);
		Raise ErrorText;
	EndIf;
	
EndProcedure

// For the AddConnector procedure.
Procedure ProcessMissingArgumentAfterConnector(Context, SecondArgument, LogicalOperation = True)
	
	LongDesc = Context.LongDesc; // See NodeDetails
	
	SetErrorInRow(LongDesc.Source,
		?(LogicalOperation,
			NStr("en = 'An argument is missing after a logical operation.';"),
			NStr("en = 'An argument is missing after an operation.';")),
		True);
	
	SecondArgument = New Structure("Source, Node, Value", Context.String, "Constant", True);
	
EndProcedure

// For the AddConnector and ProcessMissingLogicalOperation procedures.
Procedure InsertConnectorConsideringPriority(Context,
			DetailsLastArgument, NewDetails, NewDetailsFirstArgument)
	
	Attachments = Context.Attachments;
	LongDesc = Context.LongDesc; // See NodeDetails
	
	If DetailsLastArgument <> Undefined
	   And Context.String.Priority >= LongDesc.Source.Priority Then
		
		// 
		NewDetailsFirstArgument = DetailsLastArgument;
		DetailsLastArgument = NewDetails;
		
		Attachments.Insert(0, Context.LongDesc);
		Context.LongDesc = NewDetails;
		Return;
	EndIf;
	
	If Attachments.Count() = 0 Then
		// 
		NewDetailsFirstArgument = Context.LongDesc;
		Context.LongDesc = NewDetails;
		Return;
	EndIf;
	
	// 
	Context.LongDesc = Attachments[0];
	Attachments.Delete(0);
	
	AddConnector(Context, NewDetails, NewDetailsFirstArgument);
	
EndProcedure

// For the ParseExpression procedure.
Procedure ParseOperator(Context)
	
	// The Not operator.
	
	NewDetails = New Structure("Source, Node, Argument",
		Context.String, Context.String.Refinement);
	
	AddArgumentFunctionChoiceOperator(Context, NewDetails);
	
	Context.Attachments.Insert(0, Context.LongDesc);
	Context.LongDesc = NewDetails;
	
EndProcedure

// For the ParseExpression and ParseConnectorValueIn procedures.
Procedure ParseFunction(Context)
	
	String = Context.String;
	
	NewDetails = New Structure("Source, Node", String, String.Refinement);
	
	If String.Refinement = "ValueAllowed"
	 Or String.Refinement = "ObjectReadingAllowed"
	 Or String.Refinement = "ObjectUpdateAllowed"
	 Or String.Refinement = "ListReadingAllowed"
	 Or String.Refinement = "ListUpdateAllowed"
	 Or String.Refinement = "IsAuthorizedUser" Then
		
		ParseCheckingFunctionParameters(Context, NewDetails);
		
	ElsIf String.Refinement = "ForAllRows"
	      Or String.Refinement = "ForAtLeastOneRow" Then
		
		ExpressionDetails = Undefined;
		ParseExpression(String.Rows, ExpressionDetails, Context);
		NewDetails.Insert("Argument", ExpressionDetails);
	
	ElsIf String.Refinement = "Value" Then
		ParseValueFunctionOrTypeFunctionParameters(String, NewDetails, True, Context);
		
	ElsIf String.Refinement = "Type" Then
		ParseValueFunctionOrTypeFunctionParameters(String, NewDetails, False, Context);
		
	ElsIf String.Refinement = "ValueType" Then
		ParseValueTypeFunctionParameters(Context, NewDetails);
		
	ElsIf String.Refinement = "IsNull" Then
		NewDetails = FieldNodeDetailsFromIsNullFunction(Context.String, Context);
		
	ElsIf String.Refinement = "Cast" Then
		NewDetails =  FieldNodeDetailsFromExpressFunction(Context.String, Context);
		
	ElsIf String.Refinement = "AccessRight" Then
		ParseTheParametersOfTheAccessRightFunction(String, NewDetails, Context);
		
	ElsIf String.Refinement = "IsInRole" Then
		ParseFunctionParametersTheRoleIsAvailable(String, NewDetails, Context);
		
	ElsIf Not String.IsReserve Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'There is no processing algorithm defined for the ""%1"" function.';"), String.Refinement);
		Raise ErrorText;
	EndIf;
	
	AddArgumentFunctionChoiceOperator(Context, NewDetails);
	
EndProcedure

// For the ParseFunction procedure.
Procedure ParseCheckingFunctionParameters(Context, NewDetails)
	
	String = Context.String;
	
	NewDetails.Insert("Field",                        Undefined);
	NewDetails.Insert("Types",                        New Array);
	NewDetails.Insert("CheckTypesExceptListed", False);
	NewDetails.Insert("ComparisonClarifications",          New Map);
	
	ParametersContent = CommaSeparatedParameters(String, Context);
	
	If ParametersContent.Count() = 0 Then
		Return; // The parameter missing error is already set in the FunctionsWithExpressionsInParentheses function.
	EndIf;
	
	ParseFirstCheckingFunctionParameter(Context, ParametersContent[0], NewDetails);
	
	For IndexOf = 1 To ParametersContent.Count() - 1 Do
		ParseAdditionalCheckingFunctionParameter(Context,
			ParametersContent[IndexOf], NewDetails);
	EndDo;
	
EndProcedure

// For the ParseCheckingFunctionParameters procedure.
//
// Parameters:
//  FirstParameter - Structure:
//   * Rows - Array of ValueTableRow: см. ТаблицаНаборовСимволов
//
Procedure ParseFirstCheckingFunctionParameter(Context, FirstParameter, NewDetails)
	
	If FirstParameter.Rows[0].Kind = "Name" Then
		NewDetails.Field = FieldNodeOrConstantNodeDetails(FirstParameter.Rows[0]);
		
	ElsIf FirstParameter.Rows[0].Kind = "Keyword"
	        And FirstParameter.Rows[0].Refinement = "Cast" Then
		
		NewDetails.Field = FieldNodeDetailsFromExpressFunction(FirstParameter.Rows[0], Context);
		
	ElsIf FirstParameter.Rows[0].Kind = "Keyword"
	        And FirstParameter.Rows[0].Refinement = "IsNull" Then
		
		NewDetails.Field = FieldNodeDetailsFromIsNullFunction(FirstParameter.Rows[0], Context);
	Else
		SetErrorInRow(FirstParameter.Rows[0],
			InsertKeywordsIntoString(Context,
				NStr("en = 'The first parameter must be a field name, the ""%1"" function, or the ""%2"" function.';"),
				"Cast,IsNull"));
		Return;
	EndIf;
	
	If FirstParameter.Rows.Count() < 2 Then
		Return;
	EndIf;
	
	If FirstParameter.Rows[0].Kind = "Keyword"
	   And FirstParameter.Rows[0].Refinement = "Cast"
	   And NewDetails.Field.Attachment = Undefined Then
		
		SetErrorInRow(TableRow(FirstParameter.Rows[0].EndString, Context),
			InsertKeywordsIntoString(Context,
				NStr("en = 'If the ""%1"" or ""%2"" keyword is used in the ""%4"" function parameter,
				           |a dot operator and a field name are required after the ""%3"" nested function.';"),
				"Only,Not",
				FirstParameter.Rows[0].Chars,
				Context.String.Chars),
			True);
	EndIf;
	
	If FirstParameter.Rows[1].Kind <> "Keyword"
	 Or (  FirstParameter.Rows[1].Refinement <> "Only"
	      And FirstParameter.Rows[1].Refinement <> "Not" ) Then
		
		SetErrorInRow(FirstParameter.Rows[1],
			InsertKeywordsIntoString(Context,
				NStr("en = 'The ""%1"" or ""%2"" keyword is required after a field description.';"),
				"Only,Not"));
		Return;
	EndIf;
	
	If FirstParameter.Rows[1].Refinement = "Not" Then
		NewDetails.CheckTypesExceptListed = True;
	EndIf;
	
	If FirstParameter.Rows.Count() < 3 Then
		SetErrorInRow(FirstParameter.Rows[1],  StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'A type (a table name) is missing after the ""%1"" keyword.';"), FirstParameter.Rows[1].Chars));
		Return;
	EndIf;
	
	If FirstParameter.Rows[2].Kind <> "Name"
	   And FirstParameter.Rows[2].Chars <> "(" Then
	
		SetErrorInRow(FirstParameter.Rows[2],  StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Either a type (a table name) or a type list in parentheses is required after the ""%1"" keyword.';"),
			FirstParameter.Rows[1].Chars));
		Return;
	EndIf;
	
	If FirstParameter.Rows.Count() > 3 Then
		SetErrorInRow(FirstParameter.Rows[3], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'A comma is missing before the ""%1"" function parameter.';"), Context.String.Chars));
	EndIf;
	
	If FirstParameter.Rows[2].Kind = "Name" Then
		NewDetails.Types.Add(FirstParameter.Rows[2]);
		AddRequiredTableAsReferenceType(Context, FirstParameter.Rows[2].Chars, FirstParameter.Rows[2]);
		Return;
	EndIf;
	
	ParametersContent = CommaSeparatedParameters(FirstParameter.Rows[2], Context);
	
	If ParametersContent.Count() = 0 Then
		Return; // The parameter missing error is already set in the FunctionsWithExpressionsInParentheses function.
	EndIf;
	
	For Each Parameter In ParametersContent Do
		
		If Parameter.Rows[0].Kind = "Name"
		   And Parameter.Rows.Count() < 2 Then
			
			NewDetails.Types.Add(Parameter.Rows[0]);
		Else
			SetErrorInRow(Parameter.Rows[?(Parameter.Rows.Count() < 2, 0, 1)],
				NStr("en = 'Only table names separated by commas are allowed in a list of types.';"));
		EndIf;
	EndDo;
	
EndProcedure

// For the ParseCheckingFunctionParameters procedure.
// 
// Parameters:
//  Parameter - Structure:
//    * Rows - Array of ValueTableRow: см. ТаблицаНаборовСимволов
//
Procedure ParseAdditionalCheckingFunctionParameter(Context, Parameter, NewDetails)
	
	If Parameter.Rows[0].Kind = "Name"
	 Or Parameter.Rows[0].Kind = "Keyword"
	   And (    Parameter.Rows[0].Type = "ComparisonValue"
	      Or Parameter.Rows[0].Type = "TypeName" ) Then
		
		If Parameter.Rows[0].Kind = "Name" Then
			ComparisonValue = Parameter.Rows[0];
			AddRequiredTableAsReferenceType(Context, Parameter.Rows[0].Chars, Parameter.Rows[0]);
		Else
			ComparisonValue = Parameter.Rows[0].Refinement;
		EndIf;
	Else
		SetErrorInRow(Parameter.Rows[0],
			InsertKeywordsIntoString(Context,
				NStr("en = 'An additional parameter must be a type (a table name),
				           |""%1"", ""%2"", ""%3"", ""%4"", ""%5"", ""%6"", or ""%7"".';"),
				"EmptyRef,Undefined,Null,Number,String,Date,Boolean"));
		Return;
	EndIf;
	
	If Parameter.Rows.Count() < 2 Then
		If Parameter.Rows[0].Kind = "Name" Then 
			Template = NStr("en = 'The ""%1"" keyword must follow the ""%2"" type (table name).';");
		Else
			Template = NStr("en = 'The ""%1"" keyword must follow the ""%2"" keyword.';");
		EndIf;
		SetErrorInRow(Parameter.Rows[0], InsertKeywordsIntoString(Context,
				Template, "As", Parameter.Rows[0].Chars),
			True);
		Return;
	EndIf;
	
	If Parameter.Rows[1].Kind <> "Keyword"
	 Or Parameter.Rows[1].Refinement <> "As" Then
		
		If Parameter.Rows[0].Kind = "Name" Then
			Template = NStr("en = 'The ""%1"" keyword must follow the ""%2"" type (table name).';");
		Else
			Template = NStr("en = 'The ""%1"" keyword must follow the ""%2"" keyword.';");
		EndIf;
		SetErrorInRow(Parameter.Rows[1], InsertKeywordsIntoString(Context,
			Template, "As", Parameter.Rows[0].Chars));
		Return;
	EndIf;
	
	If Parameter.Rows.Count() < 3 Then
		SetErrorInRow(Parameter.Rows[1], InsertKeywordsIntoString(Context,
				NStr("en = 'A clarification value ""%1"", ""%2"", or ""%3"" is missing after the ""%4"" keyword.';"),
				"False,True,Empty",
				Parameter.Rows[1].Chars),
			True);
		Return;
	EndIf;
	
	If Parameter.Rows[2].Kind <> "Keyword"
	 Or Parameter.Rows[2].Type <> "ClarificationValue" Then
		
		SetErrorInRow(Parameter.Rows[2], InsertKeywordsIntoString(Context,
			NStr("en = 'A clarification value ""%1"", ""%2"", or ""%3"" is required after the ""%4"" keyword.';"),
			"False,True,Empty",
			Parameter.Rows[1].Chars));
	Else
		NewDetails.ComparisonClarifications.Insert(ComparisonValue, Parameter.Rows[2].Refinement);
	EndIf;
	
	If Parameter.Rows.Count() > 3 Then
		SetErrorInRow(Parameter.Rows[3],
			NStr("en = 'A comma or an extra parameter is missing before the parameter.';"));
	EndIf;
	
EndProcedure

// For the ParseFunction procedure.
Procedure ParseValueFunctionOrTypeFunctionParameters(String, NewDetails, IsValueFunction, Context)
	
	NewDetails.Insert("Name", Undefined);
	
	ParametersContent = CommaSeparatedParameters(String, Context);
	
	If ParametersContent.Count() = 0 Then
		Return; // The parameter missing error is already set in the FunctionsWithExpressionsInParentheses function.
	EndIf;
	
	Parameter = ParametersContent[0];
	If Parameter.Rows[0].Kind = "Name" Then
		NewDetails.Name = Parameter.Rows[0].Chars;
		
		If IsValueFunction Then
			AddRequiredPredefinedItem(Context, NewDetails.Name, Parameter.Rows[0]);
		Else
			AddRequiredTableAsReferenceType(Context, NewDetails.Name, Parameter.Rows[0]);
		EndIf;
		
	ElsIf IsValueFunction Then
		SetErrorInRow(Parameter.Rows[0], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'The ""%1"" function requires a predefined value name.';"), String.Chars));
	
	ElsIf Parameter.Rows[0].Kind = "Keyword"
	        And Parameter.Rows[0].Type = "TypeName" Then
		
		NewDetails.Name = Parameter.Rows[0].Refinement;
	Else
		SetErrorInRow(Parameter.Rows[0], InsertKeywordsIntoString(Context,
			NStr("en = 'The ""%5"" function requires a table name, ""%1"", ""%2"", ""%3"", or ""%4"".';"),
			"Number,String,Date,Boolean",
			String.Chars));
	EndIf;
	
	If Parameter.Rows.Count() > 1 Then
		SetErrorInRow(Parameter.Rows[1], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'The ""%1"" function requires a single parameter.';"), String.Chars));
	EndIf;
	
	If ParametersContent.Count() > 1 Then
		SetErrorInRow(ParametersContent[1].Rows[0], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'The ""%1"" function requires a single parameter.';"), String.Chars));
	EndIf;
	
EndProcedure

// For the ParseFunction procedure.
Procedure ParseFunctionParametersTheRoleIsAvailable(String, NewDetails, Context)
	
	NewDetails.Insert("NameOfRole", Undefined);
	
	ParametersContent = CommaSeparatedParameters(String, Context);
	
	If ParametersContent.Count() = 0 Then
		Return; // The parameter missing error is already set in the FunctionsWithExpressionsInParentheses function.
	EndIf;
	
	Parameter = ParametersContent[0];
	If Parameter.Rows[0].Kind = "Name" Then
		NewDetails.NameOfRole = Parameter.Rows[0].Chars;
		
		CheckTheRoleName(NewDetails.NameOfRole, Parameter.Rows[0]);
	Else
		SetErrorInRow(Parameter.Rows[0], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'The ""%1"" function requires only a role name.';"), String.Chars));
	EndIf;
	
	If Parameter.Rows.Count() > 1 Then
		SetErrorInRow(Parameter.Rows[1], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'The ""%1"" function requires a single parameter.';"), String.Chars));
	EndIf;
	
	If ParametersContent.Count() > 1 Then
		SetErrorInRow(ParametersContent[1].Rows[0], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'The ""%1"" function requires a single parameter.';"), String.Chars));
	EndIf;
	
EndProcedure

// For the ParseFunction procedure.
Procedure ParseTheParametersOfTheAccessRightFunction(String, NewDetails, Context)
	
	NewDetails.Insert("NameOfRight", Undefined);
	NewDetails.Insert("FullMetadataObjectName", Undefined);
	
	ParametersContent = CommaSeparatedParameters(String, Context);
	
	If ParametersContent.Count() = 0 Then
		Return; // The parameter missing error is already set in the FunctionsWithExpressionsInParentheses function.
	EndIf;
	
	FirstParameter = ParametersContent[0];
	If FirstParameter.Rows[0].Kind = "Name" Then
		NewDetails.NameOfRight = FirstParameter.Rows[0].Chars;
	Else
		SetErrorInRow(FirstParameter.Rows[0], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'The first parameter of the ""%1"" function requires only an access right name.';"), String.Chars));
	EndIf;
	
	If FirstParameter.Rows.Count() > 1 Then
		SetErrorInRow(FirstParameter.Rows[1], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'A comma is missing before the ""%1"" parameter of the ""%2"" function.';"),
			FirstParameter.Rows[1].Chars,
			String.Chars));
	EndIf;
	
	If ParametersContent.Count() < 2 Then
		SetErrorInRow(FirstParameter.EndString, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'The ""%1"" function requires two parameters.';"), String.Chars));
		Return;
	EndIf;
	
	SecondParameter = ParametersContent[1];
	If SecondParameter.Rows[0].Kind = "Name" Then
		NewDetails.FullMetadataObjectName = SecondParameter.Rows[0].Chars;
		
		CheckTheNameOfTheMetadataObjectRight(NewDetails.NameOfRight, FirstParameter.Rows[0],
			NewDetails.FullMetadataObjectName, SecondParameter.Rows[0]);
	Else
		SetErrorInRow(SecondParameter.Rows[0], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'The second parameter of the ""%1"" function requires only a full metadata object name.';"),
			String.Chars));
	EndIf;
	
	If SecondParameter.Rows.Count() > 1 Then
		SetErrorInRow(SecondParameter.Rows[1], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'The ""%1"" function requires only two parameters.';"), String.Chars));
	EndIf;
	
	If ParametersContent.Count() > 2 Then
		SetErrorInRow(ParametersContent[2].Rows[0], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'The ""%1"" function requires only two parameters.';"), String.Chars));
	EndIf;
	
EndProcedure

// For the ParseFunction procedure.
Procedure ParseValueTypeFunctionParameters(Context, NewDetails)
	
	String = Context.String;
	NewDetails.Insert("Argument", Undefined);
	
	ParametersContent = CommaSeparatedParameters(String, Context);
	
	If ParametersContent.Count() = 0 Then
		Return; // The parameter missing error is already set in the FunctionsWithExpressionsInParentheses function.
	EndIf;
	
	Parameter = ParametersContent[0];
	
	If Parameter.Rows[0].Kind = "Name" Then
		NewDetails.Argument = FieldNodeOrConstantNodeDetails(Parameter.Rows[0]);
		
	ElsIf Parameter.Rows[0].Kind = "Keyword"
	        And Parameter.Rows[0].Refinement = "Cast" Then
		
		NewDetails.Argument = FieldNodeDetailsFromExpressFunction(Parameter.Rows[0], Context);
		
	ElsIf Parameter.Rows[0].Kind = "Keyword"
	        And Parameter.Rows[0].Refinement = "IsNull" Then
		
		NewDetails.Argument = FieldNodeDetailsFromIsNullFunction(Parameter.Rows[0], Context);
	Else
		SetErrorInRow(Parameter.Rows[0],
			InsertKeywordsIntoString(Context,
				NStr("en = 'The parameter must be a field name, the ""%1"" function, or the ""%2"" function.';"),
				"Cast,IsNull"));
		Return;
	EndIf;
	
	If Parameter.Rows[0].Kind = "Keyword"
	   And Parameter.Rows[0].Refinement = "Cast"
	   And NewDetails.Argument.Attachment = Undefined Then
		
		SetErrorInRow(TableRow(Parameter.Rows[0].EndString, Context),
			InsertKeywordsIntoString(Context,
				NStr("en = 'A dot operator and a field name are required after the ""%1"" nested function.';"),
				Parameter.Rows[0].Chars),
			True);
	EndIf;
	
	If Parameter.Rows.Count() < 2 Then
		Return;
	EndIf;
	
	If Parameter.Rows.Count() > 1 Then
		SetErrorInRow(Parameter.Rows[1], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'The ""%1"" function requires a single parameter.';"), String.Chars));
	EndIf;
	
	If ParametersContent.Count() > 1 Then
		SetErrorInRow(ParametersContent[1].Rows[0], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'The ""%1"" function requires a single parameter.';"), String.Chars));
	EndIf;
	
EndProcedure

// For the ParseFunction, ParseFirstCheckingFunctionParameter, and ParseValueTypeFunctionParameters procedures.
Function FieldNodeDetailsFromExpressFunction(String, Context)
	
	NewDetails = FieldNodeDetails(String);
	
	If String.Rows.Count() > 0 Then
		LastRow = TableRow(String.Rows[String.Rows.Count() - 1], Context);
		If LastRow.Type = "AdditionToExpress" Then
			String.Rows.Delete(String.Rows.Count() - 1);
			NewDetails.Name         = Mid(LastRow.Chars, 2);
			NewDetails.NameSource = LastRow;
			NewDetails.Attachment    = FieldNodeDetailsFromExpressFunction(String, Context);
			Return NewDetails;
		EndIf;
	EndIf;
	
	ParametersContent = CommaSeparatedParameters(String, Context);
	
	If ParametersContent.Count() = 0 Then
		// 
		Return NewDetails;
	EndIf;
	
	FirstParameter = ParametersContent[0];
	
	If FirstParameter.Rows[0].Kind = "Name" Then
		NewDetails.Name         = FirstParameter.Rows[0].Chars;
		NewDetails.NameSource = FirstParameter.Rows[0];
		
	ElsIf FirstParameter.Rows[0].Kind = "Keyword"
	        And FirstParameter.Rows[0].Refinement = "Cast" Then
		
		NewDetails.Attachment = FieldNodeDetailsFromExpressFunction(FirstParameter.Rows[0], Context);
		If NewDetails.Attachment.Attachment = Undefined Then
			SetErrorInRow(TableRow(FirstParameter.Rows[0].EndString, Context),
				StringFunctionsClientServer.SubstituteParametersToString(
					NStr("en = 'A dot operator and a field name are required after the ""%1"" nested function.';"),
					FirstParameter.Rows[0].Chars),
				True);
		Else
			NewDetails = NewDetails.Attachment;
		EndIf;
		
	ElsIf FirstParameter.Rows[0].Kind = "Keyword"
	        And FirstParameter.Rows[0].Refinement = "IsNull" Then
		
		NewDetails = FieldNodeDetailsFromIsNullFunction(FirstParameter.Rows[0], Context);
	Else
		SetErrorInRow(FirstParameter.Rows[0],
			InsertKeywordsIntoString(Context,
				NStr("en = 'The first parameter must be a field name, the ""%1"" function, or the ""%2"" function.';"),
				"Cast,IsNull"));
		Return NewDetails;
	EndIf;
	
	If FirstParameter.Rows.Count() < 2 Then
		SetErrorInRow(FirstParameter.Rows[0],
			InsertKeywordsIntoString(Context,
				NStr("en = 'The ""%1"" keyword is required after the field description.';"), "As"), True);
		Return NewDetails;
	EndIf;
	
	If FirstParameter.Rows[1].Kind <> "Keyword"
	 Or FirstParameter.Rows[1].Refinement <> "As" Then
		
		SetErrorInRow(FirstParameter.Rows[1],
			InsertKeywordsIntoString(Context,
				NStr("en = 'The ""%1"" keyword is required after the field description.';"), "As"));
		Return NewDetails;
	EndIf;
	
	If FirstParameter.Rows.Count() < 3 Then
		SetErrorInRow(FirstParameter.Rows[1],  StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'A type (a table name) is missing after the ""%1"" keyword.';"), FirstParameter.Rows[1].Chars));
		Return NewDetails;
	EndIf;
	
	If FirstParameter.Rows[2].Kind <> "Name" Then
		SetErrorInRow(FirstParameter.Rows[2],  StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'A type (a table name) is required after the ""%1"" keyword.';"),
			FirstParameter.Rows[1].Chars));
	Else
		NewDetails.Cast = FirstParameter.Rows[2].Chars;
		NewDetails.CastSource = FirstParameter.Rows[2];
	EndIf;
	
	If FirstParameter.Rows.Count() > 3 Then
		SetErrorInRow(FirstParameter.Rows[3], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'The ""%1"" function requires a single parameter.';"), String.Chars));
	EndIf;
	
	If ParametersContent.Count() > 1 Then
		SetErrorInRow(FirstParameter.EndString, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'The ""%1"" function requires a single parameter.';"), String.Chars));
	EndIf;
	
	Return NewDetails;
	
EndFunction

// For the ParseExpression, ParseFirstCheckingFunctionParameter,
// ParseValueTypeFunctionParameters and
// the FieldNodeDetailsFromExpressFunction function.
//
Function FieldNodeDetailsFromIsNullFunction(String, Context)
	
	NewDetails = FieldNodeDetails(String);
	NewDetails.IsNullSource = String;
	
	ParametersContent = CommaSeparatedParameters(String, Context);
	
	If ParametersContent.Count() = 0 Then
		// 
		Return NewDetails;
	EndIf;
	
	FirstParameter = ParametersContent[0];
	
	If FirstParameter.Rows[0].Kind = "Name" Then
		NewDetails.Name         = FirstParameter.Rows[0].Chars;
		NewDetails.NameSource = FirstParameter.Rows[0];
	Else
		SetErrorInRow(FirstParameter.Rows[0], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'The first parameter of the ""%1"" function must be a field name.';"), String.Chars));
	EndIf;
	
	If FirstParameter.Rows.Count() > 1 Then
		SetErrorInRow(FirstParameter.Rows[1], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'A comma is missing before the ""%1"" function parameter.';"), String.Chars));
		Return NewDetails;
	EndIf;
	
	If ParametersContent.Count() < 2 Then
		SetErrorInRow(FirstParameter.EndString, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'The ""%1"" function requires two parameters.';"), String.Chars));
		Return NewDetails;
	EndIf;
	
	SecondParameter = ParametersContent[1];
	
	If SecondParameter.Rows[0].Kind = "Number"
	 Or SecondParameter.Rows[0].Kind = "ArbitraryLine"
	 Or SecondParameter.Rows[0].Kind = "Keyword"
	   And (    SecondParameter.Rows[0].Refinement = "True"
	      Or SecondParameter.Rows[0].Refinement = "False"
	      Or SecondParameter.Rows[0].Refinement = "Undefined"
	      Or SecondParameter.Rows[0].Refinement = "Value" ) Then
		
		If SecondParameter.Rows[0].Refinement = "Value" Then
			NewDetails.IsNull = New Structure("Source, Node",
				SecondParameter.Rows[0], SecondParameter.Rows[0].Refinement);
			
			ParseValueFunctionOrTypeFunctionParameters(SecondParameter.Rows[0], NewDetails.IsNull, True, Context);
		Else
			NewDetails.IsNull = FieldNodeOrConstantNodeDetails(SecondParameter.Rows[0]);
		EndIf;
	Else
		SetErrorInRow(SecondParameter.Rows[0], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'The second parameter of the ""%1"" function must be either a predefined value or a constant.';"),
			String.Chars));
	EndIf;
	
	If SecondParameter.Rows.Count() > 1 Then
		SetErrorInRow(SecondParameter.Rows[1], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'The ""%1"" function requires only two parameters.';"), String.Chars));
	EndIf;
	
	If ParametersContent.Count() > 2 Then
		SetErrorInRow(ParametersContent[2].Rows[0], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'The ""%1"" function requires only two parameters.';"), String.Chars));
	EndIf;
	
	Return NewDetails;
	
EndFunction

// For the ParseConnectorIn, ParseCheckingFunctionParameters,
// ParseValueFunctionOrTypeFunctionParameters, and ParseValueTypeFunctionParameters procedures and
// the FieldNodeDetailsFromExpressFunction and FieldNodeDetailsFromIsNullFunction functions.
//
// Parameters:
//  RowDescription - See TableRow.RowDescription
//
// Returns:
//   Array of Structure:
//   * Rows - Array of ValueTableRow: см. ТаблицаНаборовСимволов
//
Function CommaSeparatedParameters(RowDescription, Context)
	
	ParametersContent = New Array;
	String = TableRow(RowDescription, Context);
	
	If String.Rows.Count() = 0 Then
		Return ParametersContent;
	EndIf;
	
	ParameterDetails = New Structure("Rows, EndString", New Array);
	PreviousSubstringIsArgumentPart = False;
	
	For Each SubstringDetails In String.Rows Do
		Substring = TableRow(SubstringDetails, Context);
		If Substring.Chars = "," Then
			If Not PreviousSubstringIsArgumentPart Then
				If String.Rows[0] = SubstringDetails Then
					SetErrorInRow(Substring, StringFunctionsClientServer.SubstituteParametersToString(
						NStr("en = 'A parameter is missing before a comma.';"), Substring.Chars));
					ParameterDetails.Rows.Add(AdditionalString1(Substring, ""));
				Else
					SetErrorInRow(Substring, StringFunctionsClientServer.SubstituteParametersToString(
						NStr("en = 'A parameter is missing, or an extra comma is added.';"), Substring.Chars));
				EndIf;
			EndIf;
			If ParameterDetails.Rows.Count() > 0 Then
				ParametersContent.Add(ParameterDetails);
				ParameterDetails.EndString = Substring;
			EndIf;
			ParameterDetails = New Structure("Rows, EndString", New Array);
			PreviousSubstringIsArgumentPart = False;
			Continue;
		EndIf;
		
		PreviousSubstringIsArgumentPart = True;
		
		ParameterDetails.Rows.Add(Substring);
	EndDo;
	
	If ParameterDetails.Rows.Count() > 0 Then
		ParametersContent.Add(ParameterDetails);
		ParameterDetails.EndString = TableRow(String.EndString, Context);
	Else
		SetErrorInRow(Substring, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'An extra comma is added, or a parameter is missing after the comma.';"), Substring.Chars), True);
	EndIf;
	
	Return ParametersContent;
	
EndFunction

// For the ParseExpression procedure.
// 
// Parameters:
//    Context - Structure:
//    * String - Structure:
//       ** Rows - Array of ValueTableRow: см. ТаблицаНаборовСимволов
//
Procedure ParseChoice(Context)
	
	String = Context.String;
	
	NodeProperties = "Source, Node, Case, When, Else";
	NewDetails = New Structure(NodeProperties, String, "Case");
	NewDetails.When = New Array;
	
	SkipWhenAnalysis = False;
	
	Case = TableRow(String.Rows[0], Context);
	If Case.Rows.Count() > 0 Then
		ChoiceFirstRow = TableRow(Case.Rows[0], Context);
		If ChoiceFirstRow.Kind = "Name" Then
			NewDetails.Case = FieldNodeOrConstantNodeDetails(ChoiceFirstRow);
		Else
			SkipWhenAnalysis = True;
			SetErrorInRow(ChoiceFirstRow, StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'If the argument for the ""%1"" keyword is specified, it must be a field name.';"),
				String.Chars));
		EndIf;
	EndIf;
	
	IndexOf = 1;
	While True Do
		NextRow = TableRow(String.Rows[IndexOf], Context);
		If NextRow.Refinement <> "When" Then
			Break;
		EndIf;
		WhenThenDetails = New Structure("Condition, Value");
		NewWhenDetails = NewDetails.When; // Array
		NewWhenDetails.Add(WhenThenDetails);
		
		When = NextRow;
		
		If Not SkipWhenAnalysis Then
			FirstSubstringWhen = ?(When.Rows.Count() = 0, Undefined,
				TableRow(When.Rows[0], Context));
			
			If NewDetails.Case = Undefined Then
				ParseExpression(When.Rows, WhenThenDetails.Condition, Context);
				
			ElsIf When.Rows.Count() = 0 Then
				If ValueIsFilled(When.Chars) Then
					SetErrorInRow(When, StringFunctionsClientServer.SubstituteParametersToString(
						NStr("en = 'As a field follows the ""%1"" keyword, 
						           |either a predefined value or a constant is required after the ""%2"" keyword.';"),
						String.Chars,
						When.Chars));
				EndIf;
				
			ElsIf FirstSubstringWhen.Kind = "Number"
			      Or FirstSubstringWhen.Kind = "ArbitraryLine"
			      Or FirstSubstringWhen.Kind = "Keyword"
			        And (    FirstSubstringWhen.Refinement = "True"
			           Or FirstSubstringWhen.Refinement = "False"
			           Or FirstSubstringWhen.Refinement = "Undefined"
			           Or FirstSubstringWhen.Refinement = "Value" ) Then
				
				If FirstSubstringWhen.Refinement = "Value" Then
					WhenThenDetails.Condition = New Structure("Source, Node",
						FirstSubstringWhen, FirstSubstringWhen.Refinement);
					
					ParseValueFunctionOrTypeFunctionParameters(FirstSubstringWhen,
						WhenThenDetails.Condition, True, Context);
				Else
					WhenThenDetails.Condition = FieldNodeOrConstantNodeDetails(FirstSubstringWhen);
				EndIf;
			ElsIf ValueIsFilled(When.Chars) Then
				SetErrorInRow(FirstSubstringWhen, StringFunctionsClientServer.SubstituteParametersToString(
					NStr("en = 'As a field follows the ""%1"" keyword, 
					           |either a predefined value or a constant is required after the ""%2"" keyword.';"),
					String.Chars,
					When.Chars));
			EndIf;
		EndIf;
		
		ThenContent = TableRow(String.Rows[IndexOf + 1], Context);
		If ThenContent.Rows.Count() > 0 Then
			ParseExpression(ThenContent.Rows, WhenThenDetails.Value, Context);
			
		ElsIf ValueIsFilled(ThenContent.Chars) Then
			SetErrorInRow(FirstSubstringWhen, StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'A logical expression is required after the ""%1"" keyword.';"), ThenContent.Chars));
		EndIf;
		
		IndexOf = IndexOf + 2;
	EndDo;
	
	ParseExpression(NextRow.Rows, NewDetails.Else, Context);
	
	AddArgumentFunctionChoiceOperator(Context, NewDetails);
	
EndProcedure

// For the ParseExpression procedure.
Procedure ParseErrorKeyword(Context)
	
	String = Context.String;
	Context.LongDesc = Undefined;
	
	If String.Type = "NotDefined" Then
		// 
		Return;
	EndIf;
	
	If String.Type = "ComparisonValue" Then
		If String.Refinement = "Disabled" Then
			// "Disabled".
			SetErrorInRow(String, StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'The ""%1"" value is allowed only as a value to be clarified
				           |in the parameters of the ""%2"" function.';"),
				String.Chars,
				KeywordRegardingLanguage("ValueAllowed", Context)));
		Else
			// "BlankRef" or "Null".
			SetErrorInRow(String, StringFunctionsClientServer.SubstituteParametersToString(
				NStr("en = 'The ""%1"" value is allowed only as a value to be clarified
				           |in the parameters of functions that check permissions.';"),
				String.Chars));
		EndIf;
		
	ElsIf String.Type = "TypeName" Then
		// "Number", "String", "Date", "Boolean".
		SetErrorInRow(String, InsertKeywordsIntoString(Context,
			NStr("en = 'A name of the ""%1"" type is allowed only as a parameter of the ""%2"" function
			           |or as a value to be clarified in the parameters of functions that check permissions.';"),
			String.Chars,
			"Type"));
	Else
		SetErrorInRow(String, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'There is no processing algorithm defined for the ""%1"" keyword.';"), String.Chars));
	EndIf;
	
EndProcedure

// For the ParseExpression, ParseOperator, ParseFunction, and ParseChoice procedures.
Procedure AddArgumentFunctionChoiceOperator(Context, DetailsToAdd)
	
	// 
	// 
	
	LongDesc = Context.LongDesc; // See NodeDetails
	
	If LongDesc = Undefined Then
		Context.LongDesc = DetailsToAdd;
		
	ElsIf LongDesc.Node = "And"
	      Or LongDesc.Node = "Or" Then
		
		If LongDesc.Arguments.Count() = 1 Then
			LongDesc.Arguments.Add(DetailsToAdd);
		Else
			ProcessMissingLogicalOperation(Context, LongDesc.Arguments[1], DetailsToAdd);
		EndIf;
		
	ElsIf LongDesc.Node = "Not" Then
		
		If Not ValueIsFilled(LongDesc.Argument) Then
			LongDesc.Argument = DetailsToAdd;
		Else
			ProcessMissingLogicalOperation(Context, LongDesc.Argument, DetailsToAdd);
		EndIf;
		
	ElsIf LongDesc.Source.Kind = "Operation" Then
		
		If Not ValueIsFilled(LongDesc.SecondArgument) Then
			LongDesc.SecondArgument = DetailsToAdd;
			// 
			// 
		Else
			ProcessMissingLogicalOperation(Context, LongDesc.SecondArgument, DetailsToAdd);
		EndIf;
		
	ElsIf StrFind(",Field,Value,Constant,In,IsNull,Case,", "," + LongDesc.Node + ",") > 0
	      Or LongDesc.Source.Type = "Function" Then
		// 
		// 
		// 
		ProcessMissingLogicalOperation(Context, Undefined, DetailsToAdd);
	Else
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'There is no processing algorithm defined for node ""%1"".';"), LongDesc.Node);
		Raise ErrorText;
	EndIf;
	
EndProcedure

// For the AddArgumentFunctionChoiceOperator procedure
Procedure ProcessMissingLogicalOperation(Context, DetailsLastArgument, DetailsToAdd)
	
	SetErrorInRow(Context.String, NStr("en = 'A logical operation is missing.';"));
	
	// Recovery.
	AdditionalString1 = AdditionalString1(Context.String, "And", Context);
	
	NewDetails = New Structure("Source, Node, Arguments", AdditionalString1, "And", New Array);
	NewDetails.Arguments.Add();
	
	CurrentRow = Context.String;
	Context.String = AdditionalString1;
	
	InsertConnectorConsideringPriority(Context,
		DetailsLastArgument, NewDetails, NewDetails.Arguments[0]);
	
	Context.String = CurrentRow;
	
	NewDetails.Arguments.Add(DetailsToAdd);
	
EndProcedure

// For the ParseCondition procedure.
//
// Returns:
//  Array of ValueTableRow
//
Function ExpressionsInParenthesesInAttachments(Rows, Context)
	
	Result = New Array;
	
	CurrentAttachment = New Structure("Rows", Result);
	Attachments = New Array;
	Attachments.Add(CurrentAttachment);
	
	For Each String In Rows Do
		If String.Chars = "(" Then
			AddAttachment(String, Attachments, CurrentAttachment, Context);
			
		ElsIf String.Chars = ")" Then
			If Attachments.Count() = 1 Then
				SetErrorInRow(String,
					NStr("en = 'A closing parenthesis is found before an opening parenthesis.';"));
			Else
				DeleteLastAttachment(Attachments, CurrentAttachment, Context, String);
			EndIf;
		Else
			RowAdd(CurrentAttachment, String, Context);
		EndIf;
	EndDo;
	
	While Attachments.Count() > 1 Do
		LastAttachmentIndex = Attachments.Count() - 1;
		Attachment = Attachments[LastAttachmentIndex];
		Attachment.EndString = String;
		Attachments.Delete(LastAttachmentIndex);
		SetErrorInRow(Attachment,
			NStr("en = 'A closing parenthesis is missing after an opening parenthesis.';"), True);
	EndDo;
	
	Return Result;
	
EndFunction

// For the ParseCondition procedure.
//
// Parameters:
//    Rows - Array of ValueTableRow: см. ТаблицаНаборовСимволов
//
Function ExpressionsSelectionWhenThenInAttachments(Rows, Context)
	
	Result = New Array;
	
	CurrentAttachment = New Structure("Rows, Refinement", Result, "");
	Attachments = New Array;
	Attachments.Add(CurrentAttachment);
	
	For Each RowDescription In Rows Do
		String = TableRow(RowDescription, Context);
		
		If String.Kind <> "Keyword"
		 Or String.Type <> "SelectionWord" Then
			
			If CurrentAttachment.Refinement = "Case" Then
				RowAdd(TableRow(CurrentAttachment.Rows[0], Context), String, Context);
			Else
				RowAdd(CurrentAttachment, String, Context);
				If String.Chars = "(" Then
					String.Rows = ExpressionsSelectionWhenThenInAttachments(String.Rows, Context);
				EndIf;
			EndIf;
		ElsIf String.Refinement = "Case" Then
			If Attachments.Count() = 1 Then
				// Standard processing after the condition.
			Else
				If CurrentAttachment.Refinement = "Case" Then
					SetErrorInRow(CurrentAttachment, InsertKeywordsIntoString(Context,
						NStr("en = 'The ""%2"" keyword is missing after the ""%1"" keyword.';"), "Case,When"), True);
					RestoreChoiceStructure(CurrentAttachment, Attachments, CurrentAttachment, "When", Context);
				EndIf;
			EndIf;
			AddAttachment(String, Attachments, CurrentAttachment, Context);
			CurrentAttachment.Rows.Add(AdditionalString1(CurrentAttachment, "Case", Context));
			
		ElsIf String.Refinement = "When" Then
			
			If Attachments.Count() = 1 Then
				SetErrorInRow(String, InsertKeywordsIntoString(Context,
					NStr("en = 'The ""%1"" keyword precedes the ""%2"" keyword.';"), "When,Case"));
				RestoreChoiceStructure(String, Attachments, CurrentAttachment, "Case", Context);
				
			ElsIf CurrentAttachment.Refinement = "Case" Then
				// Standard processing after the condition.
				
			ElsIf CurrentAttachment.Refinement = "When" Then
				SetErrorInRow(CurrentAttachment, InsertKeywordsIntoString(Context,
					NStr("en = 'The ""%2"" keyword is missing after the ""%1"" keyword.';"), "When,Then"), True);
				RestoreChoiceStructure(CurrentAttachment, Attachments, CurrentAttachment, "Then", Context);
				
			ElsIf CurrentAttachment.Refinement = "Then" Then
				DeleteLastAttachment(Attachments, CurrentAttachment, Context);
				
			Else // CurrentAttachment.Clarification = "Else"
				SetErrorInRow(String, InsertKeywordsIntoString(Context,
					NStr("en = 'The ""%1"" keyword must precede the ""%2"" keyword.';"), "When,Else"));
				DeleteLastAttachment(Attachments, CurrentAttachment, Context);
			EndIf;
			AddAttachment(String, Attachments, CurrentAttachment, Context);
			
		ElsIf String.Refinement = "Then" Then
			
			If Attachments.Count() = 1 Then
				SetErrorInRow(String, InsertKeywordsIntoString(Context,
					NStr("en = 'The ""%1"" keyword precedes the ""%2"" and ""%3"" keywords.';"), "Then,Case,When"));
				RestoreChoiceStructure(String, Attachments, CurrentAttachment, "Case,When", Context);
			
			ElsIf CurrentAttachment.Refinement = "Case" Then
				SetErrorInRow(String, InsertKeywordsIntoString(Context,
					NStr("en = 'The ""%1"" keyword precedes the ""%2"" keyword.';"), "Then,When"));
				RestoreChoiceStructure(String, Attachments, CurrentAttachment, "When", Context);
				
			ElsIf CurrentAttachment.Refinement = "When" Then
				// Standard processing after the condition.
				
			ElsIf CurrentAttachment.Refinement = "Then" Then
				SetErrorInRow(CurrentAttachment, InsertKeywordsIntoString(Context,
					NStr("en = 'The ""%2"" keyword is missing after the ""%1"" keyword.';"), "Then,When"), True);
				RestoreChoiceStructure(CurrentAttachment, Attachments, CurrentAttachment, "When", Context);
				
			Else // CurrentAttachment.Clarification = "Else"
				SetErrorInRow(String, InsertKeywordsIntoString(Context,
					NStr("en = 'The ""%1"" keyword must precede the ""%2"" keyword.';"), "Then,Else"));
				DeleteLastAttachment(Attachments, CurrentAttachment, Context);
				RestoreChoiceStructure(String, Attachments, CurrentAttachment, "When", Context);
			EndIf;
			DeleteLastAttachment(Attachments, CurrentAttachment, Context);
			AddAttachment(String, Attachments, CurrentAttachment, Context);
			
		ElsIf String.Refinement = "Else" Then
			
			If Attachments.Count() = 1 Then
				SetErrorInRow(String, InsertKeywordsIntoString(Context,
					NStr("en = 'The ""%1"" keyword precedes the ""%2"", ""%3"", and ""%4"" keywords.';"), "Else,Case,When,Then"));
				RestoreChoiceStructure(String, Attachments, CurrentAttachment, "Case,When,Then", Context);
			
			ElsIf CurrentAttachment.Refinement = "Case" Then
				SetErrorInRow(String, InsertKeywordsIntoString(Context,
					NStr("en = 'The ""%1"" keyword precedes the ""%2"" and ""%3"" keywords.';"), "Else,When,Then"));
				RestoreChoiceStructure(String, Attachments, CurrentAttachment, "When,Then", Context);
				
			ElsIf CurrentAttachment.Refinement = "When" Then
				SetErrorInRow(String, InsertKeywordsIntoString(Context,
					NStr("en = 'The ""%1"" keyword precedes the ""%2"" keyword.';"), "Else,Then"));
				DeleteLastAttachment(Attachments, CurrentAttachment, Context);
				RestoreChoiceStructure(String, Attachments, CurrentAttachment, "Then", Context);
				
			ElsIf CurrentAttachment.Refinement = "Then" Then
				// Standard processing after the condition.
				
			Else // CurrentAttachment.Clarification = "Else"
				SetErrorInRow(String, InsertKeywordsIntoString(Context,
					NStr("en = 'Repeated keyword: ""%1"".';"), "Else"));
			EndIf;
			DeleteLastAttachment(Attachments, CurrentAttachment, Context);
			AddAttachment(String, Attachments, CurrentAttachment, Context);
			
		Else // String.Clarification = "End"
			
			If Attachments.Count() = 1 Then
				SetErrorInRow(String, StringFunctionsClientServer.SubstituteParametersToString(
					NStr("en = 'The ""%1"" keyword precedes the ""%2"", ""%3"", ""%4"", and ""%5"" keywords.';"), "End,Case,When,Then,Else"));
				RestoreChoiceStructure(String, Attachments, CurrentAttachment, "Case,When,Then,Else", Context);
				
			ElsIf CurrentAttachment.Refinement = "Case" Then
				SetErrorInRow(String, InsertKeywordsIntoString(Context,
					NStr("en = 'The ""%1"" keyword precedes the ""%2"", ""%3"", and ""%4"" keywords.';"), "End,When,Then,Else"));
				RestoreChoiceStructure(String, Attachments, CurrentAttachment, "When,Then,Else", Context);
				
			ElsIf CurrentAttachment.Refinement = "When" Then
				SetErrorInRow(String, InsertKeywordsIntoString(Context,
					NStr("en = 'The ""%1"" keyword precedes the ""%2"" and ""%3"" keywords.';"), "End,Then,Else"));
				DeleteLastAttachment(Attachments, CurrentAttachment, Context);
				RestoreChoiceStructure(String, Attachments, CurrentAttachment, "Then,Else", Context);
				
			ElsIf CurrentAttachment.Refinement = "Then" Then
				SetErrorInRow(String, InsertKeywordsIntoString(Context,
					NStr("en = 'The ""%1"" keyword precedes the ""%2"" keyword.';"), "End,Else"));
				DeleteLastAttachment(Attachments, CurrentAttachment, Context);
				RestoreChoiceStructure(String, Attachments, CurrentAttachment, "Else", Context);
				
			Else // 
				// 
			EndIf;
			DeleteLastAttachment(Attachments, CurrentAttachment, Context);
			DeleteLastAttachment(Attachments, CurrentAttachment, Context);
		EndIf;
	EndDo;
	
	While Attachments.Count() > 1 Do
		CurrentAttachment = Attachments[Attachments.Count() - 1];
		
		If CurrentAttachment.Refinement = "Case" Then
			ErrorText = InsertKeywordsIntoString(Context,
				NStr("en = 'The ""%2"", ""%3"", ""%4"", and ""%5"" keywords are missing after the ""%1"" keyword.';"), "Case,When,Then,Else,End");
			RestoreChoiceStructure(CurrentAttachment, Attachments, CurrentAttachment, "When,Then,Else", Context);
			
		ElsIf CurrentAttachment.Refinement = "When" Then
			ErrorText = InsertKeywordsIntoString(Context,
				NStr("en = 'The ""%2"", ""%3"", and ""%4"" keywords are missing after the ""%1"" keyword.';"), "When,Then,Else,End");
			DeleteLastAttachment(Attachments, CurrentAttachment, Context);
			RestoreChoiceStructure(CurrentAttachment, Attachments, CurrentAttachment, "Then,Else", Context);
			
		ElsIf CurrentAttachment.Refinement = "Then" Then
			ErrorText = InsertKeywordsIntoString(Context,
				NStr("en = 'The ""%2"" and ""%3"" keywords are missing after the ""%1"" keyword.';"), "Then,Else,End");
			DeleteLastAttachment(Attachments, CurrentAttachment, Context);
			RestoreChoiceStructure(CurrentAttachment, Attachments, CurrentAttachment, "Else", Context);
			
		Else // 
			ErrorText = InsertKeywordsIntoString(Context,
				NStr("en = 'The ""%2"" keyword is missing after the ""%1"" keyword.';"), "Else,End");
		EndIf;
		SetErrorInRow(CurrentAttachment, ErrorText, True);
		DeleteLastAttachment(Attachments, CurrentAttachment, Context);
		DeleteLastAttachment(Attachments, CurrentAttachment, Context);
	EndDo;
	
	Return Result;
	
EndFunction

// For the ParseCondition procedure.
//
// Parameters:
//    Rows - Array of See TableRow.RowDescription
//
Function FunctionsWithExpressionsInParentheses(Rows, InternalData)
	
	Result = New Array;
	ResultString1 = New Structure("Rows", Result);
	
	RowsCount = Rows.Count();
	
	String = Undefined;
	IndexOf = 0;
	While IndexOf < RowsCount Do
		PreviousString = String; // ValueTableRow of See CharsetsTable
		String = TableRow(Rows[IndexOf], InternalData);
		
		If String.Chars = "(" Then
			String.Rows = FunctionsWithExpressionsInParentheses(String.Rows, InternalData);
			
		ElsIf String.Kind = "Keyword"
		        And (    String.Type = "Function"
		           Or String.Refinement = "In" ) Then
			
			NextRow = ?(IndexOf + 1 < Rows.Count(),
				TableRow(Rows[IndexOf + 1], InternalData), Undefined);
				
			If IndexOf + 1 < Rows.Count()
			   And NextRow.Chars = "(" Then
				
				IndexOf = IndexOf + 1;
				String.Rows = FunctionsWithExpressionsInParentheses(NextRow.Rows, InternalData);
				String.EndString = NextRow.EndString;
				
				If String.Rows.Count() = 0 Then
					If String.Type = "Function" Then
						SetErrorInRow(Rows[IndexOf], StringFunctionsClientServer.SubstituteParametersToString(
							NStr("en = 'Parameters of the ""%1"" function are missing.';"), String.Chars), True);
					Else
						SetErrorInRow(Rows[IndexOf], StringFunctionsClientServer.SubstituteParametersToString(
							NStr("en = 'The list of values for the ""%1"" operation is empty.';"), String.Chars), True);
					EndIf;
				EndIf;
			Else
				String.Rows = New Array;
				If String.Type = "Function" Then
					SetErrorInRow(String, StringFunctionsClientServer.SubstituteParametersToString(
						NStr("en = 'Missing parameters in parentheses after the ""%1"" function.';"), String.Chars), True);
				Else
					SetErrorInRow(String, StringFunctionsClientServer.SubstituteParametersToString(
						NStr("en = 'Missing values in parentheses after the ""%1"" keyword.';"), String.Chars), True);
				EndIf;
			EndIf;
			
		ElsIf String.Kind = "Keyword"
		        And String.Refinement = "Is"  Then
			
			NextRow = ?(IndexOf + 1 < Rows.Count(),
				TableRow(Rows[IndexOf + 1], InternalData), Undefined);
			
			If IndexOf + 1 < Rows.Count()
			   And NextRow.Kind = "Keyword"
			   And NextRow.Refinement = "Null" Then
				
				IndexOf = IndexOf + 1;
				RowAdd(String, NextRow, InternalData);
			Else
				String.Rows = New Array;
				SetErrorInRow(String, InsertKeywordsIntoString(InternalData,
						NStr("en = 'The ""%1"" keyword is missing after the ""%2"" keyword.';"),
						"Null",
						String.Chars),
					True);
			EndIf;
			
		ElsIf String.Kind = "Name"
		        And StrStartsWith(String.Chars, ".")
		        And PreviousString <> Undefined Then
			
			If PreviousString <> Undefined
			   And PreviousString.Kind = "Keyword"
			   And PreviousString.Refinement = "Cast" Then
				
				String.Type = "AdditionToExpress";
				RowAdd(PreviousString, String, InternalData);
				IndexOf = IndexOf + 1;
				Continue;
			Else
				SetErrorInRow(String, StringFunctionsClientServer.SubstituteParametersToString(
					NStr("en = 'A field name cannot begin with a period "".""';"), String.Chars));
			EndIf;
		EndIf;
		
		RowAdd(ResultString1, String, InternalData);
		IndexOf = IndexOf + 1;
	EndDo;
	
	Return Result;
	
EndFunction

// For the ExpressionsInParenthesesInAttachments and ExpressionsWhenThenSelectionInAttachments functions.
Procedure AddAttachment(String, Attachments, CurrentAttachment, Context)
	
	RowAdd(CurrentAttachment, String, Context);
	CurrentAttachment = String;
	Attachments.Add(CurrentAttachment);
	
EndProcedure

// For the ExpressionsInParenthesesInAttachments and ExpressionsWhenThenSelectionInAttachments functions.
Procedure DeleteLastAttachment(Attachments, CurrentAttachment, Context, EndString = Undefined)
	
	If EndString = Undefined Then
		If CurrentAttachment.Rows.Count() = 0 Then
			EndString = CurrentAttachment;
		Else
			EndString = TableRow(CurrentAttachment.Rows[CurrentAttachment.Rows.Count() - 1], Context);
			If EndString.EndString <> Undefined Then
				EndString = TableRow(EndString.EndString, Context);
			EndIf;
		EndIf;
	EndIf;
	
	CurrentAttachment.EndString = Context.CharsetsTable.IndexOf(EndString);
	
	LastAttachmentIndex = Attachments.Count() - 1;
	Attachments.Delete(LastAttachmentIndex);
	CurrentAttachment = Attachments[LastAttachmentIndex - 1];
	
EndProcedure

// For the ExpressionsWhenThenSelectionInAttachments function.
Procedure RestoreChoiceStructure(String, Attachments, CurrentAttachment, MissingWordsList, Context)
	
	MissingWords = StrSplit(MissingWordsList, ",", False);
	
	For Each MissingWord In MissingWords Do
		NewRow = AdditionalString1(String, MissingWord, Context);
		CurrentAttachment.Rows.Add(NewRow);
		
		If MissingWord = "Case" Then
			CurrentAttachment = NewRow;
			Attachments.Add(CurrentAttachment);
		EndIf;
	EndDo;
	
	If MissingWord <> "Case" Then
		CurrentAttachment = NewRow;
		Attachments.Add(CurrentAttachment);
	EndIf;
	
EndProcedure

// For the ProcessMissingLogicalOperation, ExpressionsWhenThenSelectionInAttachments,
// RestoreChoiceStructure procedures, and the CommaSeparatedParameters function.
//
// Returns:
//   Structure:
//   * Chars - String
//   * Kind - String
//   * Type - String
//   * Priority - Number
//   * Refinement - String
//   * Rows - Array of Number -
//   * EndString - Number -
//   * ErrorPosition - Number
//   * ErrorText - String
//
Function AdditionalString1(String, Refinement = "", Context = Undefined)
	
	NewRow = New Structure;
	NewRow.Insert("Chars");
	NewRow.Insert("Kind");
	NewRow.Insert("Type");
	NewRow.Insert("Priority");
	NewRow.Insert("Refinement", Refinement);
	NewRow.Insert("Rows", New Array);
	NewRow.Insert("EndString");
	NewRow.Insert("ErrorPosition");
	NewRow.Insert("ErrorText");
	
	WordProperties = ?(Context = Undefined,
		Undefined, Context.LanguageSyntax.LanguageWords.Get(Upper(Refinement)));
	
	If WordProperties <> Undefined Then
		NewRow.Kind       = "Keyword";
		NewRow.Type       = WordProperties.Type;
		NewRow.Priority = WordProperties.Priority;
	EndIf;
	
	Return NewRow;
	
EndFunction

// For the ParseAdditionalTables and ParseRestrictionCondition procedures.
//
// Parameters:
//    PartRows - Array of ValueTableRow: см. ТаблицаНаборовСимволов
//
Procedure ChangeKeywordTypeListToName(PartRows, RowToExclude = Undefined)
	
	For Each String In PartRows Do
		If String = RowToExclude
		 Or String.Kind <> "Keyword"
		 Or String.Refinement <> "ThisList" Then
			Continue;
		EndIf;
		String.Kind = "Name";
		String.Refinement = "";
	EndDo;
	
EndProcedure

// For the ParseAdditionalTables and ParseCondition procedures.
//
// Parameters:
//    See CharsetsTable
//
Procedure SetAlias(PartRow, IConnectionShort, InternalData)
	
	If ValueIsFilled(PartRow.ErrorText) Then
		Return;
	EndIf;
	
	PointPosition = StrFind(PartRow.Chars, ".");
	If PointPosition > 0 Then
		PartRow.ErrorPosition = PointPosition - 1;
		PartRow.ErrorText =
			NStr("en = 'An alias cannot contain a period "".""';");
			
	ElsIf TypeOf(IConnectionShort) = Type("String") Then
		IConnectionShort = PartRow.Chars;
		InternalData.Aliases.Insert(Upper(PartRow.Chars),
			New Structure("Alias, Table", PartRow.Chars));
	Else
		IConnectionShort.Alias = PartRow.Chars + "Alias";
		If InternalData.Aliases.Get(Upper(PartRow.Chars)) = Undefined Then
			If ValueIsFilled(IConnectionShort.Table) Then
				InternalData.Aliases.Insert(Upper(PartRow.Chars),
					New Structure("Alias, Table",
						IConnectionShort.Alias, IConnectionShort.Table));
			EndIf;
		Else
			PartRow.ErrorText = NStr("en = 'Duplicate alias.';");
		EndIf;
	EndIf;
	
EndProcedure

// For the ParseConnection procedure.
//
// Parameters:
//    See CharsetsTable
//
Procedure SetTableName(PartRow, IConnectionShort, InternalData)
	
	If ValueIsFilled(PartRow.ErrorText) Then
		Return;
	EndIf;
	
	If StrStartsWith(PartRow.Chars, ".") Then
		PartRow.ErrorText =
			NStr("en = 'A table name cannot begin with a period "".""';");
		Return;
	EndIf;
	
	If StrOccurrenceCount(PartRow.Chars, ".") > 2 Then
		
		PointPosition = StrFind(PartRow.Chars, ".");
		PointPosition = PointPosition + StrFind(Mid(PartRow.Chars, PointPosition + 1), ".");
		
		PointPosition = PointPosition + StrFind(Mid(PartRow.Chars, PointPosition + 1), ".");
		PartRow.ErrorText =
			NStr("en = 'A full table name cannot contain more than two periods "".""';");
		
		PartRow.ErrorPosition = PointPosition - 1;
		Return;
	EndIf;
	
	IConnectionShort.Table = PartRow.Chars;
	
	AddRequiredTableAsDataSource(InternalData, IConnectionShort.Table, PartRow);
	
EndProcedure

// For the SetTableName procedure.
Procedure AddRequiredTableAsDataSource(Context, Table, Source)
	
	If ValueIsFilled(Source.ErrorText) Then
		Return;
	EndIf;
	
	NameProperties = TableNameProperties(Context, Table);
	
	If NameProperties.NamePartsCount < 2
	 Or NameProperties.NamePartsCount > 3 Then
		SetErrorInRow(Source,
			NStr("en = 'A name of a joined table must contain one or two dots.';"));
		Return;
	EndIf;
	
	If NameProperties.TablesTypeProperties = Undefined Then
		SetErrorInRow(Source, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'The table name ""%2"" begins with an invalid word ""%1"".';"), NameProperties.TypeName, Table));
		Return;
	EndIf;
	
	If NameProperties.NamePartsCount = 3 Then
		ClarificationProperties = NameProperties.TablesTypeProperties.TablesClarification.Get(
			Upper(NameProperties.Extension));
		
		If ClarificationProperties <> Undefined
		   And ClarificationProperties.Use <> "Allowed1" Then
			
			If ClarificationProperties.Use = "Illegal" Then
				SetErrorInRow(Source, StringFunctionsClientServer.SubstituteParametersToString(
					NStr("en = 'The ""%1"" tables of the ""%2"" table group are not allowed.';"),
					NameProperties.Extension, NameProperties.TypeName));
			Else
				SetErrorInRow(Source, StringFunctionsClientServer.SubstituteParametersToString(
					NStr("en = 'Joining the ""%1"" tables of the ""%2"" table group is not allowed.';"),
					NameProperties.Extension, NameProperties.TypeName));
			EndIf;
			Return;
		EndIf;
	EndIf;
	
	Properties = RequiredTableProperties(Context, NameProperties);
	Properties.Sources.Add(Source);
	
EndProcedure

// For the SelectFieldAlias, ParseFirstCheckingFunctionParameter,
// ParseAdditionalCheckingFunctionParameter, and ParseValueFunctionOrTypeFunctionParameters procedures.
//
Procedure AddRequiredTableAsReferenceType(Context, Table, Source)
	
	If ValueIsFilled(Source.ErrorText) Then
		Return;
	EndIf;
	
	NameProperties = TableNameProperties(Context, Table);
	
	If NameProperties.NamePartsCount <> 2 Then
		SetErrorInRow(Source,
			NStr("en = 'A table name specified as a type must contain a single dot.';"));
		Return;
	EndIf;
	
	If NameProperties.TablesTypeProperties = Undefined Then
		SetErrorInRow(Source, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'The table name ""%2"" begins with an invalid word ""%1"".';"), NameProperties.TypeName, Table));
		Return;
	EndIf;
	
	If Not NameProperties.TablesTypeProperties.IsReferenceType Then
		SetErrorInRow(Source, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'The ""%1"" table group is not included in any reference types.';"), NameProperties.TypeName, Table));
		Return;
	EndIf;
	
	Properties = RequiredTableProperties(Context, NameProperties);
	Properties.Sources.Add(Source);
	
EndProcedure

// For the ParseValueFunctionOrTypeFunctionParameters procedure.
Procedure AddRequiredPredefinedItem(Context, FullPredefinedItemName, Source)
	
	If ValueIsFilled(Source.ErrorText) Then
		Return;
	EndIf;
	
	NameProperties = TableNameProperties(Context, FullPredefinedItemName);
	
	If NameProperties.NamePartsCount <> 3 Then
		SetErrorInRow(Source,
			NStr("en = 'A predefined value name must contain two dots.';"));
		Return;
	EndIf;
	
	If NameProperties.TablesTypeProperties = Undefined Then
		SetErrorInRow(Source, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'The table name ""%2"" begins with an invalid word ""%1"".';"),
			NameProperties.TypeName,
			NameProperties.TypeName + "." + NameProperties.NameWithoutType));
		Return;
	EndIf;
	
	If Not NameProperties.TablesTypeProperties.IsReferenceType Then
		SetErrorInRow(Source, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'The ""%1"" table group is not included in any reference types.';"), NameProperties.TypeName));
		Return;
	EndIf;
	
	WordProperties = Context.LanguageSyntax.LanguageWords.Get(Upper(NameProperties.Extension)); // See WordProperties
	
	If Not NameProperties.TablesTypeProperties.HasPredefined
	   And Not NameProperties.TypeName = "Enum"
	   And (    WordProperties = Undefined
	      Or WordProperties.Id <> "EmptyRef") Then
		
		SetErrorInRow(Source, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'There are no predefined items in the ""%1"" table group.';"), NameProperties.TypeName));
		Return;
	EndIf;
	
	Properties = RequiredTableProperties(Context, NameProperties, True);
	
	PredefinedOptionProperties = Properties.Predefined.Get(Upper(NameProperties.Extension));
	If PredefinedOptionProperties = Undefined Then
		PredefinedOptionProperties = NewPredefinedOptionProperties();
		PredefinedOptionProperties.Insert("NameExists", False);
		PredefinedOptionProperties.Insert("Sources", New Array);
		Properties.Predefined.Insert(Upper(NameProperties.Extension), PredefinedOptionProperties);
	EndIf;
	PredefinedOptionProperties.Sources.Add(Source);
	
EndProcedure

// For the ParseRoleAvailableFunctionParameters procedure.
Procedure CheckTheRoleName(NameOfRole, Source)
	
	If ValueIsFilled(Source.ErrorText) Then
		Return;
	EndIf;
	
	If StrFind(NameOfRole, ".") > 0 Then
		SetErrorInRow(Source,
			NStr("en = 'Role name must not contain dots';"));
		Return;
	EndIf;
	
	If Metadata.Roles.Find(NameOfRole) = Undefined Then
		SetErrorInRow(Source, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Role ""%1"" is missing in the metadata';"), NameOfRole));
		Return;
	EndIf;
	
EndProcedure

Procedure CheckTheNameOfTheMetadataObjectRight(NameOfRight, SourceOfLaw, ObjectName, ObjectSource)
	
	If ValueIsFilled(SourceOfLaw.ErrorText)
	 Or ObjectSource <> Undefined
	   And ValueIsFilled(ObjectSource.ErrorText) Then
		Return;
	EndIf;
	
	If StrFind(NameOfRight, ".") > 0 Then
		SetErrorInRow(SourceOfLaw,
			NStr("en = 'Access right name must not contain dots';"));
		Return;
	EndIf;
	
	TheNameOfTheStandardProps = Undefined;
	MetadataObject = MetadataObjectByFullNameForCheckingTheRight(ObjectName, TheNameOfTheStandardProps);
	If MetadataObject = Undefined Then
		SetErrorInRow(ObjectSource, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Metadata object ""%1"" does not exist';"), ObjectName));
		Return;
	EndIf;
	
	ErrorText = "";
	Try
		AccessRight(NameOfRight, MetadataObject, , TheNameOfTheStandardProps);
	Except
		ErrorInfo = ErrorInfo();
		ErrorText = ErrorProcessing.BriefErrorDescription(ErrorInfo);
	EndTry;
	
	If ValueIsFilled(ErrorText) Then
		SetErrorInRow(SourceOfLaw, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("en = 'Cannot check the ""%1"" access right of the ""%2"" metadata object due to:
			           |%3';"), NameOfRight, ObjectName, ErrorText));
		Return;
	EndIf;
	
EndProcedure

// For the CheckMetadataObjectRightName procedure.
Function MetadataObjectByFullNameForCheckingTheRight(FullName, TheNameOfTheStandardProps = Undefined)
	
	MetadataObject = Common.MetadataObjectByFullName(FullName);
	If MetadataObject <> Undefined Then
		Return MetadataObject;
	EndIf;
	
	NameParts = StrSplit(FullName, ".");
	If NameParts.Count() < 4 Then
		Return Undefined;
	EndIf;
	
	MainMetadataObjectName = NameParts[0] + "." + NameParts[1];
	MainMetadataObject = Common.MetadataObjectByFullName(MainMetadataObjectName);
	If MainMetadataObject = Undefined Then
		Return Undefined;
	EndIf;
	
	If Upper(NameParts[2]) = Upper("СтандартнаяТабличнаяЧасть") // @Non-NLS
	 Or Upper(NameParts[2]) = Upper("StandardTabularSection") Then
		
		Properties = New Structure("StandardTabularSections");
		FillPropertyValues(Properties, MainMetadataObject);
		If Properties.StandardTabularSections = Undefined Then
			Return Undefined;
		EndIf;
		NameOfTheStandardTablePart = NameParts[3];
		For Each StandardTabularSection In Properties.StandardTabularSections Do
			If Upper(StandardTabularSection.Name) = Upper(NameOfTheStandardTablePart) Then
				StandardAttributes = StandardTabularSection.StandardAttributes;
				Break;
			EndIf;
		EndDo;
		If StandardAttributes = Undefined
		 Or NameParts.Count() <> 6 Then
			Return Undefined;
		EndIf;
		NameParts.Delete(0);
		NameParts.Delete(0);
		OwnerOfStandardBankingDetails = StandardTabularSection;
	Else
		OwnerOfStandardBankingDetails = MainMetadataObject;
	EndIf;
	
	If Upper(NameParts[2]) <> Upper("СтандартныйРеквизит") // @Non-NLS
	   And Upper(NameParts[2]) <> Upper("StandardAttribute") Then
		Return Undefined;
	EndIf;
	
	Properties = New Structure("StandardAttributes");
	FillPropertyValues(Properties, OwnerOfStandardBankingDetails);
	If Properties.StandardAttributes = Undefined Then
		Return Undefined;
	EndIf;
	TheNameOfTheStandardProps = NameParts[3];
	StandardAttributes = Properties.StandardAttributes; // StandardAttributeDescriptions
	
	For Each StandardAttribute In StandardAttributes Do
		If Upper(StandardAttribute.Name) = Upper(TheNameOfTheStandardProps) Then
			If ValueIsFilled(NameOfTheStandardTablePart) Then
				TheNameOfTheStandardProps = NameOfTheStandardTablePart + "." + TheNameOfTheStandardProps;
			EndIf;
			Return MainMetadataObject;
		EndIf;
	EndDo;
	
	Return Undefined;
	
EndFunction

// For the MarkIncorrectArgumentsAndProhibitedNodes, SelectFieldAlias,
// and AddUsersAndExternalUsersAccessKindsTypesToCheckAbsence procedures.
//
Procedure AddRequiredTableField(Context, Table, FieldName, Source,
			FieldType = "", FieldTypeSource = Undefined, FieldNode = Undefined)
	
	If ValueIsFilled(Source.ErrorText) Then
		Return;
	EndIf;
	
	NameProperties = TableNameProperties(Context, Table);
	If NameProperties.TablesTypeProperties = Undefined Then
		
		If NameProperties.IsMainTable
		   And Not Context.Property("ErrorSetToFirstFieldInMainTable") Then
			
			Context.Insert("ErrorSetToFirstFieldInMainTable");
			SetErrorInFieldNameString(Context, Source,
				NStr("en = 'The field does not exist as non-existent table ""%1"" is specified.';"), 0, ,
				Context.MainTable);
		EndIf;
		
		Return;
	EndIf;
	
	Properties = RequiredTableProperties(Context, NameProperties);
	
	FieldProperties = Properties.Fields.Get(Upper(FieldName));
	If FieldProperties = Undefined Then
		FieldProperties = NewFieldProperties();
		FieldProperties.Insert("FieldWithError", 0);
		FieldProperties.Insert("ErrorKind",    "");
		FieldProperties.Insert("Collection",    "");
		FieldProperties.Insert("ContainsTypes", New Map);
		FieldProperties.Insert("Sources",    New Map);
		FieldProperties.Insert("FieldNodes",     New Array);
		Properties.Fields.Insert(Upper(FieldName), FieldProperties);
		
		If Properties.Property("FirstField")
		   And Properties.FirstField = Undefined
		   And Source <> Undefined Then
			
			FieldProperties.Insert("FirstSource", New Structure("Key,Value", Source, Table));
			Properties.FirstField = FieldProperties;
		EndIf;
	EndIf;
	FieldProperties.Sources.Insert(Source, Table);
	If FieldNode <> Undefined Then
		FieldProperties.FieldNodes.Add(FieldNode);
	EndIf;
	
	If Not ValueIsFilled(FieldType) Then
		Return;
	EndIf;
	
	If TypeOf(FieldTypeSource) = Type("ValueTableRow")
	   And ValueIsFilled(FieldTypeSource.ErrorText) Then
		Return;
	EndIf;
	
	TypeProperties = FieldProperties.ContainsTypes.Get(Upper(FieldType));
	If TypeProperties = Undefined Then
		NameContent = StrSplit(FieldType, ".");
		TablesTypeProperties = Context.LanguageSyntax.TablesTypes.ByNames.Get(Upper(NameContent[0]));
		If TablesTypeProperties = Undefined Then
			TypeName = FieldType;
			TypeCollectionName = "";
			TypeCollectionObjectName = "";
		Else
			TypeName = TablesTypeProperties.LanguageRussian + "Ссылка." + NameContent[1]; // @Non-NLS
			TypeCollectionName = TablesTypeProperties.CollectionName;
			TypeCollectionObjectName = NameContent[1];
		EndIf;
		TypeProperties = New Structure;
		TypeProperties.Insert("ContainsType", False);
		TypeProperties.Insert("TypeName", TypeName);
		TypeProperties.Insert("TypeCollectionName", TypeCollectionName);
		TypeProperties.Insert("TypeCollectionObjectName", TypeCollectionObjectName);
		TypeProperties.Insert("Sources", New Map);
		FieldProperties.ContainsTypes.Insert(Upper(FieldType), TypeProperties);
	EndIf;
	TypeProperties.Sources.Insert(FieldTypeSource, Source);
	
EndProcedure

// For the AddRequiredTableAsDataSource, AddRequiredTableAsReferenceType,
// AddRequiredPredefinedItem, and AddRequiredTableField procedures.
//
Function TableNameProperties(Context, FullName)
	
	If ValueIsFilled(FullName) Then
		Table = FullName;
	Else
		Table = Context.MainTable;
	EndIf;
	
	NameContent = StrSplit(Table, ".", False);
	
	Properties = New Structure;
	Properties.Insert("NamePartsCount", NameContent.Count());
	Properties.Insert("TypeName",    NameContent[0]);
	Properties.Insert("NameWithoutType", ?(NameContent.Count() > 1, NameContent[1], Undefined));
	Properties.Insert("Extension", ?(NameContent.Count() = 3, NameContent[2], Undefined));
	Properties.Insert("IsMainTable", Upper(Table) = Upper(Context.MainTable));
	Properties.Insert("TablesTypeProperties",
		Context.LanguageSyntax.TablesTypes.ByNames.Get(Upper(NameContent[0])));
	
	Return Properties;
	
EndFunction

// For the AddRequiredTableAsDataSource, AddRequiredTableAsReferenceType,
// AddRequiredPredefinedItem, and AddRequiredTableField procedures.
//
Function RequiredTableProperties(Context, NameProperties, WithoutExtension = False)
	
	CollectionName = NameProperties.TablesTypeProperties.CollectionName;
	
	CollectionComponents = Context.TablesFields.Get(CollectionName);
	If CollectionComponents = Undefined Then
		CollectionComponents = NewCollectionComponents();
		Context.TablesFields.Insert(CollectionName, CollectionComponents);
	EndIf;
	
	Properties = CollectionComponents.Get(Upper(NameProperties.NameWithoutType));
	If Properties = Undefined Then
		Properties = NewTableProperties();
		Properties.Insert("TableExists",  False);
		Properties.Insert("IsMainTable", NameProperties.IsMainTable);
		Properties.Insert("Sources",          New Array);
		Properties.Insert("Fields",               New Map);
		Properties.Insert("Predefined",   New Map);
		Properties.Insert("Extensions",         New Map);
		If NameProperties.IsMainTable And NameProperties.Extension = Undefined Then
			Properties.Insert("FirstField");
		EndIf;
		CollectionComponents.Insert(Upper(NameProperties.NameWithoutType), Properties);
	EndIf;
	
	If NameProperties.Extension = Undefined Or WithoutExtension Then
		Return Properties;
	EndIf;
	
	ExtensionProperties1 = Properties.Extensions.Get(Upper(NameProperties.Extension));
	If ExtensionProperties1 = Undefined Then
		ExtensionProperties1 = NewExtensionProperties();
		ExtensionProperties1.Insert("TableExists", False);
		ExtensionProperties1.Insert("Sources",         New Array);
		ExtensionProperties1.Insert("Fields",              New Map);
		If NameProperties.IsMainTable Then
			ExtensionProperties1.Insert("FirstField");
		EndIf;
		Properties.Extensions.Insert(Upper(NameProperties.Extension), ExtensionProperties1);
	EndIf;
	
	Return ExtensionProperties1;
	
EndFunction

// For the RestrictionParts, ParseAdditionalTables, ParseConnection,
// ParseRestrictionCondition, and ExpressionsWhenThenSelectionInAttachments procedures and functions.
//
Function InsertKeywordsIntoString(Context, String, WordsList, ParameterOne = "", ParameterTwo = "", ParameterThree = "")
	
	Words = StrSplit(WordsList, ",", False);
	WordsToInsert = New Map;
	
	For Each Word In Words Do
		WordsToInsert.Insert(Words.Find(Word),
			KeywordRegardingLanguage(TrimAll(Word), Context));
	EndDo;
	
	IndexOf = WordsToInsert.Count();
	WordsToInsert.Insert(IndexOf,     ParameterOne);
	WordsToInsert.Insert(IndexOf + 1, ParameterTwo);
	WordsToInsert.Insert(IndexOf + 2, ParameterThree);
	
	Return StringFunctionsClientServer.SubstituteParametersToString(String,
		WordsToInsert[0], WordsToInsert[1], WordsToInsert[2],
		WordsToInsert[3], WordsToInsert[4], WordsToInsert[5],
		WordsToInsert[6], WordsToInsert[7], WordsToInsert[8]);
	
EndFunction

// For the ParseAdditionalTables, ParseConnection, and ParseRestrictionCondition procedures.
Function KeywordRegardingLanguage(WordID, Context)
	
	WordProperties = Context.LanguageSyntax.LanguageWords.Get(Upper(WordID));
	
	If ScriptVariantRussian() Then
		Word = WordProperties.LanguageRussian;
	Else
		Word = WordProperties.LanguageEnglish;
	EndIf;
	
	If WordProperties.Uppercase Then
		Word = Upper(Word);
	EndIf;
	
	Return Word;
	
EndFunction

#EndRegion

#Region TablesNamesAndTablesFieldsAnalysis

// Checking tables, table fields, and field types found when parsing the restriction text.
// The same procedure is implemented in ASDS.
//
// Parameters:
//  ParsedRestriction - See ParsedRestriction
//
Procedure CheckFieldTablesAndFieldsTypes(ParsedRestriction)
	
	Context = New Structure;
	Context.Insert("TablesTypes", AccessManagementInternalCached.LanguageSyntax().TablesTypes);
	
	For Each TablesType In ParsedRestriction.TablesFields Do
		TablesCollection = Metadata[TablesType.Key]; // MetadataObjectCollection
		
		For Each TableFields In TablesType.Value Do
			
			MetadataTables = TablesCollection.Find(TableFields.Key);
			If MetadataTables = Undefined Then
				Continue;
			EndIf;
			TableFields.Value.TableExists = True;
			
			Context.Insert("MetadataTables",  MetadataTables);
			Context.Insert("TablesTypeProperties", Context.TablesTypes.ByCollections.Get(TablesType.Key));
			Context.Insert("IsMainTable", TableFields.Value.IsMainTable);
			
			For Each TableField In TableFields.Value.Fields Do
				FieldDetails = New Structure;
				FieldDetails.Insert("NameContent", StrSplit(TableField.Key, "."));
				FieldDetails.Insert("Properties",    TableField.Value);
				FieldDetails.Insert("FieldType",     New TypeDescription);
				CheckTableField(FieldDetails, Context);
				If FieldDetails.Properties.FieldWithError = 0 Then
					CheckFieldTypes(FieldDetails, Context);
				EndIf;
			EndDo;
			
			CheckTableExtensions(TableFields, Context);
			CheckPredefinedTableValues(TableFields, Context);
		EndDo;
	EndDo;
	
EndProcedure

// For the CheckFieldTablesAndFieldsTypes and CheckNextPointSeparatedField procedures.
Procedure CheckTableField(FieldDetails, Context, IndexOf = 0, InitialCall = True)
	
	NameContent  = FieldDetails.NameContent;
	FieldProperties = FieldDetails.Properties;
	
	FieldClarification = Context.TablesTypeProperties.FieldsClarification.Get(Upper(NameContent[IndexOf]));
	
	If FieldClarification <> Undefined
	   And FieldClarification.Use <> "Allowed1" Then
		
		FieldProperties.FieldWithError = IndexOf + 1;
		FieldProperties.ErrorKind = FieldClarification;
		Return;
	EndIf;
	
	Properties = FieldOrTabularSectionProperties(NameContent[IndexOf], Context, IndexOf = 0);
	If Properties = Undefined Then
		FieldProperties.FieldWithError = IndexOf + 1;
		FieldProperties.ErrorKind = "NotFound4";
		Return;
	EndIf;
	If IndexOf = 0 Then
		FieldProperties.Collection = Properties.Collection;
	EndIf;
	
	If Properties.IsTabularSection Then
		If IndexOf > 0 Then
			FieldProperties.FieldWithError = IndexOf + 1;
			FieldProperties.ErrorKind = "TabularSectionAfterDot";
			Return;
		EndIf;
		If Not Context.IsMainTable Then
			FieldProperties.FieldWithError = IndexOf + 1;
			FieldProperties.ErrorKind = "AdditionalTableTabularSection";
			Return;
		EndIf;
		If IndexOf + 1 = NameContent.Count() Then
			FieldProperties.FieldWithError = IndexOf + 1;
			FieldProperties.ErrorKind = "TabularSectionNoField";
			Return;
		EndIf;
		IndexOf = IndexOf + 1;
		Properties = TabularSectionFieldProperties(NameContent[IndexOf],
			Properties.Metadata, Properties.Collection, Context.MetadataTables);
		If Properties = Undefined Then
			FieldProperties.FieldWithError = IndexOf + 1;
			FieldProperties.ErrorKind = "NotFound4";
			Return;
		EndIf;
	EndIf;
	
	CheckNextPointSeparatedField(FieldDetails, IndexOf, Properties, Context);
	
	If InitialCall Then
		FillFieldTypesAsStringAdditional(FieldDetails);
	EndIf;
	
EndProcedure

// For the CheckTableField and CheckTableExtensions procedures.
Procedure CheckNextPointSeparatedField(FieldDetails, IndexOf, CurrentFieldProperties, Context)
	
	AddFieldTypesAdditional(FieldDetails, IndexOf, CurrentFieldProperties, Context);
	
	IndexOf = IndexOf + 1;
	If IndexOf = FieldDetails.NameContent.Count() Then
		FieldDetails.FieldType = New TypeDescription(FieldDetails.FieldType, CurrentFieldProperties.Type.Types());
		Return;
	EndIf;
	
	FieldProperties = FieldDetails.Properties;
	FieldFound = False;
	
	If FieldDetails.Property("NextFieldTables") Then
		// See procedure AddFieldTypesAdditional.
		If FieldDetails.NextFieldTables.Count() < IndexOf + 1 Then
			NextFieldTables = New Array;
			FieldDetails.NextFieldTables.Add(NextFieldTables);
		Else
			NextFieldTables = FieldDetails.NextFieldTables[IndexOf];
		EndIf;
	EndIf;
	
	For Each Type In CurrentFieldProperties.Type.Types() Do
		If Not Common.IsReference(Type) Then
			Continue;
		EndIf;
		FieldProperties.FieldWithError = 0;
		FieldProperties.ErrorKind = "";
		
		// Save the current context.
		CurrentTableMetadata  = Context.MetadataTables;
		CurrentTablesTypeProperties = Context.TablesTypeProperties;
		
		Context.MetadataTables = Metadata.FindByType(Type);
		FullName = Context.MetadataTables.FullName();
		FullNameContent = StrSplit(FullName, ".", False);
		Context.TablesTypeProperties = Context.TablesTypes.ByNames.Get(Upper(FullNameContent[0]));
		
		CurrentIndex = IndexOf;
		CheckTableField(FieldDetails, Context, CurrentIndex, False);
		
		// 
		Context.MetadataTables  = CurrentTableMetadata;
		Context.TablesTypeProperties = CurrentTablesTypeProperties;
		
		If FieldProperties.FieldWithError = 0 Then
			FieldFound = True;
			If NextFieldTables <> Undefined Then
				// 
				NextFieldTables.Add(FullName);
			EndIf;
		ElsIf FieldProperties.ErrorKind <> "NotFound4" Then
			Return;
		EndIf;
	EndDo;
	
	If FieldFound Then
		FieldProperties.FieldWithError = 0;
		FieldProperties.ErrorKind = "";
	EndIf;
	
EndProcedure

// For the CheckTableField procedure.
Function FieldOrTabularSectionProperties(FieldOrTabularSectionName, Context, IsFirstField)
	
	Result = New Structure;
	Result.Insert("IsTabularSection", False);
	Result.Insert("Collection");
	Result.Insert("Metadata");
	Result.Insert("Type");
	
	MetadataTables  = Context.MetadataTables;
	TablesTypeProperties = Context.TablesTypeProperties;
	
	For Each TabularSectionsCollection In TablesTypeProperties.TabularPartCollections Do
		If TabularSectionsCollection.Key = "StandardTabularSections" Then
			StandardTabularSections = MetadataTables.StandardTabularSections; // StandardTabularSectionDescriptions
			For Each StandardTabularSection In StandardTabularSections Do
				If Upper(FieldOrTabularSectionName) = Upper(StandardTabularSection.Name) Then
					Result.Metadata = StandardTabularSection;
					Break;
				EndIf;
			EndDo;
		Else
			Result.Metadata = MetadataTables[TabularSectionsCollection.Key].Find(FieldOrTabularSectionName);
		EndIf;
		If Result.Metadata <> Undefined Then
			Result.IsTabularSection = True;
			Result.Collection = TabularSectionsCollection.Key;
			Return Result;
		EndIf;
	EndDo;
	
	For Each FieldsCollection In TablesTypeProperties.FieldsCollections Do
		If FieldsCollection.Key = "StandardAttributes" Then
			Number = 0;
			StandardAttributes = MetadataTables.StandardAttributes; // StandardAttributeDescriptions
			For Each StandardAttribute In StandardAttributes Do
				Number = Number + 1;
				If Upper(FieldOrTabularSectionName) = Upper(StandardAttribute.Name) Then
					Result.Metadata = StandardAttribute;
					Break;
				EndIf;
			EndDo;
		Else
			Result.Metadata = MetadataTables[FieldsCollection.Key].Find(FieldOrTabularSectionName);
		EndIf;
		If Result.Metadata <> Undefined Then
			Result.Collection = FieldsCollection.Key;
			If Result.Collection = "Columns" Then
				Result.Type = New TypeDescription;
				LogGraphsMetadata = Result.Metadata; // MetadataObjectGraph
				For Each RefMetadata In LogGraphsMetadata.References Do
					Result.Type = New TypeDescription(Result.Type, RefMetadata.Type.Types());
				EndDo;
			Else
				Result.Type = Result.Metadata.Type;
			EndIf;
			Return Result;
		EndIf;
	EndDo;
	
	If TablesTypeProperties.CommonAttributes <> "Missing1" Then
		Result.Metadata = Metadata.CommonAttributes.Find(FieldOrTabularSectionName);
		If Result.Metadata <> Undefined Then
			Result.Collection = "CommonAttributes";
			Result.Type = Result.Metadata.Type;
			Return Result;
		EndIf;
	EndIf;
	
	If TablesTypeProperties.CollectionName = "Constants" Then
		
		If Upper(FieldOrTabularSectionName) = Upper("Value")
		 Or Upper(FieldOrTabularSectionName) = Upper("Value") Then
			
			Result.Collection = "SpecialFields";
			Result.Type = MetadataTables.Type;
			Result.Insert("DefaultOrder", "001"); // 
			Return Result;
		EndIf;
		
	ElsIf TablesTypeProperties.CollectionName = "Sequences" Then
		
		If Upper(FieldOrTabularSectionName) = Upper("Period")
		 Or Upper(FieldOrTabularSectionName) = Upper("Period") Then
		
			Result.Collection = "SpecialFields";
			Result.Type = New TypeDescription("Date");
			Result.Insert("DefaultOrder", "001"); // 
			Return Result;
		EndIf;
		
		If Upper(FieldOrTabularSectionName) = Upper("Recorder")
		 Or Upper(FieldOrTabularSectionName) = Upper("Recorder") Then
			
			Result.Collection = "SpecialFields";
			Result.Type = New TypeDescription;
			MetadataSequences = MetadataTables; // MetadataObjectSequence
			For Each DocumentMetadata In MetadataSequences.Documents Do
				Result.Type = New TypeDescription(Result.Type, "DocumentRef." + DocumentMetadata.Name);
			EndDo;
			Result.Insert("DefaultOrder", "002"); // 
			Return Result;
		EndIf;
	EndIf;
	
	Return Undefined;
	
EndFunction

// For the CheckTableExtensions and CheckTableField procedures.
Function TabularSectionFieldProperties(TabularSectionFieldName, TabularSectionMetadata, CollectionName, MetadataTables)
	
	Result = New Structure;
	Result.Insert("Type");
	Result.Insert("TabularSectionName", TabularSectionMetadata.Name);
	
	If Upper(TabularSectionFieldName) = Upper("Ref")
	 Or Upper(TabularSectionFieldName) = Upper("Ref") Then
		
		For Each StandardAttribute In MetadataTables.StandardAttributes Do
			If Upper(TabularSectionFieldName) = Upper(StandardAttribute.Name) Then
				Result.Type = StandardAttribute.Type;
				Return Result;
			EndIf;
		EndDo;
	EndIf;
	
	For Each StandardAttribute In TabularSectionMetadata.StandardAttributes Do
		If Upper(TabularSectionFieldName) = Upper(StandardAttribute.Name) Then
			Result.Type = StandardAttribute.Type;
			Return Result;
		EndIf;
	EndDo;
	
	If CollectionName = "TabularSections" Then
		FieldMetadata = TabularSectionMetadata.Attributes.Find(TabularSectionFieldName);
		If FieldMetadata <> Undefined Then
			Result.Type = FieldMetadata.Type;
			Result.Insert("TabularSectionMetadata", TabularSectionMetadata);
			Return Result;
		EndIf;
	EndIf;
	
	Return Undefined;
	
EndFunction

// For the CheckTableExtensions and CheckTableField procedures.
Function RecalculationFieldProperties(RecalculationFieldName, RecalculationMetadata, MetadataTables)
	
	Result = New Structure;
	Result.Insert("Type");
	Result.Insert("Collection");
	Result.Insert("Metadata");
	
	If Upper(RecalculationFieldName) = Upper("RecalculationObject")
	 Or Upper(RecalculationFieldName) = Upper("RecalculationObject") Then
		
		FieldName = "Recorder";
		
	ElsIf Upper(RecalculationFieldName) = Upper("CalculationType")
	      Or Upper(RecalculationFieldName) = Upper("CalculationType") Then
	
		FieldName = "CalculationType";
	EndIf;
	
	RegisterMetadata = MetadataTables; // MetadataObjectCalculationRegister
	If ValueIsFilled(FieldName) Then
		For Each StandardAttribute In RegisterMetadata.StandardAttributes Do
			If Upper(FieldName) = Upper(StandardAttribute.Name) Then
				Result.Collection = "StandardAttributes";
				Result.Metadata = StandardAttribute;
				Result.Type = StandardAttribute.Type;
				Return Result;
			EndIf;
		EndDo;
		Return Undefined;
	EndIf;
	
	FieldMetadata = RecalculationMetadata.Dimensions.Find(RecalculationFieldName);
	If FieldMetadata <> Undefined Then
		Result.Type = FieldMetadata.RegisterDimension.Type;
		Result.Collection = "SpecialFields";
		Number = 200 + RegisterMetadata.Dimensions.IndexOf(FieldMetadata) + 1;
		Result.Insert("DefaultOrder", Number); // 
		Return Result;
	EndIf;
	
	Return Undefined;
	
EndFunction

// For the CheckTableField procedure.
Procedure AddFieldTypesAdditional(FieldDetails, IndexOf, CurrentFieldProperties, Context)
	
	// Additionally collecting types to use in service procedures.
	
	// Expanding properties of the Field node to use in service procedures.
	If IndexOf = 0 Or IndexOf = 1 And CurrentFieldProperties.Property("TabularSectionName") Then
		If FieldDetails.NameContent.Count() > 1 Then
			FieldDetails.Insert("NextFieldTables", New Array);
			If IndexOf = 1 Then
				FieldDetails.NextFieldTables.Add(Undefined);
			EndIf;
		EndIf;
		If IndexOf = 0 And Not Context.TablesTypeProperties.IsReferenceType Then
			AddMainFieldOrder(CurrentFieldProperties, Context);
		EndIf;
	EndIf;
	
	For Each FieldNode In FieldDetails.Properties.FieldNodes Do
		If CurrentFieldProperties.Property("DefaultOrder")
		   And Not FieldNode.Property("DefaultOrder") Then
			FieldNode.Insert("DefaultOrder", CurrentFieldProperties.DefaultOrder);
		EndIf;
		If FieldDetails.Property("NextFieldTables")
		   And Not FieldNode.Property("NextFieldTables") Then
			FieldNode.Insert("NextFieldTables", FieldDetails.NextFieldTables);
		EndIf;
		If Not FieldNode.Property("FieldTypes") Then
			FieldNode.Insert("FieldTypes", New Array);
			SetFieldContainsNull(FieldNode, CurrentFieldProperties, Context);
		EndIf;
		If CurrentFieldProperties.Property("TabularSectionName")
		   And Upper(CurrentFieldProperties.TabularSectionName) = Upper(FieldDetails.NameContent[0]) Then
			
			FieldNode.FieldTypes.Add(CurrentFieldProperties.TabularSectionName);
		EndIf;
		If IndexOf > FieldNode.FieldTypes.Count() - 1 Then
			FieldNode.FieldTypes.Add(CurrentFieldProperties.Type);
		EndIf;
		FieldNode.FieldTypes[IndexOf] = New TypeDescription(FieldNode.FieldTypes[IndexOf],
			CurrentFieldProperties.Type.Types());
	EndDo;
	
	// Add field types as String to check changes in internal procedures.
	FullFieldName1 = Context.TablesTypeProperties.LanguageRussian + "." + Upper(Context.MetadataTables.Name);
	
	If CurrentFieldProperties.Property("TabularSectionName") Then
		FullFieldName1 = FullFieldName1 + "." + Upper(CurrentFieldProperties.TabularSectionName);
	EndIf;
	
	FullFieldName1 = FullFieldName1 + "." + FieldDetails.NameContent[IndexOf];
	
	If Not FieldDetails.Property("AllFields") Then
		FieldDetails.Insert("AllFields",       New Map);
		FieldDetails.Insert("AllFieldsTypes", New ValueList);
	EndIf;
	If FieldDetails.AllFields.Get(FullFieldName1) <> Undefined Then
		Return;
	EndIf;
	FieldDetails.AllFields.Insert(FullFieldName1, True);
	
	TypesString = DataStringForHashing(CurrentFieldProperties.Type);
	FieldDetails.AllFieldsTypes.Add(TypesString, FullFieldName1);
	
EndProcedure

// For the CheckTableField procedure.
Procedure FillFieldTypesAsStringAdditional(FieldDetails)
	
	If FieldDetails.AllFieldsTypes.Count() > 1 Then
		FieldDetails.AllFieldsTypes.SortByPresentation();
	EndIf;
	TypesString = StrConcat(FieldDetails.AllFieldsTypes.UnloadValues(), Chars.LF);
	FieldNodes = FieldDetails.Properties.FieldNodes;
	
	For Each FieldNode In FieldNodes Do
		FieldNode.Insert("TypesString", TypesString);
	EndDo;
	
	FieldDetails.Delete("AllFields");
	FieldDetails.Delete("AllFieldsTypes");
	
EndProcedure

// For the AddFieldTypesAdditional procedure.
Procedure AddMainFieldOrder(CurrentFieldProperties, Context)
	
	If CurrentFieldProperties.Collection = "SpecialFields" Then
		Return; // It is set in the FieldOrTabularSectionProperties function.
	EndIf;
	
	MetadataTables = Context.MetadataTables; // MetadataObjectInformationRegister
	FieldMetadata    = CurrentFieldProperties.Metadata;
	
	If CurrentFieldProperties.Collection = "StandardAttributes" Then
		IndexOf = 0;
		For Each StandardAttribute In MetadataTables.StandardAttributes Do
			If StandardAttribute = FieldMetadata Then
				Break;
			EndIf;
			IndexOf = IndexOf + 1;
		EndDo;
		Number = 100 + IndexOf + 1;
		
	ElsIf CurrentFieldProperties.Collection = "Dimensions" Then
		Number = 200 + MetadataTables.Dimensions.IndexOf(FieldMetadata) + 1;
		
	ElsIf CurrentFieldProperties.Collection = "Resources" Then
		Number = 300 + MetadataTables.Resources.IndexOf(FieldMetadata) + 1;
		
	ElsIf CurrentFieldProperties.Collection = "Attributes" Then
		Number = 400 + MetadataTables.Attributes.IndexOf(FieldMetadata) + 1;
		
	ElsIf CurrentFieldProperties.Collection = "CommonAttributes" Then
		Number = 500 + Metadata.CommonAttributes.IndexOf(FieldMetadata) + 1;
	EndIf;
	
	CurrentFieldProperties.Insert("DefaultOrder", String(Number));
	
EndProcedure

// For the AddFieldTypesAdditional procedure.
Procedure SetFieldContainsNull(FieldNode, CurrentFieldProperties, Context)
	
	If Context.TablesTypeProperties.CollectionName <> "Catalogs"
	   And Context.TablesTypeProperties.CollectionName <> "ChartsOfCharacteristicTypes"
	 Or Not Context.MetadataTables.Hierarchical Then
		
		Return;
	EndIf;
	
	If Context.TablesTypeProperties.CollectionName = "Catalogs"
	   And Context.MetadataTables.HierarchyType
	       <> Metadata.ObjectProperties.HierarchyType.HierarchyFoldersAndItems Then
		
		Return;
	EndIf;
	
	If CurrentFieldProperties.Property("TabularSectionName") Then
		If CurrentFieldProperties.Property("TabularSectionMetadata")
		   And CurrentFieldProperties.TabularSectionMetadata.Use
		      <> Metadata.ObjectProperties.AttributeUse.ForFolderAndItem Then
			
			FieldNode.Insert("FieldContainsNull");
		EndIf;
		
		Return;
	EndIf;
	
	If CurrentFieldProperties.Collection = "Attributes"
	   And CurrentFieldProperties.Metadata.Use
	      <> Metadata.ObjectProperties.AttributeUse.ForFolderAndItem Then
		
		FieldNode.Insert("FieldContainsNull");
	EndIf;
	
EndProcedure

// For the CheckFieldTablesAndFieldsTypes procedure.
Procedure CheckTableExtensions(TableFields, Context)
	
	TablesTypeProperties = Context.TablesTypeProperties;
	
	If TablesTypeProperties.TabularPartCollections.Count() = 0
	   And TablesTypeProperties.CollectionName <> "CalculationRegisters" Then
		Return;
	EndIf;
	
	MetadataTables = Context.MetadataTables;
	
	For Each TableExtension In TableFields.Value.Extensions Do
		
		If TablesTypeProperties.CollectionName = "CalculationRegisters" Then
			ExtensionMetadata = MetadataTables.Recalculations.Find(TableExtension.Key);
		Else
			For Each TabularSectionsCollection In TablesTypeProperties.TabularPartCollections Do
				If TabularSectionsCollection.Key = "StandardTabularSections" Then
					StandardTabularSections = MetadataTables.StandardTabularSections; // StandardTabularSectionDescriptions
					For Each StandardTabularSection In StandardTabularSections Do
						If Upper(TableExtension.Key) = Upper(StandardTabularSection.Name) Then
							ExtensionMetadata = StandardTabularSection;
							Break;
						EndIf;
					EndDo;
				Else
					ExtensionMetadata = MetadataTables[TabularSectionsCollection.Key].Find(TableExtension.Key);
				EndIf;
				If ExtensionMetadata <> Undefined Then
					Break;
				EndIf;
			EndDo;
		EndIf;
		If ExtensionMetadata = Undefined Then
			Continue;
		EndIf;
		TableExtension.Value.TableExists = True;
		
		For Each TableField In TableExtension.Value.Fields Do
			FieldDetails = New Structure;
			FieldDetails.Insert("NameContent", StrSplit(TableField.Key, "."));
			FieldDetails.Insert("Properties",    TableField.Value);
			FieldDetails.Insert("FieldType",     New TypeDescription);
			
			IndexOf = 0;
			If TablesTypeProperties.CollectionName = "CalculationRegisters" Then
				FieldProperties = RecalculationFieldProperties(FieldDetails.NameContent[IndexOf],
					ExtensionMetadata, MetadataTables);
			Else
				FieldProperties = TabularSectionFieldProperties(FieldDetails.NameContent[IndexOf],
					ExtensionMetadata, TabularSectionsCollection.Key, MetadataTables);
			EndIf;
			
			If FieldProperties = Undefined Then
				FieldDetails.Properties.FieldWithError = IndexOf + 1;
				FieldDetails.Properties.ErrorKind = "NotFound4";
				Continue;
			EndIf;
			CheckNextPointSeparatedField(FieldDetails, IndexOf, FieldProperties, Context);
			FillFieldTypesAsStringAdditional(FieldDetails);
			If FieldDetails.Properties.FieldWithError = 0 Then
				CheckFieldTypes(FieldDetails, Context);
			EndIf;
		EndDo;
		
	EndDo;
	
EndProcedure

// For the CheckFieldTablesAndFieldsTypes and CheckTableExtensions procedures.
Procedure CheckFieldTypes(FieldDetails, Context)
	
	FieldTypesDetails = FieldDetails.FieldType;
	
	For Each TypeDetails In FieldDetails.Properties.ContainsTypes Do
		TypeProperties = TypeDetails.Value;
		If ValueIsFilled(TypeProperties.TypeCollectionName)
		   And Metadata[TypeProperties.TypeCollectionName].Find(TypeProperties.TypeCollectionObjectName) = Undefined Then
			Continue;
		EndIf;
		Type = Type(TypeDetails.Value.TypeName);
		TypeProperties.ContainsType = FieldTypesDetails.ContainsType(Type);
	EndDo;
	
EndProcedure

// For the CheckFieldTablesAndFieldsTypes procedure.
//
// Parameters:
//    TableFields - See NewCollectionComponents
//
Procedure CheckPredefinedTableValues(TableFields, Context)
	
	TablesTypeProperties = Context.TablesTypeProperties;
	
	TableProperties = TableFields.Value; // See NewTableProperties
	If TableProperties.Predefined.Count() = 0 Then
		Return;
	EndIf;
	
	If TablesTypeProperties.HasPredefined Then
		MetadataTables = Context.MetadataTables;
		
		If TablesTypeProperties.CollectionName = "Enums" Then
			PredefinedItemsNames = New Array;
			For Each EnumerationValue In MetadataTables.EnumValues Do
				CurrentEnumValue = EnumerationValue; // MetadataObjectEnumValue
				PredefinedItemsNames.Add(CurrentEnumValue.Name);
			EndDo;
		Else
			PredefinedItemsNames = New Array(MetadataTables.GetPredefinedNames());
		EndIf;
	Else
		PredefinedItemsNames = New Array;
	EndIf;
	
	PredefinedItemsNames.Add("EmptyRef");
	PredefinedItemsNames.Add("EmptyRef");
	
	For Each Predefined In TableProperties.Predefined Do
		For Each PredefinedItemName In PredefinedItemsNames Do
			If Upper(PredefinedItemName) = Predefined.Key Then
				Predefined.Value.NameExists = True;
				Break;
			EndIf;
		EndDo;
	EndDo;
	
EndProcedure


// For the RestrictionStructure function.
Procedure MarkIncorrectFieldsTablesAndFieldsTypesNames(TablesFields, Context)
	
	For Each TablesType In TablesFields Do
		For Each TableDetails In TablesType.Value Do
			TableProperties = TableDetails.Value; // See NewTableProperties
			
			If Not TableProperties.TableExists Then
				For Each Source In TableProperties.Sources Do
					SetErrorInRow(Source, StringFunctionsClientServer.SubstituteParametersToString(
							NStr("en = 'Table ""%1"" does not exist.';"), Source.Chars), , 2);
				EndDo;
				If TableProperties.Property("FirstField")
				   And TableProperties.FirstField.FirstSource <> Undefined Then
					
					SetErrorInFieldNameString(Context, TableProperties.FirstField.FirstSource.Key,
						NStr("en = 'The field does not exist as non-existent table ""%1"" is specified.';"), 0, ,
						TableProperties.FirstField.FirstSource.Value);
				EndIf;
				For Each PredefinedItemDetails In TableProperties.Predefined Do
					For Each Source In PredefinedItemDetails.Value.Sources Do
						NameContent = StrSplit(Source.Chars, ".");
						
						SetErrorInRow(Source, StringFunctionsClientServer.SubstituteParametersToString(
								NStr("en = 'The predefined value does not exist as non-existent table ""%1"" is specified.';"),
								NameContent[0] + "." + NameContent[1]), , 2);
					EndDo;
				EndDo;
				Continue;
			EndIf;
			
			For Each PredefinedItemDetails In TableProperties.Predefined Do
				PredefinedOptionProperties = PredefinedItemDetails.Value;
				If PredefinedOptionProperties.NameExists Then
					Continue;
				EndIf;
				For Each Source In PredefinedOptionProperties.Sources Do
					NameContent = StrSplit(Source.Chars, ".");
					Source.ErrorPosition = StrLen(NameContent[0] + "." + NameContent[1]) + 1;
					Source.ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
						NStr("en = 'Predefined value ""%1"" does not exist.';"), NameContent[2]);
				EndDo;
			EndDo;
			
			For Each FieldDetails In TableProperties.Fields Do
				MarkIncorrectFieldAndFieldTypes(FieldDetails, Context);
			EndDo;
			
			For Each ExtensionDetails In TableProperties.Extensions Do
				ExtensionProperties1 = ExtensionDetails.Value;
				If Not ExtensionProperties1.TableExists Then
					For Each Source In ExtensionProperties1.Sources Do
						SetErrorInRow(Source,
							StringFunctionsClientServer.SubstituteParametersToString(
								NStr("en = 'Table ""%1"" does not exist.';"), Source.Chars), , 2);
					EndDo;
					If ExtensionProperties1.Property("FirstField")
					   And ExtensionProperties1.FirstField.FirstSource <> Undefined Then
						
						SetErrorInFieldNameString(Context, ExtensionProperties1.FirstField.FirstSource.Key,
							NStr("en = 'The field does not exist as non-existent table ""%1"" is specified.';"), 0, ,
							ExtensionProperties1.FirstField.FirstSource.Value);
					EndIf;
					Continue;
				EndIf;
				For Each FieldDetails In ExtensionProperties1.Fields Do
					MarkIncorrectFieldAndFieldTypes(FieldDetails, Context);
				EndDo;
			EndDo;
			
		EndDo;
	EndDo;
	
EndProcedure

// For the MarkIncorrectFieldsTablesAndFieldsTypesNames procedure.
Procedure MarkIncorrectFieldAndFieldTypes(FieldDetails, Context)
	
	FieldProperties = FieldDetails.Value;
	If FieldProperties.FieldWithError = 1 Then
		For Each SourceDetails In FieldDetails.Value.Sources Do
			EOF = False;
			If FieldProperties.ErrorKind = "TabularSectionNoField" Then
				EOF = True;
				ErrorTemplate = NStr("en = 'A field is missing after the ""%1"" tabular section of the ""%2"" table.';");
				
			ElsIf FieldProperties.ErrorKind = "AdditionalTableTabularSection" Then
				ErrorTemplate = NStr("en = 'Tabular section ""%1"" of the additional table ""%2"" is not supported.';");
				
			ElsIf FieldProperties.ErrorKind = "Illegal" Then
				ErrorTemplate = NStr("en = 'The ""%1"" field of the ""%2"" table is not allowed.';");
				
			ElsIf FieldProperties.ErrorKind = "Prohibited" Then
				ErrorTemplate = NStr("en = 'The ""%1"" field of the ""%2"" table is not allowed.';");
			Else
				ErrorTemplate = NStr("en = 'Field ""%1"" of table ""%2"" does not exist.';");
			EndIf;
			SetErrorInFieldNameString(Context,
				 SourceDetails.Key, ErrorTemplate, 1, True, SourceDetails.Value, EOF);
		EndDo;
		Return;
	EndIf;
	
	If FieldProperties.FieldWithError > 1 Then
		For Each SourceDetails In FieldDetails.Value.Sources Do
			If FieldProperties.ErrorKind = "TabularSectionAfterDot" Then
				ErrorTemplate = NStr("en = 'Cannot address the ""%1"" tabular section using dot syntax.';");
				
			ElsIf FieldProperties.ErrorKind = "Illegal" Then
				ErrorTemplate = NStr("en = 'The ""%1"" field is not allowed.';");
				
			ElsIf FieldProperties.ErrorKind = "Prohibited" Then
				ErrorTemplate = NStr("en = 'The ""%1"" field is not allowed.';");
			Else
				ErrorTemplate = NStr("en = 'Field ""%1"" does not exist.';");
			EndIf;
			SetErrorInFieldNameString(Context,
				SourceDetails.Key, ErrorTemplate, FieldProperties.FieldWithError, True);
		EndDo;
		Return;
	EndIf;
	
	NameContent = StrSplit(FieldDetails.Key, ".");
	If NameContent.Count() > 1
	   And (    NameContent[1] = Upper("Ref")
	      Or NameContent[1] = Upper("Ref") )
	   And FieldProperties.Collection <> "TabularSections"
	   And FieldProperties.Collection <> "StandardTabularSections" Then
		
			For Each SourceDetails In FieldDetails.Value.Sources Do
				ErrorTemplate = NStr("en = 'Redundant syntax: a dot operator and the ""%1"" field after a field.';");
				SetErrorInFieldNameString(Context,
					SourceDetails.Key, ErrorTemplate, 2, True);
		EndDo;
		Return;
	EndIf;
	
	For Each TypeDetails In FieldProperties.ContainsTypes Do
		TypeProperties = TypeDetails.Value;
		For Each SourceDetails In TypeDetails.Value.Sources Do
			If TypeOf(SourceDetails.Key) = Type("ValueTableRow") Then
				If Not TypeProperties.ContainsType Then
					SetErrorInRow(SourceDetails.Key,
						StringFunctionsClientServer.SubstituteParametersToString(
							NStr("en = 'Type ""%2"" does not exist for field ""%1"".';"),
							SourceDetails.Value.Chars,
							SourceDetails.Key.Chars),
						, 2);
				EndIf;
			EndIf;
		EndDo;
	EndDo;
	
EndProcedure

// For the MarkIncorrectFieldsTablesAndFieldsTypesNames procedure.
Procedure SetErrorInFieldNameString(Context, String, ErrorTemplate, FieldWithError,
			InsertName = False, Table = Null, EOF = False)
	
	If ValueIsFilled(String.ErrorText) Then
		Return;
	EndIf;
	
	If TypeOf(InsertName) = Type("String") Then
		NameContent = StrSplit(InsertName, ".");
		InsertName = True;
	Else
		NameContent = StrSplit(String.Chars, ".");
	EndIf;
	
	If NameContent.Count() > 1
	   And Context.Aliases.Get(Upper(NameContent[0])) <> Undefined Then
		
		String.ErrorPosition = StrLen(NameContent[0]) + 1;
		NameContent.Delete(0);
	EndIf;
	
	For Number = 1 To FieldWithError - 1 Do
		String.ErrorPosition = String.ErrorPosition + StrLen(NameContent[0]) + 1;
		NameContent.Delete(0);
	EndDo;
	If EOF Then
		String.ErrorPosition = String.ErrorPosition + StrLen(NameContent[0]);
	EndIf;
	FieldName = NameContent[0];
	
	If InsertName And Table <> Null Then
		String.ErrorText = StringFunctionsClientServer.SubstituteParametersToString(ErrorTemplate,
			FieldName, ?(ValueIsFilled(Table), Table, Context.MainTable));
			
	ElsIf InsertName Then
		String.ErrorText = StringFunctionsClientServer.SubstituteParametersToString(ErrorTemplate, FieldName);
		
	ElsIf Table <> Null Then
		String.ErrorText = StringFunctionsClientServer.SubstituteParametersToString(ErrorTemplate,
			?(ValueIsFilled(Table), Table, Context.MainTable));
	Else
		String.ErrorText = ErrorTemplate;
	EndIf;
	
EndProcedure

#EndRegion

#EndRegion

#Region AccessUpdateProgressUpdate

// Returns:
//  Structure:
//   * ListsRows - Map
//   * ListsProperties - Map
//   * KeysCount - Number
//   * LatestUpdateDate - Date
//
Function NewStorableProgressUpdateData() Export
	
	StoredData = New Structure;
	StoredData.Insert("ListsRows",    New Map);
	StoredData.Insert("ListsProperties",  New Map);
	StoredData.Insert("KeysCount", 0);
	StoredData.Insert("LatestUpdateDate", '00010101');
	
	Return StoredData;
	
EndFunction

// Parameters:
//  Context - Structure:
//   * Version - Number
//   * StoredData - See NewStorableProgressUpdateData
//   * CalculateByDataAmount - Boolean
//   * ShowProcessedLists - Boolean
//   * IsRepeatedProgressUpdate - Boolean
//   * UpdatedTotal - Number
//   * ProgressUpdatePeriod - Number
//   * ProgressAutoUpdate - Boolean
//   * AddedRows - Array
//   * DeletedRows - Map
//   * ModifiedRows - Map
//   * AccessUpdateInProgress - Boolean
//  
//  ResultAddress - String
//
Procedure UpdateProgressInBackground(Context, ResultAddress) Export
	
	If Context.Property("Version") And Context.Version = 1 Then
		Try
			RefreshProgressBar(Context);
		Except
			ErrorInfo = ErrorInfo();
			If StandardSubsystemsServer.ThisErrorRequirementRestartSession(ErrorInfo) Then
				ErrorText = ErrorProcessing.BriefErrorDescription(ErrorInfo);
			Else
				ErrorText = ErrorProcessing.DetailErrorDescription(ErrorInfo);
			EndIf;
			Context.Insert("ErrorText", ErrorText);
		EndTry;
	Else
		Context.Insert("ErrorText",
			NStr("en = 'The application version is updated. Restart the client session.';"));
	EndIf;
	
	PutToTempStorage(Context, ResultAddress);
	
EndProcedure

Procedure RefreshProgressBar(Context)
	
	ProgressUpdateStartDate = CurrentSessionDate();
	TimeConsumingOperations.ReportProgress(0); // Update progress.
	
	ListsRows   = Context.StoredData.ListsRows;
	ListsProperties = Context.StoredData.ListsProperties;
	If Not Context.IsRepeatedProgressUpdate Then
		Context.StoredData.LatestUpdateDate = '00010101';
	EndIf;
	
	ActiveParameters = Undefined; // See ActiveAccessRestrictionParameters
	TablesIDs = ListsWithRestrictionIDs(ActiveParameters);
	
	If Context.ShowProcessedLists Then
		For Each KeyAndValue In TablesIDs Do
			If ListsRows.Get(KeyAndValue.Value) <> Undefined Then
				Continue;
			EndIf;
			AddNewListRow(Context, KeyAndValue.Value, KeyAndValue.Key);
		EndDo;
	EndIf;
	
	Query = New Query;
	Query.SetParameter("MaxDate", MaxDateOnContinue());
	Query.SetParameter("LatestUpdateDate", Context.StoredData.LatestUpdateDate);
	Query.SetParameter("BlankUUID",
		CommonClientServer.BlankUUID());
	
	Context.StoredData.LatestUpdateDate = ProgressUpdateStartDate;
	
	QueriesTexts = New Array;
	QueriesTexts.Add(
	"SELECT
	|	AllUpdateLists.List AS List,
	|	MAX(AllUpdateLists.ItemsUpdate) AS ItemsUpdate,
	|	MAX(AllUpdateLists.AccessKeysUpdate) AS AccessKeysUpdate
	|FROM
	|	(SELECT DISTINCT
	|		DataAccessKeysUpdate.List AS List,
	|		TRUE AS ItemsUpdate,
	|		FALSE AS AccessKeysUpdate
	|	FROM
	|		InformationRegister.DataAccessKeysUpdate AS DataAccessKeysUpdate
	|	
	|	UNION ALL
	|	
	|	SELECT DISTINCT
	|		UsersAccessKeysUpdate.List,
	|		FALSE,
	|		TRUE
	|	FROM
	|		InformationRegister.UsersAccessKeysUpdate AS UsersAccessKeysUpdate) AS AllUpdateLists
	|
	|GROUP BY
	|	AllUpdateLists.List");
	
	QueriesTexts.Add(
	"SELECT
	|	UpdateKeys.List AS List,
	|	UpdateKeys.ForExternalUsers AS ForExternalUsers,
	|	UpdateKeys.UniqueKey = &BlankUUID AS IsMainRecord,
	|	MAX(UpdateKeys.JobSize) AS JobSize,
	|	MAX(UpdateKeys.RegisterRecordChangeDate) AS MaxChangeDate,
	|	MIN(UpdateKeys.RegisterRecordChangeDate) AS MinChangeDate
	|FROM
	|	InformationRegister.DataAccessKeysUpdate AS UpdateKeys
	|WHERE
	|	UpdateKeys.RegisterRecordChangeDate >= &LatestUpdateDate
	|	AND UpdateKeys.List <> UNDEFINED
	|
	|GROUP BY
	|	UpdateKeys.List,
	|	UpdateKeys.ForExternalUsers,
	|	UpdateKeys.UniqueKey = &BlankUUID
	|TOTALS BY
	|	List,
	|	ForExternalUsers");
	
	QueriesTexts.Add(StrReplace(QueriesTexts[1],
		"InformationRegister.DataAccessKeysUpdate",
		"InformationRegister.UsersAccessKeysUpdate"));
	
	If Context.CalculateByDataAmount Then
		QueriesTexts.Add(
		"SELECT
		|	UpdateKeys.List AS List,
		|	UpdateKeys.ForExternalUsers AS ForExternalUsers,
		|	UpdateKeys.JobParameters AS JobParameters
		|FROM
		|	InformationRegister.DataAccessKeysUpdate AS UpdateKeys
		|WHERE
		|	UpdateKeys.RegisterRecordChangeDate >= &LatestUpdateDate
		|	AND UpdateKeys.UniqueKey = &BlankUUID
		|	AND UpdateKeys.List <> UNDEFINED
		|TOTALS BY
		|	List");
		
		QueriesTexts.Add(StrReplace(QueriesTexts[3],
			"InformationRegister.DataAccessKeysUpdate",
			"InformationRegister.UsersAccessKeysUpdate"));
		
		QueriesTexts.Add(
		"SELECT
		|	COUNT(*) AS Count
		|FROM
		|	Catalog.AccessKeys AS AccessKeys");
	EndIf;
	
	Query.Text = StrConcat(QueriesTexts, Common.QueryBatchSeparator());
	QueryResults = Query.ExecuteBatch();
	
	AllUpdateLists = QueryResults[0].Unload();
	NewLists = New Array;
	
	For Each UpdateList1 In AllUpdateLists Do
		If Not ValueIsFilled(UpdateList1.List) Then
			Continue;
		EndIf;
		String = ListsRows.Get(UpdateList1.List);
		If String = Undefined Then
			NewLists.Add(UpdateList1.List);
		EndIf;
	EndDo;
	
	If NewLists.Count() > 0 Then
		MetadataObjectsByIDs = Common.MetadataObjectsByIDs(NewLists, False);
		For Each NewList In NewLists Do
			MetadataObject = MetadataObjectsByIDs.Get(NewList);
			If MetadataObject = Undefined Then
				Continue;
			ElsIf TypeOf(MetadataObject) = Type("MetadataObject") Then
				TableName = MetadataObject.FullName();
			Else
				TableName = "";
			EndIf;
			AddNewListRow(Context, NewList, TableName);
		EndDo;
	EndIf;
	
	ElementsCountUpdateStrings = New Array;
	AccessKeysCountUpdateStrings = New Array;
	LinesToDelete = New Array;
	For Each KeyAndValue In ListsRows Do
		String = KeyAndValue.Value;
		UpdateList1 = AllUpdateLists.Find(String.List, "List");
		If UpdateList1 = Undefined And Not Context.ShowProcessedLists Then
			LinesToDelete.Add(String);
			Continue;
		EndIf;
		ListProperties = ListsProperties.Get(String.List);
		If UpdateList1 = Undefined Or Not UpdateList1.ItemsUpdate Then
			ListProperties.ItemsUpdateJobSize = 0;
			ListProperties.LastUpdatedItem = Null;
			ListProperties.ExternalUsersItemsUpdateJobSize = 0;
			ListProperties.LastUpdatedItemForExtrenalUsers = Null;
			String.ProcessedUsersItemsShare = 1;
			String.ProcessedExternalUsersItemsShare = 1;
			If Context.CalculateByDataAmount Then
				If String.ItemsProcessed <> 100 Then
					ElementsCountUpdateStrings.Add(String);
				EndIf;
			Else
				ResetItemsCount(String, Context);
			EndIf;
			UpdateValueInRow(String.ItemsProcessed, 100, String, Context);
		EndIf;
		If UpdateList1 = Undefined Or Not UpdateList1.AccessKeysUpdate Then
			ListProperties.AccessKeysUpdateJobSize = 0;
			ListProperties.LastUpdatedAccessKey = Null;
			ListProperties.ExternalUsersAccessKeysUpdateJobSize = 0;
			ListProperties.LastUpdatedAccessKeyForExtrenalUsers = Null;
			String.ProcessedUsersAccessKeysShare = 1;
			String.ProcessedExternalUsersAccessKeysShare = 1;
			If Context.CalculateByDataAmount Then
				If String.AccessKeysProcessed <> 100 Then
					AccessKeysCountUpdateStrings.Add(String);
				EndIf;
			Else
				ResetAccessKeysCount(String, Context);
			EndIf;
			UpdateValueInRow(String.AccessKeysProcessed, 100, String, Context);
		EndIf;
		If UpdateList1 = Undefined Then
			UpdateValueInRow(String.LatestUpdate, '00010101', String, Context);
			UpdateValueInRow(String.FirstUpdateSchedule, MaxDate(), String, Context);
		EndIf;
	EndDo;
	
	For Each RowToDelete In LinesToDelete Do
		ListsRows.Delete(RowToDelete.List);
		ListsProperties.Delete(RowToDelete.List);
		IndexOf = Context.AddedRows.Find(RowToDelete);
		If IndexOf <> Undefined Then
			Context.AddedRows.Delete(IndexOf);
			Continue;
		EndIf;
		Context.DeletedRows.Insert(RowToDelete.List, True);
	EndDo;
	
	If Context.CalculateByDataAmount Then
		SelectionByLists = QueryResults[3].Select(QueryResultIteration.ByGroups);
		While SelectionByLists.Next() Do
			ListProperties = ListsProperties.Get(SelectionByLists.List);
			If ListProperties = Undefined Then
				Continue;
			EndIf;
			SelectionByUsersKinds = SelectionByLists.Select();
			While SelectionByUsersKinds.Next() Do
				If SelectionByUsersKinds.ForExternalUsers Then
					ListProperties.LastUpdatedItemForExtrenalUsers
						= SelectionByUsersKinds.JobParameters;
				Else
					ListProperties.LastUpdatedItem
						= SelectionByUsersKinds.JobParameters;
				EndIf;
			EndDo;
		EndDo;
		SelectionByLists = QueryResults[4].Select(QueryResultIteration.ByGroups);
		While SelectionByLists.Next() Do
			ListProperties = ListsProperties.Get(SelectionByLists.List);
			If ListProperties = Undefined Then
				Continue;
			EndIf;
			SelectionByUsersKinds = SelectionByLists.Select();
			While SelectionByUsersKinds.Next() Do
				If SelectionByUsersKinds.ForExternalUsers Then
					ListProperties.LastUpdatedAccessKeyForExtrenalUsers
						= SelectionByUsersKinds.JobParameters;
				Else
					ListProperties.LastUpdatedAccessKey
						= SelectionByUsersKinds.JobParameters;
				EndIf;
			EndDo;
		EndDo;
	EndIf;
	
	ItemsUpdateLists = QueryResults[1].Unload(QueryResultIteration.ByGroups);
	For Each UpdateDetails1 In ItemsUpdateLists.Rows Do
		String = ListsRows.Get(UpdateDetails1.List);
		If String = Undefined Then
			Continue;
		EndIf;
		ListProperties = ListsProperties.Get(String.List);
		FillProcessedShares(String, UpdateDetails1, ListProperties, True, Context);
		If Not Context.CalculateByDataAmount Then
			Processed = ProcessedByShares(String.ProcessedUsersItemsShare,
				String.ProcessedExternalUsersItemsShare, String.TableName, ActiveParameters);
			UpdateValueInRow(String.ItemsProcessed, Processed, String, Context);
			ResetItemsCount(String, Context);
		Else
			If Context.IsRepeatedProgressUpdate Then
				ElementsCountUpdateStrings.Add(String);
			EndIf;
		EndIf;
	EndDo;
	
	AccessKeysUpdateLists = QueryResults[2].Unload(QueryResultIteration.ByGroups);
	For Each UpdateDetails1 In AccessKeysUpdateLists.Rows Do
		String = ListsRows.Get(UpdateDetails1.List);
		If String = Undefined Then
			Continue;
		EndIf;
		ListProperties = ListsProperties.Get(String.List);
		FillProcessedShares(String, UpdateDetails1, ListProperties, False, Context);
		If Not Context.CalculateByDataAmount Then
			Processed = ProcessedByShares(String.ProcessedUsersAccessKeysShare,
				String.ProcessedExternalUsersAccessKeysShare, String.TableName, ActiveParameters);
			UpdateValueInRow(String.AccessKeysProcessed, Processed, String, Context);
			ResetAccessKeysCount(String, Context);
		Else
			If Context.IsRepeatedProgressUpdate Then
				AccessKeysCountUpdateStrings.Add(String);
			EndIf;
		EndIf;
	EndDo;
	
	IndexOf = Context.AddedRows.Count() - 1;
	While IndexOf >= 0 Do
		If Not ValueIsFilled(Context.AddedRows[IndexOf].TableName) Then
			Context.AddedRows.Delete(IndexOf);
		EndIf;
		IndexOf = IndexOf - 1;
	EndDo;
	
	If Not Context.IsRepeatedProgressUpdate Then
		For Each RowDescription In ListsRows Do
			ElementsCountUpdateStrings.Add(RowDescription.Value);
			AccessKeysCountUpdateStrings.Add(RowDescription.Value);
		EndDo;
	EndIf;
	
	If Context.CalculateByDataAmount Then
		KeysCount = QueryResults[5].Unload()[0].Count;
		If Context.IsRepeatedProgressUpdate
		   And Context.StoredData.KeysCount <> KeysCount Then
			
			For Each RowDescription In ListsRows Do
				If AccessKeysCountUpdateStrings.Find(RowDescription.Value) = Undefined Then
					AccessKeysCountUpdateStrings.Add(RowDescription.Value);
				EndIf;
			EndDo;
		EndIf;
		Context.StoredData.KeysCount = KeysCount;
	Else
		Context.StoredData.KeysCount = 0;
	EndIf;
	
	If Context.CalculateByDataAmount Then
		CurrentContext = New Structure;
		CurrentContext.Insert("AddedRows",                       Context.AddedRows);
		CurrentContext.Insert("ModifiedRows",                        Context.ModifiedRows);
		CurrentContext.Insert("ListsProperties",                         ListsProperties);
		CurrentContext.Insert("ListsRows",                           ListsRows);
		CurrentContext.Insert("ActiveParameters",                    ActiveParameters);
		CurrentContext.Insert("ElementsCountUpdateStrings",     ElementsCountUpdateStrings);
		CurrentContext.Insert("AccessKeysCountUpdateStrings", AccessKeysCountUpdateStrings);
		CurrentContext.Insert("TablesIDs",                    TablesIDs);
		CurrentContext.Insert("StoredData",                          Context.StoredData);
		UpdatedTotal = 100;
		CalculateUpdatedByDataCountTotal(CurrentContext, UpdatedTotal);
	Else
		If Context.StoredData.Property("ItemsByListsCount") Then
			Context.StoredData.Delete("ItemsByListsCount");
			Context.StoredData.Delete("AccessKeysByListsCount");
		EndIf;
		CountTotal = TablesIDs.Count();
		If ListsRows.Count() > CountTotal Then
			CountTotal = ListsRows.Count();
		EndIf;
		UpdatedTotal = (100 + 100) * (CountTotal - ListsRows.Count());
		For Each KeyAndValue In ListsRows Do
			String = KeyAndValue.Value;
			UpdatedTotal = UpdatedTotal + String.ItemsProcessed + String.AccessKeysProcessed;
		EndDo;
		UpdatedTotal = UpdatedTotal / 2 / CountTotal;
	EndIf;
	If UpdatedTotal > 100 Then
		UpdatedTotal = 100;
	EndIf;
	Context.UpdatedTotal = Int(UpdatedTotal);
	
	UpdateTime = CurrentSessionDate() - ProgressUpdateStartDate;
	
	If Context.IsRepeatedProgressUpdate
	   And UpdateTime > Context.ProgressUpdatePeriod Then
		
		Context.ProgressUpdatePeriod = UpdateTime;
	Else
		Context.Delete("ProgressUpdatePeriod");
	EndIf;
	
	If Not Context.IsRepeatedProgressUpdate And UpdateTime > 60 Then
		Context.ProgressAutoUpdate = False;
	Else
		Context.Delete("ProgressAutoUpdate");
	EndIf;
	
EndProcedure

Procedure FillProcessedShares(String, UpdateDetails1, ListProperties, IsItemsProcessing, Context)
	
	For Each UpdateProperties In UpdateDetails1.Rows Do
		If IsItemsProcessing Then
			If UpdateProperties.ForExternalUsers Then
				JobSizeFieldName    = "ExternalUsersItemsUpdateJobSize";
				JobParametersFieldName = "LastUpdatedItemForExtrenalUsers";
				ShareFieldName              = "ProcessedExternalUsersItemsShare";
			Else
				JobSizeFieldName    = "ItemsUpdateJobSize";
				JobParametersFieldName = "LastUpdatedItem";
				ShareFieldName              = "ProcessedUsersItemsShare";
			EndIf;
		Else
			If UpdateProperties.ForExternalUsers Then
				JobSizeFieldName    = "ExternalUsersAccessKeysUpdateJobSize";
				JobParametersFieldName = "LastUpdatedAccessKeyForExtrenalUsers";
				ShareFieldName              = "ProcessedExternalUsersAccessKeysShare";
			Else
				JobSizeFieldName    = "AccessKeysUpdateJobSize";
				JobParametersFieldName = "LastUpdatedAccessKey";
				ShareFieldName              = "ProcessedUsersAccessKeysShare";
			EndIf;
		EndIf;
		MainRecordJobSize = ListProperties[JobSizeFieldName];
		NewRecordsJobSize = 0;
		For Each JobProperties In UpdateProperties.Rows Do
			If JobProperties.IsMainRecord Then
				If JobProperties.MaxChangeDate > String.LatestUpdate Then
					UpdateValueInRow(String.LatestUpdate,
						JobProperties.MaxChangeDate, String, Context);
				EndIf;
				MainRecordJobSize = JobProperties.JobSize;
			Else
				If JobProperties.MinChangeDate < String.FirstUpdateSchedule Then
					UpdateValueInRow(String.FirstUpdateSchedule,
						JobProperties.MinChangeDate, String, Context);
				EndIf;
				NewRecordsJobSize = JobProperties.JobSize;
			EndIf;
		EndDo;
		ListProperties[JobSizeFieldName] = MainRecordJobSize;
		If NewRecordsJobSize >= MainRecordJobSize Then
			ListProperties[JobParametersFieldName] = True;
			CurrentJobSize = NewRecordsJobSize;
		Else
			CurrentJobSize = MainRecordJobSize;
		EndIf;
		If CurrentJobSize = 1 Then
			String[ShareFieldName] = 0.99;
		ElsIf CurrentJobSize = 2 Then
			String[ShareFieldName] = 0.90;
		Else
			String[ShareFieldName] = 0.00;
		EndIf;
	EndDo;
	
EndProcedure

Function ProcessedByShares(ProcessedShareForUsers, ProcessedShareForExternalUsers, TableName, ActiveParameters)
	
	HasKeysForUsers = False;
	HasKeysForExternalUsers = False;
	Versions = ActiveParameters.ListsRestrictionsVersions.Get(TableName);
	If ValueIsFilled(Versions) Then
		HasKeysForUsers        = ValueIsFilled(StrGetLine(Versions, 1));
		HasKeysForExternalUsers = ValueIsFilled(StrGetLine(Versions, 2));
	EndIf;
	
	If ProcessedShareForUsers < 1 Then
		HasKeysForUsers = True;
	EndIf;
	If ProcessedShareForExternalUsers < 1 Then
		HasKeysForExternalUsers = True;
	EndIf;
	
	If HasKeysForUsers And HasKeysForExternalUsers Then
		Processed = Int((ProcessedShareForUsers
					+ ProcessedShareForExternalUsers) / 2 * 100);
		
	ElsIf HasKeysForUsers Then
		Processed = Int(ProcessedShareForUsers * 100);
	Else
		Processed = Int(ProcessedShareForExternalUsers * 100);
	EndIf;
	
	Return Processed;
	
EndFunction

Procedure ResetItemsCount(String, Context);
	
	UpdateValueInRow(String.ItemCount, 0, String, Context);
	UpdateValueInRow(String.ProcessedItemsCount, 0, String, Context);
	UpdateValueInRow(String.ItemsForUsersCount, 0, String, Context);
	UpdateValueInRow(String.ItemsForExternalUsersCount, 0, String, Context);
	UpdateValueInRow(String.RemainingItemsForUsersCount, 0, String, Context);
	UpdateValueInRow(String.LeftlUsersItemsShare, 0, String, Context);
	UpdateValueInRow(String.RemainingItemsForExternalUsersCount, 0, String, Context);
	UpdateValueInRow(String.LeftExternalUsersItemsShare, 0, String, Context);
	
EndProcedure

Procedure ResetAccessKeysCount(String, Context);
	
	UpdateValueInRow(String.AccessKeysCount, 0, String, Context);
	UpdateValueInRow(String.ProcessedAccessKeysCount, 0, String, Context);
	UpdateValueInRow(String.AccessKeysForUsersCount, 0, String, Context);
	UpdateValueInRow(String.AccessKeysForExternalUsersCount, 0, String, Context);
	UpdateValueInRow(String.RemainingAccessKeysForUsersCount, 0, String, Context);
	UpdateValueInRow(String.LeftUsersAccessKeysShare, 0, String, Context);
	UpdateValueInRow(String.RemainingAccessKeysForExternalUsersCount, 0, String, Context);
	UpdateValueInRow(String.LeftExternalUsersAccessKeysShare, 0, String, Context);
	
EndProcedure

Procedure AddNewListRow(Context, List, TableName)
	
	String = New Structure;
	String.Insert("List", List);
	String.Insert("ListPresentation", String(List));
	String.Insert("TableName", TableName);
	String.Insert("ItemsProcessed", 0);
	String.Insert("AccessKeysProcessed", 0);
	String.Insert("ItemCount", 0);
	String.Insert("AccessKeysCount", 0);
	String.Insert("ProcessedItemsCount", 0);
	String.Insert("ProcessedAccessKeysCount", 0);
	String.Insert("LatestUpdate", '00010101');
	String.Insert("FirstUpdateSchedule", MaxDate());
	
	String.Insert("ItemsForUsersCount", 0);
	String.Insert("ProcessedUsersItemsShare", 1);
	String.Insert("ItemsForExternalUsersCount", 0);
	String.Insert("ProcessedExternalUsersItemsShare", 1);
	String.Insert("AccessKeysForUsersCount", 0);
	String.Insert("ProcessedUsersAccessKeysShare", 1);
	String.Insert("AccessKeysForExternalUsersCount", 0);
	String.Insert("ProcessedExternalUsersAccessKeysShare", 1);
	
	String.Insert("RemainingItemsForUsersCount", 0);
	String.Insert("LeftlUsersItemsShare", 0);
	String.Insert("RemainingItemsForExternalUsersCount", 0);
	String.Insert("LeftExternalUsersItemsShare", 0);
	String.Insert("RemainingAccessKeysForUsersCount", 0);
	String.Insert("LeftUsersAccessKeysShare", 0);
	String.Insert("RemainingAccessKeysForExternalUsersCount", 0);
	String.Insert("LeftExternalUsersAccessKeysShare", 0);
	
	Context.StoredData.ListsRows.Insert(List, String);
	AddedRows = Context.AddedRows; // Array
	AddedRows.Add(String);
	
	Properties = New Structure;
	Properties.Insert("ItemsUpdateJobSize", 0);
	Properties.Insert("LastUpdatedItem", Null);
	Properties.Insert("AccessKeysUpdateJobSize", 0);
	Properties.Insert("LastUpdatedAccessKey", Null);
	
	Properties.Insert("ExternalUsersItemsUpdateJobSize", 0);
	Properties.Insert("LastUpdatedItemForExtrenalUsers", Null);
	Properties.Insert("ExternalUsersAccessKeysUpdateJobSize", 0);
	Properties.Insert("LastUpdatedAccessKeyForExtrenalUsers", Null);
	
	Context.StoredData.ListsProperties.Insert(List, Properties);
	
EndProcedure

// Parameters:
//  Context - Structure:
//   * AddedRows - Array
//   * ModifiedRows - Map
//   * ListsProperties - Map
//   * ListsRows - Map
//   * ActiveParameters - See ActiveAccessRestrictionParameters
//   * ElementsCountUpdateStrings - Array
//   * AccessKeysCountUpdateStrings - Array
//   * TablesIDs - See Common.MetadataObjectIDs
//   * StoredData - See NewStorableProgressUpdateData
//   * TablesTypesByNames - Map
//  
//  UpdatedTotal - Number
//
Procedure CalculateUpdatedByDataCountTotal(Context, UpdatedTotal)
	
	TablesTypesByNames = AccessManagementInternalCached.LanguageSyntax().TablesTypes.ByNames;
	Context.Insert("TablesTypesByNames", TablesTypesByNames);
	
	If Not Context.StoredData.Property("ItemsByListsCount") Then
		FilItemsAndAccessKeysCountByLists(Context);
	EndIf;
	
	UpdateItemsAndAccessKeysCount(Context);
	
	ItemsByListsCount     = Context.StoredData.ItemsByListsCount;
	AccessKeysByListsCount = Context.StoredData.AccessKeysByListsCount;
	
	TotalItemsCount = 0;
	For Each KeyAndValue In ItemsByListsCount Do
		TotalItemsCount = TotalItemsCount + KeyAndValue.Value;
	EndDo;
	TotalItemsCount = ?(TotalItemsCount = 0, 100, TotalItemsCount);
	
	TotalAccessKeysCount = 0;
	For Each KeyAndValue In AccessKeysByListsCount Do
		TotalAccessKeysCount = TotalAccessKeysCount + KeyAndValue.Value;
	EndDo;
	TotalAccessKeysCount = ?(TotalAccessKeysCount = 0, 100, TotalAccessKeysCount);
	
	UpdatedItemsTotal = 0;
	UpdatedAccessKeysTotal = 0;
	
	AddTotalItemsCount = 0;
	AddTotalAccessKeysCount = 0;
	
	TablesNamesWithItemsUpdate     = New Map;
	TablesNamesWithAccessKeysUpdate = New Map;
	
	For Each KeyAndValue In Context.ListsRows Do
		String = KeyAndValue.Value;
		
		ItemCount = ItemsByListsCount.Get(KeyAndValue.Value.TableName);
		If ItemCount = Undefined Then
			If ItemsByListsCount.Count() = 0 Then
				Addition = 1;
			Else
				Addition = Int(TotalItemsCount / ItemsByListsCount.Count() / 10);
				Addition = ?(Addition = 0, 1, Addition);
			EndIf;
			AddTotalItemsCount = AddTotalItemsCount + Addition;
			UpdatedItemsTotal = UpdatedItemsTotal + 100 * Addition;
		Else
			UpdatedItemsTotal = UpdatedItemsTotal + String.ItemsProcessed * ItemCount;
			TablesNamesWithItemsUpdate.Insert(KeyAndValue.Value.TableName, True);
		EndIf;
		
		AccessKeysCount = AccessKeysByListsCount.Get(KeyAndValue.Value.TableName);
		If AccessKeysCount = Undefined Then
			If AccessKeysByListsCount.Count() = 0 Then
				Addition = 1;
			Else
				Addition = Int(TotalAccessKeysCount / AccessKeysByListsCount.Count() / 10);
				Addition = ?(Addition = 0, 1, Addition);
			EndIf;
			AddTotalAccessKeysCount = AddTotalAccessKeysCount + Addition;
			UpdatedAccessKeysTotal = UpdatedAccessKeysTotal + 100 * Addition;
		Else
			UpdatedAccessKeysTotal = UpdatedAccessKeysTotal + String.AccessKeysProcessed * AccessKeysCount;
			TablesNamesWithAccessKeysUpdate.Insert(KeyAndValue.Value.TableName, True);
		EndIf;
	EndDo;
	
	UpdatedItemsCount1 = 0;
	For Each KeyAndValue In ItemsByListsCount Do
		If TablesNamesWithItemsUpdate.Get(KeyAndValue.Key) = Undefined Then
			UpdatedItemsCount1 = UpdatedItemsCount1 + KeyAndValue.Value;
		EndIf;
	EndDo;
	UpdatedItemsTotal = UpdatedItemsTotal + UpdatedItemsCount1  * 100;
		
	UpdatedAccessKeysCount = 0;
	For Each KeyAndValue In AccessKeysByListsCount Do
		If TablesNamesWithAccessKeysUpdate.Get(KeyAndValue.Key) = Undefined Then
			UpdatedAccessKeysCount = UpdatedAccessKeysCount + KeyAndValue.Value;
		EndIf;
	EndDo;
	UpdatedAccessKeysTotal = UpdatedAccessKeysTotal + UpdatedAccessKeysCount * 100;
	
	UpdatedItemsTotal = UpdatedItemsTotal
		/ (TotalItemsCount + AddTotalItemsCount);
	
	UpdatedAccessKeysTotal = UpdatedAccessKeysTotal
		/ (TotalAccessKeysCount + AddTotalAccessKeysCount);
	
	UpdatedTotal = (UpdatedItemsTotal + UpdatedAccessKeysTotal) / 2;
	
EndProcedure

Procedure FilItemsAndAccessKeysCountByLists(Context)
	
	ItemsByListsCount     = New Map;
	AccessKeysByListsCount = New Map;
	Context.StoredData.Insert("ItemsByListsCount",     ItemsByListsCount);
	Context.StoredData.Insert("AccessKeysByListsCount", AccessKeysByListsCount);
	
	QueryDetails = New Structure("Query, QueryPackageTexts", New Query, New Array);
	
	TablesToUpdate = New Map;
	TablesIDs = Context.TablesIDs;
	For Each String In Context.ElementsCountUpdateStrings Do
		If TablesIDs.Get(String.TableName) = String.List Then
			TablesToUpdate.Insert(String.TableName, String.List);
		EndIf;
	EndDo;
	For Each String In Context.AccessKeysCountUpdateStrings Do
		If TablesIDs.Get(String.TableName) = String.List Then
			TablesToUpdate.Insert(String.TableName, String.List);
		EndIf;
	EndDo;
	
	IndexOf = 0;
	TablesNames = New Array;
	For Each KeyAndValue In Context.TablesIDs Do
		If TablesToUpdate.Get(KeyAndValue.Key) = KeyAndValue.Value Then
			Continue;
		EndIf;
		TablesNames.Add(KeyAndValue.Key);
		String = New Structure("List, TableName", KeyAndValue.Value, KeyAndValue.Key);
		AddItemsCountQueryText(QueryDetails, String, IndexOf, Context, False);
		AddItemsCountQueryText(QueryDetails, String, IndexOf, Context, True);
		AddQueryTextOfAccessKeysCount(QueryDetails, String, IndexOf, False);
		AddQueryTextOfAccessKeysCount(QueryDetails, String, IndexOf, True);
	EndDo;
	
	If QueryDetails.QueryPackageTexts.Count() = 0 Then
		Return;
	EndIf;
	
	QueryResults = ExecuteQueriesPackageByParts(QueryDetails);
	
	IndexOf = 0;
	For Each TableName In TablesNames Do
		Selection = QueryResults[IndexOf].Select();
		ItemsForUsersCount = ?(Selection.Next(), Selection.Count, 0);
		IndexOf = IndexOf + 1;
		
		Selection = QueryResults[IndexOf].Select();
		ItemsForExternalUsersCount = ?(Selection.Next(), Selection.Count, 0);
		IndexOf = IndexOf + 1;
		
		ItemsByListsCount[TableName] = ItemsForUsersCount
			+ ItemsForExternalUsersCount;
		
		Selection = QueryResults[IndexOf].Select();
		AccessKeysForUsersCount = ?(Selection.Next(), Selection.Count, 0);
		IndexOf = IndexOf + 1;
		
		Selection = QueryResults[IndexOf].Select();
		AccessKeysForExternalUsersCount = ?(Selection.Next(), Selection.Count, 0);
		IndexOf = IndexOf + 1;
		
		AccessKeysByListsCount[TableName] = AccessKeysForUsersCount
			+ AccessKeysForExternalUsersCount;
	EndDo;
	
EndProcedure

Procedure UpdateItemsAndAccessKeysCount(Context)
	
	QueryDetails = New Structure("Query, QueryPackageTexts", New Query, New Array);
	IndexOf = 0;
	For Each String In Context.ElementsCountUpdateStrings Do
		AddItemsCountQueryText(QueryDetails, String, IndexOf, Context, False);
		AddItemsCountQueryText(QueryDetails, String, IndexOf, Context, True);
		AddQueryTextOfRemainingItemsCount(QueryDetails, String, IndexOf, Context, False);
		AddQueryTextOfRemainingItemsCount(QueryDetails, String, IndexOf, Context, True);
	EndDo;
	For Each String In Context.AccessKeysCountUpdateStrings Do
		AddQueryTextOfAccessKeysCount(QueryDetails, String, IndexOf, False);
		AddQueryTextOfAccessKeysCount(QueryDetails, String, IndexOf, True);
		AddQueryTextOfRemainingAccessKeysCount(QueryDetails, String, IndexOf, Context, False);
		AddQueryTextOfRemainingAccessKeysCount(QueryDetails, String, IndexOf, Context, True);
	EndDo;
	
	If QueryDetails.QueryPackageTexts.Count() = 0 Then
		Return;
	EndIf;
	
	QueryResults = ExecuteQueriesPackageByParts(QueryDetails);

	ItemsByListsCount     = Context.StoredData.ItemsByListsCount;
	AccessKeysByListsCount = Context.StoredData.AccessKeysByListsCount;
	ListsRestrictionsVersions         = Context.ActiveParameters.ListsRestrictionsVersions;
	TablesTypesByNames               = Context.TablesTypesByNames;
	
	IndexOf = 0;
	For Each String In Context.ElementsCountUpdateStrings Do
		Selection = QueryResults[IndexOf].Select();
		String.ItemsForUsersCount = ?(Selection.Next(), Selection.Count, 0);
		IndexOf = IndexOf + 1;
		
		Selection = QueryResults[IndexOf].Select();
		String.ItemsForExternalUsersCount = ?(Selection.Next(), Selection.Count, 0);
		IndexOf = IndexOf + 1;
		
		ItemCount = String.ItemsForUsersCount + String.ItemsForExternalUsersCount;
		If ValueIsFilled(String.TableName) Then
			ItemsByListsCount.Insert(String.TableName, ItemCount);
		EndIf;
		
		If ItemCount = 0 Then
			ResetItemsCount(String, Context);
			UpdateValueInRow(String.ItemsProcessed, 100, String, Context);
			IndexOf = IndexOf + 2;
		Else
			ProcessedItemsCount = 0;
			ListProperties = Context.ListsProperties.Get(String.List);
			HasKeysForUsers = False;
			HasKeysForExternalUsers = False;
			Versions = ListsRestrictionsVersions.Get(String.TableName);
			If ValueIsFilled(Versions) Then
				HasKeysForUsers        = ValueIsFilled(StrGetLine(Versions, 1));
				HasKeysForExternalUsers = ValueIsFilled(StrGetLine(Versions, 2));
			EndIf;
			NameContent = StrSplit(String.TableName, ".", False);
			TypeProperties = TablesTypesByNames.Get(Upper(NameContent[0]));
			For UsersKind = 0 To 1 Do
				If UsersKind = 0 Then
					LastUpdatedItem = ListProperties.LastUpdatedItem;
				Else
					LastUpdatedItem = ListProperties.LastUpdatedItemForExtrenalUsers;
				EndIf;
				If LastUpdatedItem = Null Or LastUpdatedItem = True Then
					RemainingItemsCount = -1;
				EndIf;
				If LastUpdatedItem <> Null Then
					If UsersKind = 0 Then
						HasKeysForUsers = True;
					Else
						HasKeysForExternalUsers = True;
					EndIf;
					If LastUpdatedItem <> True Then
						Selection = QueryResults[IndexOf].Select();
						RemainingItemsCount = ?(Selection.Next(), Selection.Count, 0);
					EndIf;
				EndIf;
				If RemainingItemsCount = -1 Then
					If UsersKind = 0 Then
						String.LeftlUsersItemsShare = 0;
					Else
						String.LeftExternalUsersItemsShare = 0;
					EndIf;
					RemainingItemsCount = 0;
				EndIf;
				If UsersKind = 0 Then
					If Not HasKeysForUsers Then
						String.RemainingItemsForUsersCount = 0;
						String.ItemsForUsersCount = 0;
					ElsIf TypeOf(RemainingItemsCount) = Type("Number") Then
						String.RemainingItemsForUsersCount
							= Int(String.ItemsForUsersCount * (1 - String.ProcessedUsersItemsShare
								- String.LeftlUsersItemsShare) + 0.99)
							+ Int(RemainingItemsCount * String.LeftlUsersItemsShare);
					EndIf;
					ProcessedItemsCount = ProcessedItemsCount
						+ (String.ItemsForUsersCount
							- String.RemainingItemsForUsersCount);
				Else
					If Not HasKeysForExternalUsers Then
						String.RemainingItemsForExternalUsersCount = 0;
						String.ItemsForExternalUsersCount = 0;
					ElsIf TypeOf(RemainingItemsCount) = Type("Number") Then
						String.RemainingItemsForExternalUsersCount
							= Int(String.ItemsForExternalUsersCount * (1 - String.ProcessedExternalUsersItemsShare
								- String.LeftExternalUsersItemsShare) + 0.99)
							+ Int(RemainingItemsCount * String.LeftExternalUsersItemsShare);
					EndIf;
					ProcessedItemsCount = ProcessedItemsCount
						+ (String.ItemsForExternalUsersCount
							- String.RemainingItemsForExternalUsersCount);
				EndIf;
				IndexOf = IndexOf + 1;
			EndDo;
			ItemCount = String.ItemsForUsersCount + String.ItemsForExternalUsersCount;
			If HasKeysForUsers And HasKeysForExternalUsers And TypeProperties.IsReferenceType Then
				ItemCount             = ItemCount / 2;
				ProcessedItemsCount = ProcessedItemsCount / 2;
			EndIf;
			UpdateValueInRow(String.ItemCount, ItemCount, String, Context);
			UpdateValueInRow(String.ProcessedItemsCount,
				Int(ProcessedItemsCount), String, Context);
			If String.ProcessedItemsCount > String.ItemCount Then
				UpdateValueInRow(String.ProcessedItemsCount,
					String.ItemCount, String, Context);
			EndIf;
			UpdateValueInRow(String.ItemsProcessed, ?(String.ItemCount = 0, 100,
				Int(String.ProcessedItemsCount / String.ItemCount * 100)), String, Context);
		EndIf;
	EndDo;
	
	For Each String In Context.AccessKeysCountUpdateStrings Do
		Selection = QueryResults[IndexOf].Select();
		AccessKeysForUsersCount = ?(Selection.Next(), Selection.Count, 0);
		IndexOf = IndexOf + 1;
		
		Selection = QueryResults[IndexOf].Select();
		AccessKeysForExternalUsersCount = ?(Selection.Next(), Selection.Count, 0);
		IndexOf = IndexOf + 1;
		
		AccessKeysCount = AccessKeysForUsersCount + AccessKeysForExternalUsersCount;
		UpdateValueInRow(String.AccessKeysCount, AccessKeysCount, String, Context);
		If ValueIsFilled(String.TableName) Then
			AccessKeysByListsCount.Insert(String.TableName, AccessKeysCount);
		EndIf;
		
		If String.AccessKeysCount = 0 Then
			ResetAccessKeysCount(String, Context);
			UpdateValueInRow(String.AccessKeysProcessed, 100, String, Context);
			IndexOf = IndexOf + 2;
		Else
			ProcessedAccessKeysCount = 0;
			ListProperties = Context.ListsProperties.Get(String.List);
			For UsersKind = 0 To 1 Do
				If UsersKind = 0 Then
					LastUpdatedAccessKey = ListProperties.LastUpdatedAccessKey;
				Else
					LastUpdatedAccessKey = ListProperties.LastUpdatedAccessKeyForExtrenalUsers;
				EndIf;
				If LastUpdatedAccessKey = Null Or LastUpdatedAccessKey = True Then
					RemainingAccessKeysCount = -1;
				Else
					Selection = QueryResults[IndexOf].Select();
					RemainingAccessKeysCount = ?(Selection.Next(), Selection.Count, 0);
				EndIf;
				If RemainingAccessKeysCount = -1 Then
					If UsersKind = 0 Then
						String.LeftUsersAccessKeysShare = 0;
					Else
						String.LeftExternalUsersAccessKeysShare = 0;
					EndIf;
					RemainingAccessKeysCount = 0;
				EndIf;
				If UsersKind = 0 Then
					If TypeOf(RemainingAccessKeysCount) = Type("Number") Then
						String.AccessKeysForUsersCount = AccessKeysForUsersCount;
						String.RemainingAccessKeysForUsersCount
							= Int(String.AccessKeysForUsersCount * (1 - String.ProcessedUsersAccessKeysShare
								- String.LeftUsersAccessKeysShare) + 0.99)
							+ Int(RemainingAccessKeysCount * String.LeftUsersAccessKeysShare);
					EndIf;
					ProcessedAccessKeysCount = ProcessedAccessKeysCount
						+ (String.AccessKeysForUsersCount
							- String.RemainingAccessKeysForUsersCount);
				Else
					If TypeOf(RemainingAccessKeysCount) = Type("Number") Then
						String.AccessKeysForExternalUsersCount = AccessKeysForExternalUsersCount;
						String.RemainingAccessKeysForExternalUsersCount
							= Int(String.AccessKeysForExternalUsersCount * (1 - String.ProcessedExternalUsersAccessKeysShare
								- String.LeftExternalUsersAccessKeysShare) + 0.99)
							+ Int(RemainingAccessKeysCount * String.LeftExternalUsersAccessKeysShare);
					EndIf;
					ProcessedAccessKeysCount = ProcessedAccessKeysCount
						+ (String.AccessKeysForExternalUsersCount
							- String.RemainingAccessKeysForExternalUsersCount);
				EndIf;
				IndexOf = IndexOf + 1;
			EndDo;
			UpdateValueInRow(String.ProcessedAccessKeysCount,
				Int(ProcessedAccessKeysCount), String, Context);
			If String.ProcessedAccessKeysCount > String.AccessKeysCount Then
				UpdateValueInRow(String.ProcessedAccessKeysCount,
					String.AccessKeysCount, String, Context);
			EndIf;
			UpdateValueInRow(String.AccessKeysProcessed,
				Int(String.ProcessedAccessKeysCount / String.AccessKeysCount * 100), String, Context);
		EndIf;
	EndDo;
	
EndProcedure

// Returns:
//  Array of QueryResult
//
Function ExecuteQueriesPackageByParts(QueryDetails)
	
	QueriesPackageResults = New Array;
	
	QueriesBatchTexts = New Array;
	For Each QueryText In QueryDetails.QueryPackageTexts Do
		If QueriesBatchTexts.Count() = 200 Then
			// 
			AddQueryResults(QueriesPackageResults, QueriesBatchTexts, QueryDetails);
			QueriesBatchTexts = New Array;
		EndIf;
		QueriesBatchTexts.Add(QueryText);
	EndDo;
	AddQueryResults(QueriesPackageResults, QueriesBatchTexts, QueryDetails);
	
	Return QueriesPackageResults;
	
EndFunction

Procedure AddQueryResults(QueriesPackageResults, QueriesBatchTexts, QueryDetails)
	
	Query = QueryDetails.Query;
	
	Query.Text = StrConcat(QueriesBatchTexts, Common.QueryBatchSeparator());
	QueryResults = Query.ExecuteBatch();
	Query.Text = "";
	
	For Each QueryResult In QueryResults Do
		QueriesPackageResults.Add(QueryResult);
	EndDo;
	
EndProcedure

Procedure UpdateValueInRow(PreviousValue2, NewValue, String, Context)
	
	If PreviousValue2 = NewValue Then
		Return;
	EndIf;
	PreviousValue2 = NewValue;
	
	If Context.AddedRows.Find(String) = Undefined
	   And Context.ModifiedRows.Get(String) = Undefined Then
		
		Context.ModifiedRows.Insert(String.List, String);
	EndIf;
	
EndProcedure

Procedure AddItemsCountQueryText(QueryDetails, String, IndexOf, Context, ForExternalUsers)
	
	Versions = Context.ActiveParameters.ListsRestrictionsVersions.Get(String.TableName);
	
	If ValueIsFilled(Versions)
	   And ValueIsFilled(String.TableName)
	 Or String.TableName = "Catalog.SetsOfAccessGroups" Then
		
		NameContent = StrSplit(String.TableName, ".", False);
		TypeProperties = Context.TablesTypesByNames.Get(Upper(NameContent[0]));
		If TypeProperties.IsReferenceType Then
			QueryText =
			"SELECT
			|	COUNT(*) AS Count
			|FROM
			|	&CurrentTable AS CurrentTable";
		Else
			QueryText = RegisterItemsCountQueryText(Context, String, IndexOf, ForExternalUsers);
		EndIf;
		QueryText = StrReplace(QueryText, "&CurrentTable", String.TableName);
	Else
		QueryText =
		"SELECT
		|	0 AS Count";
	EndIf;
	
	QueryDetails.QueryPackageTexts.Add(QueryText);
	IndexOf = IndexOf + 1;
	
EndProcedure

Function RegisterItemsCountQueryText(Context, String, IndexOf, ForExternalUsers)
	
	If ForExternalUsers Then
		AdditionalContext = Context.ActiveParameters.AdditionalContext.ForExternalUsers;
	Else
		AdditionalContext = Context.ActiveParameters.AdditionalContext.ForUsers;
	EndIf;
	Properties = AdditionalContext.ListRestrictionsProperties.Get(String.TableName);
	
	If Properties = Undefined
	 Or Properties.BasicFields = Undefined
	 Or Properties.BasicFields.UsedItems.Count() = 0 Then
	
		Return
		"SELECT
		|	0 AS Count";
	EndIf;
	
	SelectionFields = "";
	For Each FieldName In Properties.BasicFields.UsedItems Do
		SelectionFields = SelectionFields + ?(SelectionFields = "", "", ",
		|		") + "CurrentTable." + FieldName;
	EndDo;
	
	If Properties.BasicFields.UsedItems.Count() = 1 Then
		QueryText =
		"SELECT
		|	COUNT(DISTINCT &SelectionFields) AS Count
		|FROM
		|	&CurrentTable AS CurrentTable";
	Else
		QueryText =
		"SELECT
		|	COUNT(*) AS Count
		|FROM
		|	(SELECT DISTINCT
		|		&SelectionFields AS SelectionFields
		|	FROM
		|		&CurrentTable AS CurrentTable) AS Combinations";
		SelectionFields = TextWithIndent(SelectionFields, "	");
	EndIf;
	
	QueryText = StrReplace(QueryText, "&SelectionFields", SelectionFields);
	
	Return QueryText;
	
EndFunction

Procedure AddQueryTextOfRemainingItemsCount(QueryDetails, String, IndexOf, Context, ForExternalUsers)
	
	ListProperties = Context.ListsProperties.Get(String.List);
	ListsWithDate = Context.ActiveParameters.ListsWithDate;
	
	If ValueIsFilled(String.TableName) Then
		NameContent = StrSplit(String.TableName, ".", False);
		TypeProperties = Context.TablesTypesByNames.Get(Upper(NameContent[0]));
	Else
		ListProperties = Undefined;
	EndIf;
	
	If ListProperties = Undefined Then
		JobParameters = Undefined;
		
	ElsIf ForExternalUsers Then
		JobParameters = ListProperties.LastUpdatedItemForExtrenalUsers;
	Else
		JobParameters = ListProperties.LastUpdatedItem;
	EndIf;
	
	If TypeOf(JobParameters) <> Type("ValueStorage") Then
		QueryText =
		"SELECT
		|	UNDEFINED AS Count";
	Else
		ItemsCountShares = New Structure("Processed2, Left1", 0, 1);
		JobParameters = JobParameters.Get();
		
		If TypeOf(JobParameters) = Type("Structure")
		   And JobParameters.Property("LastUpdatedItem")
		   And TypeOf(JobParameters.LastUpdatedItem) = Type("Structure")
		   And JobParameters.LastUpdatedItem.Property("DataKeyKind")
		   And DataKeyKindOrder(JobParameters.LastUpdatedItem.DataKeyKind) <> Undefined
		   And JobParameters.LastUpdatedItem.Property("DataKey")
		   And JobParameters.LastUpdatedItem.Property("ProcessObsoleteItems")
		   And TypeOf(JobParameters.LastUpdatedItem.ProcessObsoleteItems) = Type("Boolean") Then
			
			LastUpdatedItem = JobParameters.LastUpdatedItem;
		Else
			LastUpdatedItem = New Structure;
			LastUpdatedItem.Insert("DataKeyKind", "DataItemsWithObsoleteKeys");
			LastUpdatedItem.Insert("DataKey");
		EndIf;
		
		FilterCriterion = "";
		If TypeProperties.IsReferenceType Then
			DataKey = LastUpdatedItem.DataKey;
			If ListsWithDate.Get(String.TableName) <> Undefined Then
				
				If LastUpdatedItem.Property("Date")
				   And TypeOf(LastUpdatedItem.Date) = Type("Date") Then
					
					ParameterName = "LastDate" + Format(IndexOf, "NG=");
					FilterCriterion = "CurrentTable.Date <= &" + ParameterName;
					QueryDetails.Query.SetParameter(ParameterName, LastUpdatedItem.Date);
				EndIf;
				
			ElsIf ValueIsFilled(DataKey) Then
				MetadataObject = Metadata.FindByType(TypeOf(DataKey));
				If MetadataObject <> Undefined
				   And MetadataObject.FullName() = String.TableName Then
					
					ParameterName = "LastRef" + Format(IndexOf, "NG=");
					FilterCriterion = "CurrentTable.Ref > &" + ParameterName;
					QueryDetails.Query.SetParameter(ParameterName, DataKey);
				EndIf;
			EndIf;
			If ValueIsFilled(FilterCriterion) Then
				QueryText =
				"SELECT
				|	COUNT(*) AS Count
				|FROM
				|	&CurrentTable AS CurrentTable
				|WHERE
				|	&FilterCriterion";
				QueryText = StrReplace(QueryText, "&FilterCriterion", FilterCriterion);
			Else
				QueryText =
				"SELECT
				|	-1 AS Count";
			EndIf;
			FillSharesRefTypeItemsCount(ItemsCountShares,
				LastUpdatedItem, String.TableName);
		Else
			If ForExternalUsers Then
				AdditionalContext = Context.ActiveParameters.AdditionalContext.ForExternalUsers;
			Else
				AdditionalContext = Context.ActiveParameters.AdditionalContext.ForUsers;
			EndIf;
			RestrictionProperties = AdditionalContext.ListRestrictionsProperties.Get(String.TableName);
			
			If RestrictionProperties <> Undefined Then
				AccessOptionsUsed = AdditionalContext.BasicAccessOptions.Get(String.TableName);
				If AccessOptionsUsed = Undefined Then
					RestrictionProperties = Undefined;
				Else
					RestrictionProperties = New Structure(RestrictionProperties);
					RestrictionProperties.Insert("AccessOption", AccessOptionsUsed[0].AccessOption);
				EndIf;
			EndIf;
			
			FillRegisterItemsCountShares(ItemsCountShares,
				LastUpdatedItem, RestrictionProperties);
			
			QueryText = QueryTextOfRemainingRegisterItemsCount(QueryDetails, String, IndexOf,
				ForExternalUsers, LastUpdatedItem, RestrictionProperties, TypeProperties);
		EndIf;
		QueryText = StrReplace(QueryText, "&CurrentTable", String.TableName);
		
		If ForExternalUsers Then
			String.ProcessedExternalUsersItemsShare = ItemsCountShares.Processed2;
			String.LeftExternalUsersItemsShare   = ItemsCountShares.Left1;
		Else
			String.ProcessedUsersItemsShare = ItemsCountShares.Processed2;
			String.LeftlUsersItemsShare   = ItemsCountShares.Left1;
		EndIf;
	EndIf;
	
	QueryDetails.QueryPackageTexts.Add(QueryText);
	IndexOf = IndexOf + 1;
	
EndProcedure

Procedure FillSharesRefTypeItemsCount(ItemsCountShares, Item, TableName)
	
	If TableName = "Catalog.SetsOfAccessGroups" Then
		If Item.DataKeyKind = "NewSingleUserSets" Then
			
			ItemsCountShares.Processed2 = 0.0;
			ItemsCountShares.Left1   = 0.1;
			
		ElsIf Item.DataKeyKind = "AccessGroupsSetsAssignedToUsers" Then
			
			ItemsCountShares.Processed2 = 0.1;
			ItemsCountShares.Left1   = 0.1;
			
		ElsIf Item.DataKeyKind = "UserGroupSetsAssignedToUsers" Then
			
			ItemsCountShares.Processed2 = 0.2;
			ItemsCountShares.Left1   = 0.1;
			
		ElsIf Item.DataKeyKind = "NewGroupsSetsWithObsoleteRights" Then
			
			ItemsCountShares.Processed2 = 0.3;
			ItemsCountShares.Left1   = 0.2;
			
		ElsIf Item.DataKeyKind = "GroupSetsAllowedForUsers" Then
			
			ItemsCountShares.Processed2 = 0.5;
			ItemsCountShares.Left1   = 0.1;
			
		ElsIf Item.DataKeyKind = "GroupsSetsWithObsoleteRights" Then
			
			If Item.ProcessObsoleteItems Then
				ItemsCountShares.Processed2 = 0.6;
				ItemsCountShares.Left1   = 0.3;
			Else
				ItemsCountShares.Processed2 = 0.6;
				ItemsCountShares.Left1   = 0.4;
			EndIf;
			
		Else // ObsoleteItems.
			ItemsCountShares.Processed2 = 0.9;
			ItemsCountShares.Left1   = 0.1;
		EndIf;
		Return;
	EndIf;
	
	If Item.DataKeyKind = "ItemsWithObsoleteKeys" Then
		If Item.ProcessObsoleteItems Then
			ItemsCountShares.Processed2 = 0.0;
			ItemsCountShares.Left1   = 0.9;
		Else
			ItemsCountShares.Processed2 = 0.0;
			ItemsCountShares.Left1   = 1.0;
		EndIf;
	Else // ObsoleteItems.
		ItemsCountShares.Processed2 = 0.9;
		ItemsCountShares.Left1   = 0.1;
	EndIf;
	
EndProcedure

Function QueryTextOfRemainingRegisterItemsCount(QueryDetails, String, IndexOf,
			ForExternalUsers, LastUpdatedItem, RestrictionProperties, TypeProperties)
	
	DataKeyKind = LastUpdatedItem.DataKeyKind;
	DataKey     = LastUpdatedItem.DataKey;
	
	If RestrictionProperties = Undefined
	 Or RestrictionProperties.BasicFields = Undefined
	 Or RestrictionProperties.BasicFields.UsedItems.Count() = 0
	 Or TypeOf(DataKey) <> Type("Structure")
	 Or DataKeyKind = "ItemsWithoutKeysByPeriod"
	   And (Not LastUpdatedItem.Property("Date")
	      Or TypeOf(LastUpdatedItem.Date) <> Type("Date"))
	 Or DataKeyKind = "ItemsWithoutKeysByFieldValues"
	   And RestrictionProperties.BasicFields.UsedItems.Count() <> DataKey.Count()
	 Or DataKeyKind <> "ItemsWithoutKeysByPeriod"
	   And DataKeyKind <> "ItemsWithoutKeysByFieldValues"
	   And RestrictionProperties.BasicFields.UsedItems.Count() > DataKey.Count() Then
	
		Return
		"SELECT
		|	-1 AS Count";
	EndIf;
	
	SelectionFields = "";
	FilterCriterion = "";
	ConnectionCondition = "";
	
	If ValueIsFilled(RestrictionProperties.SeparateKeysRegisterName) Then
		KeysRegisterName = RestrictionProperties.SeparateKeysRegisterName;
	Else
		KeysRegisterName = "AccessKeysForRegisters";
		ParameterName = "RegisterID" + Format(IndexOf, "NG=");
		ConnectionCondition = "(AccessKeysForRegisters.Register = &" + ParameterName + ")";
		QueryDetails.Query.SetParameter(ParameterName, String.List);
	EndIf;
	
	BasicFields = RestrictionProperties.BasicFields;
	FilterByUsersType = XMLString(RestrictionProperties.AccessOption);
	ConnectionCondition = ConnectionCondition + ?(ConnectionCondition = "", "", "
	|			AND ") + "(AccessKeysForRegisters.AccessOption = " + FilterByUsersType + ")"; // @query-part-1
	
	FieldNumber = 1;
	For Each FieldName In BasicFields.UsedItems Do
		FieldNameInDataKey = "Field" + FieldNumber;
		ParameterName = FieldName + Format(IndexOf, "NG=");
		
		ConnectionCondition = ConnectionCondition + ?(ConnectionCondition = "", "", "
		|			AND ") + "(AccessKeysForRegisters.Field" + FieldNumber + " = CurrentTable." + FieldName + ")"; // @query-part-1
		
		Filter = "";
		For CurrentIndex = 0 To FieldNumber - 2 Do
			CurrentFieldName = BasicFields.UsedItems[CurrentIndex];
			CurrentParameterName = CurrentFieldName + Format(IndexOf, "NG=");
			Filter = Filter + ?(Filter = "", "", "
			|	AND ") + "CurrentTable." + CurrentFieldName + " = &" + CurrentParameterName; // @query-part-1
		EndDo;
		Filter = Filter + ?(Filter = "", "", "
		|	AND ") + "CurrentTable." + FieldName + " > &" + ParameterName; // @query-part-1
		
		FilterCriterion = FilterCriterion + ?(FieldNumber = 1, ?(BasicFields.UsedItems.Count() > 1, "(", "") + Filter, "
		|		OR " + TextWithIndent(Filter, "		")); // @query-part-1
	
		If DataKey.Property(FieldNameInDataKey) Then
			QueryDetails.Query.SetParameter(ParameterName, DataKey[FieldNameInDataKey]);
		Else
			QueryDetails.Query.SetParameter(ParameterName, Undefined);
		EndIf;
		SelectionFields = SelectionFields + ?(SelectionFields = "", "", ",
		|	") + "CurrentTable." + FieldName;
		FieldNumber = FieldNumber + 1;
	EndDo;
	
	If BasicFields.UsedItems.Count() > 1 Then
		FilterCriterion  = FilterCriterion  + ")";
	EndIf;
	
	If DataKeyKind = "ItemsWithoutKeysByPeriod" Then
		PeriodFieldName = ?(TypeProperties.CollectionName = "CalculationRegisters", "RegistrationPeriod", "Period");
		ParameterName = PeriodFieldName + Format(IndexOf, "NG=");
		FilterCriterion = "(CurrentTable." + PeriodFieldName + " < &" + ParameterName + "
		|	OR CurrentTable." // @query-part-1
		+ PeriodFieldName + " = &" + ParameterName + "
		|		AND " + TextWithIndent(FilterCriterion, "	") + ")"; // @query-part-1
		QueryDetails.Query.SetParameter(ParameterName, LastUpdatedItem.Date);
	EndIf;
	
	If RestrictionProperties.BasicFields.UsedItems.Count() = 1 Then
		QueryText =
		"SELECT
		|	COUNT(DISTINCT &SelectionFields) AS Count
		|FROM
		|	&CurrentTable AS CurrentTable
		|		LEFT JOIN CurrentList AS AccessKeysForRegisters
		|		ON (&ConnectionCondition)
		|WHERE
		|	&FilterCriterion
		|	AND AccessKeysForRegisters.AccessOption IS NULL";
	Else
		QueryText =
		"SELECT
		|	COUNT(*) AS Count
		|FROM
		|	(SELECT DISTINCT
		|		&SelectionFields AS SelectionFields
		|	FROM
		|		&CurrentTable AS CurrentTable
		|			LEFT JOIN CurrentList AS AccessKeysForRegisters
		|			ON (&ConnectionCondition)
		|	WHERE
		|		&FilterCriterion
		|		AND AccessKeysForRegisters.AccessOption IS NULL) AS Combinations";
		SelectionFields    = TextWithIndent(SelectionFields, "	");
		FilterCriterion = TextWithIndent(FilterCriterion, "	");
	EndIf;
	
	QueryText = StrReplace(QueryText, "(&ConnectionCondition)", ConnectionCondition);
	QueryText = StrReplace(QueryText, "&SelectionFields",    SelectionFields);
	QueryText = StrReplace(QueryText, "&FilterCriterion", FilterCriterion);
	QueryText = StrReplace(QueryText, "CurrentList", "InformationRegister." + KeysRegisterName);
	
	Return QueryText;
	
EndFunction

Procedure FillRegisterItemsCountShares(ItemsCountShares, Item, RestrictionProperties)
	
	If Item.DataKeyKind = "ItemsWithObsoleteKeys" Then
		
		ItemsCountShares.Processed2 = 0.0;
		ItemsCountShares.Left1   = 0.5;
		
	ElsIf Item.DataKeyKind = "ItemsWithoutKeysByFieldValues"
	      Or Item.DataKeyKind = "ItemsWithoutKeysByPeriod" Then
		
		If Item.ProcessObsoleteItems Then
			ItemsCountShares.Processed2 = 0.5;
			ItemsCountShares.Left1   = 0.4;
		Else
			ItemsCountShares.Processed2 = 0.5;
			ItemsCountShares.Left1   = 0.5;
		EndIf;
		
	ElsIf Item.DataKeyKind = "ObsoleteItems" Then
		
		If RestrictionProperties <> Undefined
		   And ValueIsFilled(RestrictionProperties.SeparateKeysRegisterName) Then
			
			ItemsCountShares.Processed2 = 0.90;
			ItemsCountShares.Left1   = 0.09;
		Else
			ItemsCountShares.Processed2 = 0.9;
			ItemsCountShares.Left1   = 0.1;
		EndIf;
		
	Else // ObsoleteCommonRegisterItems.
		ItemsCountShares.Processed2 = 0.99;
		ItemsCountShares.Left1   = 0.01;
	EndIf;
	
EndProcedure

Procedure AddQueryTextOfAccessKeysCount(QueryDetails, String, IndexOf, ForExternalUsers)
	
	QueryText =
	"SELECT
	|	COUNT(AccessKeys.Ref) AS Count
	|FROM
	|	Catalog.AccessKeys AS AccessKeys
	|WHERE
	|	AccessKeys.List = &List
	|	AND AccessKeys.ForExternalUsers = FALSE";
	
	ParameterName = "KeysList" + Format(IndexOf, "NG=");
	QueryText = StrReplace(QueryText, "&List", "&" + ParameterName);
	QueryDetails.Query.SetParameter(ParameterName, String.List);
	
	If ForExternalUsers Then
		QueryText = StrReplace(QueryText, "FALSE", "TRUE");
	EndIf;
	
	QueryDetails.QueryPackageTexts.Add(QueryText);
	IndexOf = IndexOf + 1;
	
EndProcedure

Procedure AddQueryTextOfRemainingAccessKeysCount(QueryDetails, String, IndexOf, Context, ForExternalUsers)
	
	ListProperties = Context.ListsProperties.Get(String.List);
	
	If ListProperties = Undefined Then
		JobParameters = Undefined;
		
	ElsIf ForExternalUsers Then
		JobParameters = ListProperties.LastUpdatedAccessKeyForExtrenalUsers;
	Else
		JobParameters = ListProperties.LastUpdatedAccessKey;
	EndIf;
	
	If TypeOf(JobParameters) <> Type("ValueStorage") Then
		QueryText =
		"SELECT
		|	UNDEFINED AS Count";
	Else
		AccessKeysCountShares = New Structure("Processed2, Left1", 0, 1);
		JobParameters = JobParameters.Get();
		
		If TypeOf(JobParameters) = Type("Structure")
		   And JobParameters.Property("LastUpdatedItem")
		   And TypeOf(JobParameters.LastUpdatedItem) = Type("Structure")
		   And JobParameters.LastUpdatedItem.Property("DataKeyKind")
		   And DataKeyKindOrder(JobParameters.LastUpdatedItem.DataKeyKind) <> Undefined
		   And JobParameters.LastUpdatedItem.Property("DataKey") Then
			
			LastAccessKey = JobParameters.LastUpdatedItem.DataKey;
			FillAccessKeysCountShares(AccessKeysCountShares,
				JobParameters.LastUpdatedItem);
		EndIf;
		FilterCriterion = "";
		If TypeOf(LastAccessKey) = Type("CatalogRef.AccessKeys") Then
			ParameterName = "ProcessedKeysList" + Format(IndexOf, "NG=");
			FilterCriterion = "AccessKeys.List = &" + ParameterName;
			QueryDetails.Query.SetParameter(ParameterName, String.List);
			
			FilterCriterion = FilterCriterion + "
			|	AND AccessKeys.ForExternalUsers = " + ?(ForExternalUsers, "TRUE", "FALSE"); // @query-part-1
			
			ParameterName = "LastAccessKey" + Format(IndexOf, "NG=");
			FilterCriterion = FilterCriterion + "
			|	AND AccessKeys.Ref > &" + ParameterName; // @query-part-1
			QueryDetails.Query.SetParameter(ParameterName, LastAccessKey);
		EndIf;
		
		If ValueIsFilled(FilterCriterion) Then
			QueryText =
			"SELECT
			|	COUNT(*) AS Count
			|FROM
			|	Catalog.AccessKeys AS AccessKeys
			|WHERE
			|	&FilterCriterion";
			QueryText = StrReplace(QueryText, "&FilterCriterion", FilterCriterion);
		Else
			QueryText =
			"SELECT
			|	-1 AS Count";
		EndIf;
		
		If ForExternalUsers Then
			String.ProcessedExternalUsersAccessKeysShare = AccessKeysCountShares.Processed2;
			String.LeftExternalUsersAccessKeysShare   = AccessKeysCountShares.Left1;
		Else
			String.ProcessedUsersAccessKeysShare = AccessKeysCountShares.Processed2;
			String.LeftUsersAccessKeysShare   = AccessKeysCountShares.Left1;
		EndIf;
	EndIf;
	
	QueryDetails.QueryPackageTexts.Add(QueryText);
	IndexOf = IndexOf + 1;
	
EndProcedure

Procedure FillAccessKeysCountShares(AccessKeysCountShares, Item)
	
	If Item.DataKeyKind = "ItemsWithObsoleteRights" Then
		If Item.ProcessObsoleteItems Then
			AccessKeysCountShares.Processed2 = 0.0;
			AccessKeysCountShares.Left1   = 0.9;
		Else
			AccessKeysCountShares.Processed2 = 0.0;
			AccessKeysCountShares.Left1   = 1.0;
		EndIf;
	Else // ObsoleteItems.
		AccessKeysCountShares.Processed2 = 0.9;
		AccessKeysCountShares.Left1   = 0.1;
	EndIf;
	
EndProcedure

// Parameters:
//  ActiveParameters - See ActiveAccessRestrictionParameters
//  
// Returns:
//   See Common.MetadataObjectIDs
// 
Function ListsWithRestrictionIDs(ActiveParameters)
	
	ActiveParameters = ActiveAccessRestrictionParameters(Undefined, Undefined, False);
	
	Lists = New Array;
	For Each VersionDetails In ActiveParameters.ListsRestrictionsVersions Do
		Lists.Add(VersionDetails.Key);
	EndDo;
	
	Return Common.MetadataObjectIDs(Lists, False);
	
EndFunction

Function CurrentDateAtServer() Export
	
	// ACC:143-
	// 
	Return CurrentDate();
	// ACC:143-on
	
EndFunction

#EndRegion

#EndRegion

#EndRegion
